{"config":{"lang":["zh","en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u5355\u7247\u673a\u57fa\u7840\u5e93\u6587\u6863\u6307\u5357","text":""},{"location":"api/index_classes/","title":"Classes","text":"<ul> <li>struct CCGraphic_Arc </li> <li>struct CCGraphic_Ellipse </li> <li>struct CCGraphic_Image </li> <li>struct CFBDBootTuple </li> <li>struct CFBDGraphicCircle </li> <li>struct CFBDGraphicRect </li> <li>struct CFBDGraphicSize </li> <li>struct CFBDGraphic_Line </li> <li>struct CFBDGraphic_Margin </li> <li>struct CFBDGraphic_Point </li> <li>struct CFBDGraphic_Text </li> <li>struct CFBDGraphic_Triangle </li> <li>struct CFBDGraphic_Vec2i </li> <li>struct CFBD_BaseAnimationOps </li> <li>struct CFBD_GPIOHandle </li> <li>struct CFBD_GraphicDeviceOperation </li> <li>struct CFBD_I2COperations </li> <li>struct CFBD_I2C_IORequestParams </li> <li>struct CFBD_MenuItemCallbackPack </li> <li>struct CFBD_MenuOps </li> <li>struct CFBD_OLED_DeviceSpecific </li> <li>struct CFBD_OLED_IICInitsParams </li> <li>struct CFBD_ProgressBarOps </li> <li>struct CFBD_ST_I2CPrivate </li> <li>struct _CFBD_GraphicDevice </li> <li>struct _CFBD_I2CHandle </li> <li>struct _CFBD_I2C_Message </li> <li>struct _CFBD_Menu </li> <li>struct _CFBD_OLED </li> <li>struct _CFBD_OLED_OPS </li> <li>struct __CFBDApplication </li> <li>struct __CFBD_BaseAnimation </li> <li>struct __CFBD_MenuIndicator </li> <li>struct __CFBD_MenuItem </li> <li>struct __CFBD_MenuItemArray </li> <li>struct __CFBD_ProgressBar </li> </ul> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/index_examples/","title":"Examples","text":"<p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/index_files/","title":"Files","text":"<ul> <li>dir lib <ul> <li>dir lib/application <ul> <li>file c </li> <li>file h </li> <li>dir lib/application/sys_boot <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/application/sys_clock <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/config <ul> <li>file h </li> <li>file h </li> <li>file h </li> </ul> </li> <li>dir lib/gpio <ul> <li>file c </li> <li>file h </li> <li>file h </li> </ul> </li> <li>dir lib/graphic <ul> <li>file h </li> <li>dir lib/graphic/base <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/benchmark <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/device <ul> <li>file c </li> <li>file h </li> <li>dir lib/graphic/device/oled <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/graphic/fast_test <ul> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/resource <ul> <li>file h </li> <li>dir lib/graphic/resource/default <ul> <li>file c </li> <li>file c </li> </ul> </li> </ul> </li> <li>dir lib/graphic/widget <ul> <li>dir lib/graphic/widget/animation <ul> <li>file c </li> <li>file h </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/widget/base_support <ul> <li>file c </li> <li>file h </li> <li>dir lib/graphic/widget/base_support/common <ul> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/graphic/widget/menu <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/widget/progressbar <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/iic <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>dir lib/iic/backend <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/oled <ul> <li>dir lib/oled/configs <ul> <li>file h </li> <li>file h </li> </ul> </li> <li>dir lib/oled/driver <ul> <li>dir lib/oled/driver/backend <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/oled/driver/device <ul> <li>file h </li> <li>dir lib/oled/driver/device/ssd1306 <ul> <li>file c </li> <li>file h import the func to init ssd1306 specifics </li> </ul> </li> <li>dir lib/oled/driver/device/ssd1309 <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> </ul> </li> <li>file c </li> <li>file h oled general handles </li> </ul> </li> </ul> </li> </ul> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/index_groups/","title":"Modules","text":"<p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/index_namespaces/","title":"Namespaces","text":"<p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/index_pages/","title":"Pages","text":"<p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCCGraphic__Arc/","title":"CCGraphic_Arc","text":"<p><code>#include &lt;arc.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Arc/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center PointBaseType radius int16_t start_degree int16_t end_degree"},{"location":"api/Classes/structCCGraphic__Arc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Arc/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-radius","title":"variable radius","text":"<pre><code>PointBaseType radius;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-start_degree","title":"variable start_degree","text":"<pre><code>int16_t start_degree;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-end_degree","title":"variable end_degree","text":"<pre><code>int16_t end_degree;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCCGraphic__Ellipse/","title":"CCGraphic_Ellipse","text":"<p><code>#include &lt;ellipse.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Ellipse/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center PointBaseType X_Radius PointBaseType Y_Radius"},{"location":"api/Classes/structCCGraphic__Ellipse/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-x_radius","title":"variable X_Radius","text":"<pre><code>PointBaseType X_Radius;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-y_radius","title":"variable Y_Radius","text":"<pre><code>PointBaseType Y_Radius;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCCGraphic__Image/","title":"CCGraphic_Image","text":"<p><code>#include &lt;image.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point point CFBDGraphicSize image_size uint8_t * sources_register"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Image/#variable-point","title":"variable point","text":"<pre><code>CFBDGraphic_Point point;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Image/#variable-image_size","title":"variable image_size","text":"<pre><code>CFBDGraphicSize image_size;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Image/#variable-sources_register","title":"variable sources_register","text":"<pre><code>uint8_t * sources_register;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDBootTuple/","title":"CFBDBootTuple","text":"<p><code>#include &lt;boot.h&gt;</code></p>"},{"location":"api/Classes/structCFBDBootTuple/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc boot_func CFBD_BootArgs args"},{"location":"api/Classes/structCFBDBootTuple/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDBootTuple/#variable-boot_func","title":"variable boot_func","text":"<pre><code>CFBD_BootStrapFunc boot_func;\n</code></pre>"},{"location":"api/Classes/structCFBDBootTuple/#variable-args","title":"variable args","text":"<pre><code>CFBD_BootArgs args;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphicCircle/","title":"CFBDGraphicCircle","text":"<p><code>#include &lt;circle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicCircle/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType radius CFBDGraphic_Point center"},{"location":"api/Classes/structCFBDGraphicCircle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicCircle/#variable-radius","title":"variable radius","text":"<pre><code>SizeBaseType radius;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphicCircle/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphicRect/","title":"CFBDGraphicRect","text":"<p><code>#include &lt;rectangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicRect/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point tl CFBDGraphic_Point br"},{"location":"api/Classes/structCFBDGraphicRect/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicRect/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphicRect/#variable-br","title":"variable br","text":"<pre><code>CFBDGraphic_Point br;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphicSize/","title":"CFBDGraphicSize","text":"<p><code>#include &lt;size.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType width SizeBaseType height"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicSize/#variable-width","title":"variable width","text":"<pre><code>SizeBaseType width;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphicSize/#variable-height","title":"variable height","text":"<pre><code>SizeBaseType height;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Line/","title":"CFBDGraphic_Line","text":"<p><code>#include &lt;line.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p_left CFBDGraphic_Point p_right"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_left","title":"variable p_left","text":"<pre><code>CFBDGraphic_Point p_left;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_right","title":"variable p_right","text":"<pre><code>CFBDGraphic_Point p_right;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Margin/","title":"CFBDGraphic_Margin","text":"<p><code>#include &lt;margin.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Margin/#public-attributes","title":"Public Attributes","text":"Name PointBaseType left PointBaseType top PointBaseType right PointBaseType bottom"},{"location":"api/Classes/structCFBDGraphic__Margin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-left","title":"variable left","text":"<pre><code>PointBaseType left;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-top","title":"variable top","text":"<pre><code>PointBaseType top;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-right","title":"variable right","text":"<pre><code>PointBaseType right;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-bottom","title":"variable bottom","text":"<pre><code>PointBaseType bottom;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Point/","title":"CFBDGraphic_Point","text":"<p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes","title":"Public Attributes","text":"Name PointBaseType x PointBaseType y"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Point/#variable-x","title":"variable x","text":"<pre><code>PointBaseType x;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Point/#variable-y","title":"variable y","text":"<pre><code>PointBaseType y;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Text/","title":"CFBDGraphic_Text","text":"<p><code>#include &lt;text.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes","title":"Public Attributes","text":"Name char * sources_borrowed CFBDGraphic_Point tl_point CFBDGraphic_Point indexed_point CFBDGraphicSize TexthandleSize Ascii_Font_Size font_size CFBDGraphicRect text_bounding_rect"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Text/#variable-sources_borrowed","title":"variable sources_borrowed","text":"<pre><code>char * sources_borrowed;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-indexed_point","title":"variable indexed_point","text":"<pre><code>CFBDGraphic_Point indexed_point;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-texthandlesize","title":"variable TexthandleSize","text":"<pre><code>CFBDGraphicSize TexthandleSize;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-font_size","title":"variable font_size","text":"<pre><code>Ascii_Font_Size font_size;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-text_bounding_rect","title":"variable text_bounding_rect","text":"<pre><code>CFBDGraphicRect text_bounding_rect;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/","title":"CFBDGraphic_Triangle","text":"<p><code>#include &lt;triangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p1 CFBDGraphic_Point p2 CFBDGraphic_Point p3"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p1","title":"variable p1","text":"<pre><code>CFBDGraphic_Point p1;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p2","title":"variable p2","text":"<pre><code>CFBDGraphic_Point p2;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p3","title":"variable p3","text":"<pre><code>CFBDGraphic_Point p3;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/","title":"CFBDGraphic_Vec2i","text":"<p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes","title":"Public Attributes","text":"Name int32_t x int32_t y"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-x","title":"variable x","text":"<pre><code>int32_t x;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-y","title":"variable y","text":"<pre><code>int32_t y;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/","title":"CFBD_BaseAnimationOps","text":"<p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(uint32_t ms) delay_ms"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__BaseAnimationOps/#variable-delay_ms","title":"variable delay_ms","text":"<pre><code>void(*)(uint32_t ms) delay_ms;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__GPIOHandle/","title":"CFBD_GPIOHandle","text":"<p><code>#include &lt;gpio.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes","title":"Public Attributes","text":"Name GPIO_TypeHandle handle_internals_ Every man owns its own gpio privates :) GPIO_PinType pin_internals_"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-handle_internals_","title":"variable handle_internals_","text":"<pre><code>GPIO_TypeHandle handle_internals_;\n</code></pre> <p>Every man owns its own gpio privates :) </p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-pin_internals_","title":"variable pin_internals_","text":"<pre><code>GPIO_PinType pin_internals_;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/","title":"CFBD_GraphicDeviceOperation","text":"<p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_GraphicDevice *device, void *init_args) init init calls for the devices setup CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea GraphicFrameOperation update GraphicFrameOperation clear GraphicFrameOperation revert GraphicAreaOperations update_area GraphicAreaOperations clear_area GraphicAreaOperations revert_area GraphicOLEDSelfOperation open GraphicOLEDSelfOperation close GraphicOLED_QueryOperation self_consult"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_GraphicDevice *device, void *init_args) init;\n</code></pre> <p>init calls for the devices setup </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update","title":"variable update","text":"<pre><code>GraphicFrameOperation update;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear","title":"variable clear","text":"<pre><code>GraphicFrameOperation clear;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert","title":"variable revert","text":"<pre><code>GraphicFrameOperation revert;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update_area","title":"variable update_area","text":"<pre><code>GraphicAreaOperations update_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear_area","title":"variable clear_area","text":"<pre><code>GraphicAreaOperations clear_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert_area","title":"variable revert_area","text":"<pre><code>GraphicAreaOperations revert_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-open","title":"variable open","text":"<pre><code>GraphicOLEDSelfOperation open;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-close","title":"variable close","text":"<pre><code>GraphicOLEDSelfOperation close;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-self_consult","title":"variable self_consult","text":"<pre><code>GraphicOLED_QueryOperation self_consult;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__I2COperations/","title":"CFBD_I2COperations","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_I2CHandle *handle) init int(*)(CFBD_I2CHandle *handle) deinit int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready int(*)(CFBD_I2CHandle *bus) recover_bus int(*)(CFBD_I2CHandle *bus) get_error int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2COperations/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) init;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-deinit","title":"variable deinit","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) deinit;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-transfer","title":"variable transfer","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-is_device_ready","title":"variable is_device_ready","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-recover_bus","title":"variable recover_bus","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) recover_bus;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-get_error","title":"variable get_error","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) get_error;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-tx_dma_start","title":"variable tx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-rx_dma_start","title":"variable rx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/","title":"CFBD_I2C_IORequestParams","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr7 uint32_t mem_addr uint8_t mem_addr_size uint8_t * data uint16_t len uint32_t timeout_ms"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-addr7","title":"variable addr7","text":"<pre><code>uint16_t addr7;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr","title":"variable mem_addr","text":"<pre><code>uint32_t mem_addr;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr_size","title":"variable mem_addr_size","text":"<pre><code>uint8_t mem_addr_size;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-data","title":"variable data","text":"<pre><code>uint8_t * data;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-timeout_ms","title":"variable timeout_ms","text":"<pre><code>uint32_t timeout_ms;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/","title":"CFBD_MenuItemCallbackPack","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItemCallback callback void * user_data"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-callback","title":"variable callback","text":"<pre><code>CFBD_MenuItemCallback callback;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-user_data","title":"variable user_data","text":"<pre><code>void * user_data;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__MenuOps/","title":"CFBD_MenuOps","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation void(*)(CFBD_Menu *pMenu) immediate_draw draw immediately void(*)(CFBD_Menu *pMenu, int index) select_index index selectors void(*)(CFBD_Menu *pMenu) activate_current User Activate the Selections, so things goes on. void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points Reset the places."},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuOps/#variable-bind_item_groups_contains","title":"variable bind_item_groups_contains","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>assigned_menu_items </li> </ul> <p>Note: assigned_menu_items requests long lifetime exsits, recommends being static </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-add_item","title":"variable add_item","text":"<pre><code>CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_indicator_property","title":"variable set_indicator_property","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_animation","title":"variable set_animation","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>pBaseAnimation </li> </ul> <p>Note: pBaseAnimation can be temp, internal assigns </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_Menu *pMenu) immediate_draw;\n</code></pre> <p>draw immediately </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-select_index","title":"variable select_index","text":"<pre><code>void(*)(CFBD_Menu *pMenu, int index) select_index;\n</code></pre> <p>index selectors </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-activate_current","title":"variable activate_current","text":"<pre><code>void(*)(CFBD_Menu *pMenu) activate_current;\n</code></pre> <p>User Activate the Selections, so things goes on. </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-reset_tl_points","title":"variable reset_tl_points","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points;\n</code></pre> <p>Reset the places. </p> <p>Note: immediate draw requests, including clear update and redraw is expected to behave! </p> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/","title":"CFBD_OLED_DeviceSpecific","text":"<p><code>#include &lt;device_interface.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes","title":"Public Attributes","text":"Name uint8_t ()(void) init_session_tables uint8_t ** grams uint16_t init_session_tables_sz uint8_t data_prefix uint8_t cmd_prefix uint16_t logic_width uint16_t logic_height"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables","title":"variable init_session_tables","text":"<pre><code>uint8_t *(*)(void) init_session_tables;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-grams","title":"variable grams","text":"<pre><code>uint8_t ** grams;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables_sz","title":"variable init_session_tables_sz","text":"<pre><code>uint16_t init_session_tables_sz;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-data_prefix","title":"variable data_prefix","text":"<pre><code>uint8_t data_prefix;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-cmd_prefix","title":"variable cmd_prefix","text":"<pre><code>uint8_t cmd_prefix;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_width","title":"variable logic_width","text":"<pre><code>uint16_t logic_width;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_height","title":"variable logic_height","text":"<pre><code>uint16_t logic_height;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/","title":"CFBD_OLED_IICInitsParams","text":"<p><code>#include &lt;external_impl_driver.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes","title":"Public Attributes","text":"Name CFBD_I2CHandle * i2cHandle uint32_t accepted_time_delay uint16_t device_address CFBD_OLED_DeviceSpecific * device_specifics void(*)(int status) iic_transition_callback"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-i2chandle","title":"variable i2cHandle","text":"<pre><code>CFBD_I2CHandle * i2cHandle;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-accepted_time_delay","title":"variable accepted_time_delay","text":"<pre><code>uint32_t accepted_time_delay;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_address","title":"variable device_address","text":"<pre><code>uint16_t device_address;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_specifics","title":"variable device_specifics","text":"<pre><code>CFBD_OLED_DeviceSpecific * device_specifics;\n</code></pre>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-iic_transition_callback","title":"variable iic_transition_callback","text":"<pre><code>void(*)(int status) iic_transition_callback;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/","title":"CFBD_ProgressBarOps","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_ProgressBar *) immediate_draw void(*)(CFBD_ProgressBar *, int32_t new_value) set_value CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property Set Property values, like -&gt; border, uint8_t as boarders -&gt; padding, uint8_t as padding -&gt; animation, CFBD_BaseAnimation* passed."},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_ProgressBar *) immediate_draw;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_value","title":"variable set_value","text":"<pre><code>void(*)(CFBD_ProgressBar *, int32_t new_value) set_value;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_property","title":"variable set_property","text":"<pre><code>CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property;\n</code></pre> <p>Set Property values, like -&gt; border, uint8_t as boarders -&gt; padding, uint8_t as padding -&gt; animation, CFBD_BaseAnimation* passed. </p> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/","title":"CFBD_ST_I2CPrivate","text":"<p><code>#include &lt;i2c_stm_impl.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes","title":"Public Attributes","text":"Name I2C_HandleTypeDef * hi2c GPIO_TypeDef * scl_port uint16_t scl_pin GPIO_TypeDef * sda_port uint16_t sda_pin int last_err"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-hi2c","title":"variable hi2c","text":"<pre><code>I2C_HandleTypeDef * hi2c;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_port","title":"variable scl_port","text":"<pre><code>GPIO_TypeDef * scl_port;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_pin","title":"variable scl_pin","text":"<pre><code>uint16_t scl_pin;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_port","title":"variable sda_port","text":"<pre><code>GPIO_TypeDef * sda_port;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_pin","title":"variable sda_pin","text":"<pre><code>uint16_t sda_pin;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-last_err","title":"variable last_err","text":"<pre><code>int last_err;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/","title":"_CFBD_GraphicDevice","text":"<p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes","title":"Public Attributes","text":"Name CFBD_GraphicDeviceOperation * ops CFBDGraphic_DeviceType device_type CFBDGraphicDeviceHandle internal_handle CFBD_Bool immediate_draw"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_GraphicDeviceOperation * ops;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-device_type","title":"variable device_type","text":"<pre><code>CFBDGraphic_DeviceType device_type;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-internal_handle","title":"variable internal_handle","text":"<pre><code>CFBDGraphicDeviceHandle internal_handle;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>CFBD_Bool immediate_draw;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/","title":"_CFBD_I2CHandle","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes","title":"Public Attributes","text":"Name const CFBD_I2COperations * ops CFBD_I2CPrivateHandle private_handle"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_I2COperations * ops;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-private_handle","title":"variable private_handle","text":"<pre><code>CFBD_I2CPrivateHandle private_handle;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/","title":"_CFBD_I2C_Message","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr uint16_t flags uint16_t len uint8_t * buf"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-addr","title":"variable addr","text":"<pre><code>uint16_t addr;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-flags","title":"variable flags","text":"<pre><code>uint16_t flags;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t * buf;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__Menu/","title":"_CFBD_Menu","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuOps * operations CFBD_GraphicDevice * device CFBD_MenuItemGroup * menu_items CFBDGraphic_Point tl_point SizeBaseType max_width int selected CFBD_MenuIndicator indicator CFBD_BaseAnimation animation"},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__Menu/#variable-operations","title":"variable operations","text":"<pre><code>CFBD_MenuOps * operations;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-menu_items","title":"variable menu_items","text":"<pre><code>CFBD_MenuItemGroup * menu_items;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-max_width","title":"variable max_width","text":"<pre><code>SizeBaseType max_width;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-selected","title":"variable selected","text":"<pre><code>int selected;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-indicator","title":"variable indicator","text":"<pre><code>CFBD_MenuIndicator indicator;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED/","title":"_CFBD_OLED","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes","title":"Public Attributes","text":"Name const CFBD_OLEDOperations * ops CFBD_OLEDDriverType driver_type CFBD_OLEDHandle oled_internal_handle"},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_OLEDOperations * ops;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-driver_type","title":"variable driver_type","text":"<pre><code>CFBD_OLEDDriverType driver_type;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-oled_internal_handle","title":"variable oled_internal_handle","text":"<pre><code>CFBD_OLEDHandle oled_internal_handle;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/","title":"_CFBD_OLED_OPS","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_OLED *oled, void *init_args) init CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea FrameOperation update FrameOperation clear FrameOperation revert AreaOperations update_area AreaOperations clear_area AreaOperations revert_area OLEDSelfOperation open OLEDSelfOperation close OLED_QueryOperation self_consult OLED_QueryOperation queries the sessions of oled currently."},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_OLED *oled, void *init_args) init;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update","title":"variable update","text":"<pre><code>FrameOperation update;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear","title":"variable clear","text":"<pre><code>FrameOperation clear;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert","title":"variable revert","text":"<pre><code>FrameOperation revert;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update_area","title":"variable update_area","text":"<pre><code>AreaOperations update_area;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear_area","title":"variable clear_area","text":"<pre><code>AreaOperations clear_area;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert_area","title":"variable revert_area","text":"<pre><code>AreaOperations revert_area;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-open","title":"variable open","text":"<pre><code>OLEDSelfOperation open;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-close","title":"variable close","text":"<pre><code>OLEDSelfOperation close;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-self_consult","title":"variable self_consult","text":"<pre><code>OLED_QueryOperation self_consult;\n</code></pre> <p>OLED_QueryOperation queries the sessions of oled currently. </p> <p>Note: device should at least supports settings: rgb: pass CFBD_Bool type, Always no currently width: pass uint16_t type, get the width height: pass uint16_t type, get the height </p> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBDApplication/","title":"__CFBDApplication","text":"<p><code>#include &lt;app.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc selfBootFunc CFBD_BootArgs bootargs CFBD_ClockFreqProvider freq_provider CFBD_ClockTickProvider tick_provider"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDApplication/#variable-selfbootfunc","title":"variable selfBootFunc","text":"<pre><code>CFBD_BootStrapFunc selfBootFunc;\n</code></pre>"},{"location":"api/Classes/struct____CFBDApplication/#variable-bootargs","title":"variable bootargs","text":"<pre><code>CFBD_BootArgs bootargs;\n</code></pre>"},{"location":"api/Classes/struct____CFBDApplication/#variable-freq_provider","title":"variable freq_provider","text":"<pre><code>CFBD_ClockFreqProvider freq_provider;\n</code></pre>"},{"location":"api/Classes/struct____CFBDApplication/#variable-tick_provider","title":"variable tick_provider","text":"<pre><code>CFBD_ClockTickProvider tick_provider;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/","title":"__CFBD_BaseAnimation","text":"<p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes","title":"Public Attributes","text":"Name uint8_t anim_frames uint32_t anim_frame_delay_ms"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frames","title":"variable anim_frames","text":"<pre><code>uint8_t anim_frames;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frame_delay_ms","title":"variable anim_frame_delay_ms","text":"<pre><code>uint32_t anim_frame_delay_ms;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/","title":"__CFBD_MenuIndicator","text":"<p><code>#include &lt;menu_indicator.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes","title":"Public Attributes","text":"Name uint8_t width uint8_t x"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-width","title":"variable width","text":"<pre><code>uint8_t width;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-x","title":"variable x","text":"<pre><code>uint8_t x;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItem/","title":"__CFBD_MenuItem","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes","title":"Public Attributes","text":"Name char * label CFBDGraphic_Point tl CFBD_MenuItemCallbackPack on_select CFBDGraphic_Text text_obj"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-label","title":"variable label","text":"<pre><code>char * label;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-on_select","title":"variable on_select","text":"<pre><code>CFBD_MenuItemCallbackPack on_select;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-text_obj","title":"variable text_obj","text":"<pre><code>CFBDGraphic_Text text_obj;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/","title":"__CFBD_MenuItemArray","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItem * pItems size_t capacity size_t count"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-pitems","title":"variable pItems","text":"<pre><code>CFBD_MenuItem * pItems;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-capacity","title":"variable capacity","text":"<pre><code>size_t capacity;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-count","title":"variable count","text":"<pre><code>size_t count;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/","title":"__CFBD_ProgressBar","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes","title":"Public Attributes","text":"Name CFBD_ProgressBarOps * ops CFBDGraphic_Point tl CFBDGraphicSize size int32_t min int32_t max int32_t value CFBD_GraphicDevice * device uint8_t border uint8_t padding CFBD_BaseAnimation animation"},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-size","title":"variable size","text":"<pre><code>CFBDGraphicSize size;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-min","title":"variable min","text":"<pre><code>int32_t min;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-max","title":"variable max","text":"<pre><code>int32_t max;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-value","title":"variable value","text":"<pre><code>int32_t value;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-border","title":"variable border","text":"<pre><code>uint8_t border;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-padding","title":"variable padding","text":"<pre><code>uint8_t padding;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ah__no_8h/","title":"lib/config/ah_no.h","text":""},{"location":"api/Files/ah__no_8h/#functions","title":"Functions","text":"Name void CFBD_AH_NO(void )Oh no!"},{"location":"api/Files/ah__no_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ah__no_8h/#function-cfbd_ah_no","title":"function CFBD_AH_NO","text":"<pre><code>static inline void CFBD_AH_NO(\n    void \n)\n</code></pre> <p>Oh no! </p>"},{"location":"api/Files/ah__no_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nstatic inline void CFBD_AH_NO(void)\n{\n    while (1)\n        ;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/animation_8c/","title":"lib/graphic/widget/animation/animation.c","text":""},{"location":"api/Files/animation_8c/#functions","title":"Functions","text":"Name void CFBD_InitBaseAnimation(CFBD_BaseAnimation * pBaseAnimation)create a base animation with default settings"},{"location":"api/Files/animation_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/animation_8c/#function-cfbd_initbaseanimation","title":"function CFBD_InitBaseAnimation","text":"<pre><code>void CFBD_InitBaseAnimation(\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre> <p>create a base animation with default settings </p> <p>Parameters: </p> <ul> <li>pBaseAnimation pointers to the inits </li> </ul>"},{"location":"api/Files/animation_8c/#source-code","title":"Source code","text":"<pre><code>#include \"animation.h\"\n\n#include \"animation_config.h\"\n\nvoid CFBD_InitBaseAnimation(CFBD_BaseAnimation* pBaseAnimation)\n{\n    pBaseAnimation-&gt;anim_frame_delay_ms = CFBD_BASEANIMATION_DELAY_MS;\n    pBaseAnimation-&gt;anim_frames = CFBD_BASEANIMATION_FRAME_CNT;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/animation_8h/","title":"lib/graphic/widget/animation/animation.h","text":""},{"location":"api/Files/animation_8h/#classes","title":"Classes","text":"Name struct CFBD_BaseAnimationOps struct __CFBD_BaseAnimation"},{"location":"api/Files/animation_8h/#types","title":"Types","text":"Name typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation"},{"location":"api/Files/animation_8h/#functions","title":"Functions","text":"Name void CFBD_InitBaseAnimation(CFBD_BaseAnimation * pBaseAnimation)create a base animation with default settings"},{"location":"api/Files/animation_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/animation_8h/#typedef-cfbd_baseanimation","title":"typedef CFBD_BaseAnimation","text":"<pre><code>typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation;\n</code></pre>"},{"location":"api/Files/animation_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/animation_8h/#function-cfbd_initbaseanimation","title":"function CFBD_InitBaseAnimation","text":"<pre><code>void CFBD_InitBaseAnimation(\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre> <p>create a base animation with default settings </p> <p>Parameters: </p> <ul> <li>pBaseAnimation pointers to the inits </li> </ul>"},{"location":"api/Files/animation_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    void (*delay_ms)(uint32_t ms); // animation delays\n} CFBD_BaseAnimationOps;\n\ntypedef struct __CFBD_BaseAnimation\n{\n    uint8_t anim_frames;          /* frames for transition */\n    uint32_t anim_frame_delay_ms; /* delay per frame in ms; if 0, no delay */\n} CFBD_BaseAnimation;\n\nvoid CFBD_InitBaseAnimation(CFBD_BaseAnimation* pBaseAnimation);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/animation__config_8h/","title":"lib/graphic/widget/animation/animation_config.h","text":""},{"location":"api/Files/animation__config_8h/#defines","title":"Defines","text":"Name CFBD_BASEANIMATION_FRAME_CNT CFBD_BASEANIMATION_DELAY_MS"},{"location":"api/Files/animation__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_frame_cnt","title":"define CFBD_BASEANIMATION_FRAME_CNT","text":"<pre><code>#define CFBD_BASEANIMATION_FRAME_CNT (8)\n</code></pre>"},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_delay_ms","title":"define CFBD_BASEANIMATION_DELAY_MS","text":"<pre><code>#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre>"},{"location":"api/Files/animation__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_BASEANIMATION_FRAME_CNT (8)\n#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/app_8c/","title":"lib/application/app.c","text":""},{"location":"api/Files/app_8c/#functions","title":"Functions","text":"Name void _private_init_app() CFBDApplication * getApp(CFBD_Bool request_autoboot)"},{"location":"api/Files/app_8c/#attributes","title":"Attributes","text":"Name CFBDApplication _app"},{"location":"api/Files/app_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/app_8c/#function-_private_init_app","title":"function _private_init_app","text":"<pre><code>static inline void _private_init_app()\n</code></pre>"},{"location":"api/Files/app_8c/#function-getapp","title":"function getApp","text":"<pre><code>CFBDApplication * getApp(\n    CFBD_Bool request_autoboot\n)\n</code></pre>"},{"location":"api/Files/app_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/app_8c/#variable-_app","title":"variable _app","text":"<pre><code>static CFBDApplication _app;\n</code></pre>"},{"location":"api/Files/app_8c/#source-code","title":"Source code","text":"<pre><code>#include \"app.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"ah_no.h\"\n#include \"cfbd_define.h\"\n\nstatic CFBDApplication _app;\n\nstatic inline void _private_init_app()\n{\n    CFBDBootTuple* pBootTuple = CFBD_AppBootMaker();\n    _app.bootargs = pBootTuple ? pBootTuple-&gt;args : NULL;\n    _app.selfBootFunc = pBootTuple ? pBootTuple-&gt;boot_func : NULL;\n    _app.freq_provider = CFBD_AppClockProvider();\n    _app.tick_provider = CFBD_AppTickProvider();\n    if (!_app.freq_provider) {\n        CFBD_AH_NO();\n    }\n}\n\nCFBDApplication* getApp(CFBD_Bool request_autoboot)\n{\n    _private_init_app();\n\n    if (request_autoboot) {\n        _app.selfBootFunc(_app.bootargs);\n    }\n\n    return &amp;_app;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/app_8h/","title":"lib/application/app.h","text":""},{"location":"api/Files/app_8h/#classes","title":"Classes","text":"Name struct __CFBDApplication"},{"location":"api/Files/app_8h/#types","title":"Types","text":"Name typedef uint32_t(*)(void) CFBD_ClockFreqProvider typedef uint32_t(*)(void) CFBD_ClockTickProvider typedef struct __CFBDApplication CFBDApplication"},{"location":"api/Files/app_8h/#functions","title":"Functions","text":"Name CFBDBootTuple * CFBD_AppBootMaker(void ) CFBD_ClockFreqProvider CFBD_AppClockProvider(void ) CFBD_ClockTickProvider CFBD_AppTickProvider(void ) CFBDApplication * getApp(CFBD_Bool request_auto_boot)"},{"location":"api/Files/app_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/app_8h/#typedef-cfbd_clockfreqprovider","title":"typedef CFBD_ClockFreqProvider","text":"<pre><code>typedef uint32_t(* CFBD_ClockFreqProvider) (void);\n</code></pre>"},{"location":"api/Files/app_8h/#typedef-cfbd_clocktickprovider","title":"typedef CFBD_ClockTickProvider","text":"<pre><code>typedef uint32_t(* CFBD_ClockTickProvider) (void);\n</code></pre>"},{"location":"api/Files/app_8h/#typedef-cfbdapplication","title":"typedef CFBDApplication","text":"<pre><code>typedef struct __CFBDApplication CFBDApplication;\n</code></pre>"},{"location":"api/Files/app_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/app_8h/#function-cfbd_appbootmaker","title":"function CFBD_AppBootMaker","text":"<pre><code>CFBDBootTuple * CFBD_AppBootMaker(\n    void \n)\n</code></pre>"},{"location":"api/Files/app_8h/#function-cfbd_appclockprovider","title":"function CFBD_AppClockProvider","text":"<pre><code>CFBD_ClockFreqProvider CFBD_AppClockProvider(\n    void \n)\n</code></pre>"},{"location":"api/Files/app_8h/#function-cfbd_apptickprovider","title":"function CFBD_AppTickProvider","text":"<pre><code>CFBD_ClockTickProvider CFBD_AppTickProvider(\n    void \n)\n</code></pre>"},{"location":"api/Files/app_8h/#function-getapp","title":"function getApp","text":"<pre><code>CFBDApplication * getApp(\n    CFBD_Bool request_auto_boot\n)\n</code></pre>"},{"location":"api/Files/app_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"sys_boot/boot.h\"\n\ntypedef uint32_t (*CFBD_ClockFreqProvider)(void);\ntypedef uint32_t (*CFBD_ClockTickProvider)(void);\n\ntypedef struct __CFBDApplication\n{\n    CFBD_BootStrapFunc selfBootFunc;\n    CFBD_BootArgs bootargs;\n    CFBD_ClockFreqProvider freq_provider;\n    CFBD_ClockTickProvider tick_provider;\n} CFBDApplication;\n\nextern CFBDBootTuple* CFBD_AppBootMaker(void);\nextern CFBD_ClockFreqProvider CFBD_AppClockProvider(void);\nextern CFBD_ClockTickProvider CFBD_AppTickProvider(void);\n\nCFBDApplication* getApp(CFBD_Bool request_auto_boot);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/arc_8c/","title":"lib/graphic/base/arc.c","text":""},{"location":"api/Files/arc_8c/#functions","title":"Functions","text":"Name CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end) void clearArea(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void updateArea(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CCGraphic_Arc * arc)"},{"location":"api/Files/arc_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) DRAW_IF_IN(offsetx, offsety)"},{"location":"api/Files/arc_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8c/#function-__pvt_is_in_angle","title":"function __pvt_is_in_angle","text":"<pre><code>static CFBD_Bool __pvt_is_in_angle(\n    int16_t x,\n    int16_t y,\n    int16_t start,\n    int16_t end\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cleararea","title":"function clearArea","text":"<pre><code>static void clearArea(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-updatearea","title":"function updateArea","text":"<pre><code>static void updateArea(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/arc_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_if_in","title":"define DRAW_IF_IN","text":"<pre><code>#define DRAW_IF_IN(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#source-code","title":"Source code","text":"<pre><code>#include \"arc.h\"\n\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n\nstatic CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end)\n{\n    int16_t point_angle = (atan2(y, x) / 3.14 * 180);\n    return start &lt; end ? (start &lt; point_angle &amp;&amp; point_angle &lt; end)\n                       : (start &gt; point_angle || point_angle &gt; end);\n}\n\nstatic void clearArea(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void updateArea(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n\n#define DRAW_IF_IN(offsetx, offsety)                                                               \\\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    PREANNOUNCE;\n    clearArea(device, arc);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n    clearArea(device, arc);\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    __x = x;\n    __y = y;\n\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    /*\u904d\u5386\u8d77\u59cb\u70b9Y\u5750\u6807*/\n    for (int16_t j = -y; j &lt; y; j++) {\n        /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(0, j);\n    }\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n\n        /*\u904d\u5386\u4e2d\u95f4\u90e8\u5206*/\n        for (int16_t j = -y; j &lt; y; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(x, j);\n            DRAW_IF_IN(-x, j);\n        }\n\n        /*\u904d\u5386\u4e24\u4fa7\u90e8\u5206*/\n        for (int16_t j = -x; j &lt; x; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(y, j);\n            DRAW_IF_IN(-y, j);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef DRAW_IF_IN\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/arc_8h/","title":"lib/graphic/base/arc.h","text":""},{"location":"api/Files/arc_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Arc"},{"location":"api/Files/arc_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CCGraphic_Arc * circle) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CCGraphic_Arc * circle)"},{"location":"api/Files/arc_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\ntypedef struct\n{\n    CFBDGraphic_Point center;\n    PointBaseType radius;\n    int16_t start_degree;\n    int16_t end_degree;\n} CCGraphic_Arc;\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ascii6x8_8source_8c/","title":"lib/graphic/resource/default/ascii6x8.source.c","text":""},{"location":"api/Files/ascii6x8_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  6x8 OLED display using 6x8 pixel font representation.\n//  Each character in this font set is defined by an \n//  6x8 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii6x8_sources[][6];\n// ---------------------------------------------\n#if ENABLE_ASCII_6x8_SOURCES\nconst uint8_t ascii6x8_sources[][6] = \n{\n    {0x00,0x00,0x00,0x00,0x00,0x00}, // 0\n    {0x00,0x00,0x00,0x2F,0x00,0x00}, // ! 1\n    {0x00,0x00,0x07,0x00,0x07,0x00}, // \" 2\n    {0x00,0x14,0x7F,0x14,0x7F,0x14}, // # 3\n    {0x00,0x24,0x2A,0x7F,0x2A,0x12}, // $ 4\n    {0x00,0x23,0x13,0x08,0x64,0x62}, // % 5\n    {0x00,0x36,0x49,0x55,0x22,0x50}, // &amp; 6\n    {0x00,0x00,0x00,0x07,0x00,0x00}, // ' 7\n    {0x00,0x00,0x1C,0x22,0x41,0x00}, // ( 8\n    {0x00,0x00,0x41,0x22,0x1C,0x00}, // ) 9\n    {0x00,0x14,0x08,0x3E,0x08,0x14}, // * 10\n    {0x00,0x08,0x08,0x3E,0x08,0x08}, // + 11\n    {0x00,0x00,0x00,0xA0,0x60,0x00}, // , 12\n    {0x00,0x08,0x08,0x08,0x08,0x08}, // - 13\n    {0x00,0x00,0x60,0x60,0x00,0x00}, // . 14\n    {0x00,0x20,0x10,0x08,0x04,0x02}, // / 15\n    {0x00,0x3E,0x51,0x49,0x45,0x3E}, // 0 16\n    {0x00,0x00,0x42,0x7F,0x40,0x00}, // 1 17\n    {0x00,0x42,0x61,0x51,0x49,0x46}, // 2 18\n    {0x00,0x21,0x41,0x45,0x4B,0x31}, // 3 19\n    {0x00,0x18,0x14,0x12,0x7F,0x10}, // 4 20\n    {0x00,0x27,0x45,0x45,0x45,0x39}, // 5 21\n    {0x00,0x3C,0x4A,0x49,0x49,0x30}, // 6 22\n    {0x00,0x01,0x71,0x09,0x05,0x03}, // 7 23\n    {0x00,0x36,0x49,0x49,0x49,0x36}, // 8 24\n    {0x00,0x06,0x49,0x49,0x29,0x1E}, // 9 25\n    {0x00,0x00,0x36,0x36,0x00,0x00}, // : 26\n    {0x00,0x00,0x56,0x36,0x00,0x00}, // ; 27\n    {0x00,0x08,0x14,0x22,0x41,0x00}, // &lt; 28\n    {0x00,0x14,0x14,0x14,0x14,0x14}, // = 29\n    {0x00,0x00,0x41,0x22,0x14,0x08}, // &gt; 30\n    {0x00,0x02,0x01,0x51,0x09,0x06}, // ? 31\n    {0x00,0x3E,0x49,0x55,0x59,0x2E}, // @ 32\n    {0x00,0x7C,0x12,0x11,0x12,0x7C}, // A 33\n    {0x00,0x7F,0x49,0x49,0x49,0x36}, // B 34\n    {0x00,0x3E,0x41,0x41,0x41,0x22}, // C 35\n    {0x00,0x7F,0x41,0x41,0x22,0x1C}, // D 36\n    {0x00,0x7F,0x49,0x49,0x49,0x41}, // E 37\n    {0x00,0x7F,0x09,0x09,0x09,0x01}, // F 38\n    {0x00,0x3E,0x41,0x49,0x49,0x7A}, // G 39\n    {0x00,0x7F,0x08,0x08,0x08,0x7F}, // H 40\n    {0x00,0x00,0x41,0x7F,0x41,0x00}, // I 41\n    {0x00,0x20,0x40,0x41,0x3F,0x01}, // J 42\n    {0x00,0x7F,0x08,0x14,0x22,0x41}, // K 43\n    {0x00,0x7F,0x40,0x40,0x40,0x40}, // L 44\n    {0x00,0x7F,0x02,0x0C,0x02,0x7F}, // M 45\n    {0x00,0x7F,0x04,0x08,0x10,0x7F}, // N 46\n    {0x00,0x3E,0x41,0x41,0x41,0x3E}, // O 47\n    {0x00,0x7F,0x09,0x09,0x09,0x06}, // P 48\n    {0x00,0x3E,0x41,0x51,0x21,0x5E}, // Q 49\n    {0x00,0x7F,0x09,0x19,0x29,0x46}, // R 50\n    {0x00,0x46,0x49,0x49,0x49,0x31}, // S 51\n    {0x00,0x01,0x01,0x7F,0x01,0x01}, // T 52\n    {0x00,0x3F,0x40,0x40,0x40,0x3F}, // U 53\n    {0x00,0x1F,0x20,0x40,0x20,0x1F}, // V 54\n    {0x00,0x3F,0x40,0x38,0x40,0x3F}, // W 55\n    {0x00,0x63,0x14,0x08,0x14,0x63}, // X 56\n    {0x00,0x07,0x08,0x70,0x08,0x07}, // Y 57\n    {0x00,0x61,0x51,0x49,0x45,0x43}, // Z 58\n    {0x00,0x00,0x7F,0x41,0x41,0x00}, // [ 59\n    {0x00,0x02,0x04,0x08,0x10,0x20}, // \\ 60\n    {0x00,0x00,0x41,0x41,0x7F,0x00}, // ] 61\n    {0x00,0x04,0x02,0x01,0x02,0x04}, // ^ 62\n    {0x00,0x40,0x40,0x40,0x40,0x40}, // _ 63\n    {0x00,0x00,0x01,0x02,0x04,0x00}, // ` 64\n    {0x00,0x20,0x54,0x54,0x54,0x78}, // a 65\n    {0x00,0x7F,0x48,0x44,0x44,0x38}, // b 66\n    {0x00,0x38,0x44,0x44,0x44,0x20}, // c 67\n    {0x00,0x38,0x44,0x44,0x48,0x7F}, // d 68\n    {0x00,0x38,0x54,0x54,0x54,0x18}, // e 69\n    {0x00,0x08,0x7E,0x09,0x01,0x02}, // f 70\n    {0x00,0x18,0xA4,0xA4,0xA4,0x7C}, // g 71\n    {0x00,0x7F,0x08,0x04,0x04,0x78}, // h 72\n    {0x00,0x00,0x44,0x7D,0x40,0x00}, // i 73\n    {0x00,0x40,0x80,0x84,0x7D,0x00}, // j 74\n    {0x00,0x7F,0x10,0x28,0x44,0x00}, // k 75\n    {0x00,0x00,0x41,0x7F,0x40,0x00}, // l 76\n    {0x00,0x7C,0x04,0x18,0x04,0x78}, // m 77\n    {0x00,0x7C,0x08,0x04,0x04,0x78}, // n 78\n    {0x00,0x38,0x44,0x44,0x44,0x38}, // o 79\n    {0x00,0xFC,0x24,0x24,0x24,0x18}, // p 80\n    {0x00,0x18,0x24,0x24,0x18,0xFC}, // q 81\n    {0x00,0x7C,0x08,0x04,0x04,0x08}, // r 82\n    {0x00,0x48,0x54,0x54,0x54,0x20}, // s 83\n    {0x00,0x04,0x3F,0x44,0x40,0x20}, // t 84\n    {0x00,0x3C,0x40,0x40,0x20,0x7C}, // u 85\n    {0x00,0x1C,0x20,0x40,0x20,0x1C}, // v 86\n    {0x00,0x3C,0x40,0x30,0x40,0x3C}, // w 87\n    {0x00,0x44,0x28,0x10,0x28,0x44}, // x 88\n    {0x00,0x1C,0xA0,0xA0,0xA0,0x7C}, // y 89\n    {0x00,0x44,0x64,0x54,0x4C,0x44}, // z 90\n    {0x00,0x00,0x08,0x7F,0x41,0x00}, // { 91\n    {0x00,0x00,0x00,0x7F,0x00,0x00}, // | 92\n    {0x00,0x00,0x41,0x7F,0x08,0x00}, // } 93\n    {0x00,0x08,0x04,0x08,0x10,0x08}, // ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ascii8x16_8source_8c/","title":"lib/graphic/resource/default/ascii8x16.source.c","text":""},{"location":"api/Files/ascii8x16_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  8x16 OLED display using 8x16 pixel font representation.\n//  Each character in this font set is defined by an \n//  8x16 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii8x16_sources[][16];\n// ---------------------------------------------\n#if ENABLE_ASCII_8x16_SOURCES\nconst uint8_t ascii8x16_sources[][16] =\n{\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//   0\n    {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},// ! 1\n    {0x00,0x16,0x0E,0x00,0x16,0x0E,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// \" 2\n    {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,\n    0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},// # 3\n    {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,\n    0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},// $ 4\n    {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,\n    0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},// % 5\n    {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,\n    0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},// &amp; 6\n    {0x00,0x00,0x00,0x16,0x0E,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ' 7\n    {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,\n    0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},// ( 8\n    {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,\n    0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},// ) 9\n    {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,\n    0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},// * 10\n    {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,\n    0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},// + 11\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},// , 12\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},// - 13\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},// . 14\n    {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,\n    0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},// / 15\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},// 0 16\n    {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// 1 17\n    {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},// 2 18\n    {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,\n    0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},// 3 19\n    {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,\n    0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},// 4 20\n    {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,\n    0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},// 5 21\n    {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,\n    0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},// 6 22\n    {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},// 7 23\n    {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},// 8 24\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},// 9 25\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},// : 26\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00},// ; 27\n    {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,\n    0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},// &lt; 28\n    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,\n    0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},// = 29\n    {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,\n    0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},// &gt; 30\n    {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,\n    0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},// ? 31\n    {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,\n    0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},// @ 32\n    {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,\n    0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},// A 33\n    {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},// B 34\n    {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,\n    0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},// C 35\n    {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},// D 36\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},// E 37\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},// F 38\n    {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,\n    0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},// G 39\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},// H 40\n    {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// I 41\n    {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,\n    0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},// J 42\n    {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,\n    0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},// K 43\n    {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},// L 44\n    {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,\n    0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},// M 45\n    {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},// N 46\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},// O 47\n    {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,\n    0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},// P 48\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},// Q 49\n    {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},// R 50\n    {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,\n    0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},// S 51\n    {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// T 52\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// U 53\n    {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,\n    0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},// V 54\n    {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,\n    0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},// W 55\n    {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,\n    0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},// X 56\n    {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// Y 57\n    {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},// Z 58\n    {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,\n    0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},// [ 59\n    {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},// \\ 60\n    {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},// ] 61\n    {0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ^ 62\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},// _ 63\n    {0x00,0x02,0x04,0x08,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ` 64\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},// a 65\n    {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},// b 66\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},// c 67\n    {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},// d 68\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},// e 69\n    {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// f 70\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},// g 71\n    {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},// h 72\n    {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// i 73\n    {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,\n    0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},// j 74\n    {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},// k 75\n    {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// l 76\n    {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},// m 77\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x00,0x00,\n    0x00,0x20,0x3F,0x21,0x00,0x20,0x3F,0x20},// n 78\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// o 79\n    {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},// p 80\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},// q 81\n    {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},// r 82\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},// s 83\n    {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,\n    0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},// t 84\n    {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},// u 85\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},// v 86\n    {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,\n    0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},// w 87\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},// x 88\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},// y 89\n    {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},// z 90\n    {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,\n    0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},// { 91\n    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},// | 92\n    {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},// } 93\n    {0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x80,\n    0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00},// ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/base__helpers_8h/","title":"lib/graphic/base/base_helpers.h","text":""},{"location":"api/Files/base__helpers_8h/#functions","title":"Functions","text":"Name int32_t asInt32_t(PointBaseType v) PointBaseType clamp_u16_from_i32(int32_t v)"},{"location":"api/Files/base__helpers_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/base__helpers_8h/#function-asint32_t","title":"function asInt32_t","text":"<pre><code>static inline int32_t asInt32_t(\n    PointBaseType v\n)\n</code></pre>"},{"location":"api/Files/base__helpers_8h/#function-clamp_u16_from_i32","title":"function clamp_u16_from_i32","text":"<pre><code>static inline PointBaseType clamp_u16_from_i32(\n    int32_t v\n)\n</code></pre>"},{"location":"api/Files/base__helpers_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;limits.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_graphic_define.h\"\n\nstatic inline int32_t asInt32_t(PointBaseType v)\n{\n    return (int32_t) v;\n}\n\nstatic inline PointBaseType clamp_u16_from_i32(int32_t v)\n{\n    if (v &lt; 0)\n        return 0;\n    if (v &gt; INT_MAX)\n        v = INT_MAX;\n    if (v &gt; UINT16_MAX)\n        return UINT16_MAX;\n    return (PointBaseType) v;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/benchmark_8c/","title":"lib/graphic/benchmark/benchmark.c","text":""},{"location":"api/Files/benchmark_8c/#functions","title":"Functions","text":"Name void test_fps_benchmark(CFBD_GraphicDevice * handler) void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8c/#function-test_fps_benchmark","title":"function test_fps_benchmark","text":"<pre><code>static void test_fps_benchmark(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"config/system_settings.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/text.h\"\n\n// FPS\u6027\u80fd\u6d4b\u8bd5 - \u5728OLED\u5c4f\u5e55\u4e0a\u663e\u793a\u5237\u65b0\u7387\nstatic void test_fps_benchmark(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n\n    CFBDGraphic_Text fps_text;\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;fps_text, p, screen_size, ASCII_6x8);\n\n    uint32_t frame_count = 0;\n    uint32_t last_time = HAL_GetTick();\n\n    uint32_t fps_x10 = 0; // FPS * 10\uff08\u5b9a\u70b9\u6570\uff09\n    char buffer[64];\n\n    uint32_t test_start = HAL_GetTick();\n    uint32_t test_duration = 30000;\n\n    while ((HAL_GetTick() - test_start) &lt; test_duration) {\n        // CFBDGraphic_DeviceClearImmediate(handler);\n\n        frame_count++;\n        uint32_t current_time = HAL_GetTick();\n        uint32_t elapsed = current_time - last_time;\n\n        // \u6bcf 500ms \u66f4\u65b0\u4e00\u6b21 FPS\n        if (elapsed &gt;= 500) {\n            // fps_x10 = frame_count * 1000 * 10 / elapsed\n            fps_x10 = (frame_count * 10000U) / elapsed;\n\n            frame_count = 0;\n            last_time = current_time;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"FPS: %lu.%lu\\n\"\n                 \"Time: %lus\\n\",\n                 fps_x10 / 10,\n                 fps_x10 % 10,\n                 (HAL_GetTick() - test_start) / 1000);\n\n        CFBDGraphic_SetText(&amp;fps_text, buffer);\n        CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    CFBDGraphic_DeviceClearImmediate(handler);\n    snprintf(buffer,\n             sizeof(buffer),\n             \"Test Complete!\\n\"\n             \"Final FPS: %lu.%lu\",\n             fps_x10 / 10,\n             fps_x10 % 10);\n\n    CFBDGraphic_SetText(&amp;fps_text, buffer);\n    CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nvoid test_fps(CFBD_GraphicDevice* handler)\n{\n    test_fps_benchmark(handler);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/benchmark_8h/","title":"lib/graphic/benchmark/benchmark.h","text":""},{"location":"api/Files/benchmark_8h/#functions","title":"Functions","text":"Name void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8h/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_fps(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/boot_8c/","title":"lib/application/sys_boot/boot.c","text":"<p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/boot_8h/","title":"lib/application/sys_boot/boot.h","text":"<p>More...</p>"},{"location":"api/Files/boot_8h/#classes","title":"Classes","text":"Name struct CFBDBootTuple"},{"location":"api/Files/boot_8h/#types","title":"Types","text":"Name typedef void * CFBD_BootArgs typedef CFBD_Bool(*)(CFBD_BootArgs) CFBD_BootStrapFunc"},{"location":"api/Files/boot_8h/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-09</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/boot_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/boot_8h/#typedef-cfbd_bootargs","title":"typedef CFBD_BootArgs","text":"<pre><code>typedef void* CFBD_BootArgs;\n</code></pre>"},{"location":"api/Files/boot_8h/#typedef-cfbd_bootstrapfunc","title":"typedef CFBD_BootStrapFunc","text":"<pre><code>typedef CFBD_Bool(* CFBD_BootStrapFunc) (CFBD_BootArgs);\n</code></pre>"},{"location":"api/Files/boot_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef void* CFBD_BootArgs;\ntypedef CFBD_Bool (*CFBD_BootStrapFunc)(CFBD_BootArgs);\n\ntypedef struct\n{\n    CFBD_BootStrapFunc boot_func;\n    CFBD_BootArgs args;\n} CFBDBootTuple;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/cache__config_8h/","title":"lib/oled/configs/cache_config.h","text":""},{"location":"api/Files/cache__config_8h/#defines","title":"Defines","text":"Name CACHED_HEIGHT CACHED_WIDTH"},{"location":"api/Files/cache__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/cache__config_8h/#define-cached_height","title":"define CACHED_HEIGHT","text":"<pre><code>#define CACHED_HEIGHT (8)\n</code></pre>"},{"location":"api/Files/cache__config_8h/#define-cached_width","title":"define CACHED_WIDTH","text":"<pre><code>#define CACHED_WIDTH (144)\n</code></pre>"},{"location":"api/Files/cache__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n/* Array Size */\n#define CACHED_HEIGHT (8)\n#define CACHED_WIDTH (144)\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/cfbd__define_8h/","title":"lib/config/cfbd_define.h","text":""},{"location":"api/Files/cfbd__define_8h/#types","title":"Types","text":"Name typedef uint8_t CFBD_Bool Library bools. typedef CFBD_Bool(*)(void *self_handle, void *args) SelfInitFunc typedef void(*)(void *args) PlainFunc"},{"location":"api/Files/cfbd__define_8h/#defines","title":"Defines","text":"Name CFBD_FALSE CFBD_TRUE"},{"location":"api/Files/cfbd__define_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/cfbd__define_8h/#typedef-cfbd_bool","title":"typedef CFBD_Bool","text":"<pre><code>typedef uint8_t CFBD_Bool;\n</code></pre> <p>Library bools. </p>"},{"location":"api/Files/cfbd__define_8h/#typedef-selfinitfunc","title":"typedef SelfInitFunc","text":"<pre><code>typedef CFBD_Bool(* SelfInitFunc) (void *self_handle, void *args);\n</code></pre>"},{"location":"api/Files/cfbd__define_8h/#typedef-plainfunc","title":"typedef PlainFunc","text":"<pre><code>typedef void(* PlainFunc) (void *args);\n</code></pre>"},{"location":"api/Files/cfbd__define_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/cfbd__define_8h/#define-cfbd_false","title":"define CFBD_FALSE","text":"<pre><code>#define CFBD_FALSE (0)\n</code></pre>"},{"location":"api/Files/cfbd__define_8h/#define-cfbd_true","title":"define CFBD_TRUE","text":"<pre><code>#define CFBD_TRUE (1)\n</code></pre>"},{"location":"api/Files/cfbd__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\ntypedef uint8_t CFBD_Bool;\n#define CFBD_FALSE (0)\n#define CFBD_TRUE (1)\n\ntypedef CFBD_Bool (*SelfInitFunc)(void* self_handle, void* args);\ntypedef void (*PlainFunc)(void* args);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/cfbd__graphic__define_8h/","title":"lib/graphic/cfbd_graphic_define.h","text":""},{"location":"api/Files/cfbd__graphic__define_8h/#types","title":"Types","text":"Name typedef uint16_t PointBaseType typedef PointBaseType SizeBaseType typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice"},{"location":"api/Files/cfbd__graphic__define_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-pointbasetype","title":"typedef PointBaseType","text":"<pre><code>typedef uint16_t PointBaseType;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-sizebasetype","title":"typedef SizeBaseType","text":"<pre><code>typedef PointBaseType SizeBaseType;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef uint16_t PointBaseType;\ntypedef PointBaseType SizeBaseType;\n\ntypedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/circle_8c/","title":"lib/graphic/base/circle.c","text":""},{"location":"api/Files/circle_8c/#functions","title":"Functions","text":"Name void circle_calc_bbox(CFBDGraphicCircle * c, int32_t * lx, int32_t * ty, int32_t * rx, int32_t * by) void clearBound(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety)"},{"location":"api/Files/circle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8c/#function-circle_calc_bbox","title":"function circle_calc_bbox","text":"<pre><code>static inline void circle_calc_bbox(\n    CFBDGraphicCircle * c,\n    int32_t * lx,\n    int32_t * ty,\n    int32_t * rx,\n    int32_t * by\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/circle_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/circle_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/circle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"circle.h\"\n\n#include &lt;assert.h&gt;\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\nstatic inline void\ncircle_calc_bbox(CFBDGraphicCircle* c, int32_t* lx, int32_t* ty, int32_t* rx, int32_t* by)\n{\n    *lx = asInt32_t(c-&gt;center.x) - c-&gt;radius;\n    *ty = asInt32_t(c-&gt;center.y) - c-&gt;radius;\n    *rx = asInt32_t(c-&gt;center.x) + c-&gt;radius;\n    *by = asInt32_t(c-&gt;center.y) + c-&gt;radius;\n}\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    int32_t lx, ty, rx, by;\n    circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n    handler-&gt;ops-&gt;clear_area(handler,\n                             clamp_u16_from_i32(lx),\n                             clamp_u16_from_i32(ty),\n                             clamp_u16_from_i32(rx - lx + 1),\n                             clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    clearBound(handler, circle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    /* Ref Doc: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/\n    /* Ref Toturial: https://www.bilibili.com/video/BV1VM4y1u7wJ*/\n    int16_t d = 3 - circle-&gt;radius / 4;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    int16_t d = 1 - circle-&gt;radius;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n    clearBound(handler, circle);\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    for (int16_t i = -y; i &lt; y; i++)\n        DRAW_OFFSET_POINT(0, i);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n        for (int16_t i = -y; i &lt; y; i++) {\n            DRAW_OFFSET_POINT(x, i);\n            DRAW_OFFSET_POINT(-x, i);\n        }\n        for (int16_t i = -x; i &lt; x; i++) {\n            DRAW_OFFSET_POINT(y, i);\n            DRAW_OFFSET_POINT(-y, i);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/circle_8h/","title":"lib/graphic/base/circle.h","text":""},{"location":"api/Files/circle_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicCircle"},{"location":"api/Files/circle_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct\n{\n    SizeBaseType radius;\n    CFBDGraphic_Point center;\n} CFBDGraphicCircle;\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/config_8h/","title":"lib/graphic/resource/config.h","text":""},{"location":"api/Files/config_8h/#defines","title":"Defines","text":"Name ENABLE_ASCII_6x8_SOURCES ENABLE_ASCII_8x16_SOURCES"},{"location":"api/Files/config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/config_8h/#define-enable_ascii_6x8_sources","title":"define ENABLE_ASCII_6x8_SOURCES","text":"<pre><code>#define ENABLE_ASCII_6x8_SOURCES 1\n</code></pre>"},{"location":"api/Files/config_8h/#define-enable_ascii_8x16_sources","title":"define ENABLE_ASCII_8x16_SOURCES","text":"<pre><code>#define ENABLE_ASCII_8x16_SOURCES 1\n</code></pre>"},{"location":"api/Files/config_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef CCGraphic_Config_H\n#define CCGraphic_Config_H\n\n#ifdef _USE_NO_DEFAULT_SOURCES // DISABLE THE SOURCES\n#define ENABLE_ASCII_6x8_SOURCES 0\n#define ENABLE_ASCII_8X16_SOURCES 0\n#else\n/* then enable all first */\n#define ENABLE_ASCII_6x8_SOURCES 1\n#define ENABLE_ASCII_8x16_SOURCES 1\n\n/* disabled one by one */\n#ifdef DISABLE_ASCII_6X8_SOURCES\n#undef ENABLE_ASCII_6x8_SOURCES\n#define ENABLE_ASCII_6x8_SOURCES 0\n#endif\n\n#ifdef DISABLE_ASCII_8X16_SOURCES\n#undef ENABLE_ASCII_8X16_SOURCES\n#define ENABLE_ASCII_8X16_SOURCES 0\n#endif\n\n#endif // for the _USE_NO_DEFAULT_SOURCES\n\n#endif // for the no-repeative\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/device__interface_8h/","title":"lib/oled/driver/device/device_interface.h","text":""},{"location":"api/Files/device__interface_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_DeviceSpecific"},{"location":"api/Files/device__interface_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    uint8_t* (*init_session_tables)(void);\n    uint8_t** grams;\n    uint16_t init_session_tables_sz;\n    uint8_t data_prefix;\n    uint8_t cmd_prefix;\n    uint16_t logic_width;\n    uint16_t logic_height;\n} CFBD_OLED_DeviceSpecific;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/","title":"lib/graphic/fast_test","text":""},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/#files","title":"Files","text":"Name lib/graphic/fast_test/test_base_graphic.c lib/graphic/fast_test/test_base_graphic.h lib/graphic/fast_test/test_widget.c lib/graphic/fast_test/test_widget.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/","title":"lib/config","text":""},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/#files","title":"Files","text":"Name lib/config/ah_no.h lib/config/cfbd_define.h lib/config/lib_settings.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/","title":"lib/graphic","text":""},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#directories","title":"Directories","text":"Name lib/graphic/base lib/graphic/benchmark lib/graphic/device lib/graphic/fast_test lib/graphic/resource lib/graphic/widget"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#files","title":"Files","text":"Name lib/graphic/cfbd_graphic_define.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/","title":"lib/graphic/resource","text":""},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#directories","title":"Directories","text":"Name lib/graphic/resource/default"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#files","title":"Files","text":"Name lib/graphic/resource/config.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/","title":"lib/oled/driver","text":""},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/#directories","title":"Directories","text":"Name lib/oled/driver/backend lib/oled/driver/device <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/","title":"lib/application/sys_boot","text":""},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/#files","title":"Files","text":"Name lib/application/sys_boot/boot.c lib/application/sys_boot/boot.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/","title":"lib/oled","text":""},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#directories","title":"Directories","text":"Name lib/oled/configs lib/oled/driver"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#files","title":"Files","text":"Name lib/oled/oled.c lib/oled/oled.h oled general handles <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/","title":"lib/oled/driver/device/ssd1306","text":""},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1306/ssd1306.c lib/oled/driver/device/ssd1306/ssd1306.h import the func to init ssd1306 specifics <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/","title":"lib/graphic/device","text":""},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#directories","title":"Directories","text":"Name lib/graphic/device/oled"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#files","title":"Files","text":"Name lib/graphic/device/grapgic_device.c lib/graphic/device/graphic_device.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/","title":"lib/gpio","text":""},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/#files","title":"Files","text":"Name lib/gpio/gpio-stm-impl.c lib/gpio/gpio-stm-impl.h lib/gpio/gpio.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/","title":"lib/graphic/widget/menu","text":""},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/#files","title":"Files","text":"Name lib/graphic/widget/menu/menu.c lib/graphic/widget/menu/menu.h lib/graphic/widget/menu/menu_config.h lib/graphic/widget/menu/menu_indicator.c lib/graphic/widget/menu/menu_indicator.h lib/graphic/widget/menu/menu_item.c lib/graphic/widget/menu/menu_item.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/","title":"lib/graphic/base","text":""},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/#files","title":"Files","text":"Name lib/graphic/base/arc.c lib/graphic/base/arc.h lib/graphic/base/base_helpers.h lib/graphic/base/circle.c lib/graphic/base/circle.h lib/graphic/base/ellipse.c lib/graphic/base/ellipse.h lib/graphic/base/line.c lib/graphic/base/line.h lib/graphic/base/point.h lib/graphic/base/rectangle.c lib/graphic/base/rectangle.h lib/graphic/base/size.c lib/graphic/base/size.h lib/graphic/base/triangle.c lib/graphic/base/triangle.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/","title":"lib/application/sys_clock","text":""},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/#files","title":"Files","text":"Name lib/application/sys_clock/system_clock.c lib/application/sys_clock/system_clock.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/","title":"lib/oled/configs","text":""},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/#files","title":"Files","text":"Name lib/oled/configs/cache_config.h lib/oled/configs/external_impl_driver.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/","title":"lib/graphic/benchmark","text":""},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/#files","title":"Files","text":"Name lib/graphic/benchmark/benchmark.c lib/graphic/benchmark/benchmark.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/","title":"lib/graphic/widget","text":""},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#directories","title":"Directories","text":"Name lib/graphic/widget/animation lib/graphic/widget/base_support lib/graphic/widget/menu lib/graphic/widget/progressbar"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#files","title":"Files","text":"Name lib/graphic/widget/margin.h lib/graphic/widget/text.c lib/graphic/widget/text.h lib/graphic/widget/text_config.c lib/graphic/widget/text_config.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/","title":"lib/graphic/widget/progressbar","text":""},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/#files","title":"Files","text":"Name lib/graphic/widget/progressbar/progressbar.c lib/graphic/widget/progressbar/progressbar.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/","title":"lib/oled/driver/device/ssd1309","text":""},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1309/ssd1309.c lib/oled/driver/device/ssd1309/ssd1309.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/","title":"lib","text":""},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/#directories","title":"Directories","text":"Name lib/application lib/config lib/gpio lib/graphic lib/iic lib/oled <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/","title":"lib/graphic/resource/default","text":""},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/#files","title":"Files","text":"Name lib/graphic/resource/default/ascii6x8.source.c lib/graphic/resource/default/ascii8x16.source.c <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/","title":"lib/application","text":""},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#directories","title":"Directories","text":"Name lib/application/sys_boot lib/application/sys_clock"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#files","title":"Files","text":"Name lib/application/app.c lib/application/app.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/","title":"lib/oled/driver/device","text":""},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#directories","title":"Directories","text":"Name lib/oled/driver/device/ssd1306 lib/oled/driver/device/ssd1309"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#files","title":"Files","text":"Name lib/oled/driver/device/device_interface.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_b8634a52f9b73d7c45618692cc54ea1b/","title":"lib/graphic/widget/base_support/common","text":""},{"location":"api/Files/dir_b8634a52f9b73d7c45618692cc54ea1b/#files","title":"Files","text":"Name lib/graphic/widget/base_support/common/helpers.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/","title":"lib/graphic/device/oled","text":""},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/#files","title":"Files","text":"Name lib/graphic/device/oled/oled_graphic_device.c lib/graphic/device/oled/oled_graphic_device.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/","title":"lib/oled/driver/backend","text":""},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/#files","title":"Files","text":"Name lib/oled/driver/backend/oled_iic.c lib/oled/driver/backend/oled_iic.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/","title":"lib/graphic/widget/animation","text":""},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/#files","title":"Files","text":"Name lib/graphic/widget/animation/animation.c lib/graphic/widget/animation/animation.h lib/graphic/widget/animation/animation_config.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/","title":"lib/iic","text":""},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#directories","title":"Directories","text":"Name lib/iic/backend"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#files","title":"Files","text":"Name lib/iic/iic.c lib/iic/iic.h lib/iic/iic_error.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/","title":"lib/graphic/widget/base_support","text":""},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#directories","title":"Directories","text":"Name lib/graphic/widget/base_support/common"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#files","title":"Files","text":"Name lib/graphic/widget/base_support/image.c lib/graphic/widget/base_support/image.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/","title":"lib/iic/backend","text":""},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/#files","title":"Files","text":"Name lib/iic/backend/i2c_stm_impl.c lib/iic/backend/i2c_stm_impl.h <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ellipse_8c/","title":"lib/graphic/base/ellipse.c","text":""},{"location":"api/Files/ellipse_8c/#functions","title":"Functions","text":"Name void clearBound(CFBD_GraphicDevice * handler, CCGraphic_Ellipse * ellipse, const int16_t x_radius, const int16_t y_radius) void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice * handler, CCGraphic_Ellipse * ellipse) void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice * handler, CCGraphic_Ellipse * ellipse)"},{"location":"api/Files/ellipse_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) SQUARE(X)"},{"location":"api/Files/ellipse_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ellipse_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Ellipse * ellipse,\n    const int16_t x_radius,\n    const int16_t y_radius\n)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#function-cfbdgraphic_drawellipse","title":"function CFBDGraphic_DrawEllipse","text":"<pre><code>void CFBDGraphic_DrawEllipse(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#function-cfbdgraphic_drawfilledellipse","title":"function CFBDGraphic_DrawFilledEllipse","text":"<pre><code>void CFBDGraphic_DrawFilledEllipse(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ellipse_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-square","title":"define SQUARE","text":"<pre><code>#define SQUARE(\n    X\n)\n((X) * (X))\n</code></pre>"},{"location":"api/Files/ellipse_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ellipse.h\"\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\n#define SQUARE(X) ((X) * (X))\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler,\n                              CCGraphic_Ellipse* ellipse,\n                              const int16_t x_radius,\n                              const int16_t y_radius)\n{\n    int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n    int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n    int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n    int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n    handler-&gt;ops-&gt;update_area(handler,\n                              clamp_u16_from_i32(lx),\n                              clamp_u16_from_i32(ty),\n                              clamp_u16_from_i32(rx - lx + 1),\n                              clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* handler, CCGraphic_Ellipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* handler, CCGraphic_Ellipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n    // Fill the ellipse by drawing vertical lines in the specified range (filled area)\n    for (int16_t j = -y; j &lt; y; j++) {\n        // Draw vertical lines to fill the area of the ellipse\n        DRAW_OFFSET_POINT(0, j);\n        DRAW_OFFSET_POINT(0, j);\n    }\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef SQUARE\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ellipse_8h/","title":"lib/graphic/base/ellipse.h","text":""},{"location":"api/Files/ellipse_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Ellipse"},{"location":"api/Files/ellipse_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice * device, CCGraphic_Ellipse * ellipse) void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice * device, CCGraphic_Ellipse * ellipse)"},{"location":"api/Files/ellipse_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ellipse_8h/#function-cfbdgraphic_drawellipse","title":"function CFBDGraphic_DrawEllipse","text":"<pre><code>void CFBDGraphic_DrawEllipse(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre>"},{"location":"api/Files/ellipse_8h/#function-cfbdgraphic_drawfilledellipse","title":"function CFBDGraphic_DrawFilledEllipse","text":"<pre><code>void CFBDGraphic_DrawFilledEllipse(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre>"},{"location":"api/Files/ellipse_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point center;\n    PointBaseType X_Radius;\n    PointBaseType Y_Radius;\n} CCGraphic_Ellipse;\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/external__impl__driver_8h/","title":"lib/oled/configs/external_impl_driver.h","text":""},{"location":"api/Files/external__impl__driver_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_IICInitsParams"},{"location":"api/Files/external__impl__driver_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"driver/device/device_interface.h\"\n\n// iic\n#include \"../iic/iic.h\" //&lt; points to the IIC Driver\n\ntypedef struct\n{\n    CFBD_I2CHandle* i2cHandle;\n    uint32_t accepted_time_delay;\n    uint16_t device_address;\n\n    CFBD_OLED_DeviceSpecific* device_specifics;\n    void (*iic_transition_callback)(int status);\n} CFBD_OLED_IICInitsParams;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8c/","title":"lib/gpio/gpio-stm-impl.c","text":""},{"location":"api/Files/gpio-stm-impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"gpio-stm-impl.h\"\n#include \"lib_settings.h\"\n#include \"gpio.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n\n#if defined (CFBD_IS_ST)\n\nstatic inline void GPIO_CLK_Enable(GPIO_TypeDef *GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n    } else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_ENABLE();\n    } else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n    } else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_ENABLE();\n    } else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_ENABLE();\n    } \n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_ENABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_ENABLE();\n    }\n#endif\n    else {\n        /* \u975e\u6cd5 GPIO\uff0c\u5ffd\u7565\u6216\u65ad\u8a00 */\n    }\n}\n\nstatic inline void GPIO_CLK_Disable(GPIO_TypeDef *GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_DISABLE();\n    } else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_DISABLE();\n    } else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_DISABLE();\n    } else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_DISABLE();\n    } else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_DISABLE();\n    }\n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_DISABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_DISABLE();\n    }\n#endif\n    else {\n        /* \u975e\u6cd5 GPIO\uff0c\u5ffd\u7565\u6216\u65ad\u8a00 */\n    }\n}\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params){\n    CFBD_ST_GPIOInitParams* st_params = (CFBD_ST_GPIOInitParams*)params;\n    handle-&gt;handle_internals_ = st_params-&gt;handle;\n    handle-&gt;pin_internals_ = st_params-&gt;pin;\n    GPIO_CLK_Enable(st_params-&gt;handle);\n    HAL_GPIO_Init(st_params-&gt;handle, &amp;st_params-&gt;initer);\n}\n\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle){\n    HAL_GPIO_WritePin(\n        handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_, GPIO_PIN_SET);\n}\n\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle){\n    HAL_GPIO_WritePin(\n        handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_, GPIO_PIN_RESET);\n}\n\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle){\n    HAL_GPIO_TogglePin(handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_);\n}\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8h/","title":"lib/gpio/gpio-stm-impl.h","text":""},{"location":"api/Files/gpio-stm-impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../config/lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include &lt;stdint.h&gt;\n#include &lt;stm32f1xx_hal_gpio.h&gt;\n\ntypedef struct\n{\n    GPIO_TypeDef* handle;\n    uint32_t pin;\n    GPIO_InitTypeDef initer;\n} CFBD_ST_GPIOInitParams; \n\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/gpio_8h/","title":"lib/gpio/gpio.h","text":""},{"location":"api/Files/gpio_8h/#classes","title":"Classes","text":"Name struct CFBD_GPIOHandle"},{"location":"api/Files/gpio_8h/#types","title":"Types","text":"Name typedef uint32_t GPIO_PinType typedef void * GPIO_TypeHandle typedef void * CFBD_GPIOInitParams"},{"location":"api/Files/gpio_8h/#functions","title":"Functions","text":"Name void CFBD_GPIOInit(CFBD_GPIOHandle * handle, CFBD_GPIOInitParams params) void CFBD_GPIOSet(CFBD_GPIOHandle * handle) void CFBD_GPIOUnset(CFBD_GPIOHandle * handle) void CFBD_GPIOToggle(CFBD_GPIOHandle * handle) void CFBD_GPIOSetPin(CFBD_GPIOHandle * handle, CFBD_Bool status)"},{"location":"api/Files/gpio_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/gpio_8h/#typedef-gpio_pintype","title":"typedef GPIO_PinType","text":"<pre><code>typedef uint32_t GPIO_PinType;\n</code></pre>"},{"location":"api/Files/gpio_8h/#typedef-gpio_typehandle","title":"typedef GPIO_TypeHandle","text":"<pre><code>typedef void* GPIO_TypeHandle;\n</code></pre>"},{"location":"api/Files/gpio_8h/#typedef-cfbd_gpioinitparams","title":"typedef CFBD_GPIOInitParams","text":"<pre><code>typedef void* CFBD_GPIOInitParams;\n</code></pre>"},{"location":"api/Files/gpio_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/gpio_8h/#function-cfbd_gpioinit","title":"function CFBD_GPIOInit","text":"<pre><code>void CFBD_GPIOInit(\n    CFBD_GPIOHandle * handle,\n    CFBD_GPIOInitParams params\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpioset","title":"function CFBD_GPIOSet","text":"<pre><code>void CFBD_GPIOSet(\n    CFBD_GPIOHandle * handle\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiounset","title":"function CFBD_GPIOUnset","text":"<pre><code>void CFBD_GPIOUnset(\n    CFBD_GPIOHandle * handle\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiotoggle","title":"function CFBD_GPIOToggle","text":"<pre><code>void CFBD_GPIOToggle(\n    CFBD_GPIOHandle * handle\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiosetpin","title":"function CFBD_GPIOSetPin","text":"<pre><code>static inline void CFBD_GPIOSetPin(\n    CFBD_GPIOHandle * handle,\n    CFBD_Bool status\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"lib_settings.h\"\n\n\n#if defined(CFBD_IS_ST)\n#include \"../gpio/gpio-stm-impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n\ntypedef uint32_t GPIO_PinType;\ntypedef void* GPIO_TypeHandle;\n\ntypedef struct\n{\n    GPIO_TypeHandle handle_internals_;\n    GPIO_PinType pin_internals_;\n} CFBD_GPIOHandle;\n\ntypedef void* CFBD_GPIOInitParams;\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params);\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle);\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle);\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle);\n\nstatic void inline CFBD_GPIOSetPin(CFBD_GPIOHandle* handle, CFBD_Bool status)\n{\n    status ? CFBD_GPIOSet(handle) : CFBD_GPIOUnset(handle);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/grapgic__device_8c/","title":"lib/graphic/device/grapgic_device.c","text":""},{"location":"api/Files/grapgic__device_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_BindDevice(CFBD_GraphicDevice * device, CFBDGraphic_DeviceType device_type, CFBDGraphicDeviceHandle internal_handle)"},{"location":"api/Files/grapgic__device_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/grapgic__device_8c/#function-cfbdgraphic_binddevice","title":"function CFBDGraphic_BindDevice","text":"<pre><code>void CFBDGraphic_BindDevice(\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_DeviceType device_type,\n    CFBDGraphicDeviceHandle internal_handle\n)\n</code></pre>"},{"location":"api/Files/grapgic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"graphic_device.h\"\n#include \"oled/oled_graphic_device.h\"\n\nvoid CFBDGraphic_BindDevice(CFBD_GraphicDevice* device,\n                            CFBDGraphic_DeviceType device_type,\n                            /*\n                             * OLED -&gt; CFBD_OLED*\n                             */\n                            CFBDGraphicDeviceHandle internal_handle)\n{\n    device-&gt;internal_handle = internal_handle;\n    device-&gt;device_type = device_type;\n    switch(device_type){\n        case OLED:\n            CFBDGraphic_BindOLEDAsDevice(device, internal_handle);\n            return;\n        default:\n            return;\n        break;\n    }\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/graphic__device_8h/","title":"lib/graphic/device/graphic_device.h","text":"<p>More...</p>"},{"location":"api/Files/graphic__device_8h/#classes","title":"Classes","text":"Name struct CFBD_GraphicDeviceOperation struct _CFBD_GraphicDevice"},{"location":"api/Files/graphic__device_8h/#types","title":"Types","text":"Name enum CFBDGraphic_DeviceType typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height) GraphicAreaOperations GraphicAreaOperations means for the area operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicFrameOperation GraphicFrameOperation indicates the frame related operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicOLEDSelfOperation GraphicOLEDSelfOperation self indicates. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, const char *property, void *args, void *request_data) GraphicOLED_QueryOperation GraphicOLED_QueryOperation device query. typedef void * CFBDGraphicDeviceHandle"},{"location":"api/Files/graphic__device_8h/#functions","title":"Functions","text":"Name CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(CFBD_GraphicDevice * device)Check if each operations should update after the calls. void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(CFBD_GraphicDevice * device, CFBD_Bool requests)Set if each operations should update after the calls. void CFBDGraphic_DeviceClearImmediate(CFBD_GraphicDevice * device) void CFBDGraphic_BindDevice(CFBD_GraphicDevice * device, CFBDGraphic_DeviceType device_type, CFBDGraphicDeviceHandle internal_handle)"},{"location":"api/Files/graphic__device_8h/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-05</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/graphic__device_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/graphic__device_8h/#enum-cfbdgraphic_devicetype","title":"enum CFBDGraphic_DeviceType","text":"Enumerator Value Description OLED"},{"location":"api/Files/graphic__device_8h/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicareaoperations","title":"typedef GraphicAreaOperations","text":"<pre><code>typedef CFBD_Bool(* GraphicAreaOperations) (CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\n</code></pre> <p>GraphicAreaOperations means for the area operations. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicframeoperation","title":"typedef GraphicFrameOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicFrameOperation) (CFBD_GraphicDevice *device);\n</code></pre> <p>GraphicFrameOperation indicates the frame related operations. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicoledselfoperation","title":"typedef GraphicOLEDSelfOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicOLEDSelfOperation) (CFBD_GraphicDevice *device);\n</code></pre> <p>GraphicOLEDSelfOperation self indicates. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicoled_queryoperation","title":"typedef GraphicOLED_QueryOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicOLED_QueryOperation) (CFBD_GraphicDevice *device, const char *property, void *args, void *request_data);\n</code></pre> <p>GraphicOLED_QueryOperation device query. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-cfbdgraphicdevicehandle","title":"typedef CFBDGraphicDeviceHandle","text":"<pre><code>typedef void* CFBDGraphicDeviceHandle;\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_devicerequestupdateatonce","title":"function CFBDGraphic_DeviceRequestUpdateAtOnce","text":"<pre><code>static inline CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device\n)\n</code></pre> <p>Check if each operations should update after the calls. </p> <p>Parameters: </p> <ul> <li>device </li> </ul> <p>Return: CFBD_Bool </p>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_devicesetifrequestupdateatonce","title":"function CFBDGraphic_DeviceSetIfRequestUpdateAtOnce","text":"<pre><code>static inline void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device,\n    CFBD_Bool requests\n)\n</code></pre> <p>Set if each operations should update after the calls. </p> <p>Parameters: </p> <ul> <li>device </li> <li>requests </li> </ul>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_deviceclearimmediate","title":"function CFBDGraphic_DeviceClearImmediate","text":"<pre><code>static inline void CFBDGraphic_DeviceClearImmediate(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_binddevice","title":"function CFBDGraphic_BindDevice","text":"<pre><code>void CFBDGraphic_BindDevice(\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_DeviceType device_type,\n    CFBDGraphicDeviceHandle internal_handle\n)\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n\ntypedef CFBD_Bool (*GraphicAreaOperations)(CFBD_GraphicDevice* device,\n                                           uint16_t x,\n                                           uint16_t y,\n                                           uint16_t width,\n                                           uint16_t height);\ntypedef CFBD_Bool (*GraphicFrameOperation)(CFBD_GraphicDevice* device);\ntypedef CFBD_Bool (*GraphicOLEDSelfOperation)(CFBD_GraphicDevice* device);\n\ntypedef CFBD_Bool (*GraphicOLED_QueryOperation)(CFBD_GraphicDevice* device,\n                                                const char* property, // property for query\n                                                void* args,           // if property request args\n                                                void* request_data);  // contains results\n\ntypedef struct\n{\n    int (*init)(CFBD_GraphicDevice* device, void* init_args);\n\n    // enable the pixel lighten or set brushed color\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y);\n\n    // enable the area lightem or set brushed color\n    CFBD_Bool (*setArea)(CFBD_GraphicDevice* device,\n                         uint16_t x,\n                         uint16_t y,\n                         uint16_t width,\n                         uint16_t height,\n                         uint8_t* source);\n\n    /* Frame-level operations */\n    GraphicFrameOperation update; // update the frame\n    GraphicFrameOperation clear;  // clear the frame\n    GraphicFrameOperation revert; // revert the frame\n\n    /* Area-level operations */\n    GraphicAreaOperations update_area; // update the area given\n    GraphicAreaOperations clear_area;  // clear the area given\n    GraphicAreaOperations revert_area; // revert the area given\n\n    /* Open Close Devices */\n    GraphicOLEDSelfOperation open;\n    GraphicOLEDSelfOperation close;\n\n    /*\n     * Accept Queries:\n     *   rgb    -&gt; CFBD_Bool*\n     *   width  -&gt; uint16_t*\n     *   height -&gt; uint16_t*\n     */\n    GraphicOLED_QueryOperation self_consult;\n} CFBD_GraphicDeviceOperation;\n\ntypedef enum\n{\n    OLED\n} CFBDGraphic_DeviceType;\n\ntypedef void* CFBDGraphicDeviceHandle;\n\ntypedef struct _CFBD_GraphicDevice\n{\n    CFBD_GraphicDeviceOperation* ops;\n    CFBDGraphic_DeviceType device_type;\n    CFBDGraphicDeviceHandle internal_handle; // device handle internal\n    CFBD_Bool immediate_draw;                // mannual / auto updates\n} CFBD_GraphicDevice;\n\nstatic inline CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(CFBD_GraphicDevice* device)\n{\n    return device-&gt;immediate_draw;\n}\n\nstatic inline void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(CFBD_GraphicDevice* device,\n                                                              CFBD_Bool requests)\n{\n    device-&gt;immediate_draw = requests;\n}\n\nstatic inline void CFBDGraphic_DeviceClearImmediate(CFBD_GraphicDevice* device)\n{\n    device-&gt;ops-&gt;clear(device);\n    device-&gt;ops-&gt;update(device);\n}\n\nvoid CFBDGraphic_BindDevice(CFBD_GraphicDevice* device,\n                            CFBDGraphic_DeviceType device_type,\n                            /*\n                             * OLED -&gt; CFBD_OLED*\n                             */\n                            CFBDGraphicDeviceHandle internal_handle);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/helpers_8h/","title":"lib/graphic/widget/base_support/common/helpers.h","text":""},{"location":"api/Files/helpers_8h/#functions","title":"Functions","text":"Name int32_t clamp_i32(int32_t v, int32_t lo, int32_t hi)"},{"location":"api/Files/helpers_8h/#defines","title":"Defines","text":"Name MAX(a, b) MIN(a, b)"},{"location":"api/Files/helpers_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/helpers_8h/#function-clamp_i32","title":"function clamp_i32","text":"<pre><code>static inline int32_t clamp_i32(\n    int32_t v,\n    int32_t lo,\n    int32_t hi\n)\n</code></pre>"},{"location":"api/Files/helpers_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/helpers_8h/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/helpers_8h/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/helpers_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#ifndef MAX\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n\nstatic inline int32_t clamp_i32(int32_t v, int32_t lo, int32_t hi)\n{\n    if (v &lt; lo)\n        return lo;\n    if (v &gt; hi)\n        return hi;\n    return v;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8c/","title":"lib/iic/backend/i2c_stm_impl.c","text":""},{"location":"api/Files/i2c__stm__impl_8c/#functions","title":"Functions","text":"Name void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin) void stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_error(I2C_HandleTypeDef * hi2c) int stm32_init(CFBD_I2CHandle * bus) int stm32_deinit(CFBD_I2CHandle * bus) int stm32_transfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms) int stm32_is_device_ready(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) int stm32_recover_bus(CFBD_I2CHandle * bus) int stm32_get_error(CFBD_I2CHandle * bus) void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)"},{"location":"api/Files/i2c__stm__impl_8c/#attributes","title":"Attributes","text":"Name const CFBD_I2COperations stm32_i2c_ops"},{"location":"api/Files/i2c__stm__impl_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_tx_cplt","title":"function stm32_i2c_on_master_tx_cplt","text":"<pre><code>void stm32_i2c_on_master_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_rx_cplt","title":"function stm32_i2c_on_master_rx_cplt","text":"<pre><code>void stm32_i2c_on_master_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_tx_cplt","title":"function stm32_i2c_on_mem_tx_cplt","text":"<pre><code>void stm32_i2c_on_mem_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_rx_cplt","title":"function stm32_i2c_on_mem_rx_cplt","text":"<pre><code>void stm32_i2c_on_mem_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_error","title":"function stm32_i2c_on_error","text":"<pre><code>void stm32_i2c_on_error(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_init","title":"function stm32_init","text":"<pre><code>static int stm32_init(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_deinit","title":"function stm32_deinit","text":"<pre><code>static int stm32_deinit(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_transfer","title":"function stm32_transfer","text":"<pre><code>static int stm32_transfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_is_device_ready","title":"function stm32_is_device_ready","text":"<pre><code>static int stm32_is_device_ready(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_recover_bus","title":"function stm32_recover_bus","text":"<pre><code>static int stm32_recover_bus(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_get_error","title":"function stm32_get_error","text":"<pre><code>static int stm32_get_error(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#variable-stm32_i2c_ops","title":"variable stm32_i2c_ops","text":"<pre><code>static const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"i2c_stm_impl.h\"\n\n#include \"../iic.h\"\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin)\n{\n    priv-&gt;hi2c = hi2c;\n    priv-&gt;scl_pin = scl_pin;\n    priv-&gt;scl_port = scl_port;\n    priv-&gt;sda_port = sda_port;\n    priv-&gt;sda_pin = sda_pin;\n}\n\n/* forward declear */\nvoid stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_error(I2C_HandleTypeDef* hi2c);\n\n/* forward ops */\nstatic int stm32_init(CFBD_I2CHandle* bus);\nstatic int stm32_deinit(CFBD_I2CHandle* bus);\nstatic int\nstm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms);\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus);\nstatic int stm32_get_error(CFBD_I2CHandle* bus);\n\nstatic const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv)\n{\n    bus-&gt;ops = &amp;stm32_i2c_ops;\n    bus-&gt;private_handle = priv;\n}\n\n/* ---------- lifecycle ---------- */\nstatic int stm32_init(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    if (HAL_I2C_GetState(p-&gt;hi2c) == HAL_I2C_STATE_RESET) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_deinit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    if (HAL_I2C_DeInit(p-&gt;hi2c) != HAL_OK) {\n        p-&gt;last_err = I2C_ERR_IO;\n        return I2C_ERR_IO;\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle || !msgs || num &lt;= 0)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    for (int i = 0; i &lt; num; ++i) {\n        CFBD_I2C_Message* m = &amp;msgs[i];\n        uint16_t devAddr = ((m-&gt;addr &amp; 0x7F) &lt;&lt; 1);\n        HAL_StatusTypeDef status;\n\n        if ((m-&gt;flags &amp; I2C_M_RD) == 0) {\n            /* write */\n            if (i + 1 &lt; num) {\n                CFBD_I2C_Message* next = &amp;msgs[i + 1];\n                if (!(next-&gt;flags &amp; I2C_M_RD) &amp;&amp; next-&gt;addr == m-&gt;addr &amp;&amp; m-&gt;len == 1) {\n                    uint16_t memAddr = m-&gt;buf[0];\n\n                    // \u2705 \u4f7f\u7528 DMA\uff08\u5982\u679c\u6709\uff09\u5426\u5219\u8f6e\u8be2\n                    if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                        status = HAL_I2C_Mem_Write_DMA(p-&gt;hi2c,\n                                                       devAddr,\n                                                       memAddr,\n                                                       I2C_MEMADD_SIZE_8BIT,\n                                                       next-&gt;buf,\n                                                       next-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        // \u7b49\u5f85 DMA \u5b8c\u6210\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        // \u56de\u9000\u5230\u8f6e\u8be2\u6a21\u5f0f\n                        status = HAL_I2C_Mem_Write(p-&gt;hi2c,\n                                                   devAddr,\n                                                   memAddr,\n                                                   I2C_MEMADD_SIZE_8BIT,\n                                                   next-&gt;buf,\n                                                   next-&gt;len,\n                                                   timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n\n                    i++;\n                    continue;\n                }\n            }\n\n            // \u666e\u901a\u5199\n            if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                status = HAL_I2C_Master_Transmit_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Transmit(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n        else {\n            /* read */\n            if (i &gt; 0) {\n                CFBD_I2C_Message* prev = &amp;msgs[i - 1];\n                if (!(prev-&gt;flags &amp; I2C_M_RD) &amp;&amp; prev-&gt;addr == m-&gt;addr &amp;&amp;\n                    (prev-&gt;len == 1 || prev-&gt;len == 2)) {\n                    uint16_t mem = 0;\n                    if (prev-&gt;len == 1)\n                        mem = prev-&gt;buf[0];\n                    else\n                        mem = ((uint16_t) prev-&gt;buf[0] &lt;&lt; 8) | prev-&gt;buf[1];\n                    uint16_t memadd =\n                            (prev-&gt;len == 1) ? I2C_MEMADD_SIZE_8BIT : I2C_MEMADD_SIZE_16BIT;\n\n                    // \u4f7f\u7528 DMA \u8bfb\n                    if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                        status =\n                                HAL_I2C_Mem_Read_DMA(p-&gt;hi2c, devAddr, mem, memadd, m-&gt;buf, m-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        status = HAL_I2C_Mem_Read(p-&gt;hi2c,\n                                                  devAddr,\n                                                  mem,\n                                                  memadd,\n                                                  m-&gt;buf,\n                                                  m-&gt;len,\n                                                  timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            // \u666e\u901a\u8bfb\n            if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                status = HAL_I2C_Master_Receive_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Receive(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\n/* ---------- rest (is_device_ready, recover, get_error) ---------- */\n\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    uint16_t devAddr = (addr &amp; 0x7F) &lt;&lt; 1;\n    if (HAL_I2C_IsDeviceReady(p-&gt;hi2c, devAddr, trials, timeout_ms) == HAL_OK) {\n        p-&gt;last_err = I2C_OK;\n        return I2C_OK;\n    }\n    p-&gt;last_err = I2C_ERR_IO;\n    return I2C_ERR_IO;\n}\n\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;scl_port || !p-&gt;sda_port)\n        return I2C_ERR_INVAL;\n\n    if (p-&gt;hi2c)\n        HAL_I2C_DeInit(p-&gt;hi2c);\n\n    GPIO_InitTypeDef gpio = {0};\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    for (int i = 0; i &lt; 9; ++i) {\n        if (HAL_GPIO_ReadPin(p-&gt;sda_port, p-&gt;sda_pin) == GPIO_PIN_SET)\n            break;\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_RESET);\n        HAL_Delay(1);\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n        HAL_Delay(1);\n    }\n\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_RESET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    if (p-&gt;hi2c) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_get_error(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    return p-&gt;last_err;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8h/","title":"lib/iic/backend/i2c_stm_impl.h","text":""},{"location":"api/Files/i2c__stm__impl_8h/#classes","title":"Classes","text":"Name struct CFBD_ST_I2CPrivate"},{"location":"api/Files/i2c__stm__impl_8h/#functions","title":"Functions","text":"Name I2C_HandleTypeDef * native_handle(CFBD_ST_I2CPrivate * priv) void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin) void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)"},{"location":"api/Files/i2c__stm__impl_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8h/#function-native_handle","title":"function native_handle","text":"<pre><code>static inline I2C_HandleTypeDef * native_handle(\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8h/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8h/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../iic.h\"\n#include \"lib_settings.h\"\n\ntypedef struct\n{\n    I2C_HandleTypeDef* hi2c;\n    GPIO_TypeDef* scl_port;\n    uint16_t scl_pin;\n    GPIO_TypeDef* sda_port;\n    uint16_t sda_pin;\n    /* Miss assigned */\n    int last_err;\n} CFBD_ST_I2CPrivate;\n\nstatic inline I2C_HandleTypeDef* native_handle(CFBD_ST_I2CPrivate* priv)\n{\n    return priv-&gt;hi2c;\n}\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin);\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/iic_8c/","title":"lib/iic/iic.c","text":""},{"location":"api/Files/iic_8c/#functions","title":"Functions","text":"Name int CFBD_I2CRead(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r) int CFBD_I2CWrite(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)"},{"location":"api/Files/iic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/iic_8c/#function-cfbd_i2cread","title":"function CFBD_I2CRead","text":"<pre><code>int CFBD_I2CRead(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre>"},{"location":"api/Files/iic_8c/#function-cfbd_i2cwrite","title":"function CFBD_I2CWrite","text":"<pre><code>int CFBD_I2CWrite(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre>"},{"location":"api/Files/iic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"iic.h\"\n#include &lt;stdint.h&gt;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/iic_8h/","title":"lib/iic/iic.h","text":""},{"location":"api/Files/iic_8h/#classes","title":"Classes","text":"Name struct _CFBD_I2C_Message struct CFBD_I2COperations struct _CFBD_I2CHandle struct CFBD_I2C_IORequestParams"},{"location":"api/Files/iic_8h/#types","title":"Types","text":"Name typedef struct _CFBD_I2C_Message CFBD_I2C_Message typedef void(int status, void *arg) CFBD_I2C_AsyncCallback typedef struct _CFBD_I2CHandle CFBD_I2CHandle typedef void * CFBD_I2CPrivateHandle"},{"location":"api/Files/iic_8h/#functions","title":"Functions","text":"Name int CFBD_I2CInit(CFBD_I2CHandle * bus) int CFBD_I2CDeInit(CFBD_I2CHandle * bus) int CFBD_I2CTransfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms) int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) int CFBD_I2CRecoverBus(CFBD_I2CHandle * bus) int CFBD_I2CRead(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r) int CFBD_I2CWrite(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)"},{"location":"api/Files/iic_8h/#defines","title":"Defines","text":"Name I2C_M_RD I2C_M_NOSTART"},{"location":"api/Files/iic_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_message","title":"typedef CFBD_I2C_Message","text":"<pre><code>typedef struct _CFBD_I2C_Message CFBD_I2C_Message;\n</code></pre>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_asynccallback","title":"typedef CFBD_I2C_AsyncCallback","text":"<pre><code>typedef void CFBD_I2C_AsyncCallback(int status, void *arg);\n</code></pre>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2chandle","title":"typedef CFBD_I2CHandle","text":"<pre><code>typedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n</code></pre>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2cprivatehandle","title":"typedef CFBD_I2CPrivateHandle","text":"<pre><code>typedef void* CFBD_I2CPrivateHandle;\n</code></pre>"},{"location":"api/Files/iic_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/iic_8h/#function-cfbd_i2cinit","title":"function CFBD_I2CInit","text":"<pre><code>static inline int CFBD_I2CInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2cdeinit","title":"function CFBD_I2CDeInit","text":"<pre><code>static inline int CFBD_I2CDeInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2ctransfer","title":"function CFBD_I2CTransfer","text":"<pre><code>static inline int CFBD_I2CTransfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2ctransferisdeviceready","title":"function CFBD_I2CTransferIsDeviceReady","text":"<pre><code>static inline int CFBD_I2CTransferIsDeviceReady(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2crecoverbus","title":"function CFBD_I2CRecoverBus","text":"<pre><code>static inline int CFBD_I2CRecoverBus(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2cread","title":"function CFBD_I2CRead","text":"<pre><code>int CFBD_I2CRead(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#function-cfbd_i2cwrite","title":"function CFBD_I2CWrite","text":"<pre><code>int CFBD_I2CWrite(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre>"},{"location":"api/Files/iic_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/iic_8h/#define-i2c_m_rd","title":"define I2C_M_RD","text":"<pre><code>#define I2C_M_RD 0x0001      /* read data, from slave to master */\n</code></pre>"},{"location":"api/Files/iic_8h/#define-i2c_m_nostart","title":"define I2C_M_NOSTART","text":"<pre><code>#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n</code></pre>"},{"location":"api/Files/iic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"iic_error.h\"\n\n/* i2c_msg flags (like Linux) */\n#define I2C_M_RD 0x0001      /* read data, from slave to master */\n#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n\ntypedef struct _CFBD_I2C_Message\n{\n    uint16_t addr;  /* 7-bit address (0..0x7F) */\n    uint16_t flags; /* I2C Message Flags */\n    uint16_t len;   /* length of buffer */\n    uint8_t* buf;   /* pointer to data */\n} CFBD_I2C_Message;\n\n/*\n * Async Callbacks\n */\ntypedef void CFBD_I2C_AsyncCallback(int status, void* arg);\n\ntypedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n\ntypedef struct\n{\n    /*\n     * init the i2c\n     */\n    int (*init)(CFBD_I2CHandle* handle);\n    /*\n     * deinit the i2c\n     */\n    int (*deinit)(CFBD_I2CHandle* handle);\n\n    int (*transfer)(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\n\n    int (*is_device_ready)(CFBD_I2CHandle* bus,\n                           uint16_t addr,\n                           uint32_t trials,\n                           uint32_t timeout_ms);\n    int (*recover_bus)(CFBD_I2CHandle* bus);\n\n    int (*get_error)(CFBD_I2CHandle* bus);\n\n    /* optional DMA hooks */\n    int (*tx_dma_start)(CFBD_I2CHandle* bus, const uint8_t* buf, size_t len);\n    int (*rx_dma_start)(CFBD_I2CHandle* bus, uint8_t* buf, size_t len);\n} CFBD_I2COperations;\n\ntypedef void* CFBD_I2CPrivateHandle;\n\ntypedef struct _CFBD_I2CHandle\n{\n    const CFBD_I2COperations* ops;\n    CFBD_I2CPrivateHandle private_handle;\n} CFBD_I2CHandle;\n\n/* --------- inline wrappers  ---------- */\nstatic inline int CFBD_I2CInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;init)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;init(bus);\n}\n\nstatic inline int CFBD_I2CDeInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;deinit)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;deinit(bus);\n}\n\nstatic inline int\nCFBD_I2CTransfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;transfer)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;transfer(bus, msgs, num, timeout_ms);\n}\n\nstatic inline int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle* bus,\n                                                uint16_t addr,\n                                                uint32_t trials,\n                                                uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;is_device_ready)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;is_device_ready(bus, addr, trials, timeout_ms);\n}\n\nstatic inline int CFBD_I2CRecoverBus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;recover_bus)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;recover_bus(bus);\n}\n\ntypedef struct\n{\n    uint16_t addr7;\n    uint32_t mem_addr;\n    uint8_t mem_addr_size;\n    uint8_t* data;\n    uint16_t len;\n    uint32_t timeout_ms;\n} CFBD_I2C_IORequestParams;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\n\n#include \"lib_settings.h\"\n#if defined(CFBD_IS_ST)\n#include \"backend/i2c_stm_impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/iic__error_8h/","title":"lib/iic/iic_error.h","text":""},{"location":"api/Files/iic__error_8h/#defines","title":"Defines","text":"Name I2C_OK I2C_ERR_TIMEOUT I2C_ERR_NACK I2C_ERR_BUSY I2C_ERR_IO I2C_ERR_INVAL"},{"location":"api/Files/iic__error_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/iic__error_8h/#define-i2c_ok","title":"define I2C_OK","text":"<pre><code>#define I2C_OK 0\n</code></pre>"},{"location":"api/Files/iic__error_8h/#define-i2c_err_timeout","title":"define I2C_ERR_TIMEOUT","text":"<pre><code>#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n</code></pre>"},{"location":"api/Files/iic__error_8h/#define-i2c_err_nack","title":"define I2C_ERR_NACK","text":"<pre><code>#define I2C_ERR_NACK -121    /* -EPROTO (nack) */\n</code></pre>"},{"location":"api/Files/iic__error_8h/#define-i2c_err_busy","title":"define I2C_ERR_BUSY","text":"<pre><code>#define I2C_ERR_BUSY -16     /* -EBUSY */\n</code></pre>"},{"location":"api/Files/iic__error_8h/#define-i2c_err_io","title":"define I2C_ERR_IO","text":"<pre><code>#define I2C_ERR_IO -5        /* -EIO */\n</code></pre>"},{"location":"api/Files/iic__error_8h/#define-i2c_err_inval","title":"define I2C_ERR_INVAL","text":"<pre><code>#define I2C_ERR_INVAL -22    /* -EINVAL */\n</code></pre>"},{"location":"api/Files/iic__error_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n/* error codes (subset) */\n#define I2C_OK 0\n#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n#define I2C_ERR_NACK -121    /* -EPROTO (nack) */\n#define I2C_ERR_BUSY -16     /* -EBUSY */\n#define I2C_ERR_IO -5        /* -EIO */\n#define I2C_ERR_INVAL -22    /* -EINVAL */\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/image_8c/","title":"lib/graphic/widget/base_support/image.c","text":""},{"location":"api/Files/image_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image)"},{"location":"api/Files/image_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8c/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8c/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8c/#source-code","title":"Source code","text":"<pre><code>#include \"image.h\"\n\n#include \"device/graphic_device.h\"\n\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register)\n{\n    image-&gt;image_size = *image_size;\n    image-&gt;point = *tl_point;\n    image-&gt;sources_register = sources_register;\n}\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image)\n{\n    if (!image-&gt;sources_register)\n        return;\n    handler-&gt;ops-&gt;setArea(\n        handler, image-&gt;point.x, image-&gt;point.y,\n        image-&gt;image_size.width, image-&gt;image_size.height, image-&gt;sources_register\n    );\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/image_8h/","title":"lib/graphic/widget/base_support/image.h","text":""},{"location":"api/Files/image_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Image"},{"location":"api/Files/image_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image)"},{"location":"api/Files/image_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8h/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8h/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point point;\n    CFBDGraphicSize image_size;\n    uint8_t* sources_register;\n} CCGraphic_Image;\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register);\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/lib__settings_8h/","title":"lib/config/lib_settings.h","text":""},{"location":"api/Files/lib__settings_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"config/system_settings.h\"\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/line_8c/","title":"lib/graphic/base/line.c","text":""},{"location":"api/Files/line_8c/#functions","title":"Functions","text":"Name void swap_int16(int16_t * val1, int16_t * val2) uint16_t max_uint16(uint16_t val1, uint16_t val2) uint16_t min_uint16(uint16_t val1, uint16_t val2) void clearBounds(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_vertical_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_horizental_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __pvt_BresenhamMethod_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void CFBDGraphic_DrawLine(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Files/line_8c/#defines","title":"Defines","text":"Name __pvt_fast_draw_point(X, Y)"},{"location":"api/Files/line_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/line_8c/#function-swap_int16","title":"function swap_int16","text":"<pre><code>static inline void swap_int16(\n    int16_t * val1,\n    int16_t * val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-max_uint16","title":"function max_uint16","text":"<pre><code>static inline uint16_t max_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-min_uint16","title":"function min_uint16","text":"<pre><code>static inline uint16_t min_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-clearbounds","title":"function clearBounds","text":"<pre><code>static inline void clearBounds(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_vertical_line","title":"function __on_handle_vertical_line","text":"<pre><code>static void __on_handle_vertical_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_horizental_line","title":"function __on_handle_horizental_line","text":"<pre><code>static void __on_handle_horizental_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__pvt_bresenhammethod_line","title":"function __pvt_BresenhamMethod_line","text":"<pre><code>void __pvt_BresenhamMethod_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-cfbdgraphic_drawline","title":"function CFBDGraphic_DrawLine","text":"<pre><code>void CFBDGraphic_DrawLine(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/line_8c/#define-__pvt_fast_draw_point","title":"define __pvt_fast_draw_point","text":"<pre><code>#define __pvt_fast_draw_point(\n    X,\n    Y\n)\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/line_8c/#source-code","title":"Source code","text":"<pre><code>#include \"line.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\nstatic inline void swap_int16(int16_t* val1, int16_t* val2)\n{\n    if (*val1 == *val2)\n        return;\n    *val1 ^= *val2;\n    *val2 ^= *val1;\n    *val1 ^= *val2;\n}\n\nstatic inline uint16_t max_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &gt; val2 ? val1 : val2;\n}\n\nstatic inline uint16_t min_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &lt; val2 ? val1 : val2;\n}\n\nstatic inline void clearBounds(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    int32_t lx = asInt32_t(line-&gt;p_left.x);\n    int32_t rx = asInt32_t(line-&gt;p_right.x);\n    int32_t ty = asInt32_t(line-&gt;p_left.y);\n    int32_t by = asInt32_t(line-&gt;p_right.y);\n\n    if (lx &gt; rx) {\n        int32_t t = lx;\n        lx = rx;\n        rx = t;\n    }\n    if (ty &gt; by) {\n        int32_t t = ty;\n        ty = by;\n        by = t;\n    }\n}\n\n/*\n    draw the lines that matches the equal x\n*/\nstatic void __on_handle_vertical_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    PointBaseType max_y = max_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType min_y = min_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType x = line-&gt;p_left.x;\n    PointBaseType y;\n    CFBD_Bool (*setpixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    for (PointBaseType i = min_y; i &lt;= max_y; i++) {\n        y = i;\n        setpixel(handler, x, y);\n    }\n}\n\nstatic void __on_handle_horizental_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    PointBaseType max_x = max_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType min_x = min_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType x;\n    PointBaseType y = line-&gt;p_left.y;\n    for (PointBaseType i = min_x; i &lt;= max_x; i++) {\n        x = i;\n        setPixel(handler, x, y);\n    }\n}\n\n// Bresenham's Line Algorithm, designed to avoid floating point calculations\n// References: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf\n// https://www.bilibili.com/video/BV1364y1d7Lo\nvoid __pvt_BresenhamMethod_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n\n#define __pvt_fast_draw_point(X, Y)                                                                \\\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n\n    // Define initial points for the line: p_left and p_right represent the endpoints\n    int16_t startX = line-&gt;p_left.x;\n    int16_t startY = line-&gt;p_left.y;\n    int16_t endX = line-&gt;p_right.x;\n    int16_t endY = line-&gt;p_right.y;\n\n    // Flags to indicate transformations of coordinates\n    uint8_t isYInverted = 0, isXYInverted = 0;\n    {\n        // If the start point's X coordinate is greater than the end point's X, swap the points\n        if (startX &gt; endX) {\n            // Swap the X and Y coordinates for the start and end points\n            swap_int16(&amp;startX, &amp;endX);\n            swap_int16(&amp;startY, &amp;endY);\n        }\n\n        // If the start point's Y coordinate is greater than the end point's Y, invert the Y\n        // coordinates\n        if (startY &gt; endY) {\n            // Invert Y coordinates to make the line direction consistent in the first quadrant\n            startY = -startY;\n            endY = -endY;\n            // Set the flag indicating Y coordinates were inverted\n            isYInverted = 1;\n        }\n\n        // If the line's slope (dy/dx) is greater than 1, swap X and Y coordinates for a shallower\n        // slope\n        if (endY - startY &gt; endX - startX) {\n            // Swap X and Y coordinates for both points\n            swap_int16(&amp;startX, &amp;startY);\n            swap_int16(&amp;endX, &amp;endY);\n            // Set the flag indicating both X and Y coordinates were swapped\n            isXYInverted = 1;\n        }\n\n        // Calculate differences (dx, dy) and the decision variables for Bresenham's algorithm\n        const int16_t dx = endX - startX;\n        const int16_t dy = endY - startY;\n        const int16_t incrE = 2 * dy;         // Increment for eastward movement\n        const int16_t incrNE = 2 * (dy - dx); // Increment for northeastward movement\n\n        int16_t decision = 2 * dy - dx; // Initial decision variable\n        int16_t x = startX;             // Starting X coordinate\n        int16_t y = startY;             // Starting Y coordinate\n\n        // Draw the starting point and handle coordinate transformations based on flags\n        if (isYInverted &amp;&amp; isXYInverted) {\n            __pvt_fast_draw_point(y, -x);\n        }\n        else if (isYInverted) {\n            __pvt_fast_draw_point(x, -y);\n        }\n        else if (isXYInverted) {\n            __pvt_fast_draw_point(y, x);\n        }\n        else {\n            __pvt_fast_draw_point(x, y);\n        }\n\n        // Iterate through the X-axis to draw the rest of the line\n        while (x &lt; endX) {\n            x++; // Increment X coordinate\n            if (decision &lt; 0) {\n                decision += incrE; // Move eastward if decision variable is negative\n            }\n            else {\n                y++; // Move northeastward if decision variable is positive or zero\n                decision += incrNE;\n            }\n\n            // Draw each point along the line with coordinate transformation as needed\n            if (isYInverted &amp;&amp; isXYInverted) {\n                __pvt_fast_draw_point(y, -x);\n            }\n            else if (isYInverted) {\n                __pvt_fast_draw_point(x, -y);\n            }\n            else if (isXYInverted) {\n                __pvt_fast_draw_point(y, x);\n            }\n            else {\n                __pvt_fast_draw_point(x, y);\n            }\n        }\n    }\n}\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    clearBounds(handler, line);\n    // test if the vertical\n    if (line-&gt;p_left.x == line-&gt;p_right.x)\n        __on_handle_vertical_line(handler, line);\n    if (line-&gt;p_left.y == line-&gt;p_right.y)\n        __on_handle_horizental_line(handler, line);\n    __pvt_BresenhamMethod_line(handler, line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(line-&gt;p_left.x);\n        int32_t rx = asInt32_t(line-&gt;p_right.x);\n        int32_t ty = asInt32_t(line-&gt;p_left.y);\n        int32_t by = asInt32_t(line-&gt;p_right.y);\n\n        if (lx &gt; rx) {\n            int32_t t = lx;\n            lx = rx;\n            rx = t;\n        }\n        if (ty &gt; by) {\n            int32_t t = ty;\n            ty = by;\n            by = t;\n        }\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/line_8h/","title":"lib/graphic/base/line.h","text":""},{"location":"api/Files/line_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Line"},{"location":"api/Files/line_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawLine(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Files/line_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/line_8h/#function-cfbdgraphic_drawline","title":"function CFBDGraphic_DrawLine","text":"<pre><code>void CFBDGraphic_DrawLine(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point p_left;\n    CFBDGraphic_Point p_right;\n} CFBDGraphic_Line;\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/margin_8h/","title":"lib/graphic/widget/margin.h","text":""},{"location":"api/Files/margin_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Margin"},{"location":"api/Files/margin_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    PointBaseType left, top, right, bottom;\n} CFBDGraphic_Margin;\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu_8c/","title":"lib/graphic/widget/menu/menu.c","text":""},{"location":"api/Files/menu_8c/#functions","title":"Functions","text":"Name const uint16_t get_menu_new_item_x(CFBD_Menu * pMenu) const uint16_t get_menu_new_item_height(CFBD_MenuItem * item) const uint16_t get_menu_new_item_y(CFBD_Menu * pMenu) void CFBD_BindMenuItems(CFBD_Menu * pMenu, CFBD_MenuItemGroup * assigned_menu_items) void CFBD_AnimationSet(CFBD_Menu * pMenu, CFBD_BaseAnimation * pBaseAnimation) CFBD_Bool CFBD_MenuAddItems(CFBD_Menu * pMenu, const char * label, Ascii_Font_Size font_size, CFBD_MenuItemCallbackPack * callbacks) void CFBD_DrawMenu(CFBD_Menu * m) void redraw_item(CFBD_Menu * m, int idx) void OLED_Menu_Select(CFBD_Menu * m, int new_index) void reset_tl_points(CFBD_Menu * m, CFBDGraphic_Point * p, CFBD_Bool request_updates) void OLED_Menu_Activate(CFBD_Menu * m) void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width)"},{"location":"api/Files/menu_8c/#attributes","title":"Attributes","text":"Name CFBD_MenuOps _ops"},{"location":"api/Files/menu_8c/#defines","title":"Defines","text":"Name CFBD_MENU_ITEM_Y_GAP MAKE_RECT(rx, ry, rw, rh)"},{"location":"api/Files/menu_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8c/#function-get_menu_new_item_x","title":"function get_menu_new_item_x","text":"<pre><code>static inline const uint16_t get_menu_new_item_x(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_height","title":"function get_menu_new_item_height","text":"<pre><code>static const uint16_t get_menu_new_item_height(\n    CFBD_MenuItem * item\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_y","title":"function get_menu_new_item_y","text":"<pre><code>static const uint16_t get_menu_new_item_y(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_bindmenuitems","title":"function CFBD_BindMenuItems","text":"<pre><code>static void CFBD_BindMenuItems(\n    CFBD_Menu * pMenu,\n    CFBD_MenuItemGroup * assigned_menu_items\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_animationset","title":"function CFBD_AnimationSet","text":"<pre><code>static void CFBD_AnimationSet(\n    CFBD_Menu * pMenu,\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_menuadditems","title":"function CFBD_MenuAddItems","text":"<pre><code>static CFBD_Bool CFBD_MenuAddItems(\n    CFBD_Menu * pMenu,\n    const char * label,\n    Ascii_Font_Size font_size,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_drawmenu","title":"function CFBD_DrawMenu","text":"<pre><code>static void CFBD_DrawMenu(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-redraw_item","title":"function redraw_item","text":"<pre><code>static void redraw_item(\n    CFBD_Menu * m,\n    int idx\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_select","title":"function OLED_Menu_Select","text":"<pre><code>void OLED_Menu_Select(\n    CFBD_Menu * m,\n    int new_index\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-reset_tl_points","title":"function reset_tl_points","text":"<pre><code>static void reset_tl_points(\n    CFBD_Menu * m,\n    CFBDGraphic_Point * p,\n    CFBD_Bool request_updates\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_activate","title":"function OLED_Menu_Activate","text":"<pre><code>static void OLED_Menu_Activate(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu_8c/#variable-_ops","title":"variable _ops","text":"<pre><code>static CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n</code></pre>"},{"location":"api/Files/menu_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/menu_8c/#define-cfbd_menu_item_y_gap","title":"define CFBD_MENU_ITEM_Y_GAP","text":"<pre><code>#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre>"},{"location":"api/Files/menu_8c/#define-make_rect","title":"define MAKE_RECT","text":"<pre><code>#define MAKE_RECT(\n    rx,\n    ry,\n    rw,\n    rh\n)\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n</code></pre>"},{"location":"api/Files/menu_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_config.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/base_support/common/helpers.h\"\n#include \"widget/menu/menu.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\nstatic inline const uint16_t get_menu_new_item_x(CFBD_Menu* pMenu)\n{\n    return pMenu-&gt;tl_point.x + pMenu-&gt;indicator.width + pMenu-&gt;indicator.x +\n           CFBD_MENU_INDICATOR_GAP;\n}\n\nstatic const uint16_t get_menu_new_item_height(CFBD_MenuItem* item)\n{\n    CFBDGraphicSize sz = __fetch_font_size(item-&gt;text_obj.font_size);\n    return (sz.height + 2 * CFBD_MENU_ITEM_Y_GAP);\n}\n\nstatic const uint16_t get_menu_new_item_y(CFBD_Menu* pMenu)\n{\n    uint16_t result = pMenu-&gt;tl_point.y;\n    if (!pMenu || !pMenu-&gt;menu_items) {\n        return result;\n    }\n\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    for (uint8_t i = 0; i &lt; group-&gt;count; i++) {\n        result += get_menu_new_item_height(&amp;group-&gt;pItems[i]);\n    }\n    return result + CFBD_MENU_ITEM_Y_GAP;\n}\n\nstatic void CFBD_BindMenuItems(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items)\n{\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n\nstatic void CFBD_AnimationSet(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation)\n{\n    pMenu-&gt;animation = *pBaseAnimation;\n}\n\nstatic CFBD_Bool CFBD_MenuAddItems(CFBD_Menu* pMenu,\n                                   const char* label,\n                                   Ascii_Font_Size font_size,\n                                   CFBD_MenuItemCallbackPack* callbacks)\n{\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    if (group-&gt;count &gt;= group-&gt;capacity) {\n        return CFBD_FALSE;\n    }\n\n    CFBD_MenuItem* it = &amp;group-&gt;pItems[group-&gt;count];\n    it-&gt;label = (char*) label;\n    CFBDGraphic_Point p = {.x = get_menu_new_item_x(pMenu), .y = get_menu_new_item_y(pMenu)};\n    CFBD_MenuItemInit(it, &amp;p, callbacks);\n    CFBDGraphicSize sz = {.width = pMenu-&gt;max_width,\n                          .height = __fetch_font_size(font_size).height + 2 * CFBD_MENU_ITEM_Y_GAP};\n    /* init text object */\n    CFBDGraphic_InitText(&amp;it-&gt;text_obj, it-&gt;tl, sz, font_size);\n    CFBDGraphic_SetText(&amp;it-&gt;text_obj, it-&gt;label);\n    group-&gt;count++;\n\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_DrawMenu(CFBD_Menu* m)\n{\n    CFBD_GraphicDevice* dev = m-&gt;device;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    for (size_t i = 0; i &lt; group-&gt;count; ++i) {\n        CFBD_MenuItem* it = &amp;group-&gt;pItems[i];\n        CFBDGraphic_DrawText(dev, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    /* draw indicator at selected */\n    if (m-&gt;selected &gt;= 0 &amp;&amp; (size_t) m-&gt;selected &lt; group-&gt;count) {\n        CFBD_MenuItem* sel = &amp;group-&gt;pItems[m-&gt;selected];\n        uint16_t ix = m-&gt;tl_point.x + m-&gt;indicator.x;\n        uint16_t iy = sel-&gt;tl.y;\n        uint16_t ih = rect_height(&amp;sel-&gt;text_obj.text_bounding_rect);\n        CFBD_DrawMenuIndicator(m, ix, iy, m-&gt;indicator.width, ih);\n\n        /* reversed the target */\n        CFBDGraphic_Text* text = &amp;sel-&gt;text_obj;\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    text-&gt;tl_point.x,\n                                    text-&gt;tl_point.y,\n                                    rect_width(&amp;text-&gt;text_bounding_rect),\n                                    ih);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(m-&gt;device)) {\n        m-&gt;device-&gt;ops-&gt;update(m-&gt;device);\n    }\n}\n\nstatic void redraw_item(CFBD_Menu* m, int idx)\n{\n    if (idx &lt; 0 || (size_t) idx &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[idx];\n\n    /* \u4f7f\u7528\u9a71\u52a8\u63d0\u4f9b\u7684 clear_area\uff08clear_rect_area \u5df2\u7ecf\u4f1a\u4ee3\u7406\uff09 */\n    CFBDGraphicSize* size = &amp;it-&gt;text_obj.TexthandleSize;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, it-&gt;tl.x, it-&gt;tl.y, size-&gt;width, size-&gt;height);\n    CFBDGraphic_DrawText(m-&gt;device, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nvoid OLED_Menu_Select(CFBD_Menu* m, int new_index)\n{\n    if (new_index &lt; 0)\n        new_index = 0;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    if (new_index &gt;= (int) group-&gt;count)\n        new_index = (int) group-&gt;count - 1;\n    int old = m-&gt;selected;\n    if (old == new_index)\n        return;\n\n    uint16_t start_y = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? group-&gt;pItems[old].tl.y\n                                                                 : group-&gt;pItems[0].tl.y;\n\n    uint16_t end_y = group-&gt;pItems[new_index].tl.y;\n    int frames = (m-&gt;animation.anim_frames &gt; 1) ? m-&gt;animation.anim_frames : 1;\n\n#define MAKE_RECT(rx, ry, rw, rh)                                                                  \\\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n\n    CFBDGraphicRect global_upd;\n    CFBD_Bool have_global = CFBD_FALSE;\n\n    /* restore old text highlight */\n    uint16_t old_text_x = 0, old_text_w = 0, old_text_h = 0;\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        old_text_x = ot-&gt;tl_point.x;\n        old_text_w = rect_width(&amp;ot-&gt;text_bounding_rect);\n        old_text_h = rect_height(&amp;ot-&gt;text_bounding_rect);\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        CFBDGraphicRect r = MAKE_RECT(old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        global_upd = r;\n        have_global = CFBD_TRUE;\n    }\n\n    /* clear indicator column */\n    uint16_t old_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count)\n                             ? group-&gt;pItems[old].text_obj.TexthandleSize.height\n                             : group-&gt;pItems[0].text_obj.TexthandleSize.height;\n    uint16_t new_h = group-&gt;pItems[new_index].text_obj.TexthandleSize.height;\n    uint16_t miny = MIN(start_y, end_y);\n    uint16_t maxy = MAX(start_y, end_y) + MAX(old_h, new_h);\n    uint16_t colx = m-&gt;tl_point.x + m-&gt;indicator.x, colw = m-&gt;indicator.width;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, miny, colw, maxy - miny);\n    {\n        CFBDGraphicRect r = MAKE_RECT(colx, miny, colw, maxy - miny);\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n        }\n    }\n\n    /* new text parameters */\n    CFBDGraphic_Text* nt = &amp;group-&gt;pItems[new_index].text_obj;\n    uint16_t new_text_x = nt-&gt;tl_point.x;\n    uint16_t new_text_w = rect_width(&amp;nt-&gt;text_bounding_rect);\n    volatile CFBDGraphicRect n = rect_normalize(nt-&gt;text_bounding_rect);\n    uint16_t new_text_h = (uint32_t) asInt32_t(n.br.y) - (uint32_t) asInt32_t(n.tl.y);\n\n    /* prepare interpolation bases (if old missing, base on new) */\n    int base_x = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_x : (int) new_text_x;\n    int base_w = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_w : (int) new_text_w;\n    int base_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_h : (int) new_text_h;\n\n    int last_rev_x = -1, last_rev_y = -1, last_rev_w = 0, last_rev_h = 0;\n\n    for (int f = 0; f &lt;= frames; ++f) {\n        float t = (float) f / (float) frames;\n        float st = t * t * (3.0f - 2.0f * t);\n        int cur_y = (int) (start_y + (end_y - start_y) * st + 0.5f);\n\n        /* interpolated width/pos/height for this frame (smoothly morph) */\n        int cur_x = (int) (base_x + (new_text_x - base_x) * st + 0.5f);\n        int cur_w = (int) (base_w + (new_text_w - base_w) * st + 0.5f);\n        int cur_h = (int) (base_h + (new_text_h - base_h) * st + 0.5f);\n        if (cur_w &lt; 1)\n            cur_w = 1;\n        if (cur_h &lt; 1)\n            cur_h = 1;\n\n        CFBDGraphicRect frame_upd;\n        CFBD_Bool have_frame = CFBD_FALSE;\n\n        /* restore previous frame's revert (before drawing indicator) */\n        if (last_rev_y &gt;= 0) {\n            m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                        (uint16_t) last_rev_x,\n                                        (uint16_t) last_rev_y,\n                                        (uint16_t) last_rev_w,\n                                        (uint16_t) last_rev_h);\n            CFBDGraphicRect r = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n            frame_upd = r;\n            have_frame = CFBD_TRUE;\n        }\n\n        /* draw indicator */\n        uint16_t ih = MAX(old_h, new_h);\n\n        CFBD_DrawMenuIndicator(m, colx, cur_y, colw, ih);\n        {\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        /* apply current-frame text revert (this produces the highlight) */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) cur_x,\n                                    (uint16_t) cur_y,\n                                    (uint16_t) cur_w,\n                                    (uint16_t) cur_h);\n        {\n            CFBDGraphicRect r = MAKE_RECT(cur_x, cur_y, cur_w, cur_h);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        last_rev_x = cur_x;\n        last_rev_y = cur_y;\n        last_rev_w = cur_w;\n        last_rev_h = cur_h;\n\n        if (have_frame) {\n            uint16_t ux = frame_upd.tl.x;\n            uint16_t uy = frame_upd.tl.y;\n            uint16_t uw = (uint16_t) (frame_upd.br.x - frame_upd.tl.x);\n            uint16_t uh = (uint16_t) (frame_upd.br.y - frame_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n            if (!have_global) {\n                global_upd = frame_upd;\n                have_global = CFBD_TRUE;\n            }\n            else\n                global_upd = rect_union(&amp;global_upd, &amp;frame_upd);\n        }\n\n        system_delay_ms(m-&gt;animation.anim_frame_delay_ms);\n\n        /* clear indicator (non-final frame) */\n        if (f != frames) {\n            m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, cur_y, colw, ih);\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_global) {\n                global_upd = r;\n                have_global = CFBD_TRUE;\n            }\n            else {\n                global_upd = rect_union(&amp;global_upd, &amp;r);\n            }\n        }\n    }\n\n    /* redraw old item and include into global update */\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        redraw_item(m, old);\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        CFBDGraphicRect r = MAKE_RECT(ot-&gt;tl_point.x,\n                                      ot-&gt;tl_point.y,\n                                      rect_width(&amp;ot-&gt;text_bounding_rect),\n                                      rect_height(&amp;ot-&gt;text_bounding_rect));\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n    }\n\n    /* final correction: if last_rev differs from exact end, restore and set exact final */\n    if (last_rev_y &gt;= 0 &amp;&amp; (last_rev_y != (int) end_y || last_rev_w != (int) new_text_w ||\n                            last_rev_x != (int) new_text_x || last_rev_h != (int) new_text_h)) {\n        /* restore last */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) last_rev_x,\n                                    (uint16_t) last_rev_y,\n                                    (uint16_t) last_rev_w,\n                                    (uint16_t) last_rev_h);\n        CFBDGraphicRect r1 = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n        if (!have_global) {\n            global_upd = r1;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r1);\n        }\n\n        /* final exact revert at end_y with new size */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, new_text_x, end_y, new_text_w, new_text_h);\n        CFBDGraphicRect r2 = MAKE_RECT(new_text_x, end_y, new_text_w, new_text_h);\n        if (!have_global) {\n            global_upd = r2;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r2);\n        }\n\n        /* flush final small region */\n        uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n        uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n        uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n    }\n    else {\n        if (have_global) {\n            uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n            uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n            uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n        }\n    }\n\n#undef MAKE_RECT\n    m-&gt;selected = new_index;\n}\n\nstatic void reset_tl_points(CFBD_Menu* m, CFBDGraphic_Point* p, CFBD_Bool request_updates)\n{\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device,\n                               m-&gt;tl_point.x,\n                               m-&gt;tl_point.y,\n                               m-&gt;max_width,\n                               get_menu_new_item_y(m) - m-&gt;tl_point.y);\n    m-&gt;tl_point = *p;\n    PointBaseType y_height = CFBD_MENU_ITEM_Y_GAP + m-&gt;tl_point.y;\n    for (int i = 0; i &lt; m-&gt;menu_items-&gt;count; i++) {\n        CFBD_MenuItem* item = &amp;m-&gt;menu_items-&gt;pItems[i];\n        item-&gt;tl.x = get_menu_new_item_x(m);\n        item-&gt;tl.y = y_height;\n        CFBDGraphic_SetTextTLPointPoint(&amp;item-&gt;text_obj, &amp;item-&gt;tl);\n        y_height += get_menu_new_item_height(item) - CFBD_MENU_ITEM_Y_GAP;\n    }\n    if (request_updates) {\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device,\n                                    m-&gt;tl_point.x,\n                                    m-&gt;tl_point.y,\n                                    m-&gt;max_width,\n                                    get_menu_new_item_y(m) - m-&gt;tl_point.y);\n        CFBD_DrawMenu(m);\n    }\n}\n\nstatic void OLED_Menu_Activate(CFBD_Menu* m)\n{\n    if (m-&gt;selected &lt; 0 || (size_t) m-&gt;selected &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[m-&gt;selected];\n    CFBD_MenuItemCallbackPack* pack = &amp;it-&gt;on_select;\n    if (pack-&gt;callback) {\n        pack-&gt;callback(pack-&gt;user_data);\n    }\n}\n\nstatic CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width)\n{\n    pMenu-&gt;operations = &amp;_ops;\n    pMenu-&gt;max_width = max_width;\n    pMenu-&gt;device = devices;\n    pMenu-&gt;tl_point.x = 0;\n    pMenu-&gt;tl_point.y = 0;\n    CFBD_InitBaseAnimation(&amp;pMenu-&gt;animation);\n    CFBD_InitDefaultMenuIndicator(&amp;pMenu-&gt;indicator);\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu_8h/","title":"lib/graphic/widget/menu/menu.h","text":""},{"location":"api/Files/menu_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuOps struct _CFBD_Menu"},{"location":"api/Files/menu_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu"},{"location":"api/Files/menu_8h/#functions","title":"Functions","text":"Name void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width) void OLED_Menu_SelectNext(CFBD_Menu * m) void OLED_Menu_SelectPrev(CFBD_Menu * m)"},{"location":"api/Files/menu_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre>"},{"location":"api/Files/menu_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8h/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectnext","title":"function OLED_Menu_SelectNext","text":"<pre><code>static inline void OLED_Menu_SelectNext(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectprev","title":"function OLED_Menu_SelectPrev","text":"<pre><code>static inline void OLED_Menu_SelectPrev(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n\n#include \"base/point.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/text_config.h\"\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct\n{\n    void (*bind_item_groups_contains)(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items);\n\n    CFBD_Bool (*add_item)(CFBD_Menu* pMenu,\n                          const char* label,\n                          Ascii_Font_Size size,\n                          CFBD_MenuItemCallbackPack* callbacks);\n\n    void (*set_indicator_property)(CFBD_Menu* pMenu, CFBD_MenuIndicator* pIndicator);\n    void (*set_animation)(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation);\n    void (*immediate_draw)(CFBD_Menu* pMenu);\n    void (*select_index)(CFBD_Menu* pMenu, int index);\n    void (*activate_current)(CFBD_Menu* pMenu);\n    void (*reset_tl_points)(CFBD_Menu* pMenu, CFBDGraphic_Point* p, CFBD_Bool request_updates);\n} CFBD_MenuOps;\n\n/* Menu */\ntypedef struct _CFBD_Menu\n{\n    CFBD_MenuOps* operations;\n    CFBD_GraphicDevice* device;\n    CFBD_MenuItemGroup* menu_items;\n    CFBDGraphic_Point tl_point; /* default from 0, 0 */\n    SizeBaseType max_width;     // max widths\n    int selected;               /* current selected index */\n\n    /* indicator config */\n    CFBD_MenuIndicator indicator;\n    /* animation config */\n    CFBD_BaseAnimation animation;\n} CFBD_Menu;\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width);\n\nstatic inline void OLED_Menu_SelectNext(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected + 1) % (int) m-&gt;menu_items-&gt;count;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n\nstatic inline void OLED_Menu_SelectPrev(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected - 1);\n    if (ni &lt; 0)\n        ni = (int) m-&gt;menu_items-&gt;count - 1;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu__config_8h/","title":"lib/graphic/widget/menu/menu_config.h","text":""},{"location":"api/Files/menu__config_8h/#defines","title":"Defines","text":"Name CFBD_MENU_INDICATOR_WIDTH Menu Indicator Configs. CFBD_MENU_INDICATOR_POSX CFBD_MENU_INDICATOR_MAX_WIDTH_PX CFBD_MENU_INDICATOR_MAX_HEIGHT_PX CFBD_MENU_INDICATOR_GAP CFBD_MENU_ITEM_Y_GAP"},{"location":"api/Files/menu__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_width","title":"define CFBD_MENU_INDICATOR_WIDTH","text":"<pre><code>#define CFBD_MENU_INDICATOR_WIDTH (4)\n</code></pre> <p>Menu Indicator Configs. </p>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_posx","title":"define CFBD_MENU_INDICATOR_POSX","text":"<pre><code>#define CFBD_MENU_INDICATOR_POSX (0)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_max_width_px","title":"define CFBD_MENU_INDICATOR_MAX_WIDTH_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_max_height_px","title":"define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_gap","title":"define CFBD_MENU_INDICATOR_GAP","text":"<pre><code>#define CFBD_MENU_INDICATOR_GAP (4)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_item_y_gap","title":"define CFBD_MENU_ITEM_Y_GAP","text":"<pre><code>#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_MENU_INDICATOR_WIDTH (4)\n#define CFBD_MENU_INDICATOR_POSX (0)\n\n#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n\n#define CFBD_MENU_INDICATOR_GAP (4)\n\n#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu__indicator_8c/","title":"lib/graphic/widget/menu/menu_indicator.c","text":""},{"location":"api/Files/menu__indicator_8c/#functions","title":"Functions","text":"Name size_t bytes_per_row_px(uint16_t px_width) void blit_fill_rect_bytes(uint8_t * buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte) void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8c/#attributes","title":"Attributes","text":"Name uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf"},{"location":"api/Files/menu__indicator_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#function-bytes_per_row_px","title":"function bytes_per_row_px","text":"<pre><code>static inline size_t bytes_per_row_px(\n    uint16_t px_width\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-blit_fill_rect_bytes","title":"function blit_fill_rect_bytes","text":"<pre><code>static void blit_fill_rect_bytes(\n    uint8_t * buf,\n    uint16_t w_px,\n    uint16_t h_px,\n    uint8_t fill_byte\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#variable-s_indicator_buf","title":"variable s_indicator_buf","text":"<pre><code>static uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf;\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_indicator.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"menu.h\"\n#include \"menu_config.h\"\n\n\nstatic uint8_t s_indicator_buf[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX + 7) / 8) *\n                               CFBD_MENU_INDICATOR_MAX_HEIGHT_PX];\n\n/* compute bytes per row for given pixel width (1bpp) */\nstatic inline size_t bytes_per_row_px(uint16_t px_width)\n{\n    return (px_width + 7) / 8;\n}\n\n/* fill a byte buffer with 0xFF (set pixels) or 0x00 (clear) */\nstatic void blit_fill_rect_bytes(uint8_t* buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte)\n{\n    size_t rowb = bytes_per_row_px(w_px);\n    for (uint16_t r = 0; r &lt; h_px; ++r) {\n        uint8_t* rowp = buf + r * rowb;\n        for (size_t i = 0; i &lt; rowb; ++i) {\n            rowp[i] = fill_byte;\n        }\n    }\n}\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault)\n{\n    menuIndicatorDefault-&gt;width = CFBD_MENU_INDICATOR_WIDTH;\n    menuIndicatorDefault-&gt;x = CFBD_MENU_INDICATOR_POSX;\n}\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_GraphicDevice* dev = menu-&gt;device;\n\n    /* safety clamp (\u9632\u6b62\u8d8a\u754c) */\n    if (w &gt; CFBD_MENU_INDICATOR_MAX_WIDTH_PX || h &gt; CFBD_MENU_INDICATOR_MAX_HEIGHT_PX) {\n        return CFBD_FALSE;\n    }\n\n    blit_fill_rect_bytes(s_indicator_buf, w, h, 0xFF);\n\n    return dev-&gt;ops-&gt;setArea(dev, x, y, w, h, s_indicator_buf);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu__indicator_8h/","title":"lib/graphic/widget/menu/menu_indicator.h","text":""},{"location":"api/Files/menu__indicator_8h/#classes","title":"Classes","text":"Name struct __CFBD_MenuIndicator"},{"location":"api/Files/menu__indicator_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu typedef struct __CFBD_MenuIndicator CFBD_MenuIndicator"},{"location":"api/Files/menu__indicator_8h/#functions","title":"Functions","text":"Name void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menuindicator","title":"typedef CFBD_MenuIndicator","text":"<pre><code>typedef struct __CFBD_MenuIndicator CFBD_MenuIndicator;\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct __CFBD_MenuIndicator\n{\n    uint8_t width; // width of the sliding indicator(pixels), zero for none paints\n    uint8_t x;     // x-position of indicator\n} CFBD_MenuIndicator;\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault);\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu__item_8c/","title":"lib/graphic/widget/menu/menu_item.c","text":""},{"location":"api/Files/menu__item_8c/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8c/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_item.h\"\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks)\n{\n    menuItem-&gt;tl = *tl;\n    menuItem-&gt;on_select = *callbacks;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/menu__item_8h/","title":"lib/graphic/widget/menu/menu_item.h","text":""},{"location":"api/Files/menu__item_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuItemCallbackPack struct __CFBD_MenuItem struct __CFBD_MenuItemArray"},{"location":"api/Files/menu__item_8h/#types","title":"Types","text":"Name typedef void(*)(void *user_data) CFBD_MenuItemCallback typedef struct __CFBD_MenuItem CFBD_MenuItem typedef struct __CFBD_MenuItemArray CFBD_MenuItemGroup"},{"location":"api/Files/menu__item_8h/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemcallback","title":"typedef CFBD_MenuItemCallback","text":"<pre><code>typedef void(* CFBD_MenuItemCallback) (void *user_data);\n</code></pre>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitem","title":"typedef CFBD_MenuItem","text":"<pre><code>typedef struct __CFBD_MenuItem CFBD_MenuItem;\n</code></pre>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemgroup","title":"typedef CFBD_MenuItemGroup","text":"<pre><code>typedef struct __CFBD_MenuItemArray CFBD_MenuItemGroup;\n</code></pre>"},{"location":"api/Files/menu__item_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8h/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"widget/text.h\"\n\ntypedef void (*CFBD_MenuItemCallback)(void* user_data);\ntypedef struct\n{\n    CFBD_MenuItemCallback callback;\n    void* user_data;\n} CFBD_MenuItemCallbackPack;\n\n/* MenuItem */\ntypedef struct __CFBD_MenuItem\n{\n    char* label;                         /* pointer to zero-terminated string (owned by caller) */\n    CFBDGraphic_Point tl;                /* top-left pixel of item label area */\n    CFBD_MenuItemCallbackPack on_select; /* optional callback when this item activated */\n    CFBDGraphic_Text text_obj;           /* internal text object (initialized on add) */\n} CFBD_MenuItem;\n\ntypedef struct __CFBD_MenuItemArray\n{\n    CFBD_MenuItem* pItems;\n    size_t capacity;\n    size_t count;\n} CFBD_MenuItemGroup;\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled_8c/","title":"lib/oled/oled.c","text":""},{"location":"api/Files/oled_8c/#functions","title":"Functions","text":"Name void CFBD_OLED_ImmediateInit(CFBD_OLED * oled) CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8c/#function-cfbd_oled_immediateinit","title":"function CFBD_OLED_ImmediateInit","text":"<pre><code>static inline void CFBD_OLED_ImmediateInit(\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled.h\"\n\n#include \"cfbd_define.h\"\n#include \"driver/backend/oled_iic.h\"\n\nstatic inline void CFBD_OLED_ImmediateInit(CFBD_OLED* oled)\n{\n    const CFBD_OLEDOperations* ops = oled-&gt;ops;\n    ops-&gt;init(oled, NULL);\n    ops-&gt;clear(oled);\n    ops-&gt;update(oled);\n}\n\nCFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED* oled, const CFBD_OLEDDriverType driver_type, \n    CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)\n{\n    switch(driver_type){\n        case CFBD_OLEDDriverType_IIC:\n            CFBD_OLED_IICInit(oled, args);\n        break;\n        default:\n            return CFBD_FALSE;\n        break;\n    }\n\n    if(request_immediate_init){\n        CFBD_OLED_ImmediateInit(oled);\n    }\n\n    return CFBD_TRUE;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled_8h/","title":"lib/oled/oled.h","text":"<p>oled general handles  More...</p>"},{"location":"api/Files/oled_8h/#classes","title":"Classes","text":"Name struct _CFBD_OLED_OPS struct _CFBD_OLED"},{"location":"api/Files/oled_8h/#types","title":"Types","text":"Name enum CFBD_OLEDDriverType typedef void * CFBD_OLEDHandle typedef struct _CFBD_OLED CFBD_OLED typedef CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height) AreaOperations typedef CFBD_Bool(*)(CFBD_OLED *oled) FrameOperation typedef CFBD_Bool(*)(CFBD_OLED *oled) OLEDSelfOperation typedef CFBD_Bool(*)(CFBD_OLED *oled, const char *property, void *args, void *request_data) OLED_QueryOperation typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations typedef void * CFBDOLED_Params_Inits"},{"location":"api/Files/oled_8h/#functions","title":"Functions","text":"Name CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8h/#detailed-description","title":"Detailed Description","text":"<p>oled general handles </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-09</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/oled_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/oled_8h/#enum-cfbd_oleddrivertype","title":"enum CFBD_OLEDDriverType","text":"Enumerator Value Description CFBD_OLEDDriverType_IIC CFBD_OLEDDriverType_SPI"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledhandle","title":"typedef CFBD_OLEDHandle","text":"<pre><code>typedef void* CFBD_OLEDHandle;\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oled","title":"typedef CFBD_OLED","text":"<pre><code>typedef struct _CFBD_OLED CFBD_OLED;\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-areaoperations","title":"typedef AreaOperations","text":"<pre><code>typedef CFBD_Bool( * AreaOperations) (CFBD_OLED *oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-frameoperation","title":"typedef FrameOperation","text":"<pre><code>typedef CFBD_Bool(* FrameOperation) (CFBD_OLED *oled);\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-oledselfoperation","title":"typedef OLEDSelfOperation","text":"<pre><code>typedef CFBD_Bool(* OLEDSelfOperation) (CFBD_OLED *oled);\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-oled_queryoperation","title":"typedef OLED_QueryOperation","text":"<pre><code>typedef CFBD_Bool(* OLED_QueryOperation) (CFBD_OLED *oled, const char *property, void *args, void *request_data);\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledoperations","title":"typedef CFBD_OLEDOperations","text":"<pre><code>typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations;\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbdoled_params_inits","title":"typedef CFBDOLED_Params_Inits","text":"<pre><code>typedef void* CFBDOLED_Params_Inits;\n</code></pre>"},{"location":"api/Files/oled_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8h/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef enum\n{\n    CFBD_OLEDDriverType_IIC,\n    CFBD_OLEDDriverType_SPI\n} CFBD_OLEDDriverType;\n\ntypedef void* CFBD_OLEDHandle;\n\ntypedef struct _CFBD_OLED CFBD_OLED;\ntypedef CFBD_Bool (\n        *AreaOperations)(CFBD_OLED* oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\ntypedef CFBD_Bool (*FrameOperation)(CFBD_OLED* oled);\ntypedef CFBD_Bool (*OLEDSelfOperation)(CFBD_OLED* oled);\ntypedef CFBD_Bool (*OLED_QueryOperation)(CFBD_OLED* oled,\n                                         const char* property, // property for query\n                                         void* args,           // if property request args\n                                         void* request_data);  // contains results\n\ntypedef struct _CFBD_OLED_OPS\n{\n    int (*init)(CFBD_OLED* oled, void* init_args);\n    CFBD_Bool (*setPixel)(CFBD_OLED* oled, uint16_t x, uint16_t y);\n    CFBD_Bool (*setArea)(CFBD_OLED* device,\n                         uint16_t x,\n                         uint16_t y,\n                         uint16_t width,\n                         uint16_t height,\n                         uint8_t* source);\n    FrameOperation update;\n    FrameOperation clear;\n    FrameOperation revert;\n\n    AreaOperations update_area;\n    AreaOperations clear_area;\n    AreaOperations revert_area;\n\n    OLEDSelfOperation open;\n    OLEDSelfOperation close;\n    OLED_QueryOperation self_consult;\n} CFBD_OLEDOperations;\n\ntypedef struct _CFBD_OLED\n{\n    const CFBD_OLEDOperations* ops;\n    CFBD_OLEDDriverType driver_type;\n    CFBD_OLEDHandle oled_internal_handle;\n} CFBD_OLED;\n\ntypedef void* CFBDOLED_Params_Inits;\nCFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,\n                             const CFBD_OLEDDriverType driver_type,\n                             CFBDOLED_Params_Inits args,\n                             CFBD_Bool request_immediate_init);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled__graphic__device_8c/","title":"lib/graphic/device/oled/oled_graphic_device.c","text":""},{"location":"api/Files/oled__graphic__device_8c/#functions","title":"Functions","text":"Name CFBD_OLED * _get_oled(CFBD_GraphicDevice * device) int graphic_oled_init(CFBD_GraphicDevice * device, void * init_args) CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice * device, uint16_t x, uint16_t y) CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * source) CFBD_Bool graphic_oled_update(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_update_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_clear_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_revert_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_open(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_close(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice * device, const char * property, void * args, void * request_data) void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice * device, CFBD_OLED * oled)"},{"location":"api/Files/oled__graphic__device_8c/#attributes","title":"Attributes","text":"Name CFBD_GraphicDeviceOperation graphic_oled_ops"},{"location":"api/Files/oled__graphic__device_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#function-_get_oled","title":"function _get_oled","text":"<pre><code>static inline CFBD_OLED * _get_oled(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_init","title":"function graphic_oled_init","text":"<pre><code>static int graphic_oled_init(\n    CFBD_GraphicDevice * device,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_setpixel","title":"function graphic_oled_setPixel","text":"<pre><code>static CFBD_Bool graphic_oled_setPixel(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_drawarea","title":"function graphic_oled_drawArea","text":"<pre><code>static CFBD_Bool graphic_oled_drawArea(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * source\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update","title":"function graphic_oled_update","text":"<pre><code>static CFBD_Bool graphic_oled_update(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear","title":"function graphic_oled_clear","text":"<pre><code>static CFBD_Bool graphic_oled_clear(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert","title":"function graphic_oled_revert","text":"<pre><code>static CFBD_Bool graphic_oled_revert(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update_area","title":"function graphic_oled_update_area","text":"<pre><code>static CFBD_Bool graphic_oled_update_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear_area","title":"function graphic_oled_clear_area","text":"<pre><code>static CFBD_Bool graphic_oled_clear_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert_area","title":"function graphic_oled_revert_area","text":"<pre><code>static CFBD_Bool graphic_oled_revert_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_open","title":"function graphic_oled_open","text":"<pre><code>static CFBD_Bool graphic_oled_open(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_close","title":"function graphic_oled_close","text":"<pre><code>static CFBD_Bool graphic_oled_close(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_self_consult","title":"function graphic_oled_self_consult","text":"<pre><code>static CFBD_Bool graphic_oled_self_consult(\n    CFBD_GraphicDevice * device,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-cfbdgraphic_bindoledasdevice","title":"function CFBDGraphic_BindOLEDAsDevice","text":"<pre><code>void CFBDGraphic_BindOLEDAsDevice(\n    CFBD_GraphicDevice * device,\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#variable-graphic_oled_ops","title":"variable graphic_oled_ops","text":"<pre><code>static CFBD_GraphicDeviceOperation graphic_oled_ops = {\n        .init = graphic_oled_init,\n        .setPixel = graphic_oled_setPixel,\n        .setArea = graphic_oled_drawArea,\n\n        .update = graphic_oled_update,\n        .clear = graphic_oled_clear,\n        .revert = graphic_oled_revert,\n\n        .update_area = graphic_oled_update_area,\n        .clear_area = graphic_oled_clear_area,\n        .revert_area = graphic_oled_revert_area,\n\n        .open = graphic_oled_open,\n        .close = graphic_oled_close,\n\n        .self_consult = graphic_oled_self_consult,\n};\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_graphic_device.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n\n\nstatic inline CFBD_OLED* _get_oled(CFBD_GraphicDevice* device)\n{\n    return (CFBD_OLED*) device-&gt;internal_handle;\n}\n\n/* ---------- init ---------- */\n\nstatic int graphic_oled_init(CFBD_GraphicDevice* device, void* init_args)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;init(oled, init_args);\n}\n\n/* ---------- pixel ---------- */\n\nstatic CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice* device, uint16_t x, uint16_t y)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setPixel(oled, x, y);\n}\n\nstatic CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice* device,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* source)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setArea(oled, x, y, width, height, source);\n}\n/* ---------- frame ---------- */\n\nstatic CFBD_Bool graphic_oled_update(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;update(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert(_get_oled(device));\n}\n\n/* ---------- area ---------- */\n\nstatic CFBD_Bool\ngraphic_oled_update_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;update_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_clear_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_revert_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert_area(_get_oled(device), x, y, w, h);\n}\n\n/* ---------- lifecycle ---------- */\n\nstatic CFBD_Bool graphic_oled_open(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;open(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_close(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;close(_get_oled(device));\n}\n\n/* ---------- query ---------- */\n\nstatic CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice* device,\n                                           const char* property,\n                                           void* args,\n                                           void* request_data)\n{\n    return _get_oled(device)-&gt;ops-&gt;self_consult(_get_oled(device), property, args, request_data);\n}\n\nstatic CFBD_GraphicDeviceOperation graphic_oled_ops = {\n        .init = graphic_oled_init,\n        .setPixel = graphic_oled_setPixel,\n        .setArea = graphic_oled_drawArea,\n\n        .update = graphic_oled_update,\n        .clear = graphic_oled_clear,\n        .revert = graphic_oled_revert,\n\n        .update_area = graphic_oled_update_area,\n        .clear_area = graphic_oled_clear_area,\n        .revert_area = graphic_oled_revert_area,\n\n        .open = graphic_oled_open,\n        .close = graphic_oled_close,\n\n        .self_consult = graphic_oled_self_consult,\n};\n\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled)\n{\n    if (device == NULL || oled == NULL || oled-&gt;ops == NULL)\n        return;\n\n    device-&gt;ops = &amp;graphic_oled_ops;\n    device-&gt;device_type = OLED;\n    device-&gt;internal_handle = (CFBDGraphicDeviceHandle) oled;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled__graphic__device_8h/","title":"lib/graphic/device/oled/oled_graphic_device.h","text":""},{"location":"api/Files/oled__graphic__device_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice * device, CFBD_OLED * oled)"},{"location":"api/Files/oled__graphic__device_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__graphic__device_8h/#function-cfbdgraphic_bindoledasdevice","title":"function CFBDGraphic_BindOLEDAsDevice","text":"<pre><code>void CFBDGraphic_BindOLEDAsDevice(\n    CFBD_GraphicDevice * device,\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../oled/oled.h\"\n#include \"device/graphic_device.h\"\n\n/* binders */\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled__iic_8c/","title":"lib/oled/driver/backend/oled_iic.c","text":""},{"location":"api/Files/oled__iic_8c/#functions","title":"Functions","text":"Name CFBD_OLED_IICInitsParams * asIICInitsParams(void * internal) void send_data(CFBD_OLED_IICInitsParams * internal, uint8_t * data, uint16_t len) void send_cmd(CFBD_OLED_IICInitsParams * internal, uint8_t cmd) void __pvt_oled_set_cursor(CFBD_OLED_IICInitsParams * handle, const uint8_t y, const uint8_t x) int init(CFBD_OLED * oled, void * init_args) CFBD_Bool setPixel(CFBD_OLED * handle, uint16_t x, uint16_t y) CFBD_Bool clear(CFBD_OLED * handle) CFBD_Bool update(CFBD_OLED * handle) CFBD_Bool oled_helper_clear_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_draw_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * sources) CFBD_Bool oled_helper_update_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_reverse(CFBD_OLED * handle) CFBD_Bool oled_helper_reversearea(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool open_oled(CFBD_OLED * handle) CFBD_Bool close_oled(CFBD_OLED * handle) CFBD_Bool iic_query(CFBD_OLED * oled, const char * property, void * args, void * request_data) void CFBD_OLED_IICInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle)To init a iic based oled."},{"location":"api/Files/oled__iic_8c/#attributes","title":"Attributes","text":"Name uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM const CFBD_OLEDOperations iic_ops"},{"location":"api/Files/oled__iic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__iic_8c/#function-asiicinitsparams","title":"function asIICInitsParams","text":"<pre><code>static inline CFBD_OLED_IICInitsParams * asIICInitsParams(\n    void * internal\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-send_data","title":"function send_data","text":"<pre><code>static void send_data(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t * data,\n    uint16_t len\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-send_cmd","title":"function send_cmd","text":"<pre><code>static void send_cmd(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t cmd\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-__pvt_oled_set_cursor","title":"function __pvt_oled_set_cursor","text":"<pre><code>static void __pvt_oled_set_cursor(\n    CFBD_OLED_IICInitsParams * handle,\n    const uint8_t y,\n    const uint8_t x\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-init","title":"function init","text":"<pre><code>static int init(\n    CFBD_OLED * oled,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-setpixel","title":"function setPixel","text":"<pre><code>static CFBD_Bool setPixel(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-clear","title":"function clear","text":"<pre><code>static CFBD_Bool clear(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-update","title":"function update","text":"<pre><code>static CFBD_Bool update(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_clear_area","title":"function oled_helper_clear_area","text":"<pre><code>static CFBD_Bool oled_helper_clear_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_draw_area","title":"function oled_helper_draw_area","text":"<pre><code>static CFBD_Bool oled_helper_draw_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * sources\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_update_area","title":"function oled_helper_update_area","text":"<pre><code>static CFBD_Bool oled_helper_update_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_reverse","title":"function oled_helper_reverse","text":"<pre><code>static CFBD_Bool oled_helper_reverse(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_reversearea","title":"function oled_helper_reversearea","text":"<pre><code>static CFBD_Bool oled_helper_reversearea(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-open_oled","title":"function open_oled","text":"<pre><code>static CFBD_Bool open_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-close_oled","title":"function close_oled","text":"<pre><code>static CFBD_Bool close_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-iic_query","title":"function iic_query","text":"<pre><code>static CFBD_Bool iic_query(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-cfbd_oled_iicinit","title":"function CFBD_OLED_IICInit","text":"<pre><code>void CFBD_OLED_IICInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre> <p>To init a iic based oled. </p> <p>Parameters: </p> <ul> <li>handle </li> <li>pvt_handle </li> </ul>"},{"location":"api/Files/oled__iic_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__iic_8c/#variable-oled_gram","title":"variable OLED_GRAM","text":"<pre><code>static uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM;\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#variable-iic_ops","title":"variable iic_ops","text":"<pre><code>static const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query};\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_iic.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"configs/cache_config.h\"\n#include \"iic.h\"\n#include \"oled.h\"\n\nstatic uint8_t OLED_GRAM[CACHED_HEIGHT][CACHED_WIDTH];\n\nstatic inline CFBD_OLED_IICInitsParams* asIICInitsParams(void* internal)\n{\n    return internal;\n}\n\nstatic void send_data(CFBD_OLED_IICInitsParams* internal, uint8_t* data, uint16_t len)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;data_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = NULL,\n                                        .len = 1,\n                                }};\n    for (uint16_t i = 0; i &lt; len; i++) {\n        cmds[1].buf = &amp;data[i];\n        CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n    }\n}\n\nstatic void send_cmd(CFBD_OLED_IICInitsParams* internal, uint8_t cmd)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;cmd_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;cmd,\n                                        .len = 1,\n                                }};\n    CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n}\n\nstatic void\n__pvt_oled_set_cursor(CFBD_OLED_IICInitsParams* handle, const uint8_t y, const uint8_t x)\n{\n    send_cmd(handle, 0xB0 | y);\n    send_cmd(handle, 0x10 | ((x &amp; 0xF0) &gt;&gt; 4));\n    send_cmd(handle, 0x00 | (x &amp; 0x0F));\n}\n\n// Impls\nstatic int init(CFBD_OLED* oled, void* init_args)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    uint8_t* init_cmds = internal-&gt;device_specifics-&gt;init_session_tables();\n    uint16_t init_cmds_sz = internal-&gt;device_specifics-&gt;init_session_tables_sz;\n    for (int i = 0; i &lt; init_cmds_sz; i++) {\n        send_cmd(internal, init_cmds[i]);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool setPixel(CFBD_OLED* handle, uint16_t x, uint16_t y)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    if (x &lt; internal-&gt;device_specifics-&gt;logic_width &amp;&amp;\n        y &lt; internal-&gt;device_specifics-&gt;logic_height) {\n        OLED_GRAM[y / 8][x] |= 0x01 &lt;&lt; (y % 8);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool clear(CFBD_OLED* handle)\n{\n    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool update(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    for (uint8_t j = 0; j &lt; CACHED_HEIGHT; j++) {\n        __pvt_oled_set_cursor(handle-&gt;oled_internal_handle, j, 0);\n        send_data(handle-&gt;oled_internal_handle,\n                  OLED_GRAM[j],\n                  internal-&gt;device_specifics-&gt;logic_width);\n    }\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_clear_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y; i &lt; y + height; i++) {\n        for (uint8_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] &amp;= ~(0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* sources)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    uint16_t pages = (height + 7) / 8; /* safer\u5199\u6cd5 */\n    for (uint16_t j = 0; j &lt; pages; j++) {\n        uint16_t page_index = y / 8 + j;\n        if (page_index &gt;= CACHED_HEIGHT) {\n            return CFBD_TRUE;\n        }\n        for (uint16_t i = 0; i &lt; width; i++) {\n            uint16_t x_idx = x + i;\n            if (x_idx &gt;= CACHED_WIDTH) {\n                break;\n            }\n\n            uint8_t src = sources[j * width + i];\n            OLED_GRAM[page_index][x_idx] |= (src &lt;&lt; (y % 8));\n\n            if (page_index + 1 &lt; CACHED_HEIGHT) {\n                OLED_GRAM[page_index + 1][x_idx] |= (src &gt;&gt; (8 - (y % 8)));\n            }\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\n// static CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n//                                        uint16_t x,\n//                                        uint16_t y,\n//                                        uint16_t width,\n//                                        uint16_t height,\n//                                        uint8_t* sources)\n// {\n//     CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n//     const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n//     const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n//     if (x &gt;= POINT_X_MAX)\n//         return CFBD_FALSE;\n//     if (y &gt;= POINT_Y_MAX)\n//         return CFBD_FALSE;\n\n//     // clear the area before being set\n//     oled_helper_clear_area(handle, x, y, width, height);\n\n//     for (uint16_t j = 0; j &lt; (height - 1) / 8 + 1; j++) {\n//         for (uint16_t i = 0; i &lt; width; i++) {\n//             if (x + i &gt; CACHED_WIDTH) {\n//                 break;\n//             }\n//             if (y / 8 + j &gt; CACHED_HEIGHT - 1) {\n//                 return CFBD_TRUE;\n//             }\n\n//             OLED_GRAM[y / 8 + j][x + i] |= sources[j * width + i] &lt;&lt; (y % 8);\n\n//             if (y / 8 + j + 1 &gt; CACHED_HEIGHT - 1) {\n//                 continue;\n//             }\n\n//             OLED_GRAM[y / 8 + j + 1][x + i] |= sources[j * width + i] &gt;&gt; (8 - y % 8);\n//         }\n//     }\n\n//     return CFBD_TRUE;\n// }\n\nstatic CFBD_Bool\noled_helper_update_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y / 8; i &lt; (y + height - 1) / 8 + 1; i++) {\n        /*\u8bbe\u7f6e\u5149\u6807\u4f4d\u7f6e\u4e3a\u76f8\u5173\u9875\u7684\u6307\u5b9a\u5217*/\n        __pvt_oled_set_cursor(internal, i, x);\n        /*\u8fde\u7eed\u5199\u5165Width\u4e2a\u6570\u636e\uff0c\u5c06\u663e\u5b58\u6570\u7ec4\u7684\u6570\u636e\u5199\u5165\u5230OLED\u786c\u4ef6*/\n        send_data(internal, &amp;OLED_GRAM[i][x], width);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_reverse(CFBD_OLED* handle)\n{\n    for (uint16_t i = 0; i &lt; CACHED_HEIGHT; i++) {\n        for (uint16_t j = 0; j &lt; CACHED_WIDTH; j++) {\n            OLED_GRAM[i][j] ^= 0xFF;\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_reversearea(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt; POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt; POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint16_t i = y; i &lt; y + height; i++) {\n        for (uint16_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] ^= (0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool open_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x14);\n    send_cmd(internal, 0xAF);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool close_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x10);\n    send_cmd(internal, 0xAE);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool iic_query(CFBD_OLED* oled,\n                           const char* property, // property for query\n                           void* args,           // if property request args\n                           void* request_data)   // contains results\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    if (strcmp(\"rgb\", property) == 0) {\n        CFBD_Bool* support_rgb = (CFBD_Bool*) request_data;\n        *support_rgb = CFBD_FALSE;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"width\", property) == 0) {\n        uint16_t* width = (uint16_t*) request_data;\n        *width = internal-&gt;device_specifics-&gt;logic_width;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"height\", property) == 0) {\n        uint16_t* height = (uint16_t*) request_data;\n        *height = internal-&gt;device_specifics-&gt;logic_height;\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query};\n\nvoid CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle)\n{\n    handle-&gt;oled_internal_handle = pvt_handle;\n    handle-&gt;driver_type = CFBD_OLEDDriverType_IIC;\n    handle-&gt;ops = &amp;iic_ops;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/oled__iic_8h/","title":"lib/oled/driver/backend/oled_iic.h","text":""},{"location":"api/Files/oled__iic_8h/#functions","title":"Functions","text":"Name void CFBD_OLED_IICInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle)To init a iic based oled."},{"location":"api/Files/oled__iic_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__iic_8h/#function-cfbd_oled_iicinit","title":"function CFBD_OLED_IICInit","text":"<pre><code>void CFBD_OLED_IICInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre> <p>To init a iic based oled. </p> <p>Parameters: </p> <ul> <li>handle </li> <li>pvt_handle </li> </ul>"},{"location":"api/Files/oled__iic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"configs/external_impl_driver.h\"\n#include \"oled.h\"\n\nvoid CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/point_8h/","title":"lib/graphic/base/point.h","text":""},{"location":"api/Files/point_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Point struct CFBDGraphic_Vec2i"},{"location":"api/Files/point_8h/#functions","title":"Functions","text":"Name CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b) CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)"},{"location":"api/Files/point_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/point_8h/#function-point_add","title":"function point_add","text":"<pre><code>static inline CFBDGraphic_Point point_add(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre>"},{"location":"api/Files/point_8h/#function-point_sub","title":"function point_sub","text":"<pre><code>static inline CFBDGraphic_Vec2i point_sub(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre>"},{"location":"api/Files/point_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    PointBaseType x;\n    PointBaseType y;\n} CFBDGraphic_Point;\n\ntypedef struct\n{\n    int32_t x;\n    int32_t y;\n} CFBDGraphic_Vec2i;\n\nstatic inline CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    uint32_t x = (uint32_t) a.x + b.x;\n    uint32_t y = (uint32_t) a.y + b.y;\n\n    if (x &gt; UINT16_MAX)\n        x = UINT16_MAX;\n    if (y &gt; UINT16_MAX)\n        y = UINT16_MAX;\n\n    return (CFBDGraphic_Point) {(uint16_t) x, (uint16_t) y};\n}\n\nstatic inline CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    return (CFBDGraphic_Vec2i) {(int32_t) a.x - (int32_t) b.x, (int32_t) a.y - (int32_t) b.y};\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/progressbar_8c/","title":"lib/graphic/widget/progressbar/progressbar.c","text":""},{"location":"api/Files/progressbar_8c/#functions","title":"Functions","text":"Name void draw_rect_border(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void fill_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void clear_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void compute_inner_box(CFBD_ProgressBar * pb, uint16_t * out_x, uint16_t * out_y, uint16_t * out_w, uint16_t * out_h) float smoothstep(float t) uint16_t compute_fill_width(CFBD_ProgressBar * pb, int32_t value) void CFBD_ProgressBar_Draw(CFBD_ProgressBar * pb) void CFBD_ProgressBar_SetValue(CFBD_ProgressBar * pb, int32_t new_value) CFBD_Bool CFBD_ProgressBar_SetProperty(CFBD_ProgressBar * pb, const char * property, const void * value) void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8c/#attributes","title":"Attributes","text":"Name CFBD_ProgressBarOps ops"},{"location":"api/Files/progressbar_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8c/#function-draw_rect_border","title":"function draw_rect_border","text":"<pre><code>static void draw_rect_border(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-fill_rect","title":"function fill_rect","text":"<pre><code>static void fill_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-clear_rect","title":"function clear_rect","text":"<pre><code>static void clear_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_inner_box","title":"function compute_inner_box","text":"<pre><code>static void compute_inner_box(\n    CFBD_ProgressBar * pb,\n    uint16_t * out_x,\n    uint16_t * out_y,\n    uint16_t * out_w,\n    uint16_t * out_h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-smoothstep","title":"function smoothstep","text":"<pre><code>static float smoothstep(\n    float t\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_fill_width","title":"function compute_fill_width","text":"<pre><code>static uint16_t compute_fill_width(\n    CFBD_ProgressBar * pb,\n    int32_t value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_draw","title":"function CFBD_ProgressBar_Draw","text":"<pre><code>void CFBD_ProgressBar_Draw(\n    CFBD_ProgressBar * pb\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setvalue","title":"function CFBD_ProgressBar_SetValue","text":"<pre><code>void CFBD_ProgressBar_SetValue(\n    CFBD_ProgressBar * pb,\n    int32_t new_value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setproperty","title":"function CFBD_ProgressBar_SetProperty","text":"<pre><code>CFBD_Bool CFBD_ProgressBar_SetProperty(\n    CFBD_ProgressBar * pb,\n    const char * property,\n    const void * value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/progressbar_8c/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n</code></pre>"},{"location":"api/Files/progressbar_8c/#source-code","title":"Source code","text":"<pre><code>#include \"progressbar.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\" /* for system_delay_ms */\n#include \"widget/animation/animation.h\"\n#include \"widget/base_support/common/helpers.h\"\n\n/* Draw rectangle border using setPixel (1px thick) */\nstatic void\ndraw_rect_border(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    /* top/bottom */\n    for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n        SetPixelAction(dev, ix, y);\n        SetPixelAction(dev, ix, y + h - 1);\n    }\n    /* left/right */\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        SetPixelAction(dev, x, iy);\n        SetPixelAction(dev, x + w - 1, iy);\n    }\n}\n\n/* Fill rectangular area with pixels (setPixel) */\nstatic void fill_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n            SetPixelAction(dev, ix, iy);\n        }\n    }\n}\n\n/* Clear area using device-provided clear_area (faster than per-pixel clear) */\nstatic void clear_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    dev-&gt;ops-&gt;clear_area(dev, x, y, w, h);\n}\n\n/* internal: compute inner box (where fill is drawn) */\nstatic void compute_inner_box(CFBD_ProgressBar* pb,\n                              uint16_t* out_x,\n                              uint16_t* out_y,\n                              uint16_t* out_w,\n                              uint16_t* out_h)\n{\n    uint16_t x = pb-&gt;tl.x;\n    uint16_t y = pb-&gt;tl.y;\n    uint16_t w = pb-&gt;size.width;\n    uint16_t h = pb-&gt;size.height;\n\n    uint8_t pad = pb-&gt;padding;\n    if (pb-&gt;border) {\n        /* 1 px border assumed */\n        if (w &lt;= 2)\n            w = 0;\n        else {\n            x += 1;\n            w -= 2;\n        }\n        if (h &lt;= 2)\n            h = 0;\n        else {\n            y += 1;\n            h -= 2;\n        }\n    }\n    /* apply padding inside */\n    if (w &gt; 2 * pad) {\n        x += pad;\n        w -= (uint16_t) (2 * pad);\n    }\n    else\n        w = 0;\n    if (h &gt; 2 * pad) {\n        y += pad;\n        h -= (uint16_t) (2 * pad);\n    }\n    else\n        h = 0;\n\n    *out_x = x;\n    *out_y = y;\n    *out_w = w;\n    *out_h = h;\n}\n\nstatic float smoothstep(float t)\n{\n    /* classic smoothstep: 3t^2 - 2t^3 */\n    return t * t * (3.0f - 2.0f * t);\n}\n\nstatic uint16_t compute_fill_width(CFBD_ProgressBar* pb, int32_t value)\n{\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    if (iw == 0 || pb-&gt;max &lt;= pb-&gt;min)\n        return 0;\n\n    value = clamp_i32(value, pb-&gt;min, pb-&gt;max);\n    float frac = (float) (value - pb-&gt;min) / (float) (pb-&gt;max - pb-&gt;min);\n\n    if (frac &lt; 0.0f)\n        frac = 0.0f;\n    if (frac &gt; 1.0f)\n        frac = 1.0f;\n\n    return (uint16_t) (frac * (float) iw + 0.5f);\n}\n\nvoid CFBD_ProgressBar_Draw(CFBD_ProgressBar* pb)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    CFBD_GraphicDevice* dev = pb-&gt;device;\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    /* clear inner area */\n    clear_rect(dev, ix, iy, iw, ih);\n\n    /* draw filled area */\n    uint16_t fill_w = compute_fill_width(pb, pb-&gt;value);\n    if (fill_w &gt; 0)\n        fill_rect(dev, ix, iy, fill_w, ih);\n\n    /* border */\n    if (pb-&gt;border)\n        draw_rect_border(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n    dev-&gt;ops-&gt;update_area(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n}\n\nvoid CFBD_ProgressBar_SetValue(CFBD_ProgressBar* pb, int32_t new_value)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    new_value = clamp_i32(new_value, pb-&gt;min, pb-&gt;max);\n\n    int32_t old_value = pb-&gt;value;\n    if (pb-&gt;animation.anim_frames &lt;= 1) {\n        pb-&gt;value = new_value;\n        CFBD_ProgressBar_Draw(pb);\n        return;\n    }\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n    if (iw == 0 || ih == 0) {\n        pb-&gt;value = new_value;\n        return;\n    }\n\n    int frames = pb-&gt;animation.anim_frames;\n    int delay = (pb-&gt;animation.anim_frame_delay_ms &gt; 0) ? pb-&gt;animation.anim_frame_delay_ms : 16;\n\n    uint16_t last_fill = compute_fill_width(pb, old_value);\n\n    for (int f = 1; f &lt;= frames; ++f) {\n        float t = (float) f / (float) frames;\n        float st = smoothstep(t);\n\n        int32_t cur_value = old_value + (int32_t) ((float) (new_value - old_value) * st);\n\n        uint16_t cur_fill = compute_fill_width(pb, cur_value);\n\n        /* incremental update only */\n        if (cur_fill &gt; last_fill) {\n            /* grow */\n            fill_rect(pb-&gt;device, ix + last_fill, iy, cur_fill - last_fill, ih);\n        }\n        else if (cur_fill &lt; last_fill) {\n            /* shrink */\n            clear_rect(pb-&gt;device, ix + cur_fill, iy, last_fill - cur_fill, ih);\n        }\n\n        if (pb-&gt;border)\n            draw_rect_border(pb-&gt;device, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n        pb-&gt;device-&gt;ops-&gt;update_area(pb-&gt;device,\n                                     pb-&gt;tl.x,\n                                     pb-&gt;tl.y,\n                                     pb-&gt;size.width,\n                                     pb-&gt;size.height);\n\n        last_fill = cur_fill;\n        pb-&gt;value = cur_value;\n\n        system_delay_ms(delay);\n    }\n\n    pb-&gt;value = new_value;\n}\n\n/*\n *          -&gt; border, uint8_t as boarders\n *          -&gt; padding, uint8_t as padding\n *          -&gt; animation, CFBD_BaseAnimation* passed\n */\nCFBD_Bool\nCFBD_ProgressBar_SetProperty(CFBD_ProgressBar* pb, const char* property, const void* value)\n{\n    if (strcmp(property, \"border\") == 0) {\n        uint8_t border = *(uint8_t*) (value);\n        pb-&gt;border = border;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"padding\") == 0) {\n        uint8_t padding = *(uint8_t*) (value);\n        pb-&gt;padding = padding;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"animation\") == 0) {\n        CFBD_BaseAnimation* animation = (CFBD_BaseAnimation*) (value);\n        pb-&gt;animation = *animation;\n        return CFBD_TRUE;\n    }\n    return CFBD_FALSE;\n}\n\nCFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n\n/* simple setters */\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max)\n{\n    if (!pb)\n        return;\n    memset(pb, 0, sizeof(*pb));\n    pb-&gt;tl = *tl;\n    pb-&gt;size = *sz;\n    pb-&gt;min = min;\n    pb-&gt;max = max;\n    pb-&gt;value = min;\n    pb-&gt;device = device;\n    pb-&gt;border = 1;\n    pb-&gt;padding = 1;\n    pb-&gt;ops = &amp;ops;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/progressbar_8h/","title":"lib/graphic/widget/progressbar/progressbar.h","text":""},{"location":"api/Files/progressbar_8h/#classes","title":"Classes","text":"Name struct CFBD_ProgressBarOps struct __CFBD_ProgressBar"},{"location":"api/Files/progressbar_8h/#types","title":"Types","text":"Name typedef struct __CFBD_ProgressBar CFBD_ProgressBar"},{"location":"api/Files/progressbar_8h/#functions","title":"Functions","text":"Name void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/progressbar_8h/#typedef-cfbd_progressbar","title":"typedef CFBD_ProgressBar","text":"<pre><code>typedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n</code></pre>"},{"location":"api/Files/progressbar_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8h/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/animation/animation.h\"\n\ntypedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n\ntypedef struct\n{\n    void (*immediate_draw)(CFBD_ProgressBar*);\n    void (*set_value)(CFBD_ProgressBar*, int32_t new_value);\n    CFBD_Bool (*set_property)(CFBD_ProgressBar*, const char* property, const void* args);\n} CFBD_ProgressBarOps;\n\ntypedef struct __CFBD_ProgressBar\n{\n    CFBD_ProgressBarOps* ops;\n    CFBDGraphic_Point tl; /* top-left */\n    CFBDGraphicSize size;\n    int32_t min;   /* min value */\n    int32_t max;   /* max value */\n    int32_t value; /* current value */\n    CFBD_GraphicDevice* device;\n\n    /* visual config */\n    uint8_t border;  /* 0 = no border, 1 = border */\n    uint8_t padding; /* inner padding px between border and fill */\n\n    /* animation config */\n    CFBD_BaseAnimation animation;\n} CFBD_ProgressBar;\n\n/* Initialize progressbar (no dynamic allocation). device must be valid. */\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/rectangle_8c/","title":"lib/graphic/base/rectangle.c","text":""},{"location":"api/Files/rectangle_8c/#types","title":"Types","text":"Name enum ____CSCode"},{"location":"api/Files/rectangle_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) void CFBDGraphic_FillRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) int cs_compute_code(const CFBDGraphicRect * r, int32_t x, int32_t y) CFBDGraphicRect rect_intersection(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_union(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_offset(const CFBDGraphicRect * r, int32_t dx, int32_t dy) CFBDGraphicRect rect_inset(const CFBDGraphicRect * r, int32_t left, int32_t top, int32_t right, int32_t bottom) CFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect * r, float sx, float sy) CFBDGraphicRect rect_align_in_parent(const CFBDGraphicRect * parent, const CFBDGraphicRect * child, uint8_t anchor) CFBDGraphic_Point rect_closest_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) uint32_t rect_distance_to_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_clip_line(CFBDGraphicRect * r, CFBDGraphic_Point * p0, CFBDGraphic_Point * p1) CFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect * r, uint16_t screen_w, uint16_t screen_h)"},{"location":"api/Files/rectangle_8c/#defines","title":"Defines","text":"Name MAX(a, b) MIN(a, b)"},{"location":"api/Files/rectangle_8c/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/rectangle_8c/#enum-____cscode","title":"enum ____CSCode","text":"Enumerator Value Description CS_LEFT 1 &lt;&lt; 0 CS_RIGHT 1 &lt;&lt; 1 CS_BOTTOM 1 &lt;&lt; 2 CS_TOP 1 &lt;&lt; 3"},{"location":"api/Files/rectangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/rectangle_8c/#function-cfbdgraphic_drawrect","title":"function CFBDGraphic_DrawRect","text":"<pre><code>void CFBDGraphic_DrawRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-cfbdgraphic_fillrect","title":"function CFBDGraphic_FillRect","text":"<pre><code>void CFBDGraphic_FillRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-cs_compute_code","title":"function cs_compute_code","text":"<pre><code>static int cs_compute_code(\n    const CFBDGraphicRect * r,\n    int32_t x,\n    int32_t y\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_intersection","title":"function rect_intersection","text":"<pre><code>CFBDGraphicRect rect_intersection(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_union","title":"function rect_union","text":"<pre><code>CFBDGraphicRect rect_union(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_offset","title":"function rect_offset","text":"<pre><code>CFBDGraphicRect rect_offset(\n    const CFBDGraphicRect * r,\n    int32_t dx,\n    int32_t dy\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_inset","title":"function rect_inset","text":"<pre><code>CFBDGraphicRect rect_inset(\n    const CFBDGraphicRect * r,\n    int32_t left,\n    int32_t top,\n    int32_t right,\n    int32_t bottom\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_scale_about_center","title":"function rect_scale_about_center","text":"<pre><code>CFBDGraphicRect rect_scale_about_center(\n    const CFBDGraphicRect * r,\n    float sx,\n    float sy\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_align_in_parent","title":"function rect_align_in_parent","text":"<pre><code>CFBDGraphicRect rect_align_in_parent(\n    const CFBDGraphicRect * parent,\n    const CFBDGraphicRect * child,\n    uint8_t anchor\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_closest_point","title":"function rect_closest_point","text":"<pre><code>CFBDGraphic_Point rect_closest_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_distance_to_point","title":"function rect_distance_to_point","text":"<pre><code>uint32_t rect_distance_to_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_expand_to_include_point","title":"function rect_expand_to_include_point","text":"<pre><code>CFBDGraphicRect rect_expand_to_include_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_clip_line","title":"function rect_clip_line","text":"<pre><code>CFBD_Bool rect_clip_line(\n    CFBDGraphicRect * r,\n    CFBDGraphic_Point * p0,\n    CFBDGraphic_Point * p1\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#function-rect_clamp_to_screen","title":"function rect_clamp_to_screen","text":"<pre><code>CFBDGraphicRect rect_clamp_to_screen(\n    const CFBDGraphicRect * r,\n    uint16_t screen_w,\n    uint16_t screen_h\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/rectangle_8c/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"rectangle.h\"\n\n#include &lt;math.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"device/graphic_device.h\"\n\ntypedef enum\n{\n    CS_LEFT = 1 &lt;&lt; 0,\n    CS_RIGHT = 1 &lt;&lt; 1,\n    CS_BOTTOM = 1 &lt;&lt; 2,\n    CS_TOP = 1 &lt;&lt; 3\n} ____CSCode;\n\nvoid CFBDGraphic_DrawRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    if (device == NULL || rect == NULL)\n        return;\n    if (device-&gt;ops == NULL)\n        return;\n\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    if (lx == rx &amp;&amp; ty == by) {\n        device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty));\n    }\n    else {\n        /* \u9876\u8fb9\u4e0e\u5e95\u8fb9\uff08\u6c34\u5e73\uff09: x = lx..rx */\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(ty));\n            if (by != ty) /* \u5982\u679c\u9ad8\u5ea6&gt;1 \u518d\u753b\u5e95\u8fb9\uff0c\u9632\u6b62\u91cd\u590d\u753b\u540c\u4e00\u884c */\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(by));\n        }\n        if (by - ty &gt;= 2) {\n            for (int32_t y = ty + 1; y &lt;= by - 1; ++y) {\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(y));\n                if (rx != lx)\n                    device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(rx), clamp_u16_from_i32(y));\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nvoid CFBDGraphic_FillRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    for (int32_t y = ty; y &lt;= by; ++y) {\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(y));\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nstatic int cs_compute_code(const CFBDGraphicRect* r, int32_t x, int32_t y)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t code = 0;\n\n    if (x &lt; asInt32_t(n.tl.x))\n        code |= CS_LEFT;\n    else if (x &gt; asInt32_t(n.br.x))\n        code |= CS_RIGHT;\n\n    if (y &lt; asInt32_t(n.tl.y))\n        code |= CS_TOP;\n    else if (y &gt; asInt32_t(n.br.y))\n        code |= CS_BOTTOM;\n\n    return code;\n}\n\nCFBDGraphicRect rect_intersection(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n#ifndef MAX\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n    int32_t lx = MAX(asInt32_t(A.tl.x), asInt32_t(B.tl.x));\n    int32_t ty = MAX(asInt32_t(A.tl.y), asInt32_t(B.tl.y));\n    int32_t rx = MIN(asInt32_t(A.br.x), asInt32_t(B.br.x));\n    int32_t by = MIN(asInt32_t(A.br.y), asInt32_t(B.br.y));\n#undef MAX\n#undef MIN\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_union(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n    int32_t lx = asInt32_t(A.tl.x) &lt; asInt32_t(B.tl.x) ? asInt32_t(A.tl.x) : asInt32_t(B.tl.x);\n    int32_t ty = asInt32_t(A.tl.y) &lt; asInt32_t(B.tl.y) ? asInt32_t(A.tl.y) : asInt32_t(B.tl.y);\n    int32_t rx = asInt32_t(A.br.x) &gt; asInt32_t(B.br.x) ? asInt32_t(A.br.x) : asInt32_t(B.br.x);\n    int32_t by = asInt32_t(A.br.y) &gt; asInt32_t(B.br.y) ? asInt32_t(A.br.y) : asInt32_t(B.br.y);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_offset(const CFBDGraphicRect* r, int32_t dx, int32_t dy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(asInt32_t(n.tl.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.tl.y) + dy)},\n                              {clamp_u16_from_i32(asInt32_t(n.br.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.br.y) + dy)}};\n}\n\nCFBDGraphicRect\nrect_inset(const CFBDGraphicRect* r, int32_t left, int32_t top, int32_t right, int32_t bottom)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t lx = asInt32_t(n.tl.x) + left;\n    int32_t ty = asInt32_t(n.tl.y) + top;\n    int32_t rx = asInt32_t(n.br.x) - right;\n    int32_t by = asInt32_t(n.br.y) - bottom;\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect* r, float sx, float sy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t cx = (asInt32_t(n.tl.x) + asInt32_t(n.br.x)) / 2;\n    int32_t cy = (asInt32_t(n.tl.y) + asInt32_t(n.br.y)) / 2;\n\n    int32_t hw = asInt32_t(n.br.x) - asInt32_t(n.tl.x);\n    int32_t hh = asInt32_t(n.br.y) - asInt32_t(n.tl.y);\n\n    int32_t new_hw = (int32_t) floorf(hw * sx / 2.0f + 0.5f);\n    int32_t new_hh = (int32_t) floorf(hh * sy / 2.0f + 0.5f);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(cx - new_hw), clamp_u16_from_i32(cy - new_hh)},\n                              {clamp_u16_from_i32(cx + new_hw), clamp_u16_from_i32(cy + new_hh)}};\n}\n\nCFBDGraphicRect\nrect_align_in_parent(const CFBDGraphicRect* parent, const CFBDGraphicRect* child, uint8_t anchor)\n{\n    CFBDGraphicRect P = rect_normalize(*parent);\n    CFBDGraphicRect C = rect_normalize(*child);\n    int32_t pw = asInt32_t(P.br.x) - asInt32_t(P.tl.x);\n    int32_t ph = asInt32_t(P.br.y) - asInt32_t(P.tl.y);\n    int32_t cw = asInt32_t(C.br.x) - asInt32_t(C.tl.x);\n    int32_t ch = asInt32_t(C.br.y) - asInt32_t(C.tl.y);\n    int32_t nx = asInt32_t(P.tl.x);\n    int32_t ny = asInt32_t(P.tl.y); /* \u6c34\u5e73 */\n    if (anchor &amp; RECT_ANCHOR_LEFT) {\n        nx = asInt32_t(P.tl.x);\n    }\n    else if (anchor &amp; RECT_ANCHOR_RIGHT) {\n        nx = asInt32_t(P.br.x) - cw;\n    }\n    else { /* center by default */\n        nx = asInt32_t(P.tl.x) + (pw - cw) / 2;\n    } /* \u5782\u76f4 */\n    if (anchor &amp; RECT_ANCHOR_TOP) {\n        ny = asInt32_t(P.tl.y);\n    }\n    else if (anchor &amp; RECT_ANCHOR_BOTTOM) {\n        ny = asInt32_t(P.br.y) - ch;\n    }\n    else {\n        ny = asInt32_t(P.tl.y) + (ph - ch) / 2;\n    }\n    return rect_from_xywh(nx, ny, cw, ch);\n}\n\n/* ---------- \u6700\u8fd1\u70b9 / \u70b9\u5230\u77e9\u5f62\u8ddd\u79bb ---------- */\n\n/* \u8fd4\u56de\u77e9\u5f62\u5185\u5230\u70b9\u6700\u8fd1\u7684\u70b9\uff08\u5982\u679c\u70b9\u5728\u77e9\u5f62\u5185\uff0c\u5219\u8fd4\u56de\u70b9\u672c\u8eab\uff0c\u7ed3\u679c\u4e3a uint16_t\uff09 */\nCFBDGraphic_Point rect_closest_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t px = asInt32_t(p.x), py = asInt32_t(p.y);\n    int32_t lx = asInt32_t(n.tl.x), ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x), by = asInt32_t(n.br.y);\n    int32_t cx = px &lt; lx ? lx : (px &gt; rx ? rx : px);\n    int32_t cy = py &lt; ty ? ty : (py &gt; by ? by : py);\n    CFBDGraphic_Point out = {clamp_u16_from_i32(cx), clamp_u16_from_i32(cy)};\n    return out;\n}\n\n/* \u70b9\u5230\u77e9\u5f62\u6700\u77ed\u8ddd\u79bb\uff08\u50cf\u7d20\u8ddd\u79bb\uff0c\u82e5\u5728\u77e9\u5f62\u5185\u5219\u4e3a0\uff09*/\nuint32_t rect_distance_to_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphic_Point cp = rect_closest_point(r, p);\n    int32_t dx = asInt32_t(cp.x) - asInt32_t(p.x);\n    int32_t dy = asInt32_t(cp.y) - asInt32_t(p.y);\n    return (uint32_t) (sqrt((double) (dx * dx + dy * dy)));\n}\n\n/* ---------- \u6269\u5c55 / \u5305\u542b\u70b9 ---------- */\nCFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; asInt32_t(p.x) ? asInt32_t(n.tl.x) : asInt32_t(p.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; asInt32_t(p.y) ? asInt32_t(n.tl.y) : asInt32_t(p.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; asInt32_t(p.x) ? asInt32_t(n.br.x) : asInt32_t(p.x);\n    int32_t by = asInt32_t(n.br.y) &gt; asInt32_t(p.y) ? asInt32_t(n.br.y) : asInt32_t(p.y);\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n\nCFBD_Bool rect_clip_line(CFBDGraphicRect* r, CFBDGraphic_Point* p0, CFBDGraphic_Point* p1)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t x0 = asInt32_t(p0-&gt;x), y0 = asInt32_t(p0-&gt;y);\n    int32_t x1 = asInt32_t(p1-&gt;x), y1 = asInt32_t(p1-&gt;y);\n    int code0 = cs_compute_code(&amp;n, x0, y0);\n    int code1 = cs_compute_code(&amp;n, x1, y1);\n    CFBD_Bool accept = CFBD_FALSE;\n    while (1) {\n        if ((code0 | code1) == 0) {\n            accept = CFBD_TRUE;\n            break;\n        }\n        else if (code0 &amp; code1) {\n            accept = CFBD_FALSE;\n            break;\n        }\n        else {\n            int outcode = code0 ? code0 : code1;\n            int32_t nx = 0, ny = 0;\n            if (outcode &amp; CS_TOP) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.tl.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.tl.y);\n            }\n            else if (outcode &amp; CS_BOTTOM) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.br.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.br.y);\n            }\n            else if (outcode &amp; CS_RIGHT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.br.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.br.x);\n            }\n            else if (outcode &amp; CS_LEFT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.tl.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.tl.x);\n            }\n            if (outcode == code0) {\n                x0 = nx;\n                y0 = ny;\n                code0 = cs_compute_code(&amp;n, x0, y0);\n            }\n            else {\n                x1 = nx;\n                y1 = ny;\n                code1 = cs_compute_code(&amp;n, x1, y1);\n            }\n        }\n    }\n    if (accept) {\n        p0-&gt;x = clamp_u16_from_i32(x0);\n        p0-&gt;y = clamp_u16_from_i32(y0);\n        p1-&gt;x = clamp_u16_from_i32(x1);\n        p1-&gt;y = clamp_u16_from_i32(y1);\n    }\n    return accept;\n}\n\n/* ---------- \u591a\u7528\u9014\uff1a\u88c1\u526a\u5230\u5c4f\u5e55\u8fb9\u754c ---------- */\nCFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect* r, uint16_t screen_w, uint16_t screen_h)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; 0 ? 0 : asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; 0 ? 0 : asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; screen_w ? screen_w : asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y) &gt; screen_h ? screen_h : asInt32_t(n.br.y);\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/rectangle_8h/","title":"lib/graphic/base/rectangle.h","text":""},{"location":"api/Files/rectangle_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicRect"},{"location":"api/Files/rectangle_8h/#types","title":"Types","text":"Name enum CCGraphicAnchor"},{"location":"api/Files/rectangle_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) void CFBDGraphic_FillRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) CFBDGraphicRect rect_normalize(CFBDGraphicRect r)Followings are common utils for the rects. uint32_t rect_width(const CFBDGraphicRect * r) uint32_t rect_height(const CFBDGraphicRect * r) CFBD_Bool rect_is_empty(const CFBDGraphicRect * r) CFBDGraphicRect rect_from_xywh(int32_t x, int32_t y, int32_t w, int32_t h) void rect_to_xywh(const CFBDGraphicRect * r, int32_t * out_x, int32_t * out_y, int32_t * out_w, int32_t * out_h) CFBD_Bool rect_contains_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_intersects(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_intersection(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_union(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_offset(const CFBDGraphicRect * r, int32_t dx, int32_t dy) CFBDGraphicRect rect_inset(const CFBDGraphicRect * r, int32_t left, int32_t top, int32_t right, int32_t bottom) CFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect * r, float sx, float sy) CFBDGraphicRect rect_align_in_parent(const CFBDGraphicRect * parent, const CFBDGraphicRect * child, uint8_t anchor) CFBDGraphic_Point rect_closest_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) uint32_t rect_distance_to_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_clip_line(CFBDGraphicRect * r, CFBDGraphic_Point * p0, CFBDGraphic_Point * p1) CFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect * r, uint16_t screen_w, uint16_t screen_h) uint32_t rect_area(const CFBDGraphicRect * r) CFBDGraphicSize rect_size(const CFBDGraphicRect * r) uint32_t rect_overlap_area(const CFBDGraphicRect * a, const CFBDGraphicRect * b)"},{"location":"api/Files/rectangle_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/rectangle_8h/#enum-ccgraphicanchor","title":"enum CCGraphicAnchor","text":"Enumerator Value Description RECT_ANCHOR_LEFT 1 &lt;&lt; 0 RECT_ANCHOR_HCENTER 1 &lt;&lt; 1 RECT_ANCHOR_RIGHT 1 &lt;&lt; 2 RECT_ANCHOR_TOP 1 &lt;&lt; 3 RECT_ANCHOR_VCENTER 1 &lt;&lt; 4 RECT_ANCHOR_BOTTOM 1 &lt;&lt; 5"},{"location":"api/Files/rectangle_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/rectangle_8h/#function-cfbdgraphic_drawrect","title":"function CFBDGraphic_DrawRect","text":"<pre><code>void CFBDGraphic_DrawRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-cfbdgraphic_fillrect","title":"function CFBDGraphic_FillRect","text":"<pre><code>void CFBDGraphic_FillRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_normalize","title":"function rect_normalize","text":"<pre><code>static inline CFBDGraphicRect rect_normalize(\n    CFBDGraphicRect r\n)\n</code></pre> <p>Followings are common utils for the rects. </p>"},{"location":"api/Files/rectangle_8h/#function-rect_width","title":"function rect_width","text":"<pre><code>static inline uint32_t rect_width(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_height","title":"function rect_height","text":"<pre><code>static inline uint32_t rect_height(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_is_empty","title":"function rect_is_empty","text":"<pre><code>static inline CFBD_Bool rect_is_empty(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_from_xywh","title":"function rect_from_xywh","text":"<pre><code>static inline CFBDGraphicRect rect_from_xywh(\n    int32_t x,\n    int32_t y,\n    int32_t w,\n    int32_t h\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_to_xywh","title":"function rect_to_xywh","text":"<pre><code>static inline void rect_to_xywh(\n    const CFBDGraphicRect * r,\n    int32_t * out_x,\n    int32_t * out_y,\n    int32_t * out_w,\n    int32_t * out_h\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_contains_point","title":"function rect_contains_point","text":"<pre><code>static inline CFBD_Bool rect_contains_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_intersects","title":"function rect_intersects","text":"<pre><code>static inline CFBD_Bool rect_intersects(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_intersection","title":"function rect_intersection","text":"<pre><code>CFBDGraphicRect rect_intersection(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_union","title":"function rect_union","text":"<pre><code>CFBDGraphicRect rect_union(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_offset","title":"function rect_offset","text":"<pre><code>CFBDGraphicRect rect_offset(\n    const CFBDGraphicRect * r,\n    int32_t dx,\n    int32_t dy\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_inset","title":"function rect_inset","text":"<pre><code>CFBDGraphicRect rect_inset(\n    const CFBDGraphicRect * r,\n    int32_t left,\n    int32_t top,\n    int32_t right,\n    int32_t bottom\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_scale_about_center","title":"function rect_scale_about_center","text":"<pre><code>CFBDGraphicRect rect_scale_about_center(\n    const CFBDGraphicRect * r,\n    float sx,\n    float sy\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_align_in_parent","title":"function rect_align_in_parent","text":"<pre><code>CFBDGraphicRect rect_align_in_parent(\n    const CFBDGraphicRect * parent,\n    const CFBDGraphicRect * child,\n    uint8_t anchor\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_closest_point","title":"function rect_closest_point","text":"<pre><code>CFBDGraphic_Point rect_closest_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_distance_to_point","title":"function rect_distance_to_point","text":"<pre><code>uint32_t rect_distance_to_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_expand_to_include_point","title":"function rect_expand_to_include_point","text":"<pre><code>CFBDGraphicRect rect_expand_to_include_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_clip_line","title":"function rect_clip_line","text":"<pre><code>CFBD_Bool rect_clip_line(\n    CFBDGraphicRect * r,\n    CFBDGraphic_Point * p0,\n    CFBDGraphic_Point * p1\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_clamp_to_screen","title":"function rect_clamp_to_screen","text":"<pre><code>CFBDGraphicRect rect_clamp_to_screen(\n    const CFBDGraphicRect * r,\n    uint16_t screen_w,\n    uint16_t screen_h\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_area","title":"function rect_area","text":"<pre><code>static inline uint32_t rect_area(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_size","title":"function rect_size","text":"<pre><code>static inline CFBDGraphicSize rect_size(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#function-rect_overlap_area","title":"function rect_overlap_area","text":"<pre><code>static inline uint32_t rect_overlap_area(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Files/rectangle_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;limits.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"point.h\"\n#include \"size.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct\n{\n    CFBDGraphic_Point tl;\n    CFBDGraphic_Point br;\n} CFBDGraphicRect;\n\nvoid CFBDGraphic_DrawRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect);\nvoid CFBDGraphic_FillRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect);\n\nstatic inline CFBDGraphicRect rect_normalize(CFBDGraphicRect r)\n{\n    PointBaseType x1 = r.tl.x, y1 = r.tl.y;\n    PointBaseType x2 = r.br.x, y2 = r.br.y;\n    int32_t lx = x1 &lt; x2 ? x1 : x2;\n    int32_t rx = x1 &lt; x2 ? x2 : x1;\n    int32_t ty = y1 &lt; y2 ? y1 : y2;\n    int32_t by = y1 &lt; y2 ? y2 : y1;\n    CFBDGraphicRect out = {{lx, ty}, {rx, by}};\n    return out;\n}\n\nstatic inline uint32_t rect_width(const CFBDGraphicRect* r)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    return (uint32_t) asInt32_t(n.br.x) - (uint32_t) asInt32_t(n.tl.x);\n}\nstatic inline uint32_t rect_height(const CFBDGraphicRect* r)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    return (uint32_t) asInt32_t(n.br.y) - (uint32_t) asInt32_t(n.tl.y);\n}\n\nstatic inline CFBD_Bool rect_is_empty(const CFBDGraphicRect* r)\n{\n    return rect_width(r) == 0 || rect_height(r) == 0;\n}\n\n/* ---------- \u8f6c\u6362\uff1axywh &lt;-&gt; rect ---------- */\nstatic inline CFBDGraphicRect rect_from_xywh(int32_t x, int32_t y, int32_t w, int32_t h)\n{\n    CFBDGraphicRect r;\n    r.tl.x = clamp_u16_from_i32(x);\n    r.tl.y = clamp_u16_from_i32(y);\n    r.br.x = clamp_u16_from_i32(x + w);\n    r.br.y = clamp_u16_from_i32(y + h);\n    return rect_normalize(r);\n}\n\nstatic inline void rect_to_xywh(const CFBDGraphicRect* r,\n                                int32_t* out_x,\n                                int32_t* out_y,\n                                int32_t* out_w,\n                                int32_t* out_h)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    *out_x = asInt32_t(n.tl.x);\n    *out_y = asInt32_t(n.tl.y);\n    *out_w = asInt32_t(n.br.x) - asInt32_t(n.tl.x);\n    *out_h = asInt32_t(n.br.y) - asInt32_t(n.tl.y);\n}\n\n/* ---------- \u70b9 / \u77e9\u5f62\u5305\u542b / \u76f8\u4ea4 ---------- */\nstatic inline CFBD_Bool rect_contains_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    return (p.x &gt;= n.tl.x &amp;&amp; p.x &lt;= n.br.x &amp;&amp; p.y &gt;= n.tl.y &amp;&amp; p.y &lt;= n.br.y);\n}\n\n/* \u5224\u65ad\u4e24\u77e9\u5f62\u662f\u5426\u76f8\u4ea4\uff08\u8fb9\u7f18\u7b97\u76f8\u4ea4\uff09*/\nstatic inline CFBD_Bool rect_intersects(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n    if (asInt32_t(A.br.x) &lt; asInt32_t(B.tl.x) || asInt32_t(B.br.x) &lt; asInt32_t(A.tl.x))\n        return CFBD_FALSE;\n    if (asInt32_t(A.br.y) &lt; asInt32_t(B.tl.y) || asInt32_t(B.br.y) &lt; asInt32_t(A.tl.y))\n        return CFBD_FALSE;\n    return CFBD_TRUE;\n}\n\n/* Anchor flags\uff08\u6c34\u5e73 | \u5782\u76f4\uff09 */\ntypedef enum\n{\n    RECT_ANCHOR_LEFT = 1 &lt;&lt; 0,\n    RECT_ANCHOR_HCENTER = 1 &lt;&lt; 1,\n    RECT_ANCHOR_RIGHT = 1 &lt;&lt; 2,\n\n    RECT_ANCHOR_TOP = 1 &lt;&lt; 3,\n    RECT_ANCHOR_VCENTER = 1 &lt;&lt; 4,\n    RECT_ANCHOR_BOTTOM = 1 &lt;&lt; 5\n} CCGraphicAnchor;\n\n/* \u4ea4\u96c6 / \u5e76\u96c6 */\nCFBDGraphicRect rect_intersection(const CFBDGraphicRect* a, const CFBDGraphicRect* b);\n\nCFBDGraphicRect rect_union(const CFBDGraphicRect* a, const CFBDGraphicRect* b);\n\n/* \u5e73\u79fb / inset / \u7f29\u653e */\nCFBDGraphicRect rect_offset(const CFBDGraphicRect* r, int32_t dx, int32_t dy);\n\nCFBDGraphicRect\nrect_inset(const CFBDGraphicRect* r, int32_t left, int32_t top, int32_t right, int32_t bottom);\n\nCFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect* r, float sx, float sy);\n\nCFBDGraphicRect\nrect_align_in_parent(const CFBDGraphicRect* parent, const CFBDGraphicRect* child, uint8_t anchor);\n\n/* \u70b9\u76f8\u5173 */\nCFBDGraphic_Point rect_closest_point(const CFBDGraphicRect* r, CFBDGraphic_Point p);\n\nuint32_t rect_distance_to_point(const CFBDGraphicRect* r, CFBDGraphic_Point p);\n\nCFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect* r, CFBDGraphic_Point p);\n\n/* \u88c1\u526a */\nCFBD_Bool rect_clip_line(CFBDGraphicRect* r, CFBDGraphic_Point* p0, CFBDGraphic_Point* p1);\n\nCFBDGraphicRect\nrect_clamp_to_screen(const CFBDGraphicRect* r, uint16_t screen_w, uint16_t screen_h);\n\nstatic inline uint32_t rect_area(const CFBDGraphicRect* r)\n{\n    if (rect_is_empty(r))\n        return 0;\n    return rect_width(r) * rect_height(r);\n}\n\nstatic inline CFBDGraphicSize rect_size(const CFBDGraphicRect* r)\n{\n    CFBDGraphicSize sz = {0, 0};\n    if (rect_is_empty(r))\n        return sz;\n    sz.height = rect_height(r);\n    sz.width = rect_width(r);\n    return sz;\n}\n\nstatic inline uint32_t rect_overlap_area(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect inter = rect_intersection(a, b);\n    return rect_area(&amp;inter);\n}\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/size_8c/","title":"lib/graphic/base/size.c","text":""},{"location":"api/Files/size_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice * device, CFBDGraphicSize * pSize)"},{"location":"api/Files/size_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/size_8c/#function-cfbdgraphic_getscreensize","title":"function CFBDGraphic_GetScreenSize","text":"<pre><code>void CFBDGraphic_GetScreenSize(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicSize * pSize\n)\n</code></pre>"},{"location":"api/Files/size_8c/#source-code","title":"Source code","text":"<pre><code>#include \"size.h\"\n#include \"cfbd_graphic_define.h\"\n#include &lt;stddef.h&gt;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize){\n    PointBaseType width, height;\n    device-&gt;ops-&gt;self_consult(device, \"width\", NULL, &amp;width);\n    device-&gt;ops-&gt;self_consult(device, \"height\", NULL, &amp;height);\n    pSize-&gt;height = height;\n    pSize-&gt;width = width;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/size_8h/","title":"lib/graphic/base/size.h","text":""},{"location":"api/Files/size_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicSize"},{"location":"api/Files/size_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice * device, CFBDGraphicSize * pSize)"},{"location":"api/Files/size_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/size_8h/#function-cfbdgraphic_getscreensize","title":"function CFBDGraphic_GetScreenSize","text":"<pre><code>void CFBDGraphic_GetScreenSize(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicSize * pSize\n)\n</code></pre>"},{"location":"api/Files/size_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\ntypedef struct\n{\n    SizeBaseType width;\n    SizeBaseType height;\n} CFBDGraphicSize;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ssd1306_8c/","title":"lib/oled/driver/device/ssd1306/ssd1306.c","text":""},{"location":"api/Files/ssd1306_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1306_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1306_inits_commands CFBD_OLED_DeviceSpecific ssd1306_specific"},{"location":"api/Files/ssd1306_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8c/#function-ssd1306_init_sessions","title":"function ssd1306_init_sessions","text":"<pre><code>static uint8_t * ssd1306_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_inits_commands","title":"variable ssd1306_inits_commands","text":"<pre><code>static uint8_t[] ssd1306_inits_commands = {\n\n};\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_specific","title":"variable ssd1306_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1306_specific;\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1306.h\"\n#include &lt;stdint.h&gt;\n\nstatic uint8_t ssd1306_inits_commands[] = {\n\n};\n\n\nstatic uint8_t* ssd1306_init_sessions(void){\n    return ssd1306_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1306_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific(){\n    ssd1306_specific.init_session_tables = ssd1306_init_sessions;\n    return &amp;ssd1306_specific;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ssd1306_8h/","title":"lib/oled/driver/device/ssd1306/ssd1306.h","text":"<p>import the func to init ssd1306 specifics  More...</p>"},{"location":"api/Files/ssd1306_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8h/#detailed-description","title":"Detailed Description","text":"<p>import the func to init ssd1306 specifics </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-02</p> <p>Copyright: Copyright \u00a9 2026 </p> <p>import the func to init ssd1309 specifics</p>"},{"location":"api/Files/ssd1306_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8h/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"driver/device/device_interface.h\"\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific();\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ssd1309_8c/","title":"lib/oled/driver/device/ssd1309/ssd1309.c","text":""},{"location":"api/Files/ssd1309_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1309_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1309_inits_commands CFBD_OLED_DeviceSpecific ssd1309_specific"},{"location":"api/Files/ssd1309_8c/#defines","title":"Defines","text":"Name CMD_TABLE_SZ"},{"location":"api/Files/ssd1309_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8c/#function-ssd1309_init_sessions","title":"function ssd1309_init_sessions","text":"<pre><code>static uint8_t * ssd1309_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_inits_commands","title":"variable ssd1309_inits_commands","text":"<pre><code>static uint8_t[] ssd1309_inits_commands = {\n        0xAE,       \n        0xFD, 0x12, \n        0xD5,       \n        0xA0,       \n        0xA8,       \n        0x3F,       \n        0xD3,       \n        0x00,       \n        0x40,       \n        0xA1,       \n        0xC8,       \n        0xDA,       \n        0x12,       \n        0x81,       \n        0xBF,       \n        0xD9,       \n        0x25,       \n        0xDB,       \n        0x34,       \n        0xA4,       \n        0xA6,       \n        0xAF        \n};\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_specific","title":"variable ssd1309_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1309_specific;\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1309_8c/#define-cmd_table_sz","title":"define CMD_TABLE_SZ","text":"<pre><code>#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1309.h\"\n\n#include &lt;stdint.h&gt;\n\n\nstatic uint8_t ssd1309_inits_commands[] = {\n        0xAE,       // Turn off OLED panel\n        0xFD, 0x12, // Set display clock divide ratio/oscillator frequency\n        0xD5,       // Set display clock divide ratio\n        0xA0,       // Set multiplex ratio\n        0xA8,       // Set multiplex ratio (1 to 64)\n        0x3F,       // 1/64 duty\n        0xD3,       // Set display offset\n        0x00,       // No offset\n        0x40,       // Set start line address\n        0xA1,       // Set SEG/Column mapping (0xA0 for reverse, 0xA1 for normal)\n        0xC8,       // Set COM/Row scan direction (0xC0 for reverse, 0xC8 for normal)\n        0xDA,       // Set COM pins hardware configuration\n        0x12,       // COM pins configuration\n        0x81,       // Set contrast control register\n        0xBF,       // Set SEG output current brightness\n        0xD9,       // Set pre-charge period\n        0x25,       // Set pre-charge as 15 clocks &amp; discharge as 1 clock\n        0xDB,       // Set VCOMH\n        0x34,       // Set VCOM deselect level\n        0xA4,       // Disable entire display on\n        0xA6,       // Disable inverse display on\n        0xAF        // Turn on the display\n};\n\n#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n\nstatic uint8_t* ssd1309_init_sessions(void)\n{\n    return ssd1309_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1309_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific()\n{\n    ssd1309_specific.init_session_tables = ssd1309_init_sessions;\n    ssd1309_specific.init_session_tables_sz = CMD_TABLE_SZ;\n    ssd1309_specific.cmd_prefix = 0x00;\n    ssd1309_specific.data_prefix = 0x40;\n    ssd1309_specific.logic_height = 64;\n    ssd1309_specific.logic_width = 128;\n\n    return &amp;ssd1309_specific;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/ssd1309_8h/","title":"lib/oled/driver/device/ssd1309/ssd1309.h","text":""},{"location":"api/Files/ssd1309_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8h/#defines","title":"Defines","text":"Name SSD1309_DRIVER_ADDRESS"},{"location":"api/Files/ssd1309_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8h/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1309_8h/#define-ssd1309_driver_address","title":"define SSD1309_DRIVER_ADDRESS","text":"<pre><code>#define SSD1309_DRIVER_ADDRESS (0x78)\n</code></pre>"},{"location":"api/Files/ssd1309_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#pragma once\n#include \"driver/device/device_interface.h\"\n\n#define SSD1309_DRIVER_ADDRESS (0x78)\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific();\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/system__clock_8c/","title":"lib/application/sys_clock/system_clock.c","text":"<p>More...</p>"},{"location":"api/Files/system__clock_8c/#functions","title":"Functions","text":"Name void system_delay_us(uint32_t us)delay the global system for given museconds void system_delay_ms(uint32_t delay_ms)delay the global system for given miliseconds"},{"location":"api/Files/system__clock_8c/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30</p> <p>Copyright: Copyright \u00a9 2025 </p>"},{"location":"api/Files/system__clock_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/system__clock_8c/#function-system_delay_us","title":"function system_delay_us","text":"<pre><code>void system_delay_us(\n    uint32_t us\n)\n</code></pre> <p>delay the global system for given museconds </p> <p>Parameters: </p> <ul> <li>us </li> </ul>"},{"location":"api/Files/system__clock_8c/#function-system_delay_ms","title":"function system_delay_ms","text":"<pre><code>void system_delay_ms(\n    uint32_t delay_ms\n)\n</code></pre> <p>delay the global system for given miliseconds </p> <p>Parameters: </p> <ul> <li>delay_ms </li> </ul> <p>Note: we must use for loop for delay, as the large decrement makes the slow deviation for the delay </p>"},{"location":"api/Files/system__clock_8c/#source-code","title":"Source code","text":"<pre><code>#include \"system_clock.h\"\n#include \"config/system_settings.h\"\n#include \"app.h\"\n#include \"cfbd_define.h\"\n\n\nvoid system_delay_us(uint32_t us)\n{\n    CFBDApplication* app = getApp(CFBD_FALSE);\n\n    uint64_t ticks;                                     // Total number of ticks required for the delay\n    uint32_t prevValue, currentValue, elapsedTicks = 0; // Variables for SysTick counter values and elapsed ticks\n    uint32_t reloadValue = SysTick-&gt;LOAD;               // Value of the SysTick reload register\n    uint32_t sysclk_freq = app-&gt;tick_provider() / 1000000L;\n    ticks = us * sysclk_freq; // Calculate the number of ticks needed for the desired delay in microseconds\n\n    prevValue = SysTick-&gt;VAL; // Store the initial SysTick counter value\n\n    while (1)\n    {\n        currentValue = SysTick-&gt;VAL; // Get the current SysTick counter value\n        if (currentValue != prevValue)\n        {\n            if (currentValue &lt; prevValue)\n            {\n                elapsedTicks += prevValue - currentValue; // Count the elapsed ticks (SysTick is a decrementing counter)\n            }\n            else\n            {\n                elapsedTicks += reloadValue - currentValue + prevValue; // Handle the rollover case\n            }\n            prevValue = currentValue; // Update the previous value to the current value\n\n            if (elapsedTicks &gt;= ticks) // If the elapsed time is greater than or equal to the requested delay\n            {\n                break; // Exit the loop to complete the delay\n            }\n        }\n    }\n}\n\nvoid system_delay_ms(uint32_t delay_ms)\n{\n    for (uint32_t i = 0; i &lt; delay_ms; i++)\n    {\n        system_delay_us(1000);\n    }\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/system__clock_8h/","title":"lib/application/sys_clock/system_clock.h","text":"<p>More...</p>"},{"location":"api/Files/system__clock_8h/#functions","title":"Functions","text":"Name void system_delay_ms(uint32_t delay_ms)delay the global system for given miliseconds void system_delay_us(uint32_t us)delay the global system for given museconds"},{"location":"api/Files/system__clock_8h/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30</p> <p>Copyright: Copyright \u00a9 2025 </p>"},{"location":"api/Files/system__clock_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/system__clock_8h/#function-system_delay_ms","title":"function system_delay_ms","text":"<pre><code>void system_delay_ms(\n    uint32_t delay_ms\n)\n</code></pre> <p>delay the global system for given miliseconds </p> <p>Parameters: </p> <ul> <li>delay_ms </li> <li>delay_ms </li> </ul> <p>Note: we must use for loop for delay, as the large decrement makes the slow deviation for the delay </p>"},{"location":"api/Files/system__clock_8h/#function-system_delay_us","title":"function system_delay_us","text":"<pre><code>void system_delay_us(\n    uint32_t us\n)\n</code></pre> <p>delay the global system for given museconds </p> <p>Parameters: </p> <ul> <li>us </li> </ul>"},{"location":"api/Files/system__clock_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef SYSCLK_H\n#define SYSCLK_H\n#include &lt;stdint.h&gt;\n\nvoid system_delay_ms(uint32_t delay_ms);\n\nvoid system_delay_us(uint32_t us);\n\n#endif\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/test__base__graphic_8c/","title":"lib/graphic/fast_test/test_base_graphic.c","text":""},{"location":"api/Files/test__base__graphic_8c/#functions","title":"Functions","text":"Name void test_draw_line(CFBD_GraphicDevice * handler) void test_draw_rectangle(CFBD_GraphicDevice * handler) void test_draw_circle(CFBD_GraphicDevice * handler) void test_draw_ellipse(CFBD_GraphicDevice * handler) void test_draw_triangle(CFBD_GraphicDevice * handler) void test_draw_arc(CFBD_GraphicDevice * handler) void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_line","title":"function test_draw_line","text":"<pre><code>static void test_draw_line(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_rectangle","title":"function test_draw_rectangle","text":"<pre><code>static void test_draw_rectangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_circle","title":"function test_draw_circle","text":"<pre><code>static void test_draw_circle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_ellipse","title":"function test_draw_ellipse","text":"<pre><code>static void test_draw_ellipse(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_triangle","title":"function test_draw_triangle","text":"<pre><code>static void test_draw_triangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_arc","title":"function test_draw_arc","text":"<pre><code>static void test_draw_arc(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"base/arc.h\"\n#include \"base/circle.h\"\n#include \"base/ellipse.h\"\n#include \"base/line.h\"\n#include \"base/rectangle.h\"\n#include \"base/triangle.h\"\n\n// \u6d4b\u8bd5\u76f4\u7ebf\u7ed8\u5236\nstatic void test_draw_line(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u6c34\u5e73\u7ebf\n    CFBDGraphic_Line line1 = {.p_left = {10, 10}, .p_right = {50, 10}};\n    CFBDGraphic_DrawLine(handler, &amp;line1);\n\n    // \u6d4b\u8bd52: \u5782\u76f4\u7ebf\n    CFBDGraphic_Line line2 = {.p_left = {60, 5}, .p_right = {60, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line2);\n\n    // \u6d4b\u8bd53: \u659c\u7ebf\n    CFBDGraphic_Line line3 = {.p_left = {70, 5}, .p_right = {90, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line3);\n}\n\n// \u6d4b\u8bd5\u77e9\u5f62\u7ed8\u5236\nstatic void test_draw_rectangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect1 = {.tl = {5, 30}, .br = {35, 50}};\n    CFBDGraphic_DrawRect(handler, &amp;rect1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect2 = {.tl = {40, 32}, .br = {60, 48}};\n    CFBDGraphic_FillRect(handler, &amp;rect2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f62\u7ed8\u5236\nstatic void test_draw_circle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\n    CFBDGraphicCircle circle1 = {.center = {80, 15}, .radius = 10};\n    CFBDGraphic_DrawCircle(handler, &amp;circle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u5706\n    CFBDGraphicCircle circle2 = {.center = {105, 15}, .radius = 8};\n    CFBDGraphic_DrawFilledCircle(handler, &amp;circle2);\n}\n\n// \u6d4b\u8bd5\u692d\u5706\u7ed8\u5236\nstatic void test_draw_ellipse(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u692d\u5706\n    CCGraphic_Ellipse ellipse1 = {.center = {85, 40}, .X_Radius = 15, .Y_Radius = 10};\n    CFBDGraphic_DrawEllipse(handler, &amp;ellipse1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u692d\u5706\n    CCGraphic_Ellipse ellipse2 = {.center = {110, 55}, .X_Radius = 10, .Y_Radius = 6};\n    CFBDGraphic_DrawFilledEllipse(handler, &amp;ellipse2);\n}\n\n// \u6d4b\u8bd5\u4e09\u89d2\u5f62\u7ed8\u5236\nstatic void test_draw_triangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle1 = {.p1 = {15, 55}, .p2 = {5, 62}, .p3 = {25, 62}};\n    CCGraphic_DrawTriangle(handler, &amp;triangle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle2 = {.p1 = {45, 55}, .p2 = {35, 62}, .p3 = {55, 62}};\n    CCGraphic_DrawFilledTriangle(handler, &amp;triangle2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f27\u7ed8\u5236\nstatic void test_draw_arc(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\u5f27 (0-90\u5ea6)\n    CCGraphic_Arc arc1 = {.center = {20, 15}, .radius = 12, .start_degree = 0, .end_degree = 90};\n    CFBDGraphic_DrawArc(handler, &amp;arc1);\n\n    // \u6d4b\u8bd52: \u7a7a\u5fc3\u5706\u5f27 (180-270\u5ea6)\n    CCGraphic_Arc arc2 = {.center = {45, 15}, .radius = 12, .start_degree = 180, .end_degree = 270};\n    CFBDGraphic_DrawArc(handler, &amp;arc2);\n\n    // \u6d4b\u8bd53: \u5b9e\u5fc3\u5706\u5f27 (45-135\u5ea6)\n    CCGraphic_Arc arc3 = {.center = {70, 55}, .radius = 8, .start_degree = 45, .end_degree = 135};\n    CFBDGraphic_DrawFilledArc(handler, &amp;arc3);\n}\n\n// \u4e3b\u6d4b\u8bd5\u51fd\u6570 - \u6309\u987a\u5e8f\u6d4b\u8bd5\u6240\u6709\u56fe\u5f62\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler)\n{\n    // 1. \u6d4b\u8bd5\u76f4\u7ebf\n    test_draw_line(handler);\n\n    // 2. \u6d4b\u8bd5\u77e9\u5f62\n    test_draw_rectangle(handler);\n\n    // 3. \u6d4b\u8bd5\u5706\u5f62\n    test_draw_circle(handler);\n\n    // 4. \u6d4b\u8bd5\u692d\u5706\n    test_draw_ellipse(handler);\n\n    // 5. \u6d4b\u8bd5\u4e09\u89d2\u5f62\n    test_draw_triangle(handler);\n\n    // 6. \u6d4b\u8bd5\u5706\u5f27\n    test_draw_arc(handler);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/test__base__graphic_8h/","title":"lib/graphic/fast_test/test_base_graphic.h","text":""},{"location":"api/Files/test__base__graphic_8h/#functions","title":"Functions","text":"Name void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8h/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/test__widget_8c/","title":"lib/graphic/fast_test/test_widget.c","text":""},{"location":"api/Files/test__widget_8c/#functions","title":"Functions","text":"Name void test_text(CFBD_GraphicDevice * handler) void menu_example(CFBD_GraphicDevice * dev) void progressbar_usage(CFBD_GraphicDevice * dev) void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8c/#function-test_text","title":"function test_text","text":"<pre><code>static void test_text(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-menu_example","title":"function menu_example","text":"<pre><code>void menu_example(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-progressbar_usage","title":"function progressbar_usage","text":"<pre><code>void progressbar_usage(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#source-code","title":"Source code","text":"<pre><code>#include \"test_widget.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"app.h\"\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"config/system_settings.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/menu/menu.h\"\n#include \"widget/progressbar/progressbar.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\nstatic void test_text(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphic_DeviceClearImmediate(handler);\n    /* print sources */\n    char* source = \"Hello, World!This is Charlie's Speeking!\";\n    CFBDGraphic_Text item;\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;item, p, screen_size, ASCII_6x8);\n\n    CFBDGraphic_SetText(&amp;item, source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    /* after delay, print new_sources */\n    char* new_source = \"May I Help You?\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    // resets everythings\n    CFBDGraphic_DeviceClearImmediate(handler);\n    CFBDGraphic_SetTextIndexedPoint(&amp;item, &amp;p);\n\n    new_source = \"Yes!Please Offer me a lemon juice\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n}\n\nvoid menu_example(CFBD_GraphicDevice* dev)\n{\n    CFBD_MenuItem items_buf[5];\n    CFBD_Menu mymenu;\n    CFBD_MenuItemGroup groups;\n    groups.pItems = items_buf;\n    groups.capacity = 5;\n    groups.count = 0;\n\n    CFBD_InitMenu(&amp;mymenu, dev, &amp;groups, 120);\n\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 1\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 2das\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 3fasd\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 4fffff\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item numbr\", ASCII_6x8, NULL);\n\n    mymenu.operations-&gt;immediate_draw(&amp;mymenu);\n\n    system_delay_ms(500);\n\n    /* auto demo loop */\n    while (1) {\n        for (int i = 1; i &lt; (int) mymenu.menu_items-&gt;count - 1; ++i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        for (int i = (int) mymenu.menu_items-&gt;count - 3; i &gt;= 0; --i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        CFBDGraphic_Point p = {.x = 30, .y = 10};\n        mymenu.operations-&gt;reset_tl_points(&amp;mymenu, &amp;p, CFBD_TRUE);\n\n        for (int i = 1; i &lt; (int) mymenu.menu_items-&gt;count - 1; ++i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        for (int i = (int) mymenu.menu_items-&gt;count - 3; i &gt;= 0; --i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        p.x = 0;\n        p.y = 0;\n        mymenu.operations-&gt;reset_tl_points(&amp;mymenu, &amp;p, CFBD_TRUE);\n    }\n}\n\n/*\n * Demo: ProgressBar usage\n * OLED: 128x64\n * Effect:\n *  - Title text\n *  - Main progress bar (0 -&gt; 100, smooth + flow light)\n *  - Sub progress bar (busy animation in stages)\n */\n\nvoid progressbar_usage(CFBD_GraphicDevice* dev)\n{\n    /* =======================\n     * Title\n     * ======================= */\n    CFBDGraphic_Text title;\n    CFBDGraphic_Point tp = {.x = 12, .y = 2};\n    CFBDGraphicSize ts = {.width = 104, .height = 10};\n    CFBDGraphic_InitText(&amp;title, tp, ts, ASCII_6x8);\n    CFBDGraphic_SetText(&amp;title, \"System Booting...\");\n\n    /* =======================\n     * Main ProgressBar\n     * ======================= */\n    CFBD_ProgressBar main_pb;\n    CFBDGraphic_Point p = {6, 18};\n    CFBDGraphicSize sz = {116, 12};\n    CFBD_ProgressBar_Init(&amp;main_pb, dev, &amp;p, &amp;sz, 0, 100);\n    uint8_t boarder_and_padding = 1;\n    CFBD_BaseAnimation animation = {.anim_frame_delay_ms = 25, .anim_frames = 10};\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"border\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"padding\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"animation\", &amp;animation);\n\n    /* =======================\n     * Stage ProgressBar\n     * ======================= */\n    CFBD_ProgressBar stage_pb;\n    CFBDGraphic_Point p2 = {20, 38};\n    CFBDGraphicSize sz2 = {88, 8};\n    CFBD_ProgressBar_Init(&amp;stage_pb, dev, &amp;p2, &amp;sz2, 0, 100);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"border\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"padding\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"animation\", &amp;animation);\n    /* =======================\n     * First frame draw\n     * ======================= */\n    dev-&gt;ops-&gt;clear(dev);\n\n    CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_RequestOldPoint);\n\n    main_pb.ops-&gt;immediate_draw(&amp;main_pb);\n    main_pb.ops-&gt;immediate_draw(&amp;stage_pb);\n\n    dev-&gt;ops-&gt;update(dev);\n\n    /* =======================\n     * Demo animation\n     * ======================= */\n    const int stages[] = {0, 20, 45, 70, 100};\n\n    while (1) {\n        for (int s = 0; s &lt; 5; ++s) {\n            /* main progress moves forward */\n            main_pb.ops-&gt;set_value(&amp;main_pb, stages[s]);\n            system_delay_ms(500);\n\n            /* stage progress busy animation */\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 25);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 50);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 75);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 100);\n            system_delay_ms(500);\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 0);\n        }\n    }\n}\n\nvoid test_widget(CFBD_GraphicDevice* handler)\n{\n    progressbar_usage(handler);\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/test__widget_8h/","title":"lib/graphic/fast_test/test_widget.h","text":""},{"location":"api/Files/test__widget_8h/#functions","title":"Functions","text":"Name void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8h/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cfbd_graphic_define.h\"\n\nvoid test_widget(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/text_8c/","title":"lib/graphic/widget/text.c","text":""},{"location":"api/Files/text_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_InitText(CFBDGraphic_Text * item, CFBDGraphic_Point tl_point, CFBDGraphicSize textHandleSize, Ascii_Font_Size text_size) void __pvt_draw_char_each(CFBD_GraphicDevice * device_handle, CCGraphic_Image * borrowing_image, const char ch, Ascii_Font_Size size) uint8_t __pvt_should_be_next_line(CFBD_GraphicDevice * device_handle, CFBDGraphic_Point * brpoint, CFBDGraphic_Point * cur_draw_p, Ascii_Font_Size s) CFBDGraphic_Point __pvt_fetch_valid_final_point(CFBD_GraphicDevice * device_handle, CFBDGraphicSize * size, CFBDGraphic_Point * tl) CFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice * device_handle, CFBDGraphic_Text * item, AppendMethod method)"},{"location":"api/Files/text_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text_8c/#function-cfbdgraphic_inittext","title":"function CFBDGraphic_InitText","text":"<pre><code>void CFBDGraphic_InitText(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point tl_point,\n    CFBDGraphicSize textHandleSize,\n    Ascii_Font_Size text_size\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_draw_char_each","title":"function __pvt_draw_char_each","text":"<pre><code>static void __pvt_draw_char_each(\n    CFBD_GraphicDevice * device_handle,\n    CCGraphic_Image * borrowing_image,\n    const char ch,\n    Ascii_Font_Size size\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_should_be_next_line","title":"function __pvt_should_be_next_line","text":"<pre><code>static inline uint8_t __pvt_should_be_next_line(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Point * brpoint,\n    CFBDGraphic_Point * cur_draw_p,\n    Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_fetch_valid_final_point","title":"function __pvt_fetch_valid_final_point","text":"<pre><code>static inline CFBDGraphic_Point __pvt_fetch_valid_final_point(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphicSize * size,\n    CFBDGraphic_Point * tl\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-cfbdgraphic_drawtext","title":"function CFBDGraphic_DrawText","text":"<pre><code>CFBDGraphic_Point CFBDGraphic_DrawText(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Text * item,\n    AppendMethod method\n)\n</code></pre>"},{"location":"api/Files/text_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text.h\"\n\n#include &lt;limits.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/base_helpers.h\"\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"base_support/image.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/text.h\"\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size)\n{\n    item-&gt;font_size = text_size;\n    item-&gt;sources_borrowed = \"\";\n    item-&gt;tl_point = tl_point;\n    item-&gt;indexed_point = tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n}\n\nstatic void __pvt_draw_char_each(CFBD_GraphicDevice* device_handle,\n                                 CCGraphic_Image* borrowing_image,\n                                 const char ch,\n                                 Ascii_Font_Size size)\n{\n    borrowing_image-&gt;image_size = __fetch_font_size(size);\n    uint8_t* ascii = __select_from_ascii_font_size(size, ch);\n    borrowing_image-&gt;sources_register = ascii;\n    CFBDGraphic_DrawImage(device_handle, borrowing_image);\n}\n\nstatic uint8_t inline __pvt_should_be_next_line(CFBD_GraphicDevice* device_handle,\n                                                CFBDGraphic_Point* brpoint,\n                                                CFBDGraphic_Point* cur_draw_p,\n                                                Ascii_Font_Size s)\n{\n    return cur_draw_p-&gt;x + (int16_t) (1.5 * __fetch_font_size(s).width) &gt;= brpoint-&gt;x;\n}\n\nstatic CFBDGraphic_Point inline __pvt_fetch_valid_final_point(CFBD_GraphicDevice* device_handle,\n                                                              CFBDGraphicSize* size,\n                                                              CFBDGraphic_Point* tl)\n{\n    CFBDGraphic_Point br;\n    CFBDGraphicSize device_size;\n    CFBDGraphic_GetScreenSize(device_handle, &amp;device_size);\n\n    br.x = tl-&gt;x + size-&gt;width;\n    br.y = tl-&gt;y + size-&gt;height;\n    if (device_size.width &lt; br.x) {\n        br.x = device_size.width;\n    }\n    if (device_size.height &lt; br.y) {\n        br.y = device_size.height;\n    }\n    return br;\n}\n\nCFBDGraphic_Point\nCFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle, CFBDGraphic_Text* item, AppendMethod method)\n{\n    if (!device_handle || !item || !device_handle-&gt;ops)\n        return item-&gt;tl_point;\n\n    if (strcmp(item-&gt;sources_borrowed, \"\") == 0)\n        return item-&gt;tl_point;\n    CFBDGraphic_Point old = item-&gt;tl_point;\n    CCGraphic_Image handle_draw_image;\n    CFBDGraphic_Point draw_tl_point = item-&gt;indexed_point;\n\n    const Ascii_Font_Size font_size = item-&gt;font_size;\n    const CFBDGraphicSize size = __fetch_font_size(font_size);\n    const SizeBaseType font_width = size.width;\n    const SizeBaseType font_height = size.height;\n\n    CFBDGraphic_Point br = __pvt_fetch_valid_final_point(device_handle,\n                                                         &amp;(item-&gt;TexthandleSize),\n                                                         &amp;(item-&gt;tl_point));\n\n    uint8_t offseterx = 0;\n    uint8_t offsetery = 0;\n\n    int32_t lx = INT32_MAX;\n    int32_t ty = INT32_MAX;\n    int32_t rx = INT32_MIN;\n    int32_t by = INT32_MIN;\n\n    for (uint8_t i = 0; item-&gt;sources_borrowed[i] != '\\0'; i++) {\n        draw_tl_point.x = item-&gt;indexed_point.x + offseterx * font_width;\n        draw_tl_point.y = item-&gt;indexed_point.y + offsetery * font_height;\n\n        handle_draw_image.point = draw_tl_point;\n\n        __pvt_draw_char_each(device_handle,\n                             &amp;handle_draw_image,\n                             item-&gt;sources_borrowed[i],\n                             item-&gt;font_size);\n\n        int32_t cx1 = asInt32_t(draw_tl_point.x);\n        int32_t cy1 = asInt32_t(draw_tl_point.y);\n        int32_t cx2 = cx1 + font_width;\n        int32_t cy2 = cy1 + font_height;\n\n        if (cx1 &lt; lx)\n            lx = cx1;\n        if (cy1 &lt; ty)\n            ty = cy1;\n        if (cx2 &gt; rx)\n            rx = cx2;\n        if (cy2 &gt; by)\n            by = cy2;\n\n        if (__pvt_should_be_next_line(device_handle, &amp;br, &amp;draw_tl_point, font_size)) {\n            offseterx = 0;\n            offsetery++;\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n        }\n        else {\n            offseterx++;\n        }\n    }\n\n    /* \u7f13\u5b58 TextBoundingRect */\n    if (lx &lt;= rx &amp;&amp; ty &lt;= by) {\n        item-&gt;text_bounding_rect.tl.x = clamp_u16_from_i32(lx - CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.tl.y = clamp_u16_from_i32(ty - CFBDGraphic_TEXT_PADDING_HEIGHT);\n        item-&gt;text_bounding_rect.br.x = clamp_u16_from_i32(rx + CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.br.y = clamp_u16_from_i32(by + CFBDGraphic_TEXT_PADDING_HEIGHT);\n    }\n    else {\n        item-&gt;text_bounding_rect.tl = item-&gt;indexed_point;\n        item-&gt;text_bounding_rect.br = item-&gt;indexed_point;\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device_handle)) {\n        device_handle-&gt;ops-&gt;update_area(device_handle,\n                                        clamp_u16_from_i32(lx),\n                                        clamp_u16_from_i32(ty),\n                                        clamp_u16_from_i32(rx - lx + 1),\n                                        clamp_u16_from_i32(by - ty + 1));\n    }\n\n    switch (method) {\n        case CCGraphic_AsciiTextItem_AppendNextLine:\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n            item-&gt;indexed_point.y += font_height;\n            break;\n        case CCGraphic_AsciiTextItem_AppendContinously:\n            item-&gt;indexed_point.x += font_width;\n            break;\n        case CCGraphic_AsciiTextItem_RequestOldPoint:\n            item-&gt;indexed_point = old;\n            break;\n        default:\n            break;\n    }\n\n    return item-&gt;indexed_point;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/text_8h/","title":"lib/graphic/widget/text.h","text":""},{"location":"api/Files/text_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Text"},{"location":"api/Files/text_8h/#types","title":"Types","text":"Name enum AppendMethod"},{"location":"api/Files/text_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_InitText(CFBDGraphic_Text * item, CFBDGraphic_Point tl_point, CFBDGraphicSize textHandleSize, Ascii_Font_Size text_size) void CFBDGraphic_SetText(CFBDGraphic_Text * item, char * text) void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text * item, CFBDGraphic_Point * tl_point, CFBDGraphicSize textHandleSize) CFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice * device_handle, CFBDGraphic_Text * item, AppendMethod method)"},{"location":"api/Files/text_8h/#defines","title":"Defines","text":"Name CFBDGraphic_TEXT_PADDING_WIDTH CFBDGraphic_TEXT_PADDING_HEIGHT"},{"location":"api/Files/text_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/text_8h/#enum-appendmethod","title":"enum AppendMethod","text":"Enumerator Value Description CCGraphic_AsciiTextItem_AppendContinously CCGraphic_AsciiTextItem_AppendNextLine CCGraphic_AsciiTextItem_RequestOldPoint"},{"location":"api/Files/text_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text_8h/#function-cfbdgraphic_inittext","title":"function CFBDGraphic_InitText","text":"<pre><code>void CFBDGraphic_InitText(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point tl_point,\n    CFBDGraphicSize textHandleSize,\n    Ascii_Font_Size text_size\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settext","title":"function CFBDGraphic_SetText","text":"<pre><code>static inline void CFBDGraphic_SetText(\n    CFBDGraphic_Text * item,\n    char * text\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settexttlpointpoint","title":"function CFBDGraphic_SetTextTLPointPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextTLPointPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settextindexedpoint","title":"function CFBDGraphic_SetTextIndexedPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextIndexedPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-ccgraphicwidget_asciitextitem_relocate","title":"function CCGraphicWidget_AsciiTextItem_relocate","text":"<pre><code>static inline void CCGraphicWidget_AsciiTextItem_relocate(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize textHandleSize\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_drawtext","title":"function CFBDGraphic_DrawText","text":"<pre><code>CFBDGraphic_Point CFBDGraphic_DrawText(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Text * item,\n    AppendMethod method\n)\n</code></pre>"},{"location":"api/Files/text_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/text_8h/#define-cfbdgraphic_text_padding_width","title":"define CFBDGraphic_TEXT_PADDING_WIDTH","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n</code></pre>"},{"location":"api/Files/text_8h/#define-cfbdgraphic_text_padding_height","title":"define CFBDGraphic_TEXT_PADDING_HEIGHT","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n</code></pre>"},{"location":"api/Files/text_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"text_config.h\"\n\n#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n\ntypedef struct\n{\n    char* sources_borrowed;\n    CFBDGraphic_Point tl_point;\n    CFBDGraphic_Point indexed_point;\n    CFBDGraphicSize TexthandleSize;\n    Ascii_Font_Size font_size;\n    CFBDGraphicRect text_bounding_rect;\n} CFBDGraphic_Text;\n\ntypedef enum\n{\n    CCGraphic_AsciiTextItem_AppendContinously,\n    CCGraphic_AsciiTextItem_AppendNextLine,\n    CCGraphic_AsciiTextItem_RequestOldPoint\n} AppendMethod;\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size);\n\nstatic inline void CFBDGraphic_SetText(CFBDGraphic_Text* item, char* text)\n{\n    item-&gt;sources_borrowed = text;\n}\n\nstatic inline void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;tl_point = *p;\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text* item,\n                                                          CFBDGraphic_Point* tl_point,\n                                                          CFBDGraphicSize textHandleSize)\n{\n    item-&gt;tl_point = *tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n}\n\nCFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle,\n                                       CFBDGraphic_Text* item,\n                                       AppendMethod method);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/text__config_8c/","title":"lib/graphic/widget/text_config.c","text":""},{"location":"api/Files/text__config_8c/#functions","title":"Functions","text":"Name uint8_t * __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)Selects the font data array based on the specified font size. CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)"},{"location":"api/Files/text__config_8c/#attributes","title":"Attributes","text":"Name const uint8_t[][16] ascii8x16_sources const uint8_t[][6] ascii6x8_sources"},{"location":"api/Files/text__config_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text__config_8c/#function-__select_from_ascii_font_size","title":"function __select_from_ascii_font_size","text":"<pre><code>uint8_t * __select_from_ascii_font_size(\n    const Ascii_Font_Size s,\n    const char ch\n)\n</code></pre> <p>Selects the font data array based on the specified font size. </p> <p>Parameters: </p> <ul> <li>s The font size to be selected (from the <code>Ascii_Font_Size</code> enum). </li> <li>ch the character wanna display </li> </ul> <p>Return: A pointer to the font data array corresponding to the selected font size. If an invalid font size is passed, the function returns UNSUPPORTIVE_FONT_SOURCE. </p> <p>This function receives an <code>Ascii_Font_Size</code> value and returns a pointer to the corresponding font data array. The function helps in selecting the appropriate font data for display purposes, allowing for different font sizes (e.g., 8x16, 6x8, etc.).</p>"},{"location":"api/Files/text__config_8c/#function-__fetch_font_size","title":"function __fetch_font_size","text":"<pre><code>CFBDGraphicSize __fetch_font_size(\n    const Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text__config_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/text__config_8c/#variable-ascii8x16_sources","title":"variable ascii8x16_sources","text":"<pre><code>const uint8_t[][16] ascii8x16_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#variable-ascii6x8_sources","title":"variable ascii6x8_sources","text":"<pre><code>const uint8_t[][6] ascii6x8_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text_config.h\"\n\n\nextern const uint8_t ascii8x16_sources[][16];\nextern const uint8_t ascii6x8_sources[][6];\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)\n{\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            return (uint8_t*) (ascii6x8_sources[ch - ' ']);\n#endif\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            return (uint8_t*) (ascii8x16_sources[ch - ' ']);\n#endif\n        /*\n            To programmers, if new ascii like sources is\n            registered, please implement follows\n        */\n        default:\n            return UNSUPPORTIVE_FONT_SOURCE;\n    }\n}\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)\n{\n    CFBDGraphicSize size = {0, 0};\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            size.height = 8;\n            size.width = 6;\n            break;\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            size.height = 16;\n            size.width = 8;\n            break;\n#endif\n        default:\n            break;\n    }\n    return size;\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/text__config_8h/","title":"lib/graphic/widget/text_config.h","text":""},{"location":"api/Files/text__config_8h/#types","title":"Types","text":"Name enum Ascii_Font_Size enum Unicode_Font_Size"},{"location":"api/Files/text__config_8h/#functions","title":"Functions","text":"Name uint8_t * __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)Selects the font data array based on the specified font size. CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)"},{"location":"api/Files/text__config_8h/#defines","title":"Defines","text":"Name UNSUPPORTIVE_FONT_SOURCE"},{"location":"api/Files/text__config_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/text__config_8h/#enum-ascii_font_size","title":"enum Ascii_Font_Size","text":"Enumerator Value Description NO_ASCII_SIZE"},{"location":"api/Files/text__config_8h/#enum-unicode_font_size","title":"enum Unicode_Font_Size","text":"Enumerator Value Description Unicode_16x16"},{"location":"api/Files/text__config_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text__config_8h/#function-__select_from_ascii_font_size","title":"function __select_from_ascii_font_size","text":"<pre><code>uint8_t * __select_from_ascii_font_size(\n    const Ascii_Font_Size s,\n    const char ch\n)\n</code></pre> <p>Selects the font data array based on the specified font size. </p> <p>Parameters: </p> <ul> <li>s The font size to be selected (from the <code>Ascii_Font_Size</code> enum). </li> <li>ch the character wanna display </li> </ul> <p>Return: A pointer to the font data array corresponding to the selected font size. If an invalid font size is passed, the function returns UNSUPPORTIVE_FONT_SOURCE. </p> <p>This function receives an <code>Ascii_Font_Size</code> value and returns a pointer to the corresponding font data array. The function helps in selecting the appropriate font data for display purposes, allowing for different font sizes (e.g., 8x16, 6x8, etc.).</p>"},{"location":"api/Files/text__config_8h/#function-__fetch_font_size","title":"function __fetch_font_size","text":"<pre><code>CFBDGraphicSize __fetch_font_size(\n    const Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/text__config_8h/#define-unsupportive_font_source","title":"define UNSUPPORTIVE_FONT_SOURCE","text":"<pre><code>#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n</code></pre>"},{"location":"api/Files/text__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/size.h\"\n#include \"resource/config.h\"\n\n/*\n    current version we only support\n    6x8 and 8x16. to register more, u should\n    provide the source and implement the functions\n*/\ntypedef enum\n{\n#if ENABLE_ASCII_6x8_SOURCES\n    ASCII_6x8,\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n    ASCII_8x16,\n#endif\n    NO_ASCII_SIZE\n} Ascii_Font_Size;\n\ntypedef enum\n{\n    Unicode_16x16\n} Unicode_Font_Size;\n\n#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch);\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/triangle_8c/","title":"lib/graphic/base/triangle.c","text":""},{"location":"api/Files/triangle_8c/#functions","title":"Functions","text":"Name int16_t find_int16min(int16_t * vals, int16_t size) int16_t find_int16max(int16_t * vals, int16_t size) void clearBound(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void update_requests(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void CCGraphic_DrawTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) uint8_t __pvt_is_in_triangle(int16_t * triangles_x, int16_t * triangles_y, PointBaseType x, PointBaseType y) void CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle)"},{"location":"api/Files/triangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/triangle_8c/#function-find_int16min","title":"function find_int16min","text":"<pre><code>static inline int16_t find_int16min(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-find_int16max","title":"function find_int16max","text":"<pre><code>static inline int16_t find_int16max(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static void clearBound(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-update_requests","title":"function update_requests","text":"<pre><code>static void update_requests(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-ccgraphic_drawtriangle","title":"function CCGraphic_DrawTriangle","text":"<pre><code>void CCGraphic_DrawTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-__pvt_is_in_triangle","title":"function __pvt_is_in_triangle","text":"<pre><code>static uint8_t __pvt_is_in_triangle(\n    int16_t * triangles_x,\n    int16_t * triangles_y,\n    PointBaseType x,\n    PointBaseType y\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-ccgraphic_drawfilledtriangle","title":"function CCGraphic_DrawFilledTriangle","text":"<pre><code>void CCGraphic_DrawFilledTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"triangle.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"line.h\"\n#include \"point.h\"\n\nstatic inline int16_t find_int16min(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &lt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic inline int16_t find_int16max(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &gt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic void clearBound(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;clear_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void update_requests(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;update_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nvoid CCGraphic_DrawTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBDGraphic_Line line;\n    line.p_left = triangle-&gt;p1;\n    line.p_right = triangle-&gt;p2;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p2;\n    line.p_right = triangle-&gt;p3;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p1;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n\nstatic uint8_t\n__pvt_is_in_triangle(int16_t* triangles_x, int16_t* triangles_y, PointBaseType x, PointBaseType y)\n{\n    uint8_t is_in = 0;\n    /* https://wrfranklin.org/Research/Short_Notes/pnpoly.html */\n    for (uint8_t i = 0, j = 2; i &lt; 3; j = i++) {\n        if (((triangles_y[i] &gt; y) != (triangles_y[j] &gt; y)) &amp;&amp;\n            (x &lt; (triangles_x[j] - triangles_x[i]) * (y - triangles_y[i]) /\n                                 (triangles_y[j] - triangles_y[i]) +\n                         triangles_x[i])) {\n            is_in = !is_in;\n        }\n    }\n    return is_in;\n}\n\nvoid CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handle-&gt;ops-&gt;setPixel;\n\n    int16_t triangles_x[] = {triangle-&gt;p1.x, triangle-&gt;p2.x, triangle-&gt;p3.x};\n\n    int16_t triangles_y[] = {triangle-&gt;p1.y, triangle-&gt;p2.y, triangle-&gt;p3.y};\n\n    int16_t minX = find_int16min(triangles_x, 3);\n    int16_t minY = find_int16min(triangles_y, 3);\n\n    int16_t maxX = find_int16max(triangles_x, 3);\n    int16_t maxY = find_int16max(triangles_y, 3);\n\n    for (int16_t i = minX; i &lt; maxX; i++) {\n        for (int16_t j = minY; j &lt; maxY; j++) {\n            if (__pvt_is_in_triangle(triangles_x, triangles_y, i, j)) {\n                setPixel(handle, i, j);\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"},{"location":"api/Files/triangle_8h/","title":"lib/graphic/base/triangle.h","text":""},{"location":"api/Files/triangle_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Triangle"},{"location":"api/Files/triangle_8h/#functions","title":"Functions","text":"Name void CCGraphic_DrawTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle)"},{"location":"api/Files/triangle_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/triangle_8h/#function-ccgraphic_drawtriangle","title":"function CCGraphic_DrawTriangle","text":"<pre><code>void CCGraphic_DrawTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8h/#function-ccgraphic_drawfilledtriangle","title":"function CCGraphic_DrawFilledTriangle","text":"<pre><code>void CCGraphic_DrawFilledTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\ntypedef struct\n{\n    CFBDGraphic_Point p1;\n    CFBDGraphic_Point p2;\n    CFBDGraphic_Point p3;\n} CFBDGraphic_Triangle;\n\nvoid CCGraphic_DrawTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle);\nvoid CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle);\n</code></pre> <p>Updated on 2026-01-09 at 14:27:44 +0000</p>"}]}