{"config":{"lang":["zh","en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u5355\u7247\u673a\u57fa\u7840\u5e93\u6587\u6863\u6307\u5357","text":""},{"location":"api/index_classes/","title":"Classes","text":"<ul> <li>struct CCGraphic_Arc Represents a circular arc defined by center, radius, and angular range. </li> <li>struct CCGraphic_Ellipse Represents an ellipse defined by center point and two radii. </li> <li>struct CCGraphic_Image </li> <li>namespace CFBD Core Framework Bare Device (CFBD) namespace *. <ul> <li>namespace OLED OLED display driver subsystem *. </li> </ul> </li> <li>struct CFBDBootTuple </li> <li>struct CFBDGraphicCircle Represents a circle defined by center point and radius. </li> <li>struct CFBDGraphicRect Represents a rectangle defined by top-left and bottom-right corner points. </li> <li>struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area. </li> <li>struct CFBDGraphic_Line Represents a line segment defined by two endpoints. </li> <li>struct CFBDGraphic_Margin </li> <li>struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. </li> <li>struct CFBDGraphic_Text </li> <li>struct CFBDGraphic_Triangle Represents a triangle defined by three vertices. </li> <li>struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components. </li> <li>struct CFBD_BaseAnimationOps </li> <li>struct CFBD_GPIOHandle Public GPIO handle combining platform handle and pin id. </li> <li>struct CFBD_GraphicDeviceOperation </li> <li>struct CFBD_I2CHandle Public I2C handle containing the operations table and private state. </li> <li>struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus. </li> <li>struct CFBD_I2C_IORequestParams Helper structure used by convenience read/write helpers. </li> <li>struct CFBD_I2C_Message Single I2C message description used for multi-message transfers. </li> <li>struct CFBD_MenuItemCallbackPack </li> <li>struct CFBD_MenuOps </li> <li>struct CFBD_OLED The generic OLED device object exposed to application code. </li> <li>struct CFBD_OLEDOperations Virtual operation table implementing OLED driver functionality. </li> <li>struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel. </li> <li>struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C. </li> <li>struct CFBD_ProgressBarOps </li> <li>struct CFBD_ST_I2CPrivate Backend-private state for the STM32 I2C implementation. </li> <li>struct _CFBD_GraphicDevice </li> <li>struct _CFBD_I2CHandle </li> <li>struct _CFBD_I2C_Message </li> <li>struct _CFBD_Menu </li> <li>struct _CFBD_OLED </li> <li>struct _CFBD_OLED_OPS </li> <li>struct __CFBDApplication Application descriptor. </li> <li>struct __CFBD_BaseAnimation </li> <li>struct __CFBD_MenuIndicator </li> <li>struct __CFBD_MenuItem </li> <li>struct __CFBD_MenuItemArray </li> <li>struct __CFBD_ProgressBar </li> <li>namespace for </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/index_examples/","title":"Examples","text":"<ul> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic.h Initialize an I2C-based OLED device instance. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h Factory function: returns the SSD1306 device-specific descriptor. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h Factory function: returns the SSD1309 device-specific descriptor. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h </li> <li>example &gt;: Comprehensive guides and reference documentation </li> <li>example blocks </li> <li>example code </li> <li>example standalone pages </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/index_files/","title":"Files","text":"<ul> <li>file OLED_Documentation_Summary.md </li> <li>file OLED_Examples.md </li> <li>file OLED_Namespace.md </li> <li>file OLED_Usage_Guide.md </li> <li>file circle.c </li> <li>file circle.h Circle geometry and drawing function declarations. </li> <li>file ellipse.c </li> <li>file ellipse.h Ellipse drawing utilities for 2D graphics rendering. </li> <li>dir lib <ul> <li>dir lib/application <ul> <li>file c </li> <li>file h Application descriptor and clock/boot provider interfaces. </li> <li>dir lib/application/sys_boot <ul> <li>file c </li> <li>file h Boot / startup helpers and types for application bootstrap sequence. </li> </ul> </li> <li>dir lib/application/sys_clock <ul> <li>file c </li> <li>file h System timing primitives and delay helpers. </li> </ul> </li> </ul> </li> <li>dir lib/config <ul> <li>file h Emergency halt helper used when unrecoverable errors occur. </li> <li>file h Core type and macro definitions used across CFBD libraries. </li> <li>file h </li> </ul> </li> <li>dir lib/gpio <ul> <li>file c </li> <li>file h STM32 specific GPIO implementation details for CFBD. </li> <li>file h GPIO abstraction and helpers used by platform and application code. </li> </ul> </li> <li>dir lib/graphic <ul> <li>file h </li> <li>dir lib/graphic/base <ul> <li>file c </li> <li>file h Arc geometry and drawing prototypes for the graphics subsystem. </li> </ul> </li> <li>dir lib/graphic/benchmark <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/device <ul> <li>file c </li> <li>file h </li> <li>dir lib/graphic/device/oled <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/graphic/fast_test <ul> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/resource <ul> <li>file h </li> <li>dir lib/graphic/resource/default <ul> <li>file c </li> <li>file c </li> </ul> </li> </ul> </li> <li>dir lib/graphic/widget <ul> <li>dir lib/graphic/widget/animation <ul> <li>file c </li> <li>file h </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/widget/base_support <ul> <li>file c </li> <li>file h </li> <li>dir lib/graphic/widget/base_support/common <ul> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/graphic/widget/menu <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/widget/progressbar <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/iic <ul> <li>file c </li> <li>file h I2C (IIC) abstraction layer for CFBD drivers. </li> <li>file h I2C/IIC error codes used by the CFBD I2C abstraction. </li> <li>dir lib/iic/backend <ul> <li>file c </li> <li>file h STM32 HAL-based I2C backend private types and helpers. </li> </ul> </li> </ul> </li> <li>dir lib/oled <ul> <li>dir lib/oled/configs <ul> <li>file h Configuration constants for the OLED display pixel cache. </li> <li>file h External (platform/application) implementation hooks for OLED driver. </li> </ul> </li> <li>dir lib/oled/driver <ul> <li>dir lib/oled/driver/backend <ul> <li>file c </li> <li>file h I2C-backed OLED driver initialization interface. </li> </ul> </li> <li>dir lib/oled/driver/device <ul> <li>file h Generic device descriptor used by OLED drivers. </li> <li>dir lib/oled/driver/device/ssd1306 <ul> <li>file c </li> <li>file h SSD1306 device-specific descriptor and factory. </li> </ul> </li> <li>dir lib/oled/driver/device/ssd1309 <ul> <li>file c </li> <li>file h SSD1309 device-specific descriptor and factory. </li> </ul> </li> </ul> </li> </ul> </li> <li>file c </li> <li>file h Generic OLED object and operations exposed to application code. </li> </ul> </li> </ul> </li> <li>file line.c </li> <li>file line.h Line drawing utilities for 2D graphics rendering. </li> <li>file point.h Point and Vector data structures and utility functions for 2D graphics. </li> <li>file rectangle.c </li> <li>file size.c </li> <li>file size.h Size data structure and utilities for 2D graphics. </li> <li>file triangle.c </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/index_groups/","title":"Modules","text":"<ul> <li>group Application Management Application-level bootstrap and clock providers. </li> <li>group Arc Drawing </li> <li>group Graphic Base Helpers </li> <li>group Boot Minimal boot/bootstrap types and helpers. </li> <li>group Core Definitions Small portable types and macros used throughout the project. </li> <li>group I2C Backend Implementation Backend implementation interface for I2C drivers. </li> <li>group I2C/IIC Error Codes Standard error codes for I2C operations. </li> <li>group I2C High-Level Helpers Convenience functions for common I2C operations. </li> <li>group I2C Inline Wrappers Convenience inline functions for I2C operations. </li> <li>group OLED Display Cache Configuration OLED display framebuffer dimensions and settings. </li> <li>group OLED Display Integration OLED driver initialization and platform integration. </li> <li>group Circle Drawing </li> <li>group Core System Utilities System-level utilities for error handling and emergency states. </li> <li>group Ellipse Drawing </li> <li>group Line Drawing </li> <li>group OLED Display Driver <ul> <li>group OLED Backend Implementations Backend transport implementations (I2C, SPI) for OLED drivers. </li> <li>group OLED Device Interface Device-specific descriptors and configurations for OLED drivers. </li> </ul> </li> <li>group Point Utilities </li> <li>group Rectangle Operations <ul> <li>group Rectangle Normalization Utilities for normalizing rectangle corner points. <ul> <li>group Advanced Rectangle Operations Complex rectangle manipulation and analysis functions. </li> <li>group Anchor Flags Flags for specifying rectangle alignment anchors. </li> <li>group Point and Rectangle Containment Functions to check containment and intersection relationships. </li> <li>group Rectangle Format Conversion Conversion between different rectangle representations. </li> <li>group Rectangle Dimensions Functions to calculate rectangle dimensions. </li> </ul> </li> </ul> </li> <li>group Size Utilities </li> <li>group System Clock and Timing Short blocking delay primitives for timing operations. </li> <li>group Triangle Drawing </li> <li>group new module concepts </li> <li>group &gt;: Hierarchical organization of related components </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/index_namespaces/","title":"Namespaces","text":"<ul> <li>namespace CFBD Core Framework Bare Device (CFBD) namespace *. <ul> <li>namespace OLED OLED display driver subsystem *. </li> </ul> </li> <li>namespace for </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/index_pages/","title":"Pages","text":"<ul> <li>page &gt;: Comprehensive guides and reference documentation </li> <li>page Arc Drawing and Geometry Guide Comprehensive guide to arc drawing and sector rendering. </li> <li>page Graphic Base Helpers User Guide Guide to using numeric conversion and clamping helpers. </li> <li>page Circle Drawing and Geometry Guide Comprehensive guide to drawing circles using the graphics library. </li> <li>page OLED Documentation Summary </li> <li>page OLED Driver Examples </li> <li>page OLED Driver Usage Guide </li> <li>page Application Initialization and Setup </li> <li>page Boot System Design Overview of the Boot System. </li> <li>page Core Types and Definitions Guide </li> <li>page with new information </li> <li>page Error Handling Guide </li> <li>page standalone pages </li> <li>page I2C Error Handling Comprehensive Guide to I2C Error Codes and Recovery. </li> <li>page I2C Integration Guide How to Integrate I2C Devices with the CFBD I2C Abstraction. </li> <li>page OLED_Documentation_Summary </li> <li>page OLED_Examples </li> <li>page OLED_Namespace </li> <li>page OLED_Usage_Guide </li> <li>page OLED Display Cache Architecture Design and Management of OLED Display Framebuffer. </li> <li>page OLED Driver Integration Platform Integration and Initialization for OLED Displays. </li> <li>page System Timing and Delay Guide </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCCGraphic__Arc/","title":"CCGraphic_Arc","text":"<p>Module: Arc Drawing</p> <p>Represents a circular arc defined by center, radius, and angular range.  More...</p> <p><code>#include &lt;arc.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Arc/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center Center point of the arc's parent circle. PointBaseType radius Radius from center to the arc in device units. int16_t start_degree Starting angle in degrees (0-359), measured counter-clockwise from right (3 o'clock). int16_t end_degree Ending angle in degrees (0-359). The arc sweeps from start_degree to end_degree."},{"location":"api/Classes/structCCGraphic__Arc/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CCGraphic_Arc;\n</code></pre> <p>Represents a circular arc defined by center, radius, and angular range. </p> <p>An arc is a portion of a circle specified by a center point, radius, and a pair of angles defining the start and end of the arc.</p> <p>Arc definition:</p> <ul> <li>center: The center point of the circle from which the arc is drawn</li> <li>radius: Distance from center to the arc edge, in device units</li> <li>start_degree: Starting angle in degrees (0-359)</li> <li>end_degree: Ending angle in degrees (0-359)</li> </ul> <p>Angular convention:</p> <ul> <li>0\u00b0 points horizontally right (3 o'clock)</li> <li>Positive angles sweep counter-clockwise</li> <li>Angles are automatically normalized to [0, 359]</li> <li>If start_degree &gt; end_degree, the arc wraps around 0\u00b0 </li> </ul>"},{"location":"api/Classes/structCCGraphic__Arc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Arc/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>Center point of the arc's parent circle. </p>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-radius","title":"variable radius","text":"<pre><code>PointBaseType radius;\n</code></pre> <p>Radius from center to the arc in device units. </p>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-start_degree","title":"variable start_degree","text":"<pre><code>int16_t start_degree;\n</code></pre> <p>Starting angle in degrees (0-359), measured counter-clockwise from right (3 o'clock). </p>"},{"location":"api/Classes/structCCGraphic__Arc/#variable-end_degree","title":"variable end_degree","text":"<pre><code>int16_t end_degree;\n</code></pre> <p>Ending angle in degrees (0-359). The arc sweeps from start_degree to end_degree. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCCGraphic__Ellipse/","title":"CCGraphic_Ellipse","text":"<p>Module: Ellipse Drawing</p> <p>Represents an ellipse defined by center point and two radii.  More...</p> <p><code>#include &lt;ellipse.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Ellipse/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center PointBaseType X_Radius PointBaseType Y_Radius"},{"location":"api/Classes/structCCGraphic__Ellipse/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CCGraphic_Ellipse;\n</code></pre> <p>Represents an ellipse defined by center point and two radii. </p> <p>This structure defines an ellipse in 2D space using a center point and separate radii for the X and Y axes. This allows for efficient rendering of circles (when X_Radius == Y_Radius) and ellipses with arbitrary dimensions.</p> <p>The ellipse is defined by:</p> <ul> <li>A center point (center)</li> <li>Horizontal radius extending from center along X-axis (X_Radius)</li> <li>Vertical radius extending from center along Y-axis (Y_Radius)</li> </ul> <p>The rendering is typically done using the Midpoint Ellipse Algorithm, which provides accurate rasterization with good performance. </p>"},{"location":"api/Classes/structCCGraphic__Ellipse/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>The center point of the ellipse </p>"},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-x_radius","title":"variable X_Radius","text":"<pre><code>PointBaseType X_Radius;\n</code></pre> <p>The horizontal radius (semi-major or semi-minor axis) </p>"},{"location":"api/Classes/structCCGraphic__Ellipse/#variable-y_radius","title":"variable Y_Radius","text":"<pre><code>PointBaseType Y_Radius;\n</code></pre> <p>The vertical radius (semi-minor or semi-major axis) </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCCGraphic__Image/","title":"CCGraphic_Image","text":"<p><code>#include &lt;image.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point point CFBDGraphicSize image_size uint8_t * sources_register"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Image/#variable-point","title":"variable point","text":"<pre><code>CFBDGraphic_Point point;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Image/#variable-image_size","title":"variable image_size","text":"<pre><code>CFBDGraphicSize image_size;\n</code></pre>"},{"location":"api/Classes/structCCGraphic__Image/#variable-sources_register","title":"variable sources_register","text":"<pre><code>uint8_t * sources_register;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDBootTuple/","title":"CFBDBootTuple","text":"<p>Module: Boot</p> <p><code>#include &lt;boot.h&gt;</code></p>"},{"location":"api/Classes/structCFBDBootTuple/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc boot_func Pointer to the bootstrap function to invoke. CFBD_BootArgs args Opaque pointer passed to <code>boot_func</code> when invoked."},{"location":"api/Classes/structCFBDBootTuple/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDBootTuple/#variable-boot_func","title":"variable boot_func","text":"<pre><code>CFBD_BootStrapFunc boot_func;\n</code></pre> <p>Pointer to the bootstrap function to invoke. </p> <p>Must conform to the <code>CFBD_BootStrapFunc</code> contract: accept a <code>CFBD_BootArgs</code> and return <code>CFBD_Bool</code>. </p>"},{"location":"api/Classes/structCFBDBootTuple/#variable-args","title":"variable args","text":"<pre><code>CFBD_BootArgs args;\n</code></pre> <p>Opaque pointer passed to <code>boot_func</code> when invoked. </p> <p>Interpretation of this pointer is implementation-defined and must match what the <code>boot_func</code> expects. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphicCircle/","title":"CFBDGraphicCircle","text":"<p>Module: Circle Drawing</p> <p>Represents a circle defined by center point and radius.  More...</p> <p><code>#include &lt;circle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicCircle/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType radius Radius of the circle in device units. CFBDGraphic_Point center Center coordinate of the circle."},{"location":"api/Classes/structCFBDGraphicCircle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicCircle;\n</code></pre> <p>Represents a circle defined by center point and radius. </p> <p>This structure describes a perfect circle in 2D screen space. The circle is defined mathematically as the set of all points at a fixed distance (radius) from the center point.</p> <p>Circle rendering is performed using efficient integer-based algorithms suitable for embedded displays. The radius should typically be in the range 1-500 pixels for best performance on standard displays. </p>"},{"location":"api/Classes/structCFBDGraphicCircle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicCircle/#variable-radius","title":"variable radius","text":"<pre><code>SizeBaseType radius;\n</code></pre> <p>Radius of the circle in device units. </p>"},{"location":"api/Classes/structCFBDGraphicCircle/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>Center coordinate of the circle. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphicRect/","title":"CFBDGraphicRect","text":"<p>Module: Rectangle Operations</p> <p>Represents a rectangle defined by top-left and bottom-right corner points.  More...</p> <p><code>#include &lt;rectangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicRect/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicRect;\n</code></pre> <p>Represents a rectangle defined by top-left and bottom-right corner points. </p> <p>This structure defines a rectangular region using two diagonal corner points. The corners do not need to be in any particular order; the rect_normalize() function can be used to ensure consistent corner positioning.</p> <p>The rectangle is defined by:</p> <ul> <li><code>tl</code> (top-left): One corner of the rectangle</li> <li><code>br</code> (bottom-right): The diagonal corner of the rectangle</li> </ul> <p>Key properties:</p> <ul> <li>Corners can be specified in any order (will be normalized if needed)</li> <li>Supports all standard rectangle operations (area, width, height, intersection, etc.)</li> <li>Can be empty (zero width or height)</li> <li>Coordinates are clamped to valid range by device driver </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphicSize/","title":"CFBDGraphicSize","text":"<p>Module: Size Utilities</p> <p>Represents dimensions (width and height) of a rectangular area.  More...</p> <p><code>#include &lt;size.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType width SizeBaseType height"},{"location":"api/Classes/structCFBDGraphicSize/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicSize;\n</code></pre> <p>Represents dimensions (width and height) of a rectangular area. </p> <p>This structure defines the size of a 2D object using width and height components. It is commonly used in conjunction with position information to define layout and rendering areas for UI elements and graphics.</p> <p>The size is defined by:</p> <ul> <li><code>width:</code> The horizontal dimension in pixels</li> <li><code>height:</code> The vertical dimension in pixels</li> </ul> <p>Both dimensions use SizeBaseType (typically uint16_t) for efficient storage and fast computation on embedded systems. </p>"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicSize/#variable-width","title":"variable width","text":"<pre><code>SizeBaseType width;\n</code></pre> <p>The width of the size in pixels </p>"},{"location":"api/Classes/structCFBDGraphicSize/#variable-height","title":"variable height","text":"<pre><code>SizeBaseType height;\n</code></pre> <p>The height of the size in pixels </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Line/","title":"CFBDGraphic_Line","text":"<p>Module: Line Drawing</p> <p>Represents a line segment defined by two endpoints.  More...</p> <p><code>#include &lt;line.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p_left CFBDGraphic_Point p_right"},{"location":"api/Classes/structCFBDGraphic__Line/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Line;\n</code></pre> <p>Represents a line segment defined by two endpoints. </p> <p>This structure defines a line in 2D space using two points. The line segment extends from the left endpoint to the right endpoint, and can be used for rendering, collision detection, and geometric calculations.</p> <p>The naming convention \"left\" and \"right\" refers to the logical order of the endpoints rather than spatial positioning. The endpoints can be at any position, including when p_left is spatially to the right of p_right. </p>"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_left","title":"variable p_left","text":"<pre><code>CFBDGraphic_Point p_left;\n</code></pre> <p>The left endpoint of the line segment </p>"},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_right","title":"variable p_right","text":"<pre><code>CFBDGraphic_Point p_right;\n</code></pre> <p>The right endpoint of the line segment </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Margin/","title":"CFBDGraphic_Margin","text":"<p><code>#include &lt;margin.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Margin/#public-attributes","title":"Public Attributes","text":"Name PointBaseType left PointBaseType top PointBaseType right PointBaseType bottom"},{"location":"api/Classes/structCFBDGraphic__Margin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-left","title":"variable left","text":"<pre><code>PointBaseType left;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-top","title":"variable top","text":"<pre><code>PointBaseType top;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-right","title":"variable right","text":"<pre><code>PointBaseType right;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Margin/#variable-bottom","title":"variable bottom","text":"<pre><code>PointBaseType bottom;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Point/","title":"CFBDGraphic_Point","text":"<p>Module: Point Utilities</p> <p>Represents a 2D point in the graphics coordinate system.  More...</p> <p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes","title":"Public Attributes","text":"Name PointBaseType x PointBaseType y"},{"location":"api/Classes/structCFBDGraphic__Point/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Point;\n</code></pre> <p>Represents a 2D point in the graphics coordinate system. </p> <p>This structure defines a point in 2D space with unsigned 16-bit coordinates. It is used throughout the graphics module for positioning and drawing operations.</p> <p>The coordinates are limited to the range [0, UINT16_MAX] by the PointBaseType definition. This allows for efficient storage and computation on embedded systems. </p>"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Point/#variable-x","title":"variable x","text":"<pre><code>PointBaseType x;\n</code></pre> <p>X-coordinate of the point </p>"},{"location":"api/Classes/structCFBDGraphic__Point/#variable-y","title":"variable y","text":"<pre><code>PointBaseType y;\n</code></pre> <p>Y-coordinate of the point </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Text/","title":"CFBDGraphic_Text","text":"<p><code>#include &lt;text.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes","title":"Public Attributes","text":"Name char * sources_borrowed CFBDGraphic_Point tl_point CFBDGraphic_Point indexed_point CFBDGraphicSize TexthandleSize Ascii_Font_Size font_size CFBDGraphicRect text_bounding_rect"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Text/#variable-sources_borrowed","title":"variable sources_borrowed","text":"<pre><code>char * sources_borrowed;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-indexed_point","title":"variable indexed_point","text":"<pre><code>CFBDGraphic_Point indexed_point;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-texthandlesize","title":"variable TexthandleSize","text":"<pre><code>CFBDGraphicSize TexthandleSize;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-font_size","title":"variable font_size","text":"<pre><code>Ascii_Font_Size font_size;\n</code></pre>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-text_bounding_rect","title":"variable text_bounding_rect","text":"<pre><code>CFBDGraphicRect text_bounding_rect;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/","title":"CFBDGraphic_Triangle","text":"<p>Module: Triangle Drawing</p> <p>Represents a triangle defined by three vertices.  More...</p> <p><code>#include &lt;triangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p1 CFBDGraphic_Point p2 CFBDGraphic_Point p3"},{"location":"api/Classes/structCFBDGraphic__Triangle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Triangle;\n</code></pre> <p>Represents a triangle defined by three vertices. </p> <p>This structure defines a triangle in 2D space using three corner points. Triangles are fundamental geometric shapes used for creating complex graphics, UI elements, and efficient polygon rendering through triangulation.</p> <p>The triangle is defined by:</p> <ul> <li><code>p1:</code> First vertex of the triangle</li> <li><code>p2:</code> Second vertex of the triangle</li> <li><code>p3:</code> Third vertex of the triangle</li> </ul> <p>The vertices can be specified in any order. For consistent rendering and efficient backface culling, vertices are typically ordered counter-clockwise.</p> <p>Key properties:</p> <ul> <li>Vertices can form acute, obtuse, or right triangles</li> <li>Degenerate triangles (collinear points) result in no visible output</li> <li>Rendering may use barycentric interpolation for shading </li> </ul>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p1","title":"variable p1","text":"<pre><code>CFBDGraphic_Point p1;\n</code></pre> <p>First vertex of the triangle </p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p2","title":"variable p2","text":"<pre><code>CFBDGraphic_Point p2;\n</code></pre> <p>Second vertex of the triangle </p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p3","title":"variable p3","text":"<pre><code>CFBDGraphic_Point p3;\n</code></pre> <p>Third vertex of the triangle </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/","title":"CFBDGraphic_Vec2i","text":"<p>Module: Point Utilities</p> <p>Represents a 2D vector with signed 32-bit integer components.  More...</p> <p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes","title":"Public Attributes","text":"Name int32_t x int32_t y"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Vec2i;\n</code></pre> <p>Represents a 2D vector with signed 32-bit integer components. </p> <p>This structure is used for vector operations that may result in negative values, such as the difference between two points. The use of 32-bit signed integers allows for proper representation of negative displacements. </p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-x","title":"variable x","text":"<pre><code>int32_t x;\n</code></pre> <p>X-component of the vector </p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-y","title":"variable y","text":"<pre><code>int32_t y;\n</code></pre> <p>Y-component of the vector </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/","title":"CFBD_BaseAnimationOps","text":"<p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(uint32_t ms) delay_ms"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__BaseAnimationOps/#variable-delay_ms","title":"variable delay_ms","text":"<pre><code>void(*)(uint32_t ms) delay_ms;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__GPIOHandle/","title":"CFBD_GPIOHandle","text":"<p>Public GPIO handle combining platform handle and pin id.  More...</p> <p><code>#include &lt;gpio.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes","title":"Public Attributes","text":"Name GPIO_TypeHandle handle_internals_ Platform-specific handle or peripheral pointer. GPIO_PinType pin_internals_ Platform-specific pin identifier (see <code>GPIO_PinType</code>)."},{"location":"api/Classes/structCFBD__GPIOHandle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GPIOHandle;\n</code></pre> <p>Public GPIO handle combining platform handle and pin id. </p> <p>This small POD aggregates a platform handle and a pin identifier. It is the primary handle passed to the GPIO API. The <code>handle_internals_</code> field contains the backend-specific state while <code>pin_internals_</code> identifies which pin to operate on. </p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-handle_internals_","title":"variable handle_internals_","text":"<pre><code>GPIO_TypeHandle handle_internals_;\n</code></pre> <p>Platform-specific handle or peripheral pointer. </p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-pin_internals_","title":"variable pin_internals_","text":"<pre><code>GPIO_PinType pin_internals_;\n</code></pre> <p>Platform-specific pin identifier (see <code>GPIO_PinType</code>). </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/","title":"CFBD_GraphicDeviceOperation","text":"<p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_GraphicDevice *device, void *init_args) init init calls for the devices setup CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea GraphicFrameOperation update GraphicFrameOperation clear GraphicFrameOperation revert GraphicAreaOperations update_area GraphicAreaOperations clear_area GraphicAreaOperations revert_area GraphicOLEDSelfOperation open GraphicOLEDSelfOperation close GraphicOLED_QueryOperation self_consult"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_GraphicDevice *device, void *init_args) init;\n</code></pre> <p>init calls for the devices setup </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update","title":"variable update","text":"<pre><code>GraphicFrameOperation update;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear","title":"variable clear","text":"<pre><code>GraphicFrameOperation clear;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert","title":"variable revert","text":"<pre><code>GraphicFrameOperation revert;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update_area","title":"variable update_area","text":"<pre><code>GraphicAreaOperations update_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear_area","title":"variable clear_area","text":"<pre><code>GraphicAreaOperations clear_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert_area","title":"variable revert_area","text":"<pre><code>GraphicAreaOperations revert_area;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-open","title":"variable open","text":"<pre><code>GraphicOLEDSelfOperation open;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-close","title":"variable close","text":"<pre><code>GraphicOLEDSelfOperation close;\n</code></pre>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-self_consult","title":"variable self_consult","text":"<pre><code>GraphicOLED_QueryOperation self_consult;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__I2CHandle/","title":"CFBD_I2CHandle","text":"<p>Public I2C handle containing the operations table and private state.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2CHandle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2CHandle;\n</code></pre> <p>Public I2C handle containing the operations table and private state. </p> <p>Par: Example - Initializing an I2C Handle</p> <pre><code>// Backend (e.g., STM32) provides its operations\nextern const CFBD_I2COperations stm32_i2c_ops;\nextern void *i2c1_private_state;\n\n// Initialize handle\nCFBD_I2CHandle bus = {\n    .ops = &amp;stm32_i2c_ops,\n    .private_handle = i2c1_private_state\n};\n\n// Now ready for use\nCFBD_I2CInit(&amp;bus);\n</code></pre> <p>Represents a complete I2C bus instance combining platform-independent operations with platform-specific state.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__I2COperations/","title":"CFBD_I2COperations","text":"<p>Module: I2C Backend Implementation</p> <p>Function table that a backend must implement to drive an I2C bus.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_I2CHandle *handle) init Initialize the I2C hardware/peripheral. int(*)(CFBD_I2CHandle *handle) deinit Deinitialize the I2C hardware/peripheral. int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer Perform a sequence of I2C messages. int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready Check whether a device is ready (acknowledges) within trials. int(*)(CFBD_I2CHandle *bus) recover_bus Attempt to recover the I2C bus (clock recovery, toggling lines). int(*)(CFBD_I2CHandle *bus) get_error Retrieve the last backend-specific error code. int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start Initiate DMA transmission (optional). int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start Initiate DMA reception (optional)."},{"location":"api/Classes/structCFBD__I2COperations/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2COperations;\n</code></pre> <p>Function table that a backend must implement to drive an I2C bus. </p> <p>Backends populate this table with pointers to concrete functions that implement initialization, transfers and optional DMA operations. This design enables pluggable I2C backends (STM32, ESP32, etc.) while maintaining a unified public interface. </p>"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2COperations/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) init;\n</code></pre> <p>Initialize the I2C hardware/peripheral. </p> <p>Return: I2C_OK on success, or negative error code on failure </p> <p>Called once during system startup to configure clock, pins, and I2C peripheral registers.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-deinit","title":"variable deinit","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) deinit;\n</code></pre> <p>Deinitialize the I2C hardware/peripheral. </p> <p>Return: I2C_OK on success, or negative error code on failure </p> <p>Clean shutdown: disables interrupts, releases DMA, powers down hardware.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-transfer","title":"variable transfer","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer;\n</code></pre> <p>Perform a sequence of I2C messages. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>msgs Array of messages to transfer </li> <li>num Number of messages </li> <li>timeout_ms Operation timeout in milliseconds </li> </ul> <p>Return: I2C_OK on success, or negative error code </p> <p>Core transfer function. Must support multiple messages in a single transaction (write-read patterns, repeated START, etc.).</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-is_device_ready","title":"variable is_device_ready","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready;\n</code></pre> <p>Check whether a device is ready (acknowledges) within trials. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>addr Device address (7-bit) </li> <li>trials Number of probe attempts </li> <li>timeout_ms Per-trial timeout </li> </ul> <p>Return: I2C_OK if device acknowledged, negative error otherwise </p> <p>Probes device presence by attempting multiple transactions. Useful for detecting device hotplug, power-on sequences, etc.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-recover_bus","title":"variable recover_bus","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) recover_bus;\n</code></pre> <p>Attempt to recover the I2C bus (clock recovery, toggling lines). </p> <p>Return: I2C_OK if recovered, negative error if recovery failed </p> <p>Handles stuck bus scenarios by toggling SCL, sending dummy clocks, or performing platform-specific recovery procedures.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-get_error","title":"variable get_error","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) get_error;\n</code></pre> <p>Retrieve the last backend-specific error code. </p> <p>Return: Backend-specific error code </p> <p>Returns additional error details beyond the standard error codes, such as hardware-specific status registers or state flags.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-tx_dma_start","title":"variable tx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start;\n</code></pre> <p>Initiate DMA transmission (optional). </p> <p>Return: I2C_OK if DMA started, error code otherwise </p> <p>Enables efficient bulk data transmission via DMA. Can return I2C_ERR_INVAL if DMA not supported.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-rx_dma_start","title":"variable rx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start;\n</code></pre> <p>Initiate DMA reception (optional). </p> <p>Return: I2C_OK if DMA started, error code otherwise </p> <p>Enables efficient bulk data reception via DMA.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/","title":"CFBD_I2C_IORequestParams","text":"<p>Helper structure used by convenience read/write helpers.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr7 uint32_t mem_addr uint8_t mem_addr_size uint8_t * data uint16_t len uint32_t timeout_ms"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2C_IORequestParams;\n</code></pre> <p>Helper structure used by convenience read/write helpers. </p> <p>Par: Example - Register Read</p> <pre><code>uint8_t register_value[4];\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x50,           // Device address\n    .mem_addr = 0x0100,      // Register/memory address in device\n    .mem_addr_size = 2,      // 2-byte register address\n    .data = register_value,\n    .len = sizeof(register_value),\n    .timeout_ms = 1000\n};\n\nif (CFBD_I2CRead(bus, &amp;req) == I2C_OK) {\n    // register_value now contains data from address 0x0100\n}\n</code></pre> <p>Simplifies high-level I2C read/write operations by bundling common parameters (address, register offset, buffer, timeout) into a single structure.</p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-addr7","title":"variable addr7","text":"<pre><code>uint16_t addr7;\n</code></pre> <p>7-bit I2C address. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr","title":"variable mem_addr","text":"<pre><code>uint32_t mem_addr;\n</code></pre> <p>Optional device memory/register address. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr_size","title":"variable mem_addr_size","text":"<pre><code>uint8_t mem_addr_size;\n</code></pre> <p>Size in bytes of <code>mem_addr</code>. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-data","title":"variable data","text":"<pre><code>uint8_t * data;\n</code></pre> <p>Pointer to data buffer. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre> <p>Length of <code>data</code> in bytes. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-timeout_ms","title":"variable timeout_ms","text":"<pre><code>uint32_t timeout_ms;\n</code></pre> <p>Operation timeout in milliseconds. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__I2C__Message/","title":"CFBD_I2C_Message","text":"<p>Single I2C message description used for multi-message transfers.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2C__Message/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2C_Message;\n</code></pre> <p>Single I2C message description used for multi-message transfers. </p> <p>Par: </p> <ul> <li>Message Direction</li> </ul> <p>The <code>flags</code> field determines message direction:</p> <ul> <li>flags = 0: Write (master -&gt; slave)</li> <li>flags = I2C_M_RD: Read (slave -&gt; master)</li> <li>Example - Multi-Message Transaction</li> </ul> <pre><code>// Read register 0x20 from SSD1306 OLED display\nCFBD_I2C_Message msgs[2];\nuint8_t addr_byte = 0x20;\nuint8_t reg_data[2];\n\n// Message 1: Send register address (write)\nmsgs[0].addr = 0x3C;       // OLED I2C address\nmsgs[0].flags = 0;         // Write operation\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;addr_byte;\n\n// Message 2: Read register contents\nmsgs[1].addr = 0x3C;\nmsgs[1].flags = I2C_M_RD;  // Read operation\nmsgs[1].len = 2;\nmsgs[1].buf = reg_data;\n\n// Execute both messages atomically\nint status = CFBD_I2CTransfer(bus, msgs, 2, 1000);\n</code></pre> <p>Provides the address, flags, buffer pointer and length for one message in a potentially multi-message transfer. The <code>addr</code> field contains a 7-bit device address.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/","title":"CFBD_MenuItemCallbackPack","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItemCallback callback void * user_data"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-callback","title":"variable callback","text":"<pre><code>CFBD_MenuItemCallback callback;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-user_data","title":"variable user_data","text":"<pre><code>void * user_data;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__MenuOps/","title":"CFBD_MenuOps","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation void(*)(CFBD_Menu *pMenu) immediate_draw draw immediately void(*)(CFBD_Menu *pMenu, int index) select_index index selectors void(*)(CFBD_Menu *pMenu) activate_current User Activate the Selections, so things goes on. void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points Reset the places."},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuOps/#variable-bind_item_groups_contains","title":"variable bind_item_groups_contains","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>assigned_menu_items </li> </ul> <p>Note: assigned_menu_items requests long lifetime exsits, recommends being static </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-add_item","title":"variable add_item","text":"<pre><code>CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_indicator_property","title":"variable set_indicator_property","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_animation","title":"variable set_animation","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>pBaseAnimation </li> </ul> <p>Note: pBaseAnimation can be temp, internal assigns </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_Menu *pMenu) immediate_draw;\n</code></pre> <p>draw immediately </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-select_index","title":"variable select_index","text":"<pre><code>void(*)(CFBD_Menu *pMenu, int index) select_index;\n</code></pre> <p>index selectors </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-activate_current","title":"variable activate_current","text":"<pre><code>void(*)(CFBD_Menu *pMenu) activate_current;\n</code></pre> <p>User Activate the Selections, so things goes on. </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-reset_tl_points","title":"variable reset_tl_points","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points;\n</code></pre> <p>Reset the places. </p> <p>Note: immediate draw requests, including clear update and redraw is expected to behave! </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__OLED/","title":"CFBD_OLED","text":"<p>The generic OLED device object exposed to application code.  More...</p> <p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED;\n</code></pre> <p>The generic OLED device object exposed to application code. </p> <p>Note: The oled_internal_handle is opaque and device-specific. Do not access it directly; all device interaction must occur through the ops table. </p> <p>This is the primary interface through which application code interacts with OLED displays. It encapsulates the operation table, device type, and backend-specific state into a single, transport-agnostic interface.</p> <p>Typical usage pattern:</p> <ol> <li>Call CFBD_GetOLEDHandle() to obtain and initialize an instance</li> <li>Call ops-&gt;open() to enable the device</li> <li>Use rendering operations (setPixel, setArea, etc.) to draw</li> <li>Call ops-&gt;update() to push changes to the display</li> <li>Call ops-&gt;close() when done</li> </ol> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__OLEDOperations/","title":"CFBD_OLEDOperations","text":"<p>Virtual operation table implementing OLED driver functionality.  More...</p> <p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLEDOperations/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLEDOperations;\n</code></pre> <p>Virtual operation table implementing OLED driver functionality. </p> <p>Note: All function pointers must be non-NULL unless explicitly stated otherwise. Device implementations should handle edge cases (out-of-bounds coordinates) gracefully by clipping or returning error codes. </p> <p>Concrete device drivers populate an instance of this table and assign it to the ops member of a CFBD_OLED object. This structure defines the complete interface for display operations, lifecycle management, and device queries. Callers should only invoke functions through this table after device initialization.</p> <p>The operation table enables:</p> <ul> <li>Device initialization and lifecycle (init, open, close)</li> <li>Pixel and area rendering (setPixel, setArea)</li> <li>Frame operations (update, clear, revert)</li> <li>Rectangular area operations (update_area, clear_area, revert_area)</li> <li>Device capability queries (self_consult)</li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/","title":"CFBD_OLED_DeviceSpecific","text":"<p>Module: OLED Display Driver / OLED Device Interface</p> <p>Device-specific configuration for an OLED panel.  More...</p> <p><code>#include &lt;device_interface.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes","title":"Public Attributes","text":"Name uint8_t ()(void) init_session_tables Optional callback to return initialization command tables. uint8_t ** grams Array of pointers to GRAM/frame buffers used by the device. uint16_t init_session_tables_sz Size (in bytes) of the initialization tables returned by <code>init_session_tables</code>. uint8_t data_prefix Byte prefix to use for data transmissions to the display. uint8_t cmd_prefix Byte prefix to use for command transmissions to the display. uint16_t logic_width Logical width of the display in pixels. uint16_t logic_height Logical height of the display in pixels."},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED_DeviceSpecific;\n</code></pre> <p>Device-specific configuration for an OLED panel. </p> <p>Note: Implementations must ensure that:</p> <ul> <li>init_session_tables() returns a valid pointer or NULL if no initialization is needed</li> <li>grams points to valid frame buffer pointers</li> <li>All size and geometry fields are correctly populated </li> </ul> <p>Fields in this structure control how the generic OLED driver initializes and communicates with a specific panel. Implementations should populate <code>init_session_tables</code> and <code>grams</code> with pointers to static data describing the initialization sequence and frame buffers respectively.</p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables","title":"variable init_session_tables","text":"<pre><code>uint8_t *(*)(void) init_session_tables;\n</code></pre> <p>Optional callback to return initialization command tables. </p> <p>The callback should allocate or return a pointer to a contiguous block containing the device initialization sequence bytes. If no initialization sequence is required, this may be NULL. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-grams","title":"variable grams","text":"<pre><code>uint8_t ** grams;\n</code></pre> <p>Array of pointers to GRAM/frame buffers used by the device. </p> <p>The driver may expect one or more pointers here depending on the device's memory layout. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables_sz","title":"variable init_session_tables_sz","text":"<pre><code>uint16_t init_session_tables_sz;\n</code></pre> <p>Size (in bytes) of the initialization tables returned by <code>init_session_tables</code>. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-data_prefix","title":"variable data_prefix","text":"<pre><code>uint8_t data_prefix;\n</code></pre> <p>Byte prefix to use for data transmissions to the display. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-cmd_prefix","title":"variable cmd_prefix","text":"<pre><code>uint8_t cmd_prefix;\n</code></pre> <p>Byte prefix to use for command transmissions to the display. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_width","title":"variable logic_width","text":"<pre><code>uint16_t logic_width;\n</code></pre> <p>Logical width of the display in pixels. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_height","title":"variable logic_height","text":"<pre><code>uint16_t logic_height;\n</code></pre> <p>Logical height of the display in pixels. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/","title":"CFBD_OLED_IICInitsParams","text":"<p>Module: OLED Display Integration</p> <p>Initialization parameters for OLED devices using I2C.  More...</p> <p><code>#include &lt;external_impl_driver.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes","title":"Public Attributes","text":"Name CFBD_I2CHandle * i2cHandle Pointer to the I2C handle used for communication. uint32_t accepted_time_delay Minimum or accepted time delay (units implementation-defined). uint16_t device_address 7-bit or 8-bit I2C device address depending on backend. CFBD_OLED_DeviceSpecific * device_specifics Pointer to device-specific configuration and callbacks. void(*)(int status) iic_transition_callback Optional callback invoked on I2C transaction transitions."},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED_IICInitsParams;\n</code></pre> <p>Initialization parameters for OLED devices using I2C. </p> <p>Par: </p> <ul> <li>Field Relationships</li> </ul> <p>All fields must be properly initialized before passing to OLED_Init():</p> <ul> <li><code>i2cHandle</code> must point to an initialized I2C bus</li> <li><code>device_address</code> must match the actual hardware (0x3C or 0x3D typical)</li> <li><code>device_specifics</code> must match the actual display model</li> <li><code>iic_transition_callback</code> may be NULL if polling is acceptable</li> <li>Example - Complete Initialization</li> </ul> <pre><code>// Create and configure the initialization structure\nCFBD_OLED_IICInitsParams params;\n\n// Get I2C bus handle (configured by board layer)\nparams.i2cHandle = get_i2c1_handle();\n\n// Configure device-specific parameters\nparams.device_address = 0x3C;\nparams.accepted_time_delay = 5;           // 5 ticks between ops\nparams.device_specifics = get_ssd1306_config();\nparams.iic_transition_callback = on_iic_complete;\n\n// Initialize OLED\nint result = OLED_Initialize(&amp;params);\n</code></pre> <p>Aggregates the I2C handle, device address, timing parameters and a pointer to device-specific data required by the OLED driver. The optional <code>iic_transition_callback</code> can be supplied by the platform to receive status updates about I2C transaction completion.</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-i2chandle","title":"variable i2cHandle","text":"<pre><code>CFBD_I2CHandle * i2cHandle;\n</code></pre> <p>Pointer to the I2C handle used for communication. </p> <p>Note: The I2C handle remains owned by the board/platform layer. The OLED driver does not take ownership or close it. </p> <p>This should point to a valid <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> provided by the project's I2C driver (<code>lib/iic</code>). The handle must be already initialized before passing to the OLED driver.</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-accepted_time_delay","title":"variable accepted_time_delay","text":"<pre><code>uint32_t accepted_time_delay;\n</code></pre> <p>Minimum or accepted time delay (units implementation-defined). </p> <p>Note: The actual timing behavior depends on the OLED driver implementation and the platform's timer/scheduler. </p> <p>Used by the driver to schedule retries or throttling between transactions. Interpret the unit according to the platform's timing conventions (milliseconds, ticks, scheduler quantum, etc.).</p> <p>Typical values:</p> <ul> <li>0-1: No delay (fast polling systems)</li> <li>1-5: Minimal delay (cooperative multitasking)</li> <li>5-10: Small delay (allows other tasks to run)</li> <li>10+: Significant delay (low-priority display updates)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_address","title":"variable device_address","text":"<pre><code>uint16_t device_address;\n</code></pre> <p>7-bit or 8-bit I2C device address depending on backend. </p> <p>Note: The actual interpretation (7-bit vs 8-bit) is backend-specific. Consult the I2C driver documentation for address format.</p> <p>Par: Example - Address Selection by Hardware</p> <pre><code>// Check SA0 pin to determine address\n#ifdef OLED_SA0_HIGH\n    params.device_address = 0x3D;\n#else\n    params.device_address = 0x3C;\n#endif\n</code></pre> <p>Standard OLED display addresses:</p> <ul> <li>0x3C: Most common (SSD1306, SSD1309 default)</li> <li>0x3D: Alternative address (if SA0 pin tied high)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_specifics","title":"variable device_specifics","text":"<pre><code>CFBD_OLED_DeviceSpecific * device_specifics;\n</code></pre> <p>Pointer to device-specific configuration and callbacks. </p> <p>See: CFBD_OLED_DeviceSpecific</p> <p>Note: Must not be NULL. The OLED driver requires this to be properly initialized for the specific hardware model.</p> <p>Implementation-defined structure describing device parameters such as display geometry, command set quirks, or initialization sequences. The concrete type is <code>[CFBD_OLED_DeviceSpecific](Classes/structCFBD__OLED__DeviceSpecific.md)</code>.</p> <p>Device-specific data typically includes:</p> <ul> <li>Display resolution (width, height in pixels)</li> <li>Controller model (SSD1306, SSD1309, SH1106)</li> <li>Initialization command sequences</li> <li>Timing constants (frame rate, refresh rate)</li> <li>Feature flags (supports DMA, contrast adjustment, etc.)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-iic_transition_callback","title":"variable iic_transition_callback","text":"<pre><code>void(*)(int status) iic_transition_callback;\n</code></pre> <p>Optional callback invoked on I2C transaction transitions. </p> <p>See: CFBD_I2C_AsyncCallback</p> <p>Note: May be NULL if the application does not require async notification. In that case, the driver may use polling or ignore completion status.</p> <p>Par: Callback Pattern - Async Notification</p> <pre><code>void on_display_event(int status) {\n    if (status == I2C_OK) {\n        // Display command executed\n        update_display_state();\n    } else {\n        // Display error\n        increment_error_counter();\n        schedule_retry();\n    }\n}\n\nparams.iic_transition_callback = on_display_event;\n</code></pre> <p>The callback receives an integer <code>status</code> describing the result of a transaction (semantics are platform-defined). Use this to signal completion or error conditions back to the application.</p> <p>Typical status values:</p> <ul> <li>I2C_OK: Transaction succeeded</li> <li>I2C_ERR_NACK: Device not responding</li> <li>I2C_ERR_TIMEOUT: Operation timed out</li> <li>I2C_ERR_BUSY: Bus busy, retry needed</li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/","title":"CFBD_ProgressBarOps","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_ProgressBar *) immediate_draw void(*)(CFBD_ProgressBar *, int32_t new_value) set_value CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property Set Property values, like -&gt; border, uint8_t as boarders -&gt; padding, uint8_t as padding -&gt; animation, CFBD_BaseAnimation* passed."},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_ProgressBar *) immediate_draw;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_value","title":"variable set_value","text":"<pre><code>void(*)(CFBD_ProgressBar *, int32_t new_value) set_value;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_property","title":"variable set_property","text":"<pre><code>CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property;\n</code></pre> <p>Set Property values, like -&gt; border, uint8_t as boarders -&gt; padding, uint8_t as padding -&gt; animation, CFBD_BaseAnimation* passed. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/","title":"CFBD_ST_I2CPrivate","text":"<p>Backend-private state for the STM32 I2C implementation.  More...</p> <p><code>#include &lt;i2c_stm_impl.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes","title":"Public Attributes","text":"Name I2C_HandleTypeDef * hi2c Pointer to the HAL <code>I2C_HandleTypeDef</code> instance. GPIO_TypeDef * scl_port GPIO port for the SCL line. uint16_t scl_pin GPIO pin number (mask) for SCL. GPIO_TypeDef * sda_port GPIO port for the SDA line. uint16_t sda_pin GPIO pin number (mask) for SDA. int last_err Last backend error code (implementation-defined)."},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_ST_I2CPrivate;\n</code></pre> <p>Backend-private state for the STM32 I2C implementation. </p> <p>Stores references to the HAL I2C peripheral instance and the GPIO pins used for SCL and SDA. The <code>last_err</code> field is available to record the most recent backend error and may be consulted by the public <code>get_error</code> operation in <code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code>. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-hi2c","title":"variable hi2c","text":"<pre><code>I2C_HandleTypeDef * hi2c;\n</code></pre> <p>Pointer to the HAL <code>I2C_HandleTypeDef</code> instance. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_port","title":"variable scl_port","text":"<pre><code>GPIO_TypeDef * scl_port;\n</code></pre> <p>GPIO port for the SCL line. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_pin","title":"variable scl_pin","text":"<pre><code>uint16_t scl_pin;\n</code></pre> <p>GPIO pin number (mask) for SCL. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_port","title":"variable sda_port","text":"<pre><code>GPIO_TypeDef * sda_port;\n</code></pre> <p>GPIO port for the SDA line. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_pin","title":"variable sda_pin","text":"<pre><code>uint16_t sda_pin;\n</code></pre> <p>GPIO pin number (mask) for SDA. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-last_err","title":"variable last_err","text":"<pre><code>int last_err;\n</code></pre> <p>Last backend error code (implementation-defined). </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/","title":"_CFBD_GraphicDevice","text":"<p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes","title":"Public Attributes","text":"Name CFBD_GraphicDeviceOperation * ops CFBDGraphic_DeviceType device_type CFBDGraphicDeviceHandle internal_handle CFBD_Bool immediate_draw"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_GraphicDeviceOperation * ops;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-device_type","title":"variable device_type","text":"<pre><code>CFBDGraphic_DeviceType device_type;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-internal_handle","title":"variable internal_handle","text":"<pre><code>CFBDGraphicDeviceHandle internal_handle;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>CFBD_Bool immediate_draw;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/","title":"_CFBD_I2CHandle","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes","title":"Public Attributes","text":"Name const CFBD_I2COperations * ops CFBD_I2CPrivateHandle private_handle"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_I2COperations * ops;\n</code></pre> <p>Backend operation table. </p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-private_handle","title":"variable private_handle","text":"<pre><code>CFBD_I2CPrivateHandle private_handle;\n</code></pre> <p>Backend-specific state. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/","title":"_CFBD_I2C_Message","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr uint16_t flags uint16_t len uint8_t * buf"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-addr","title":"variable addr","text":"<pre><code>uint16_t addr;\n</code></pre> <p>7-bit address (0..0x7F) </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-flags","title":"variable flags","text":"<pre><code>uint16_t flags;\n</code></pre> <p>I2C Message Flags (see I2C_M_* macros) </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre> <p>length of buffer </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t * buf;\n</code></pre> <p>pointer to data </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__Menu/","title":"_CFBD_Menu","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuOps * operations CFBD_GraphicDevice * device CFBD_MenuItemGroup * menu_items CFBDGraphic_Point tl_point SizeBaseType max_width int selected CFBD_MenuIndicator indicator CFBD_BaseAnimation animation"},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__Menu/#variable-operations","title":"variable operations","text":"<pre><code>CFBD_MenuOps * operations;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-menu_items","title":"variable menu_items","text":"<pre><code>CFBD_MenuItemGroup * menu_items;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-max_width","title":"variable max_width","text":"<pre><code>SizeBaseType max_width;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-selected","title":"variable selected","text":"<pre><code>int selected;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-indicator","title":"variable indicator","text":"<pre><code>CFBD_MenuIndicator indicator;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED/","title":"_CFBD_OLED","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes","title":"Public Attributes","text":"Name const CFBD_OLEDOperations * ops Pointer to the operation table. CFBD_OLEDDriverType driver_type The underlying transport/driver type used for this device. CFBD_OLEDHandle oled_internal_handle Opaque backend-specific handle and state."},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_OLEDOperations * ops;\n</code></pre> <p>Pointer to the operation table. </p> <p>Device drivers populate this with concrete implementations of all OLED operations. Must be non-NULL after device initialization. </p>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-driver_type","title":"variable driver_type","text":"<pre><code>CFBD_OLEDDriverType driver_type;\n</code></pre> <p>The underlying transport/driver type used for this device. </p> <p>Identifies whether communication occurs via I2C, SPI, or another transport mechanism. Affects the format of initialization parameters and internal implementation details. </p>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-oled_internal_handle","title":"variable oled_internal_handle","text":"<pre><code>CFBD_OLEDHandle oled_internal_handle;\n</code></pre> <p>Opaque backend-specific handle and state. </p> <p>Contains driver-specific state, including transport handles, device addresses, frame buffers, and callback contexts. Callers must not access or dereference this directly. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/","title":"_CFBD_OLED_OPS","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_OLED *oled, void *init_args) init Initialize the OLED device. CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel Set a single pixel at (x, y) to on/enabled state. CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea Write a block of pixel data to a rectangular area. FrameOperation update Push the local frame buffer to the display. FrameOperation clear Clear the entire display and frame buffer. FrameOperation revert Revert the display to the previous frame content (if supported). AreaOperations update_area Update a rectangular area on the display. AreaOperations clear_area Clear a rectangular area on the display and buffer. AreaOperations revert_area Revert a rectangular area to its previous content (if supported). OLEDSelfOperation open Open/enable the display device. OLEDSelfOperation close Close/disable the display device. OLED_QueryOperation self_consult Query device properties and capabilities."},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_OLED *oled, void *init_args) init;\n</code></pre> <p>Initialize the OLED device. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance. </li> <li>init_args Optional device-specific initialization arguments. </li> </ul> <p>Return: int Status code; typically 0 for success, negative for errors. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel;\n</code></pre> <p>Set a single pixel at (x, y) to on/enabled state. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance. </li> <li>x X coordinate of the pixel. </li> <li>y Y coordinate of the pixel. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre> <p>Write a block of pixel data to a rectangular area. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_OLED instance. </li> <li>x X coordinate of the area's top-left corner. </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. </li> <li>height Height of the area in pixels. </li> <li>source Pointer to source bitmap data. Format is device-dependent. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update","title":"variable update","text":"<pre><code>FrameOperation update;\n</code></pre> <p>Push the local frame buffer to the display. </p> <p>Synchronizes the local frame buffer (frame RAM) with the display, making all buffered changes visible on the physical display. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear","title":"variable clear","text":"<pre><code>FrameOperation clear;\n</code></pre> <p>Clear the entire display and frame buffer. </p> <p>Clears all pixels on the display and in the local frame buffer, typically by writing zero bytes to all GRAM locations. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert","title":"variable revert","text":"<pre><code>FrameOperation revert;\n</code></pre> <p>Revert the display to the previous frame content (if supported). </p> <p>Restores the previously displayed content. Not all devices support this operation; implementation may return CFBD_FALSE if unavailable. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update_area","title":"variable update_area","text":"<pre><code>AreaOperations update_area;\n</code></pre> <p>Update a rectangular area on the display. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear_area","title":"variable clear_area","text":"<pre><code>AreaOperations clear_area;\n</code></pre> <p>Clear a rectangular area on the display and buffer. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert_area","title":"variable revert_area","text":"<pre><code>AreaOperations revert_area;\n</code></pre> <p>Revert a rectangular area to its previous content (if supported). </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-open","title":"variable open","text":"<pre><code>OLEDSelfOperation open;\n</code></pre> <p>Open/enable the display device. </p> <p>Powers on the display and initializes hardware resources. Must be called before using display operations. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-close","title":"variable close","text":"<pre><code>OLEDSelfOperation close;\n</code></pre> <p>Close/disable the display device. </p> <p>Powers off the display and releases hardware resources. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-self_consult","title":"variable self_consult","text":"<pre><code>OLED_QueryOperation self_consult;\n</code></pre> <p>Query device properties and capabilities. </p> <p>Retrieves device-specific information such as resolution, color depth, and supported features. Implementations must support at least:</p> <ul> <li>\"rgb\" (CFBD_Bool): CFBD_TRUE for RGB, CFBD_FALSE for monochrome</li> <li>\"width\" (uint16_t): Display width in pixels</li> <li>\"height\" (uint16_t): Display height in pixels</li> </ul> <p>Additional device-specific properties may be queried as needed. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBDApplication/","title":"__CFBDApplication","text":"<p>Module: Application Management</p> <p>Application descriptor.  More...</p> <p><code>#include &lt;app.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc selfBootFunc Optional bootstrap function for the application. CFBD_BootArgs bootargs Opaque pointer passed to <code>selfBootFunc</code> when invoked. CFBD_ClockFreqProvider freq_provider Provider that returns the system clock frequency (Hz). CFBD_ClockTickProvider tick_provider Provider that returns a monotonically increasing tick value."},{"location":"api/Classes/struct____CFBDApplication/#detailed-description","title":"Detailed Description","text":"<pre><code>struct __CFBDApplication;\n</code></pre> <p>Application descriptor. </p> <p>See: </p> <ul> <li>getApp()</li> <li>CFBD_AppBootMaker()</li> <li>CFBD_AppClockProvider()</li> <li>CFBD_AppTickProvider()</li> </ul> <p>Aggregates the bootstrap function and clock providers for an application. Typical usage is to expose a single application instance via <code>[getApp()](Modules/group__Application__Module.md#function-getapp)</code> that other framework components query to obtain boot actions and timing sources.</p> <p>The application descriptor serves as a central registry for all application-level services, allowing framework components to access initialization routines and timing information without requiring direct coupling to application code.</p>"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDApplication/#variable-selfbootfunc","title":"variable selfBootFunc","text":"<pre><code>CFBD_BootStrapFunc selfBootFunc;\n</code></pre> <p>Optional bootstrap function for the application. </p> <p>Note: If NULL, the application framework will skip this step and rely on explicit boot table instead. </p> <p>When non-NULL, this function will be called during application startup to perform any app-specific initialization. Must match the <code>CFBD_BootStrapFunc</code> signature.</p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-bootargs","title":"variable bootargs","text":"<pre><code>CFBD_BootArgs bootargs;\n</code></pre> <p>Opaque pointer passed to <code>selfBootFunc</code> when invoked. </p> <p>Interpretation is defined by the bootstrap function. Common usage includes passing a configuration structure or application-specific context. </p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-freq_provider","title":"variable freq_provider","text":"<pre><code>CFBD_ClockFreqProvider freq_provider;\n</code></pre> <p>Provider that returns the system clock frequency (Hz). </p> <p>See: CFBD_ClockFreqProvider</p> <p>If NULL, timing calculations will fail. All timing-sensitive operations require this provider to be set.</p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-tick_provider","title":"variable tick_provider","text":"<pre><code>CFBD_ClockTickProvider tick_provider;\n</code></pre> <p>Provider that returns a monotonically increasing tick value. </p> <p>See: CFBD_ClockTickProvider</p> <p>If NULL, interval measurements will be unavailable. Used in conjunction with freq_provider for time calculations.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/","title":"__CFBD_BaseAnimation","text":"<p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes","title":"Public Attributes","text":"Name uint8_t anim_frames uint32_t anim_frame_delay_ms"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frames","title":"variable anim_frames","text":"<pre><code>uint8_t anim_frames;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frame_delay_ms","title":"variable anim_frame_delay_ms","text":"<pre><code>uint32_t anim_frame_delay_ms;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/","title":"__CFBD_MenuIndicator","text":"<p><code>#include &lt;menu_indicator.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes","title":"Public Attributes","text":"Name uint8_t width uint8_t x"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-width","title":"variable width","text":"<pre><code>uint8_t width;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-x","title":"variable x","text":"<pre><code>uint8_t x;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItem/","title":"__CFBD_MenuItem","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes","title":"Public Attributes","text":"Name char * label CFBDGraphic_Point tl CFBD_MenuItemCallbackPack on_select CFBDGraphic_Text text_obj"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-label","title":"variable label","text":"<pre><code>char * label;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-on_select","title":"variable on_select","text":"<pre><code>CFBD_MenuItemCallbackPack on_select;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-text_obj","title":"variable text_obj","text":"<pre><code>CFBDGraphic_Text text_obj;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/","title":"__CFBD_MenuItemArray","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItem * pItems size_t capacity size_t count"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-pitems","title":"variable pItems","text":"<pre><code>CFBD_MenuItem * pItems;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-capacity","title":"variable capacity","text":"<pre><code>size_t capacity;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-count","title":"variable count","text":"<pre><code>size_t count;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/","title":"__CFBD_ProgressBar","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes","title":"Public Attributes","text":"Name CFBD_ProgressBarOps * ops CFBDGraphic_Point tl CFBDGraphicSize size int32_t min int32_t max int32_t value CFBD_GraphicDevice * device uint8_t border uint8_t padding CFBD_BaseAnimation animation"},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-size","title":"variable size","text":"<pre><code>CFBDGraphicSize size;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-min","title":"variable min","text":"<pre><code>int32_t min;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-max","title":"variable max","text":"<pre><code>int32_t max;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-value","title":"variable value","text":"<pre><code>int32_t value;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-border","title":"variable border","text":"<pre><code>uint8_t border;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-padding","title":"variable padding","text":"<pre><code>uint8_t padding;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h","text":"<pre><code>// Example 1: 90-degree quarter arc\nCCGraphic_Arc quarter = {\n    .center = {160, 120},\n    .radius = 50,\n    .start_degree = 0,\n    .end_degree = 90\n};\nCFBDGraphic_DrawArc(device, &amp;quarter);\n\n// Example 2: Progress indicator (filled arc)\nCCGraphic_Arc progress = {\n    .center = {160, 120},\n    .radius = 40,\n    .start_degree = 0,\n    .end_degree = 270  // 75% complete\n};\nCFBDGraphic_DrawFilledArc(device, &amp;progress);\n\n// Example 3: Clock hour markers (12 arcs)\nfor (int i = 0; i &lt; 12; i++) {\n    int angle = (i * 30);  // 30 degrees per hour\n    CCGraphic_Arc marker = {\n        .center = {160, 120},\n        .radius = 60,\n        .start_degree = angle,\n        .end_degree = angle + 5\n    };\n    CFBDGraphic_DrawArc(device, &amp;marker);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct {     CFBDGraphic_Point center;</p> <pre><code>PointBaseType radius;\n\nint16_t start_degree;\n\nint16_t end_degree;\n</code></pre> <p>} CCGraphic_Arc;</p> <p>void CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);</p> <p>void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);</p> <p>// End of Arc_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h","text":"<pre><code>// Example 1: Draw a simple circle outline\nCFBDGraphicCircle indicator = {\\n *     .radius = 20,\n    .center = {160, 120}\n};\nCFBDGraphic_DrawCircle(display_device, &amp;indicator);\n\n// Example 2: Draw filled circles of increasing size\nfor (int r = 10; r &lt; 50; r += 10) {\n    CFBDGraphicCircle circle = {.radius = r, .center = {160, 120}};\n    CFBDGraphic_DrawFilledCircle(display_device, &amp;circle);\n}\n\n// Example 3: Multiple circles for a radar display\nCFBDGraphicCircle radar_rings[] = {\n    {.radius = 30, .center = {160, 120}},\n    {.radius = 60, .center = {160, 120}},\n    {.radius = 90, .center = {160, 120}}\n};\nfor (int i = 0; i &lt; 3; i++) {\n    CFBDGraphic_DrawCircle(device, &amp;radar_rings[i]);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct {     SizeBaseType radius;</p> <pre><code>CFBDGraphic_Point center;\n</code></pre> <p>} CFBDGraphicCircle;</p> <p>void CFBDGraphic_DrawCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);</p> <p>void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);</p> <p>// End of Circle_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h","text":"<pre><code>// Create a circle with center at (160, 120) and radius 50\nCCGraphic_Ellipse circle = {\n    {160, 120},  // center\n    50,          // X_Radius\n    50           // Y_Radius\n};\nCFBDGraphic_DrawEllipse(device, &amp;circle);\n\n// Create an ellipse with different horizontal and vertical radii\nCCGraphic_Ellipse ellipse = {\n    {160, 120},  // center\n    80,          // X_Radius (wider)\n    50           // Y_Radius (narrower)\n};\nCFBDGraphic_DrawEllipse(device, &amp;ellipse);\n\n// Draw a filled ellipse\nCCGraphic_Ellipse filled_ellipse = {{320, 240}, 30, 40};\nCFBDGraphic_DrawFilledEllipse(device, &amp;filled_ellipse);\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct {     CFBDGraphic_Point center;      PointBaseType X_Radius;      PointBaseType Y_Radius;  } CCGraphic_Ellipse;</p> <p>void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);</p> <p>void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);</p> <p>// End of Ellipse_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h","text":"<pre><code>// Create a horizontal line from (50, 100) to (200, 100)\nCFBDGraphic_Line horizontal_line = {\n    {50, 100},   // p_left\n    {200, 100}   // p_right\n};\n\n// Create a diagonal line from (0, 0) to (100, 100)\nCFBDGraphic_Point start = {0, 0};\nCFBDGraphic_Point end = {100, 100};\nCFBDGraphic_Line diagonal = {start, end};\n\n// Using points defined elsewhere\nCFBDGraphic_Line custom_line = {center_point, edge_point};\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct {     CFBDGraphic_Point p_left;     CFBDGraphic_Point p_right;  } CFBDGraphic_Line;</p> <p>void CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line);</p> <p>// End of Line_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h","text":"<pre><code>// Create a point at coordinates (100, 200)\nCFBDGraphic_Point my_point = {100, 200};\n\n// Add two points together with automatic clamping\nCFBDGraphic_Point point1 = {50, 75};\nCFBDGraphic_Point point2 = {100, 150};\nCFBDGraphic_Point result = point_add(point1, point2);\n// result: {150, 225}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":"<p>typedef struct {     PointBaseType x;      PointBaseType y;  } CFBDGraphic_Point;</p> <p>typedef struct {     int32_t x;      int32_t y;  } CFBDGraphic_Vec2i;</p> <p>static inline CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b) {     uint32_t x = (uint32_t) a.x + b.x;     uint32_t y = (uint32_t) a.y + b.y;</p> <pre><code>if (x &gt; UINT16_MAX)\n    x = UINT16_MAX;\nif (y &gt; UINT16_MAX)\n    y = UINT16_MAX;\n\nreturn (CFBDGraphic_Point) {(uint16_t) x, (uint16_t) y};\n</code></pre> <p>}</p> <p>static inline CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b) {     return (CFBDGraphic_Vec2i) {(int32_t) a.x - (int32_t) b.x, (int32_t) a.y - (int32_t) b.y}; }</p> <p>// End of Point_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h","text":"<pre><code>// Create a size for a 320x240 display\nCFBDGraphicSize screen_size = {320, 240};\n\n// Create a size for a button\nCFBDGraphicSize button_size = {80, 40};\n\n// Get screen size from device\nCFBDGraphicSize dev_size;\nCFBDGraphic_GetScreenSize(graphics_device, &amp;dev_size);\n\n// Use size to calculate area\nuint32_t area = dev_size.width * dev_size.height;\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#include-devicegraphic_deviceh","title":"include \"device/graphic_device.h\"","text":"<p>typedef struct {     SizeBaseType width;     SizeBaseType height;  } CFBDGraphicSize;</p> <p>void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize);</p> <p>// End of Size_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2backend_2oled_iic_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic.h","text":"<p>Initialize an I2C-based OLED device instance.Performs the necessary wiring between the generic CFBD_OLED object and the platform-specific I2C implementation described by pvt_handle. This function configures the device address, binds the I2C handle, and sets up callbacks for asynchronous transaction notifications.</p> <p>After calling this function, the OLED object is ready for device operations. The caller must ensure that the I2C interface is properly initialized before calling this function.</p> <pre><code>// Example: Complete I2C OLED initialization flow\n#include \"driver/backend/oled_iic.h\"\n#include \"driver/device/ssd1309/ssd1309.h\"\n\n// Step 1: Prepare I2C parameters\nCFBD_OLED_IICInitsParams iic_params = {\n    .device_address = SSD1309_DRIVER_ADDRESS,\n    .i2c_handle = my_i2c_interface,\n    .notify_tx_complete = on_transaction_complete,\n    .notify_error = on_i2c_error\n};\n\n// Step 2: Create and initialize OLED instance\nCFBD_OLED oled_device;\nCFBD_OLED_IICInit(&amp;oled_device, &amp;iic_params);\n\n// Step 3: Open the device and begin operations\nif (oled_device.ops-&gt;open(&amp;oled_device)) {\n    // Device is ready for use\n    oled_device.ops-&gt;update(&amp;oled_device);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h","text":"<pre><code>// Example: Getting device-specific descriptor and querying geometry\nCFBD_OLED_DeviceSpecific* device_spec = getSSD1306Specific();\nif (device_spec != NULL) {\n    uint16_t width = device_spec-&gt;logic_width;\n    uint16_t height = device_spec-&gt;logic_height;\n    uint8_t* frame_buffer = device_spec-&gt;grams[0];\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/#include","title":"include  <p>typedef struct {     uint8_t* (*init_session_tables)(void);</p> <pre><code>uint8_t** grams;\n\nuint16_t init_session_tables_sz;\n\nuint8_t data_prefix;\n\nuint8_t cmd_prefix;\n\nuint16_t logic_width;\n\nuint16_t logic_height;\n</code></pre> <p>} CFBD_OLED_DeviceSpecific;</p> <p>// end of OLED_Device group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h</p>  <p>Updated on 2026-01-10 at 03:19:52 +0000</p>","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1306_2ssd1306_8h-example/","title":"2home 2runner 2work 2BareMetal Drivers 2BareMetal Drivers 2lib 2oled 2driver 2device 2ssd1306 2ssd1306 8h example","text":"<p>title: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h summary: Factory function: returns the SSD1306 device-specific descriptor. </p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1306_2ssd1306_8h-example/#homerunnerworkbaremetal-driversbaremetal-driversliboleddriverdevicessd1306ssd1306h","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h","text":"<p>Factory function: returns the SSD1306 device-specific descriptor.Retrieves a pointer to the static SSD1306 device descriptor. This descriptor encapsulates all hardware-specific parameters needed to initialize and operate an SSD1306 display via the generic OLED driver interface.</p> <p>The returned descriptor contains:</p> <ul> <li>Initialization command sequences</li> <li>Frame buffer (GRAM) pointers</li> <li>I2C/SPI communication prefixes</li> <li>Display resolution (typically 128x64)</li> </ul> <pre><code>// Example: Obtaining SSD1306 device descriptor for initialization\n#include \"driver/device/ssd1306/ssd1306.h\"\n#include \"oled.h\"\n\nCFBD_OLED_DeviceSpecific* device = getSSD1306Specific();\nCFBD_OLED oled_handle;\nCFBD_OLEDDriverType driver_type = CFBD_OLEDDriverType_IIC;\n\n// The device descriptor is passed implicitly through the driver initialization\nCFBD_GetOLEDHandle(&amp;oled_handle, driver_type, NULL, CFBD_TRUE);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1309_2ssd1309_8h-example/","title":"2home 2runner 2work 2BareMetal Drivers 2BareMetal Drivers 2lib 2oled 2driver 2device 2ssd1309 2ssd1309 8h example","text":"<p>title: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h summary: Factory function: returns the SSD1309 device-specific descriptor. </p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1309_2ssd1309_8h-example/#homerunnerworkbaremetal-driversbaremetal-driversliboleddriverdevicessd1309ssd1309h","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h","text":"<p>Factory function: returns the SSD1309 device-specific descriptor.Retrieves a pointer to the static SSD1309 device descriptor. This descriptor encapsulates all hardware-specific parameters needed to initialize and operate an SSD1309 display via the generic OLED driver interface.</p> <p>The returned descriptor contains:</p> <ul> <li>Device-specific initialization command sequences</li> <li>Frame buffer (GRAM) pointers optimized for SSD1309 memory layout</li> <li>I2C/SPI communication prefixes with SSD1309-specific values</li> <li>Display resolution adapted for SSD1309 capabilities</li> <li>Enhanced timing and contrast parameters</li> </ul> <pre><code>// Example: Obtaining SSD1309 device descriptor for I2C initialization\n#include \"driver/device/ssd1309/ssd1309.h\"\n#include \"driver/backend/oled_iic.h\"\n#include \"oled.h\"\n\nCFBD_OLED_DeviceSpecific* device = getSSD1309Specific();\nCFBD_OLED oled_handle;\n\n// Setup I2C parameters for SSD1309\nCFBD_OLED_IICInitsParams iic_params = {\n    .device_address = SSD1309_DRIVER_ADDRESS,\n    // ... other I2C parameters\n};\n\n// Initialize OLED device\nCFBD_GetOLEDHandle(&amp;oled_handle, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h","text":"<pre><code>// Example: Clear a rectangular area at (10, 20) with size 64x32\nCFBD_OLED* oled = &amp;my_oled_device;\nCFBD_Bool result = oled-&gt;ops-&gt;clear_area(oled, 10, 20, 64, 32);\nif (result) {\n    oled-&gt;ops-&gt;update_area(oled, 10, 20, 64, 32);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/#include-cfbd_defineh","title":"include \"cfbd_define.h\"","text":"<p>typedef enum {     CFBD_OLEDDriverType_IIC,      CFBD_OLEDDriverType_SPI } CFBD_OLEDDriverType;</p> <p>typedef void* CFBD_OLEDHandle;</p> <p>typedef struct _CFBD_OLED CFBD_OLED;</p> <p>typedef CFBD_Bool (         AreaOperations)(CFBD_OLED oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);</p> <p>typedef CFBD_Bool (FrameOperation)(CFBD_OLED oled);</p> <p>typedef CFBD_Bool (OLEDSelfOperation)(CFBD_OLED oled);</p> <p>typedef CFBD_Bool (OLED_QueryOperation)(CFBD_OLED oled,                                          const char* property,                                          void* args,                                          void* request_data);</p> <p>typedef struct _CFBD_OLED_OPS {     int (init)(CFBD_OLED oled, void* init_args);</p> <pre><code>CFBD_Bool (*setPixel)(CFBD_OLED* oled, uint16_t x, uint16_t y);\n\nCFBD_Bool (*setArea)(CFBD_OLED* device,\n                     uint16_t x,\n                     uint16_t y,\n                     uint16_t width,\n                     uint16_t height,\n                     uint8_t* source);\n\nFrameOperation update;\n\nFrameOperation clear;\n\nFrameOperation revert;\n\nAreaOperations update_area;\n\nAreaOperations clear_area;\n\nAreaOperations revert_area;\n\nOLEDSelfOperation open;\n\nOLEDSelfOperation close;\n\nOLED_QueryOperation self_consult;\n</code></pre> <p>} CFBD_OLEDOperations;</p> <p>typedef struct _CFBD_OLED {     const CFBD_OLEDOperations* ops;</p> <pre><code>CFBD_OLEDDriverType driver_type;\n\nCFBD_OLEDHandle oled_internal_handle;\n</code></pre> <p>} CFBD_OLED;</p> <p>typedef void* CFBDOLED_Params_Inits;</p> <p>CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,                              const CFBD_OLEDDriverType driver_type,                              CFBDOLED_Params_Inits args,                              CFBD_Bool request_immediate_init);</p> <p>// end of OLED group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/_2strong-example/","title":"2strong example","text":"<p>title: &gt;: Comprehensive guides and reference documentation</p>"},{"location":"api/Examples/_2strong-example/#-comprehensive-guides-and-reference-documentation","title":"&gt;: Comprehensive guides and reference documentation","text":"<p>: Practical code examples demonstrating usage</p> <ul> <li> <ul> <li>**Pages ( ```</li> </ul> </li> </ul> <p>Filename: /strong</p> <p>**</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/blocks-example/","title":"blocks","text":"<ul> <li> <ul> <li>Complete working programs</li> </ul> </li> <li> <ul> <li>Practical usage demonstrations</li> </ul> </li> <li> <ul> <li>Pages Tab:</li> </ul> </li> <li> <ul> <li>OLED Usage Guide (comprehensive guide)</li> </ul> </li> <li> <ul> <li>OLED Examples (10+ code samples)</li> </ul> </li> <li> <ul> <li>OLED Namespace (namespace organization)</li> </ul> </li> <li> <ul> <li>OLED Documentation Summary (this page)</li> </ul> </li> <li> <ul> <li>Namespaces Tab:</li> </ul> </li> <li> <ul> <li>CFBD - Core Framework Bare Device</li> </ul> </li> <li> <ul> <li>CFBD::OLED - OLED Display Driver</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#documentation-guidelines","title":"Documentation Guidelines","text":"<ul> <li> <ul> <li>The documentation follows these principles:</li> </ul> </li> <li> <ul> <li> <ul> <li>Completeness: All public APIs are documented</li> </ul> </li> </ul> </li> <li> <ul> <li>Clarity: Technical terms are explained</li> </ul> </li> <li> <ul> <li>Examples: Practical code examples included</li> </ul> </li> <li> <ul> <li>Cross-referencing: Related concepts are linked</li> </ul> </li> <li> <ul> <li>Hierarchy: Information is organized logically</li> </ul> </li> <li> <ul> <li>Audience: Both beginners and advanced users are served</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#generating-documentation","title":"Generating Documentation","text":"<ul> <li> <ul> <li>To generate the Doxygen documentation:</li> </ul> </li> <li> <ul> <li><code>bash</code></li> </ul> </li> <li><code>doxygen Doxyfile *</code></li> <li> <ul> <li>The output will be generated in the configured directory (typically <code>documentation/</code>).</li> </ul> </li> <li> <ul> <li>Key configuration points in Doxyfile:</li> </ul> </li> <li> <ul> <li>EXAMPLE_PATH: Directory containing example files</li> </ul> </li> <li> <ul> <li>GENERATE_HTML: HTML output generation</li> </ul> </li> <li> <ul> <li>GENERATE_LATEX: PDF generation</li> </ul> </li> <li> <ul> <li>EXTRACT_ALL: Whether to document all entities</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#related-resources","title":"Related Resources","text":"<ul> <li> <ul> <li> <ul> <li>OLED Driver Usage Guide - Comprehensive guide for developers</li> </ul> </li> </ul> </li> <li> <ul> <li>Code Examples - 10+ practical examples</li> </ul> </li> <li> <ul> <li>README.md - Project overview and build instructions</li> </ul> </li> <li> <ul> <li>Doxyfile - Doxygen configuration</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#maintaining-documentation","title":"Maintaining Documentation","text":"<ul> <li> <ul> <li>When adding new features to the OLED driver:</li> </ul> </li> <li> <ul> <li> <ol> <li>Add comprehensive comments to header files</li> </ol> </li> </ul> </li> <li> <ol> <li>Use ```</li> </ol> </li> </ul> <p>Filename: blocks</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/code-example/","title":"code","text":"<p>blocks for new operations</p> <ul> <li> <ol> <li>Update ```</li> </ol> </li> </ul> <p>Filename: code</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Examples/for-example/","title":"standalone pages","text":"<p>code examples</p> <ul> <li> <ul> <li><code>@code</code>  / for code blocks</li> </ul> </li> <li> <ul> <li><code>@see</code> /standalone pages cross-references</li> </ul> </li> <li> <ul> <li><code>@param</code>  for parameter documentation</li> </ul> </li> <li> <ul> <li><code>@return</code>  for return value documentation</li> </ul> </li> <li> <ul> <li><code>@note</code> /for special notes</li> </ul> </li> <li> <ul> <li><code>\\include</code>  for </li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/OLED__Documentation__Summary_8md/","title":"OLED_Documentation_Summary.md","text":""},{"location":"api/Files/OLED__Documentation__Summary_8md/#namespaces","title":"Namespaces","text":"Name for"},{"location":"api/Files/OLED__Documentation__Summary_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_Documentation_Summary OLED Documentation Summary\n *\n * This page summarizes the comprehensive Doxygen documentation additions made\n * to the OLED driver subsystem.\n *\n * @section DocumentationEnhancements Overview of Enhancements\n *\n * The OLED driver documentation has been significantly enhanced to support\n * Doxygen's advanced features, including:\n *\n * - **Modules (@defgroup)**: Hierarchical organization of related components\n * - **Examples (@example)**: Practical code examples demonstrating usage\n * - **Pages (@page)**: Comprehensive guides and reference documentation\n * - **Detailed Comments**: Extended @details sections with implementation guidance\n *\n * @section ModuleHierarchy Module Organization\n *\n * The OLED subsystem is organized into the following modules:\n *\n * @subsection MainModule OLED - Main Display Driver\n * - **Location**: oled.h\n * - **Purpose**: Generic OLED interface and device operations\n * - **Contents**:\n *   - CFBD_OLED device structure\n *   - CFBD_OLEDOperations virtual operation table\n *   - CFBD_OLEDDriverType transport enumeration\n *   - CFBD_GetOLEDHandle() factory function\n *\n * @subsection DeviceModule OLED_Device - Device Interface\n * - **Location**: device_interface.h, ssd1306.h, ssd1309.h\n * - **Purpose**: Device-specific configurations and factories\n * - **Contents**:\n *   - CFBD_OLED_DeviceSpecific structure\n *   - getSSD1306Specific() factory function\n *   - getSSD1309Specific() factory function\n *   - SSD1309_DRIVER_ADDRESS constant\n *\n * @subsection BackendModule OLED_Backend - Transport Backends\n * - **Location**: oled_iic.h (and potentially future spi backends)\n * - **Purpose**: Transport-specific implementations\n * - **Contents**:\n *   - CFBD_OLED_IICInit() I2C initialization\n *   - Backend parameter structures\n *   - Transport configuration\n *\n * @section DocumentationFiles New Documentation Files\n *\n * Three comprehensive documentation files have been created:\n *\n * @subsection UsageGuideFile OLED_UsageGuide.md (@page OLED_UsageGuide)\n * - **Purpose**: Comprehensive user guide for OLED driver usage\n * - **Contents**:\n *   - Architecture overview\n *   - Getting started instructions (steps 1-4)\n *   - Common operations guide\n *   - Complete working example\n *   - Performance considerations\n *   - Troubleshooting guide\n * - **Target Audience**: Application developers\n *\n * @subsection ExamplesFile OLED_Examples.md (@page OLED_Examples)\n * - **Purpose**: Collection of practical code examples\n * - **Contents**:\n *   - 10+ complete, runnable examples\n *   - Basic initialization\n *   - Display clearing and updating\n *   - Pixel and area drawing\n *   - Device property queries\n *   - Multi-display management\n *   - Error handling patterns\n *   - Deferred initialization\n * - **Target Audience**: Developers learning by example\n *\n * @subsection NamespaceFile OLED_Namespace.md (@page OLED Namespace)\n * - **Purpose**: Namespace organization documentation\n * - **Contents**:\n *   - CFBD namespace overview\n *   - CFBD::OLED sub-namespace\n *   - Component organization\n * - **Target Audience**: Architecture documentation readers\n *\n * @section EnhancedDocumentation Enhanced Inline Documentation\n *\n * All header files have received extensive documentation improvements:\n *\n * @subsection oledh_enhancements oled.h Enhancements\n *\n * **Enumerations**:\n * - @ref CFBD_OLEDDriverType: Expanded with detailed transport descriptions\n *\n * **Type Definitions**:\n * - @ref AreaOperations: Enhanced with usage examples\n * - @ref FrameOperation: Detailed operation semantics\n * - @ref OLEDSelfOperation: Lifecycle management documentation\n * - @ref OLED_QueryOperation: Property query protocol and examples\n * - @ref CFBDOLED_Params_Inits: Transport-specific parameter abstraction\n *\n * **Structures**:\n * - @ref CFBD_OLEDOperations: Complete operation table with:\n *   - Field-by-field documentation\n *   - Usage examples\n *   - Supported operation types\n * - @ref CFBD_OLED: Device object with:\n *   - Member descriptions\n *   - Usage patterns\n *   - Lifecycle documentation\n *\n * **Functions**:\n * - @ref CFBD_GetOLEDHandle(): Extended documentation with:\n *   - Multiple usage examples\n *   - Transport-specific parameter guidelines\n *   - Error handling guidance\n *   - Two complete code examples\n *\n * @subsection device_interface_enhancements device_interface.h Enhancements\n *\n * **New @defgroup OLED_Device**:\n * - Hierarchical module organization\n * - Cross-references to device implementations\n * - Module relationships\n *\n * **Structure Documentation**:\n * - @ref CFBD_OLED_DeviceSpecific: Comprehensive documentation with:\n *   - Field descriptions\n *   - Implementation requirements\n *   - Usage examples\n *\n * @subsection device_drivers_enhancements Device Driver Enhancements\n *\n * **ssd1306.h**:\n * - Extended file documentation with SSD1306 capabilities\n * - @ref getSSD1306Specific(): Complete factory function documentation\n * - Usage examples and cross-references\n *\n * **ssd1309.h**:\n * - Extended file documentation with SSD1309 enhancements\n * - @ref SSD1309_DRIVER_ADDRESS: Address constant documentation\n * - @ref getSSD1309Specific(): Comprehensive factory documentation\n * - Multi-example usage patterns\n *\n * @subsection backend_enhancements oled_iic.h Enhancements\n *\n * **New @defgroup OLED_Backend**:\n * - Backend implementation organization\n * - Transport abstraction documentation\n *\n * **Function Documentation**:\n * - @ref CFBD_OLED_IICInit(): Complete I2C initialization with:\n *   - Parameter descriptions\n *   - Step-by-step initialization flow\n *   - Complete working example\n *   - Thread-safety notes\n *\n * @section ExampleProgramming Example: Supported Property Queries\n *\n * The documentation now clearly specifies all supported property queries:\n *\n * ```cpp\n * // Query display width\n * uint16_t width = 0;\n * oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *\n * // Query display height  \n * uint16_t height = 0;\n * oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *\n * // Query RGB color support\n * CFBD_bool is_rgb = CFBD_FALSE;\n * oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n * ```\n *\n * @section DoxygenOutput Expected Doxygen Generation\n *\n * When Doxygen processes these enhanced comments, it will generate:\n *\n * **Modules Tab**:\n * - OLED - OLED Display Driver (main group)\n *   - OLED_Device - OLED Device Interface\n *   - OLED_Backend - OLED Backend Implementations\n *\n * **Examples Tab**:\n * - Multiple code examples from @example blocks\n * - Complete working programs\n * - Practical usage demonstrations\n *\n * **Pages Tab**:\n * - OLED Usage Guide (comprehensive guide)\n * - OLED Examples (10+ code samples)\n * - OLED Namespace (namespace organization)\n * - OLED Documentation Summary (this page)\n *\n * **Namespaces Tab**:\n * - CFBD - Core Framework Bare Device\n *   - CFBD::OLED - OLED Display Driver\n *\n * @section DocumentationGuidelines Documentation Guidelines\n *\n * The documentation follows these principles:\n *\n * - **Completeness**: All public APIs are documented\n * - **Clarity**: Technical terms are explained\n * - **Examples**: Practical code examples included\n * - **Cross-referencing**: Related concepts are linked\n * - **Hierarchy**: Information is organized logically\n * - **Audience**: Both beginners and advanced users are served\n *\n * @section GeneratingDocumentation Generating Documentation\n *\n * To generate the Doxygen documentation:\n *\n * ```bash\n * doxygen Doxyfile\n * ```\n *\n * The output will be generated in the configured directory (typically `documentation/`).\n *\n * **Key configuration points in Doxyfile**:\n * - EXAMPLE_PATH: Directory containing example files\n * - GENERATE_HTML: HTML output generation\n * - GENERATE_LATEX: PDF generation\n * - EXTRACT_ALL: Whether to document all entities\n *\n * @section RelatedDocumentation Related Resources\n *\n * - @ref OLED_UsageGuide \"OLED Driver Usage Guide\" - Comprehensive guide for developers\n * - @ref OLED_Examples \"Code Examples\" - 10+ practical examples\n * - README.md - Project overview and build instructions\n * - Doxyfile - Doxygen configuration\n *\n * @section DocumentationMaintenance Maintaining Documentation\n *\n * When adding new features to the OLED driver:\n *\n * 1. Add comprehensive comments to header files\n * 2. Use @defgroup for new module concepts\n * 3. Add @example code blocks for new operations\n * 4. Update @page documents with new information\n * 5. Maintain cross-references between related items\n * 6. Keep examples in sync with implementation\n *\n * @section SupportedDoxygenFeatures Doxygen Features Used\n *\n * This documentation makes use of:\n * - @c @file for file documentation\n * - @c @brief for brief descriptions\n * - @c @details for detailed documentation\n * - @c @defgroup for module grouping\n * - @c @ingroup for hierarchical organization\n * - @c @page for standalone pages\n * - @c @example for code examples\n * - @c @code/@endcode for code blocks\n * - @c @see/@ref for cross-references\n * - @c @param for parameter documentation\n * - @c @return for return value documentation\n * - @c @note/@warning for special notes\n * - @c @namespace for namespace documentation\n *\n */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/OLED__Examples_8md/","title":"OLED_Examples.md","text":""},{"location":"api/Files/OLED__Examples_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_Examples OLED Driver Examples\n *\n * @tableofcontents\n *\n * This page contains comprehensive code examples demonstrating how to use\n * the OLED driver for various common tasks.\n *\n * @section Example1_BasicInitialization Basic Device Initialization\n *\n * The most fundamental example showing device setup and initialization:\n *\n * @code\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n *\n * void example_basic_init(void) {\n *     // Create OLED device structure\n *     CFBD_OLED oled;\n *\n *     // Setup I2C parameters\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,  // Use standard address\n *         .i2c_handle = get_my_i2c_interface(),\n *     };\n *\n *     // Initialize OLED with I2C backend\n *     CFBD_bool success = CFBD_GetOLEDHandle(\n *         &amp;oled,\n *         CFBD_OLEDDriverType_IIC,\n *         &amp;i2c_params,\n *         CFBD_TRUE  // Immediate initialization\n *     );\n *\n *     if (success &amp;&amp; oled.ops-&gt;open(&amp;oled)) {\n *         // Device is now ready for use\n *     }\n * }\n * @endcode\n *\n * @section Example2_ClearAndDisplay Clear Display\n *\n * Clear all pixels and update the physical display:\n *\n * @code\n * void example_clear_display(CFBD_OLED* oled) {\n *     // Clear all pixels in the local buffer\n *     oled-&gt;ops-&gt;clear(oled);\n *\n *     // Synchronize with physical display\n *     oled-&gt;ops-&gt;update(oled);\n * }\n * @endcode\n *\n * @section Example3_DrawingPixels Drawing Individual Pixels\n *\n * Set individual pixels to create a pattern:\n *\n * @code\n * void example_draw_checkerboard(CFBD_OLED* oled) {\n *     // Get display dimensions\n *     uint16_t width = 0, height = 0;\n *     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *\n *     // Draw checkerboard pattern\n *     for (uint16_t y = 0; y &lt; height; y += 2) {\n *         for (uint16_t x = 0; x &lt; width; x += 2) {\n *             if ((x + y) % 4 == 0) {\n *                 oled-&gt;ops-&gt;setPixel(oled, x, y);\n *             }\n *         }\n *     }\n *\n *     // Update display\n *     oled-&gt;ops-&gt;update(oled);\n * }\n * @endcode\n *\n * @section Example4_AreaOperations Area-Based Drawing\n *\n * Efficiently update rectangular regions of the display:\n *\n * @code\n * void example_draw_rectangle(CFBD_OLED* oled,\n *                             uint16_t x, uint16_t y,\n *                             uint16_t width, uint16_t height) {\n *     // Prepare bitmap data (format depends on device)\n *     uint8_t* bitmap = prepare_rectangle_data(width, height);\n *\n *     // Write the area\n *     CFBD_bool success = oled-&gt;ops-&gt;setArea(oled, x, y, width, height, bitmap);\n *\n *     if (success) {\n *         // Update only this area on the display\n *         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n *     }\n *\n *     free_bitmap_data(bitmap);\n * }\n * @endcode\n *\n * @section Example5_DeviceQueries Device Property Queries\n *\n * Query device capabilities and properties:\n *\n * @code\n * void example_query_device(CFBD_OLED* oled) {\n *     uint16_t width = 0, height = 0;\n *     CFBD_bool is_rgb = CFBD_FALSE;\n *\n *     // Query basic properties\n *     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *     oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n *\n *     // Report display information\n *     printf(\"Display Resolution: %u x %u pixels\\n\", width, height);\n *     printf(\"Color Mode: %s\\n\", is_rgb ? \"RGB Color\" : \"Monochrome\");\n *     printf(\"Total Pixels: %u\\n\", (unsigned long)width * height);\n * }\n * @endcode\n *\n * @section Example6_AreaClear Clearing Specific Regions\n *\n * Clear only a portion of the display:\n *\n * @code\n * void example_clear_area(CFBD_OLED* oled,\n *                        uint16_t x, uint16_t y,\n *                        uint16_t width, uint16_t height) {\n *     // Clear rectangular area in the frame buffer\n *     CFBD_bool success = oled-&gt;ops-&gt;clear_area(oled, x, y, width, height);\n *\n *     if (success) {\n *         // Update the cleared area on the physical display\n *         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n *     }\n * }\n * @endcode\n *\n * @section Example7_MultipleDevices Multiple OLED Devices\n *\n * Control multiple OLED displays on different I2C addresses:\n *\n * @code\n * #define NUM_DISPLAYS 2\n *\n * void example_multiple_displays(void) {\n *     CFBD_OLED oled_displays[NUM_DISPLAYS];\n *\n *     // Configuration for each display\n *     struct {\n *         uint8_t address;\n *     } configs[NUM_DISPLAYS] = {\n *         { 0x78 },  // First device\n *         { 0x7A },  // Second device (alternate address)\n *     };\n *\n *     // Initialize all displays\n *     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n *         CFBD_OLED_IICInitsParams i2c_params = {\n *             .device_address = configs[i].address,\n *             .i2c_handle = get_i2c_interface(),\n *         };\n *\n *         if (CFBD_GetOLEDHandle(&amp;oled_displays[i],\n *                                CFBD_OLEDDriverType_IIC,\n *                                &amp;i2c_params,\n *                                CFBD_TRUE)) {\n *             oled_displays[i].ops-&gt;open(&amp;oled_displays[i]);\n *         }\n *     }\n *\n *     // Use both displays independently\n *     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n *         oled_displays[i].ops-&gt;clear(&amp;oled_displays[i]);\n *         oled_displays[i].ops-&gt;update(&amp;oled_displays[i]);\n *     }\n * }\n * @endcode\n *\n * @section Example8_DeferredInitialization Deferred Initialization\n *\n * Create device handle but delay initialization:\n *\n * @code\n * void example_deferred_init(void) {\n *     CFBD_OLED oled;\n *\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     // Create handle without immediate initialization\n *     if (CFBD_GetOLEDHandle(&amp;oled,\n *                            CFBD_OLEDDriverType_IIC,\n *                            &amp;i2c_params,\n *                            CFBD_FALSE)) {  // Deferred init\n *\n *         // ... perform other setup operations ...\n *\n *         // Later, initialize when needed\n *         oled.ops-&gt;init(&amp;oled, NULL);\n *         oled.ops-&gt;open(&amp;oled);\n *\n *         // Now ready for use\n *     }\n * }\n * @endcode\n *\n * @section Example9_ErrorHandling Error Handling\n *\n * Proper error checking throughout device usage:\n *\n * @code\n * CFBD_bool safe_display_operation(void) {\n *     CFBD_OLED oled;\n *\n *     // Step 1: Initialize with error checking\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     if (!CFBD_GetOLEDHandle(&amp;oled,\n *                             CFBD_OLEDDriverType_IIC,\n *                             &amp;i2c_params,\n *                             CFBD_TRUE)) {\n *         printf(\"ERROR: Failed to get OLED handle\\n\");\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 2: Open device with error checking\n *     if (!oled.ops-&gt;open(&amp;oled)) {\n *         printf(\"ERROR: Failed to open OLED device\\n\");\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 3: Perform operations with error checking\n *     if (!oled.ops-&gt;clear(&amp;oled)) {\n *         printf(\"ERROR: Failed to clear display\\n\");\n *         oled.ops-&gt;close(&amp;oled);\n *         return CFBD_FALSE;\n *     }\n *\n *     if (!oled.ops-&gt;update(&amp;oled)) {\n *         printf(\"ERROR: Failed to update display\\n\");\n *         oled.ops-&gt;close(&amp;oled);\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 4: Cleanup\n *     oled.ops-&gt;close(&amp;oled);\n *     return CFBD_TRUE;\n * }\n * @endcode\n *\n * @section Example10_DisplayText Text Display Pattern\n *\n * Example showing how to structure text display operations:\n *\n * @code\n * void example_display_pattern(CFBD_OLED* oled) {\n *     // Get display dimensions\n *     uint16_t width = 128, height = 64;  // Typical SSD1309\n *\n *     // Clear and prepare\n *     oled-&gt;ops-&gt;clear(oled);\n *     oled-&gt;ops-&gt;update(oled);\n *\n *     // Create a pattern (horizontal lines)\n *     for (uint16_t y = 0; y &lt; height; y += 4) {\n *         for (uint16_t x = 0; x &lt; width; x++) {\n *             oled-&gt;ops-&gt;setPixel(oled, x, y);\n *         }\n *     }\n *\n *     // Update display with new pattern\n *     oled-&gt;ops-&gt;update(oled);\n *\n *     // Alternative: update only affected area for efficiency\n *     // oled-&gt;ops-&gt;update_area(oled, 0, 0, width, height);\n * }\n * @endcode\n *\n * @see @ref OLED_UsageGuide for detailed usage documentation\n * @see CFBD_OLED for device structure documentation\n * @see CFBD_OLEDOperations for operation table documentation\n */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/OLED__Namespace_8md/","title":"OLED_Namespace.md","text":""},{"location":"api/Files/OLED__Namespace_8md/#namespaces","title":"Namespaces","text":"Name CFBD Core Framework Bare Device (CFBD) namespace *. CFBD::OLED OLED display driver subsystem *."},{"location":"api/Files/OLED__Namespace_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @namespace CFBD\n * @brief Core Framework Bare Device (CFBD) namespace\n *\n * @details\n * The CFBD namespace encompasses all core framework types and operations\n * for bare-metal embedded device drivers. This includes display interfaces,\n * communication protocols, and device abstraction layers.\n *\n * The namespace is organized into several submodules:\n * - OLED: Generic OLED display driver subsystem\n * - Device abstraction layers for hardware communication\n * - Type definitions and constants for device control\n */\n\n/**\n * @namespace CFBD::OLED\n * @ingroup OLED\n * @brief OLED display driver subsystem\n *\n * @details\n * The CFBD::OLED namespace contains all OLED-related types, operations,\n * and device drivers. It provides a generic, transport-agnostic interface\n * for controlling OLED displays through various communication backends.\n *\n * Key components:\n * - @ref CFBD_OLED: Main device object\n * - @ref CFBD_OLEDOperations: Virtual operation table\n * - @ref CFBD_OLEDDriverType: Transport type enumeration\n * - Device-specific factories (getSSD1306Specific, getSSD1309Specific)\n */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/OLED__Usage__Guide_8md/","title":"OLED_Usage_Guide.md","text":""},{"location":"api/Files/OLED__Usage__Guide_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_UsageGuide OLED Driver Usage Guide\n *\n * @tableofcontents\n *\n * @section Overview\n *\n * The OLED subsystem provides a generic, transport-agnostic interface for\n * controlling OLED displays. It supports multiple device types (SSD1306, SSD1309, etc.)\n * and multiple communication backends (I2C, SPI).\n *\n * @section Architecture\n *\n * The OLED driver architecture consists of three main layers:\n *\n * - **Generic OLED Driver**: The top-level interface (`oled.h`) that application\n *   code interacts with. Provides a device-agnostic API for rendering and control.\n *\n * - **Device Drivers**: Device-specific implementations (SSD1306, SSD1309) that\n *   provide device-specific initialization, memory layouts, and communication prefixes.\n *\n * - **Transport Backends**: Transport-specific implementations (I2C, SPI) that\n *   handle the actual hardware communication with the device.\n *\n * @section GettingStarted\n *\n * @subsection Step1_HeaderFiles Include Required Headers\n *\n * ```cpp\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n * ```\n *\n * @subsection Step2_InitializeI2C Initialize I2C Transport\n *\n * Before initializing the OLED device, ensure your I2C interface is properly\n * configured. Prepare the I2C initialization parameters:\n *\n * ```cpp\n * CFBD_OLED_IICInitsParams i2c_config = {\n *     .device_address = SSD1309_DRIVER_ADDRESS,  // 0x78\n *     .i2c_handle = &amp;my_i2c_interface,\n *     .notify_tx_complete = on_i2c_transmit_complete,\n *     .notify_error = on_i2c_error,\n * };\n * ```\n *\n * @subsection Step3_ObtainOLEDHandle Get OLED Device Handle\n *\n * Use `CFBD_GetOLEDHandle()` to create and initialize an OLED device:\n *\n * ```cpp\n * CFBD_OLED oled_device;\n *\n * if (CFBD_GetOLEDHandle(&amp;oled_device,\n *                        CFBD_OLEDDriverType_IIC,\n *                        &amp;i2c_config,\n *                        CFBD_TRUE)) {  // Request immediate initialization\n *     // Device handle created successfully\n * }\n * ```\n *\n * @subsection Step4_EnableDisplay Enable the Display\n *\n * Open/enable the OLED display:\n *\n * ```cpp\n * if (oled_device.ops-&gt;open(&amp;oled_device)) {\n *     // Display is now powered on and ready\n * }\n * ```\n *\n * @section CommonOperations\n *\n * @subsection ClearDisplay Clear the Entire Display\n *\n * ```cpp\n * // Clear all pixels\n * oled_device.ops-&gt;clear(&amp;oled_device);\n *\n * // Push changes to physical display\n * oled_device.ops-&gt;update(&amp;oled_device);\n * ```\n *\n * @subsection DrawPixel Draw Individual Pixels\n *\n * ```cpp\n * // Set pixel at (x=64, y=32) to on\n * CFBD_bool success = oled_device.ops-&gt;setPixel(&amp;oled_device, 64, 32);\n *\n * // Update display to show the pixel\n * oled_device.ops-&gt;update(&amp;oled_device);\n * ```\n *\n * @subsection DrawArea Draw a Block of Data\n *\n * ```cpp\n * // Example: Draw a 16x16 bitmap at position (0, 0)\n * uint8_t bitmap_data[32];  // 16x16 pixels, monochrome format\n *\n * oled_device.ops-&gt;setArea(&amp;oled_device,\n *                          0, 0,           // x, y position\n *                          16, 16,         // width, height\n *                          bitmap_data);   // source data\n *\n * // Update the area on display\n * oled_device.ops-&gt;update_area(&amp;oled_device, 0, 0, 16, 16);\n * ```\n *\n * @subsection QueryDeviceProperties Query Display Properties\n *\n * ```cpp\n * // Query display width\n * uint16_t width = 0;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);\n *\n * // Query display height\n * uint16_t height = 0;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);\n *\n * // Query color support (RGB vs monochrome)\n * CFBD_bool is_rgb = CFBD_FALSE;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"rgb\", NULL, &amp;is_rgb);\n *\n * printf(\"Display: %u x %u, Color Mode: %s\\n\",\n *        width, height, is_rgb ? \"RGB\" : \"Monochrome\");\n * ```\n *\n * @subsection CloseDisplay Close/Disable the Display\n *\n * When finished with the display, close it to power off and release resources:\n *\n * ```cpp\n * oled_device.ops-&gt;close(&amp;oled_device);\n * ```\n *\n * @section CompleteExample\n *\n * Here's a complete example demonstrating the OLED driver usage:\n *\n * ```cpp\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n * #include &lt;stdio.h&gt;\n *\n * void oled_demo(void) {\n *     // Step 1: Setup I2C configuration\n *     CFBD_OLED_IICInitsParams i2c_config = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     // Step 2: Get OLED device handle\n *     CFBD_OLED oled_device;\n *     if (!CFBD_GetOLEDHandle(&amp;oled_device,\n *                             CFBD_OLEDDriverType_IIC,\n *                             &amp;i2c_config,\n *                             CFBD_TRUE)) {\n *         printf(\"Failed to initialize OLED device\\n\");\n *         return;\n *     }\n *\n *     // Step 3: Open the display\n *     if (!oled_device.ops-&gt;open(&amp;oled_device)) {\n *         printf(\"Failed to open OLED device\\n\");\n *         return;\n *     }\n *\n *     // Step 4: Query and display device information\n *     uint16_t width = 0, height = 0;\n *     oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);\n *     oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);\n *     printf(\"OLED Display: %u x %u pixels\\n\", width, height);\n *\n *     // Step 5: Clear the display\n *     oled_device.ops-&gt;clear(&amp;oled_device);\n *     oled_device.ops-&gt;update(&amp;oled_device);\n *\n *     // Step 6: Draw some pixels\n *     for (uint16_t x = 0; x &lt; width; x += 2) {\n *         oled_device.ops-&gt;setPixel(&amp;oled_device, x, 10);\n *     }\n *     oled_device.ops-&gt;update(&amp;oled_device);\n *\n *     // Step 7: Close the display\n *     oled_device.ops-&gt;close(&amp;oled_device);\n * }\n * ```\n *\n * @section SupportedDevices\n *\n * Currently supported OLED controller chips:\n * - **SSD1306**: Common monochrome controller, 128x64 resolution typical\n * - **SSD1309**: Enhanced version with improved contrast and timing control\n *\n * @section SupportedTransports\n *\n * Available transport backends:\n * - **I2C (IIC)**: Two-wire interface, default at 0x78 for SSD1309\n * - **SPI**: High-speed serial interface (implementation available)\n *\n * @section ErrorHandling\n *\n * Most operations return `CFBD_bool` (TRUE/FALSE) to indicate success or failure.\n * Common error conditions:\n * - Invalid device address\n * - I2C communication errors\n * - Device not initialized or opened\n * - Out-of-bounds coordinate access\n *\n * Always check return values before proceeding with display operations.\n *\n * @section Performance Considerations\n *\n * - **Full frame updates**: Use `update()` for complete display refresh\n * - **Partial updates**: Use `update_area()` for better performance when\n *   updating only specific regions\n * - **Buffering**: The driver maintains a local frame buffer; changes are\n *   not visible on the display until `update()` or `update_area()` is called\n *\n * @section Troubleshooting\n *\n * **Display not responding**: Verify I2C address and electrical connections\n *\n * **Garbled display**: Check frame buffer data format and pixel ordering\n *\n * **Slow updates**: Consider using area-based updates instead of full updates\n *\n * @section References\n *\n * - @ref OLED Main OLED driver module\n * - @ref OLED_Device Device interface documentation\n * - @ref OLED_Backend Backend transport implementations\n *\n */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ah__no_8h/","title":"lib/config/ah_no.h","text":"<p>Emergency halt helper used when unrecoverable errors occur.  More...</p>"},{"location":"api/Files/ah__no_8h/#detailed-description","title":"Detailed Description","text":"<p>Emergency halt helper used when unrecoverable errors occur. </p> <p>Provides a tiny, platform-agnostic panic/halt routine intended for fatal error paths where recovery is not possible. The function is implemented as an infinite loop to halt program execution. On many embedded targets a debugger or watchdog will be used to recover from this state; platform-specific implementations may extend this function to signal error LEDs, log information, or trigger a reset.</p> <p>Use with caution \u2014 this function does not return. </p>"},{"location":"api/Files/ah__no_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nstatic inline void CFBD_AH_NO(void)\n{\n    while (1)\n        ;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/animation_8c/","title":"lib/graphic/widget/animation/animation.c","text":""},{"location":"api/Files/animation_8c/#functions","title":"Functions","text":"Name void CFBD_InitBaseAnimation(CFBD_BaseAnimation * pBaseAnimation)create a base animation with default settings"},{"location":"api/Files/animation_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/animation_8c/#function-cfbd_initbaseanimation","title":"function CFBD_InitBaseAnimation","text":"<pre><code>void CFBD_InitBaseAnimation(\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre> <p>create a base animation with default settings </p> <p>Parameters: </p> <ul> <li>pBaseAnimation pointers to the inits </li> </ul>"},{"location":"api/Files/animation_8c/#source-code","title":"Source code","text":"<pre><code>#include \"animation.h\"\n\n#include \"animation_config.h\"\n\nvoid CFBD_InitBaseAnimation(CFBD_BaseAnimation* pBaseAnimation)\n{\n    pBaseAnimation-&gt;anim_frame_delay_ms = CFBD_BASEANIMATION_DELAY_MS;\n    pBaseAnimation-&gt;anim_frames = CFBD_BASEANIMATION_FRAME_CNT;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/animation_8h/","title":"lib/graphic/widget/animation/animation.h","text":""},{"location":"api/Files/animation_8h/#classes","title":"Classes","text":"Name struct CFBD_BaseAnimationOps struct __CFBD_BaseAnimation"},{"location":"api/Files/animation_8h/#types","title":"Types","text":"Name typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation"},{"location":"api/Files/animation_8h/#functions","title":"Functions","text":"Name void CFBD_InitBaseAnimation(CFBD_BaseAnimation * pBaseAnimation)create a base animation with default settings"},{"location":"api/Files/animation_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/animation_8h/#typedef-cfbd_baseanimation","title":"typedef CFBD_BaseAnimation","text":"<pre><code>typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation;\n</code></pre>"},{"location":"api/Files/animation_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/animation_8h/#function-cfbd_initbaseanimation","title":"function CFBD_InitBaseAnimation","text":"<pre><code>void CFBD_InitBaseAnimation(\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre> <p>create a base animation with default settings </p> <p>Parameters: </p> <ul> <li>pBaseAnimation pointers to the inits </li> </ul>"},{"location":"api/Files/animation_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    void (*delay_ms)(uint32_t ms); // animation delays\n} CFBD_BaseAnimationOps;\n\ntypedef struct __CFBD_BaseAnimation\n{\n    uint8_t anim_frames;          /* frames for transition */\n    uint32_t anim_frame_delay_ms; /* delay per frame in ms; if 0, no delay */\n} CFBD_BaseAnimation;\n\nvoid CFBD_InitBaseAnimation(CFBD_BaseAnimation* pBaseAnimation);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/animation__config_8h/","title":"lib/graphic/widget/animation/animation_config.h","text":""},{"location":"api/Files/animation__config_8h/#defines","title":"Defines","text":"Name CFBD_BASEANIMATION_FRAME_CNT CFBD_BASEANIMATION_DELAY_MS"},{"location":"api/Files/animation__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_frame_cnt","title":"define CFBD_BASEANIMATION_FRAME_CNT","text":"<pre><code>#define CFBD_BASEANIMATION_FRAME_CNT (8)\n</code></pre>"},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_delay_ms","title":"define CFBD_BASEANIMATION_DELAY_MS","text":"<pre><code>#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre>"},{"location":"api/Files/animation__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_BASEANIMATION_FRAME_CNT (8)\n#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/app_8c/","title":"lib/application/app.c","text":""},{"location":"api/Files/app_8c/#functions","title":"Functions","text":"Name void _private_init_app()"},{"location":"api/Files/app_8c/#attributes","title":"Attributes","text":"Name CFBDApplication _app"},{"location":"api/Files/app_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/app_8c/#function-_private_init_app","title":"function _private_init_app","text":"<pre><code>static inline void _private_init_app()\n</code></pre>"},{"location":"api/Files/app_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/app_8c/#variable-_app","title":"variable _app","text":"<pre><code>static CFBDApplication _app;\n</code></pre>"},{"location":"api/Files/app_8c/#source-code","title":"Source code","text":"<pre><code>#include \"app.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"ah_no.h\"\n#include \"cfbd_define.h\"\n\nstatic CFBDApplication _app;\n\nstatic inline void _private_init_app()\n{\n    CFBDBootTuple* pBootTuple = CFBD_AppBootMaker();\n    _app.bootargs = pBootTuple ? pBootTuple-&gt;args : NULL;\n    _app.selfBootFunc = pBootTuple ? pBootTuple-&gt;boot_func : NULL;\n    _app.freq_provider = CFBD_AppClockProvider();\n    _app.tick_provider = CFBD_AppTickProvider();\n    if (!_app.freq_provider) {\n        CFBD_AH_NO();\n    }\n}\n\nCFBDApplication* getApp(CFBD_Bool request_autoboot)\n{\n    _private_init_app();\n\n    if (request_autoboot) {\n        _app.selfBootFunc(_app.bootargs);\n    }\n\n    return &amp;_app;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/app_8h/","title":"lib/application/app.h","text":"<p>Application descriptor and clock/boot provider interfaces.  More...</p>"},{"location":"api/Files/app_8h/#classes","title":"Classes","text":"Name struct __CFBDApplication Application descriptor."},{"location":"api/Files/app_8h/#detailed-description","title":"Detailed Description","text":"<p>Application descriptor and clock/boot provider interfaces. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-10 </p> <p>This header defines the <code>CFBDApplication</code> structure which aggregates application-specific bootstrap and clock provider hooks used by the framework. It also declares helper functions to obtain the global application's boot table and clock/tick providers.</p> <p>Implementations in the application layer should provide matching definitions for the providers declared here. Keep these interfaces small to allow linking a minimal runtime for constrained targets.</p>"},{"location":"api/Files/app_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"sys_boot/boot.h\"\n\ntypedef uint32_t (*CFBD_ClockFreqProvider)(void);\n\ntypedef uint32_t (*CFBD_ClockTickProvider)(void);\n\ntypedef struct __CFBDApplication\n{\n    CFBD_BootStrapFunc selfBootFunc;\n\n    CFBD_BootArgs bootargs;\n\n    CFBD_ClockFreqProvider freq_provider;\n\n    CFBD_ClockTickProvider tick_provider;\n} CFBDApplication;\n\nextern CFBDBootTuple* CFBD_AppBootMaker(void);\n\nextern CFBD_ClockFreqProvider CFBD_AppClockProvider(void);\n\nextern CFBD_ClockTickProvider CFBD_AppTickProvider(void);\n\nCFBDApplication* getApp(CFBD_Bool request_auto_boot);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/arc_8c/","title":"lib/graphic/base/arc.c","text":""},{"location":"api/Files/arc_8c/#functions","title":"Functions","text":"Name CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end) void clearArea(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void updateArea(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CCGraphic_Arc * arc) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CCGraphic_Arc * arc)"},{"location":"api/Files/arc_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) DRAW_IF_IN(offsetx, offsety)"},{"location":"api/Files/arc_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8c/#function-__pvt_is_in_angle","title":"function __pvt_is_in_angle","text":"<pre><code>static CFBD_Bool __pvt_is_in_angle(\n    int16_t x,\n    int16_t y,\n    int16_t start,\n    int16_t end\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cleararea","title":"function clearArea","text":"<pre><code>static void clearArea(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-updatearea","title":"function updateArea","text":"<pre><code>static void updateArea(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/arc_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_if_in","title":"define DRAW_IF_IN","text":"<pre><code>#define DRAW_IF_IN(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#source-code","title":"Source code","text":"<pre><code>#include \"arc.h\"\n\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n\nstatic CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end)\n{\n    int16_t point_angle = (atan2(y, x) / 3.14 * 180);\n    return start &lt; end ? (start &lt; point_angle &amp;&amp; point_angle &lt; end)\n                       : (start &gt; point_angle || point_angle &gt; end);\n}\n\nstatic void clearArea(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void updateArea(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n\n#define DRAW_IF_IN(offsetx, offsety)                                                               \\\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    PREANNOUNCE;\n    clearArea(device, arc);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CCGraphic_Arc* arc)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n    clearArea(device, arc);\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    __x = x;\n    __y = y;\n\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    /*\u904d\u5386\u8d77\u59cb\u70b9Y\u5750\u6807*/\n    for (int16_t j = -y; j &lt; y; j++) {\n        /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(0, j);\n    }\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n\n        /*\u904d\u5386\u4e2d\u95f4\u90e8\u5206*/\n        for (int16_t j = -y; j &lt; y; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(x, j);\n            DRAW_IF_IN(-x, j);\n        }\n\n        /*\u904d\u5386\u4e24\u4fa7\u90e8\u5206*/\n        for (int16_t j = -x; j &lt; x; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(y, j);\n            DRAW_IF_IN(-y, j);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef DRAW_IF_IN\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/arc_8h/","title":"lib/graphic/base/arc.h","text":"<p>Arc geometry and drawing prototypes for the graphics subsystem.  More...</p>"},{"location":"api/Files/arc_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Arc Represents a circular arc defined by center, radius, and angular range."},{"location":"api/Files/arc_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CCGraphic_Arc * circle) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CCGraphic_Arc * circle)"},{"location":"api/Files/arc_8h/#detailed-description","title":"Detailed Description","text":"<p>Arc geometry and drawing prototypes for the graphics subsystem. </p> <p>Author: Charliechen114514 </p>"},{"location":"api/Files/arc_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Arc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point center;\n\n    PointBaseType radius;\n\n    int16_t start_degree;\n\n    int16_t end_degree;\n} CCGraphic_Arc;\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);\n\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CCGraphic_Arc* circle);\n\n // End of Arc_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ascii6x8_8source_8c/","title":"lib/graphic/resource/default/ascii6x8.source.c","text":""},{"location":"api/Files/ascii6x8_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  6x8 OLED display using 6x8 pixel font representation.\n//  Each character in this font set is defined by an \n//  6x8 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii6x8_sources[][6];\n// ---------------------------------------------\n#if ENABLE_ASCII_6x8_SOURCES\nconst uint8_t ascii6x8_sources[][6] = \n{\n    {0x00,0x00,0x00,0x00,0x00,0x00}, // 0\n    {0x00,0x00,0x00,0x2F,0x00,0x00}, // ! 1\n    {0x00,0x00,0x07,0x00,0x07,0x00}, // \" 2\n    {0x00,0x14,0x7F,0x14,0x7F,0x14}, // # 3\n    {0x00,0x24,0x2A,0x7F,0x2A,0x12}, // $ 4\n    {0x00,0x23,0x13,0x08,0x64,0x62}, // % 5\n    {0x00,0x36,0x49,0x55,0x22,0x50}, // &amp; 6\n    {0x00,0x00,0x00,0x07,0x00,0x00}, // ' 7\n    {0x00,0x00,0x1C,0x22,0x41,0x00}, // ( 8\n    {0x00,0x00,0x41,0x22,0x1C,0x00}, // ) 9\n    {0x00,0x14,0x08,0x3E,0x08,0x14}, // * 10\n    {0x00,0x08,0x08,0x3E,0x08,0x08}, // + 11\n    {0x00,0x00,0x00,0xA0,0x60,0x00}, // , 12\n    {0x00,0x08,0x08,0x08,0x08,0x08}, // - 13\n    {0x00,0x00,0x60,0x60,0x00,0x00}, // . 14\n    {0x00,0x20,0x10,0x08,0x04,0x02}, // / 15\n    {0x00,0x3E,0x51,0x49,0x45,0x3E}, // 0 16\n    {0x00,0x00,0x42,0x7F,0x40,0x00}, // 1 17\n    {0x00,0x42,0x61,0x51,0x49,0x46}, // 2 18\n    {0x00,0x21,0x41,0x45,0x4B,0x31}, // 3 19\n    {0x00,0x18,0x14,0x12,0x7F,0x10}, // 4 20\n    {0x00,0x27,0x45,0x45,0x45,0x39}, // 5 21\n    {0x00,0x3C,0x4A,0x49,0x49,0x30}, // 6 22\n    {0x00,0x01,0x71,0x09,0x05,0x03}, // 7 23\n    {0x00,0x36,0x49,0x49,0x49,0x36}, // 8 24\n    {0x00,0x06,0x49,0x49,0x29,0x1E}, // 9 25\n    {0x00,0x00,0x36,0x36,0x00,0x00}, // : 26\n    {0x00,0x00,0x56,0x36,0x00,0x00}, // ; 27\n    {0x00,0x08,0x14,0x22,0x41,0x00}, // &lt; 28\n    {0x00,0x14,0x14,0x14,0x14,0x14}, // = 29\n    {0x00,0x00,0x41,0x22,0x14,0x08}, // &gt; 30\n    {0x00,0x02,0x01,0x51,0x09,0x06}, // ? 31\n    {0x00,0x3E,0x49,0x55,0x59,0x2E}, // @ 32\n    {0x00,0x7C,0x12,0x11,0x12,0x7C}, // A 33\n    {0x00,0x7F,0x49,0x49,0x49,0x36}, // B 34\n    {0x00,0x3E,0x41,0x41,0x41,0x22}, // C 35\n    {0x00,0x7F,0x41,0x41,0x22,0x1C}, // D 36\n    {0x00,0x7F,0x49,0x49,0x49,0x41}, // E 37\n    {0x00,0x7F,0x09,0x09,0x09,0x01}, // F 38\n    {0x00,0x3E,0x41,0x49,0x49,0x7A}, // G 39\n    {0x00,0x7F,0x08,0x08,0x08,0x7F}, // H 40\n    {0x00,0x00,0x41,0x7F,0x41,0x00}, // I 41\n    {0x00,0x20,0x40,0x41,0x3F,0x01}, // J 42\n    {0x00,0x7F,0x08,0x14,0x22,0x41}, // K 43\n    {0x00,0x7F,0x40,0x40,0x40,0x40}, // L 44\n    {0x00,0x7F,0x02,0x0C,0x02,0x7F}, // M 45\n    {0x00,0x7F,0x04,0x08,0x10,0x7F}, // N 46\n    {0x00,0x3E,0x41,0x41,0x41,0x3E}, // O 47\n    {0x00,0x7F,0x09,0x09,0x09,0x06}, // P 48\n    {0x00,0x3E,0x41,0x51,0x21,0x5E}, // Q 49\n    {0x00,0x7F,0x09,0x19,0x29,0x46}, // R 50\n    {0x00,0x46,0x49,0x49,0x49,0x31}, // S 51\n    {0x00,0x01,0x01,0x7F,0x01,0x01}, // T 52\n    {0x00,0x3F,0x40,0x40,0x40,0x3F}, // U 53\n    {0x00,0x1F,0x20,0x40,0x20,0x1F}, // V 54\n    {0x00,0x3F,0x40,0x38,0x40,0x3F}, // W 55\n    {0x00,0x63,0x14,0x08,0x14,0x63}, // X 56\n    {0x00,0x07,0x08,0x70,0x08,0x07}, // Y 57\n    {0x00,0x61,0x51,0x49,0x45,0x43}, // Z 58\n    {0x00,0x00,0x7F,0x41,0x41,0x00}, // [ 59\n    {0x00,0x02,0x04,0x08,0x10,0x20}, // \\ 60\n    {0x00,0x00,0x41,0x41,0x7F,0x00}, // ] 61\n    {0x00,0x04,0x02,0x01,0x02,0x04}, // ^ 62\n    {0x00,0x40,0x40,0x40,0x40,0x40}, // _ 63\n    {0x00,0x00,0x01,0x02,0x04,0x00}, // ` 64\n    {0x00,0x20,0x54,0x54,0x54,0x78}, // a 65\n    {0x00,0x7F,0x48,0x44,0x44,0x38}, // b 66\n    {0x00,0x38,0x44,0x44,0x44,0x20}, // c 67\n    {0x00,0x38,0x44,0x44,0x48,0x7F}, // d 68\n    {0x00,0x38,0x54,0x54,0x54,0x18}, // e 69\n    {0x00,0x08,0x7E,0x09,0x01,0x02}, // f 70\n    {0x00,0x18,0xA4,0xA4,0xA4,0x7C}, // g 71\n    {0x00,0x7F,0x08,0x04,0x04,0x78}, // h 72\n    {0x00,0x00,0x44,0x7D,0x40,0x00}, // i 73\n    {0x00,0x40,0x80,0x84,0x7D,0x00}, // j 74\n    {0x00,0x7F,0x10,0x28,0x44,0x00}, // k 75\n    {0x00,0x00,0x41,0x7F,0x40,0x00}, // l 76\n    {0x00,0x7C,0x04,0x18,0x04,0x78}, // m 77\n    {0x00,0x7C,0x08,0x04,0x04,0x78}, // n 78\n    {0x00,0x38,0x44,0x44,0x44,0x38}, // o 79\n    {0x00,0xFC,0x24,0x24,0x24,0x18}, // p 80\n    {0x00,0x18,0x24,0x24,0x18,0xFC}, // q 81\n    {0x00,0x7C,0x08,0x04,0x04,0x08}, // r 82\n    {0x00,0x48,0x54,0x54,0x54,0x20}, // s 83\n    {0x00,0x04,0x3F,0x44,0x40,0x20}, // t 84\n    {0x00,0x3C,0x40,0x40,0x20,0x7C}, // u 85\n    {0x00,0x1C,0x20,0x40,0x20,0x1C}, // v 86\n    {0x00,0x3C,0x40,0x30,0x40,0x3C}, // w 87\n    {0x00,0x44,0x28,0x10,0x28,0x44}, // x 88\n    {0x00,0x1C,0xA0,0xA0,0xA0,0x7C}, // y 89\n    {0x00,0x44,0x64,0x54,0x4C,0x44}, // z 90\n    {0x00,0x00,0x08,0x7F,0x41,0x00}, // { 91\n    {0x00,0x00,0x00,0x7F,0x00,0x00}, // | 92\n    {0x00,0x00,0x41,0x7F,0x08,0x00}, // } 93\n    {0x00,0x08,0x04,0x08,0x10,0x08}, // ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ascii8x16_8source_8c/","title":"lib/graphic/resource/default/ascii8x16.source.c","text":""},{"location":"api/Files/ascii8x16_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  8x16 OLED display using 8x16 pixel font representation.\n//  Each character in this font set is defined by an \n//  8x16 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii8x16_sources[][16];\n// ---------------------------------------------\n#if ENABLE_ASCII_8x16_SOURCES\nconst uint8_t ascii8x16_sources[][16] =\n{\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//   0\n    {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},// ! 1\n    {0x00,0x16,0x0E,0x00,0x16,0x0E,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// \" 2\n    {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,\n    0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},// # 3\n    {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,\n    0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},// $ 4\n    {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,\n    0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},// % 5\n    {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,\n    0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},// &amp; 6\n    {0x00,0x00,0x00,0x16,0x0E,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ' 7\n    {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,\n    0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},// ( 8\n    {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,\n    0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},// ) 9\n    {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,\n    0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},// * 10\n    {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,\n    0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},// + 11\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},// , 12\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},// - 13\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},// . 14\n    {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,\n    0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},// / 15\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},// 0 16\n    {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// 1 17\n    {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},// 2 18\n    {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,\n    0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},// 3 19\n    {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,\n    0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},// 4 20\n    {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,\n    0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},// 5 21\n    {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,\n    0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},// 6 22\n    {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},// 7 23\n    {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},// 8 24\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},// 9 25\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},// : 26\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00},// ; 27\n    {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,\n    0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},// &lt; 28\n    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,\n    0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},// = 29\n    {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,\n    0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},// &gt; 30\n    {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,\n    0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},// ? 31\n    {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,\n    0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},// @ 32\n    {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,\n    0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},// A 33\n    {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},// B 34\n    {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,\n    0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},// C 35\n    {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},// D 36\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},// E 37\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},// F 38\n    {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,\n    0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},// G 39\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},// H 40\n    {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// I 41\n    {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,\n    0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},// J 42\n    {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,\n    0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},// K 43\n    {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},// L 44\n    {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,\n    0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},// M 45\n    {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},// N 46\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},// O 47\n    {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,\n    0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},// P 48\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},// Q 49\n    {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},// R 50\n    {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,\n    0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},// S 51\n    {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// T 52\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// U 53\n    {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,\n    0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},// V 54\n    {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,\n    0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},// W 55\n    {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,\n    0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},// X 56\n    {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// Y 57\n    {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},// Z 58\n    {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,\n    0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},// [ 59\n    {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},// \\ 60\n    {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},// ] 61\n    {0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ^ 62\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},// _ 63\n    {0x00,0x02,0x04,0x08,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ` 64\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},// a 65\n    {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},// b 66\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},// c 67\n    {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},// d 68\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},// e 69\n    {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// f 70\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},// g 71\n    {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},// h 72\n    {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// i 73\n    {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,\n    0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},// j 74\n    {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},// k 75\n    {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// l 76\n    {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},// m 77\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x00,0x00,\n    0x00,0x20,0x3F,0x21,0x00,0x20,0x3F,0x20},// n 78\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// o 79\n    {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},// p 80\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},// q 81\n    {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},// r 82\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},// s 83\n    {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,\n    0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},// t 84\n    {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},// u 85\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},// v 86\n    {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,\n    0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},// w 87\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},// x 88\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},// y 89\n    {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},// z 90\n    {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,\n    0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},// { 91\n    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},// | 92\n    {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},// } 93\n    {0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x80,\n    0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00},// ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/benchmark_8c/","title":"lib/graphic/benchmark/benchmark.c","text":""},{"location":"api/Files/benchmark_8c/#functions","title":"Functions","text":"Name void test_fps_benchmark(CFBD_GraphicDevice * handler) void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8c/#function-test_fps_benchmark","title":"function test_fps_benchmark","text":"<pre><code>static void test_fps_benchmark(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"config/system_settings.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/text.h\"\n\n// FPS\u6027\u80fd\u6d4b\u8bd5 - \u5728OLED\u5c4f\u5e55\u4e0a\u663e\u793a\u5237\u65b0\u7387\nstatic void test_fps_benchmark(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n\n    CFBDGraphic_Text fps_text;\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;fps_text, p, screen_size, ASCII_6x8);\n\n    uint32_t frame_count = 0;\n    uint32_t last_time = HAL_GetTick();\n\n    uint32_t fps_x10 = 0; // FPS * 10\uff08\u5b9a\u70b9\u6570\uff09\n    char buffer[64];\n\n    uint32_t test_start = HAL_GetTick();\n    uint32_t test_duration = 30000;\n\n    while ((HAL_GetTick() - test_start) &lt; test_duration) {\n        // CFBDGraphic_DeviceClearImmediate(handler);\n\n        frame_count++;\n        uint32_t current_time = HAL_GetTick();\n        uint32_t elapsed = current_time - last_time;\n\n        // \u6bcf 500ms \u66f4\u65b0\u4e00\u6b21 FPS\n        if (elapsed &gt;= 500) {\n            // fps_x10 = frame_count * 1000 * 10 / elapsed\n            fps_x10 = (frame_count * 10000U) / elapsed;\n\n            frame_count = 0;\n            last_time = current_time;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"FPS: %lu.%lu\\n\"\n                 \"Time: %lus\\n\",\n                 fps_x10 / 10,\n                 fps_x10 % 10,\n                 (HAL_GetTick() - test_start) / 1000);\n\n        CFBDGraphic_SetText(&amp;fps_text, buffer);\n        CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    CFBDGraphic_DeviceClearImmediate(handler);\n    snprintf(buffer,\n             sizeof(buffer),\n             \"Test Complete!\\n\"\n             \"Final FPS: %lu.%lu\",\n             fps_x10 / 10,\n             fps_x10 % 10);\n\n    CFBDGraphic_SetText(&amp;fps_text, buffer);\n    CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nvoid test_fps(CFBD_GraphicDevice* handler)\n{\n    test_fps_benchmark(handler);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/benchmark_8h/","title":"lib/graphic/benchmark/benchmark.h","text":""},{"location":"api/Files/benchmark_8h/#functions","title":"Functions","text":"Name void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8h/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_fps(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/boot_8c/","title":"lib/application/sys_boot/boot.c","text":""},{"location":"api/Files/boot_8c/#source-code","title":"Source code","text":"<pre><code>#include \"boot.h\"\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/boot_8h/","title":"lib/application/sys_boot/boot.h","text":"<p>Boot / startup helpers and types for application bootstrap sequence.  More...</p>"},{"location":"api/Files/boot_8h/#classes","title":"Classes","text":"Name struct CFBDBootTuple"},{"location":"api/Files/boot_8h/#detailed-description","title":"Detailed Description","text":"<p>Boot / startup helpers and types for application bootstrap sequence. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>This header declares the lightweight types used by the application's bootstrap sequence. It provides a generic argument container type (<code>CFBD_BootArgs</code>), a function-pointer type for bootstrap entry points (<code>CFBD_BootStrapFunc</code>) and a small tuple type (<code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code>) that associates an entry function with its arguments.</p> <p>The design aims to be minimal and portable across platforms used in this repository. Implementations of bootstrap functions should adhere to the contract documented for <code>CFBD_BootStrapFunc</code>. </p>"},{"location":"api/Files/boot_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef void* CFBD_BootArgs;\n\ntypedef CFBD_Bool (*CFBD_BootStrapFunc)(CFBD_BootArgs args);\n\ntypedef struct\n{\n    CFBD_BootStrapFunc boot_func;\n\n    CFBD_BootArgs args;\n} CFBDBootTuple;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/cache__config_8h/","title":"lib/oled/configs/cache_config.h","text":"<p>Configuration constants for the OLED display pixel cache.  More...</p>"},{"location":"api/Files/cache__config_8h/#detailed-description","title":"Detailed Description","text":"<p>Configuration constants for the OLED display pixel cache. </p> <p>These macros define the dimensions of the off-screen pixel cache used by the OLED driver. They represent the physical pixel arrangement used when composing frames before sending them to the display device. Adjusting these values requires ensuring the driver and any code that manipulates the cache are updated accordingly. </p>"},{"location":"api/Files/cache__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CACHED_HEIGHT (8)\n\n#define CACHED_WIDTH (144)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/cfbd__define_8h/","title":"lib/config/cfbd_define.h","text":"<p>Core type and macro definitions used across CFBD libraries.  More...</p>"},{"location":"api/Files/cfbd__define_8h/#detailed-description","title":"Detailed Description","text":"<p>Core type and macro definitions used across CFBD libraries. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-01 </p> <p>This header centralizes small, portable typedefs and helper macros used by the CFBD (CF BareMetal Drivers) project. It intentionally contains only minimal, dependency-free declarations so it can be included widely in both platform and application code.</p> <p>The types defined here are lightweight building blocks such as a boolean type and common function-pointer signatures used for component initialization or simple callbacks.</p>"},{"location":"api/Files/cfbd__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\ntypedef uint8_t CFBD_Bool;\n\n#define CFBD_FALSE (0)\n\n#define CFBD_TRUE (1)\n\ntypedef CFBD_Bool (*SelfInitFunc)(void* self_handle, void* args);\n\ntypedef void (*PlainFunc)(void* args);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/cfbd__graphic__define_8h/","title":"lib/graphic/cfbd_graphic_define.h","text":""},{"location":"api/Files/cfbd__graphic__define_8h/#types","title":"Types","text":"Name typedef uint16_t PointBaseType typedef PointBaseType SizeBaseType typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice"},{"location":"api/Files/cfbd__graphic__define_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-pointbasetype","title":"typedef PointBaseType","text":"<pre><code>typedef uint16_t PointBaseType;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-sizebasetype","title":"typedef SizeBaseType","text":"<pre><code>typedef PointBaseType SizeBaseType;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre>"},{"location":"api/Files/cfbd__graphic__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef uint16_t PointBaseType;\ntypedef PointBaseType SizeBaseType;\n\ntypedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/circle_8c/","title":"circle.c","text":""},{"location":"api/Files/circle_8c/#functions","title":"Functions","text":"Name void circle_calc_bbox(CFBDGraphicCircle * c, int32_t * lx, int32_t * ty, int32_t * rx, int32_t * by) void clearBound(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety)"},{"location":"api/Files/circle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8c/#function-circle_calc_bbox","title":"function circle_calc_bbox","text":"<pre><code>static inline void circle_calc_bbox(\n    CFBDGraphicCircle * c,\n    int32_t * lx,\n    int32_t * ty,\n    int32_t * rx,\n    int32_t * by\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/circle_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/circle_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/circle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"circle.h\"\n\n#include &lt;assert.h&gt;\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\nstatic inline void\ncircle_calc_bbox(CFBDGraphicCircle* c, int32_t* lx, int32_t* ty, int32_t* rx, int32_t* by)\n{\n    *lx = asInt32_t(c-&gt;center.x) - c-&gt;radius;\n    *ty = asInt32_t(c-&gt;center.y) - c-&gt;radius;\n    *rx = asInt32_t(c-&gt;center.x) + c-&gt;radius;\n    *by = asInt32_t(c-&gt;center.y) + c-&gt;radius;\n}\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    int32_t lx, ty, rx, by;\n    circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n    handler-&gt;ops-&gt;clear_area(handler,\n                             clamp_u16_from_i32(lx),\n                             clamp_u16_from_i32(ty),\n                             clamp_u16_from_i32(rx - lx + 1),\n                             clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    clearBound(handler, circle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    /* Ref Doc: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/\n    /* Ref Toturial: https://www.bilibili.com/video/BV1VM4y1u7wJ*/\n    int16_t d = 3 - circle-&gt;radius / 4;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    int16_t d = 1 - circle-&gt;radius;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n    clearBound(handler, circle);\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    for (int16_t i = -y; i &lt; y; i++)\n        DRAW_OFFSET_POINT(0, i);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n        for (int16_t i = -y; i &lt; y; i++) {\n            DRAW_OFFSET_POINT(x, i);\n            DRAW_OFFSET_POINT(-x, i);\n        }\n        for (int16_t i = -x; i &lt; x; i++) {\n            DRAW_OFFSET_POINT(y, i);\n            DRAW_OFFSET_POINT(-y, i);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/circle_8h/","title":"circle.h","text":"<p>Circle geometry and drawing function declarations.  More...</p>"},{"location":"api/Files/circle_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicCircle Represents a circle defined by center point and radius."},{"location":"api/Files/circle_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8h/#detailed-description","title":"Detailed Description","text":"<p>Circle geometry and drawing function declarations. </p> <p>Author: Charliechen114514 </p>"},{"location":"api/Files/circle_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct\n{\n    SizeBaseType radius;\n\n    CFBDGraphic_Point center;\n} CFBDGraphicCircle;\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\n\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\n\n // End of Circle_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/config_8h/","title":"lib/graphic/resource/config.h","text":""},{"location":"api/Files/config_8h/#defines","title":"Defines","text":"Name ENABLE_ASCII_6x8_SOURCES ENABLE_ASCII_8x16_SOURCES"},{"location":"api/Files/config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/config_8h/#define-enable_ascii_6x8_sources","title":"define ENABLE_ASCII_6x8_SOURCES","text":"<pre><code>#define ENABLE_ASCII_6x8_SOURCES 1\n</code></pre>"},{"location":"api/Files/config_8h/#define-enable_ascii_8x16_sources","title":"define ENABLE_ASCII_8x16_SOURCES","text":"<pre><code>#define ENABLE_ASCII_8x16_SOURCES 1\n</code></pre>"},{"location":"api/Files/config_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef CCGraphic_Config_H\n#define CCGraphic_Config_H\n\n#ifdef _USE_NO_DEFAULT_SOURCES // DISABLE THE SOURCES\n#define ENABLE_ASCII_6x8_SOURCES 0\n#define ENABLE_ASCII_8X16_SOURCES 0\n#else\n/* then enable all first */\n#define ENABLE_ASCII_6x8_SOURCES 1\n#define ENABLE_ASCII_8x16_SOURCES 1\n\n/* disabled one by one */\n#ifdef DISABLE_ASCII_6X8_SOURCES\n#undef ENABLE_ASCII_6x8_SOURCES\n#define ENABLE_ASCII_6x8_SOURCES 0\n#endif\n\n#ifdef DISABLE_ASCII_8X16_SOURCES\n#undef ENABLE_ASCII_8X16_SOURCES\n#define ENABLE_ASCII_8X16_SOURCES 0\n#endif\n\n#endif // for the _USE_NO_DEFAULT_SOURCES\n\n#endif // for the no-repeative\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/device__interface_8h/","title":"lib/oled/driver/device/device_interface.h","text":"<p>Generic device descriptor used by OLED drivers.  More...</p>"},{"location":"api/Files/device__interface_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel."},{"location":"api/Files/device__interface_8h/#detailed-description","title":"Detailed Description","text":"<p>Generic device descriptor used by OLED drivers. </p> <p>See: CFBD_OLED_DeviceSpecificfor the main interface structure. </p> <p>This module encapsulates device-specific information required by the generic OLED driver, including pointers to initialization tables, GRAM buffers and logical geometry. Concrete device drivers (e.g. SSD1306/SSD1309) provide instances of this structure.</p>"},{"location":"api/Files/device__interface_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    uint8_t* (*init_session_tables)(void);\n\n    uint8_t** grams;\n\n    uint16_t init_session_tables_sz;\n\n    uint8_t data_prefix;\n\n    uint8_t cmd_prefix;\n\n    uint16_t logic_width;\n\n    uint16_t logic_height;\n} CFBD_OLED_DeviceSpecific;\n\n // end of OLED_Device group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/","title":"lib/graphic/fast_test","text":""},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/#files","title":"Files","text":"Name lib/graphic/fast_test/test_base_graphic.c lib/graphic/fast_test/test_base_graphic.h lib/graphic/fast_test/test_widget.c lib/graphic/fast_test/test_widget.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/","title":"lib/config","text":""},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/#files","title":"Files","text":"Name lib/config/ah_no.h Emergency halt helper used when unrecoverable errors occur. lib/config/cfbd_define.h Core type and macro definitions used across CFBD libraries. lib/config/lib_settings.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/","title":"lib/graphic","text":""},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#directories","title":"Directories","text":"Name lib/graphic/base lib/graphic/benchmark lib/graphic/device lib/graphic/fast_test lib/graphic/resource lib/graphic/widget"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#files","title":"Files","text":"Name lib/graphic/cfbd_graphic_define.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/","title":"lib/graphic/resource","text":""},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#directories","title":"Directories","text":"Name lib/graphic/resource/default"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#files","title":"Files","text":"Name lib/graphic/resource/config.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/","title":"lib/oled/driver","text":""},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/#directories","title":"Directories","text":"Name lib/oled/driver/backend lib/oled/driver/device <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/","title":"lib/application/sys_boot","text":""},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/#files","title":"Files","text":"Name lib/application/sys_boot/boot.c lib/application/sys_boot/boot.h Boot / startup helpers and types for application bootstrap sequence. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/","title":"lib/oled","text":""},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#directories","title":"Directories","text":"Name lib/oled/configs lib/oled/driver"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#files","title":"Files","text":"Name lib/oled/oled.c lib/oled/oled.h Generic OLED object and operations exposed to application code. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/","title":"lib/oled/driver/device/ssd1306","text":""},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1306/ssd1306.c lib/oled/driver/device/ssd1306/ssd1306.h SSD1306 device-specific descriptor and factory. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/","title":"lib/graphic/device","text":""},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#directories","title":"Directories","text":"Name lib/graphic/device/oled"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#files","title":"Files","text":"Name lib/graphic/device/grapgic_device.c lib/graphic/device/graphic_device.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/","title":"lib/gpio","text":""},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/#files","title":"Files","text":"Name lib/gpio/gpio-stm-impl.c lib/gpio/gpio-stm-impl.h STM32 specific GPIO implementation details for CFBD. lib/gpio/gpio.h GPIO abstraction and helpers used by platform and application code. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/","title":"lib/graphic/widget/menu","text":""},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/#files","title":"Files","text":"Name lib/graphic/widget/menu/menu.c lib/graphic/widget/menu/menu.h lib/graphic/widget/menu/menu_config.h lib/graphic/widget/menu/menu_indicator.c lib/graphic/widget/menu/menu_indicator.h lib/graphic/widget/menu/menu_item.c lib/graphic/widget/menu/menu_item.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/","title":"lib/graphic/base","text":""},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/#files","title":"Files","text":"Name lib/graphic/base/arc.c lib/graphic/base/arc.h Arc geometry and drawing prototypes for the graphics subsystem. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/","title":"lib/application/sys_clock","text":""},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/#files","title":"Files","text":"Name lib/application/sys_clock/system_clock.c lib/application/sys_clock/system_clock.h System timing primitives and delay helpers. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/","title":"lib/oled/configs","text":""},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/#files","title":"Files","text":"Name lib/oled/configs/cache_config.h Configuration constants for the OLED display pixel cache. lib/oled/configs/external_impl_driver.h External (platform/application) implementation hooks for OLED driver. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/","title":"lib/graphic/benchmark","text":""},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/#files","title":"Files","text":"Name lib/graphic/benchmark/benchmark.c lib/graphic/benchmark/benchmark.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/","title":"lib/graphic/widget","text":""},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#directories","title":"Directories","text":"Name lib/graphic/widget/animation lib/graphic/widget/base_support lib/graphic/widget/menu lib/graphic/widget/progressbar"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#files","title":"Files","text":"Name lib/graphic/widget/margin.h lib/graphic/widget/text.c lib/graphic/widget/text.h lib/graphic/widget/text_config.c lib/graphic/widget/text_config.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/","title":"lib/graphic/widget/progressbar","text":""},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/#files","title":"Files","text":"Name lib/graphic/widget/progressbar/progressbar.c lib/graphic/widget/progressbar/progressbar.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/","title":"lib/oled/driver/device/ssd1309","text":""},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1309/ssd1309.c lib/oled/driver/device/ssd1309/ssd1309.h SSD1309 device-specific descriptor and factory. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/","title":"lib","text":""},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/#directories","title":"Directories","text":"Name lib/application lib/config lib/gpio lib/graphic lib/iic lib/oled <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/","title":"lib/graphic/resource/default","text":""},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/#files","title":"Files","text":"Name lib/graphic/resource/default/ascii6x8.source.c lib/graphic/resource/default/ascii8x16.source.c <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/","title":"lib/application","text":""},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#directories","title":"Directories","text":"Name lib/application/sys_boot lib/application/sys_clock"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#files","title":"Files","text":"Name lib/application/app.c lib/application/app.h Application descriptor and clock/boot provider interfaces. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/","title":"lib/oled/driver/device","text":""},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#directories","title":"Directories","text":"Name lib/oled/driver/device/ssd1306 lib/oled/driver/device/ssd1309"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#files","title":"Files","text":"Name lib/oled/driver/device/device_interface.h Generic device descriptor used by OLED drivers. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_b8634a52f9b73d7c45618692cc54ea1b/","title":"lib/graphic/widget/base_support/common","text":""},{"location":"api/Files/dir_b8634a52f9b73d7c45618692cc54ea1b/#files","title":"Files","text":"Name lib/graphic/widget/base_support/common/helpers.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/","title":"lib/graphic/device/oled","text":""},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/#files","title":"Files","text":"Name lib/graphic/device/oled/oled_graphic_device.c lib/graphic/device/oled/oled_graphic_device.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/","title":"lib/oled/driver/backend","text":""},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/#files","title":"Files","text":"Name lib/oled/driver/backend/oled_iic.c lib/oled/driver/backend/oled_iic.h I2C-backed OLED driver initialization interface. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/","title":"lib/graphic/widget/animation","text":""},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/#files","title":"Files","text":"Name lib/graphic/widget/animation/animation.c lib/graphic/widget/animation/animation.h lib/graphic/widget/animation/animation_config.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/","title":"lib/iic","text":""},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#directories","title":"Directories","text":"Name lib/iic/backend"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#files","title":"Files","text":"Name lib/iic/iic.c lib/iic/iic.h I2C (IIC) abstraction layer for CFBD drivers. lib/iic/iic_error.h I2C/IIC error codes used by the CFBD I2C abstraction. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/","title":"lib/graphic/widget/base_support","text":""},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#directories","title":"Directories","text":"Name lib/graphic/widget/base_support/common"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#files","title":"Files","text":"Name lib/graphic/widget/base_support/image.c lib/graphic/widget/base_support/image.h <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/","title":"lib/iic/backend","text":""},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/#files","title":"Files","text":"Name lib/iic/backend/i2c_stm_impl.c lib/iic/backend/i2c_stm_impl.h STM32 HAL-based I2C backend private types and helpers. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ellipse_8c/","title":"ellipse.c","text":""},{"location":"api/Files/ellipse_8c/#functions","title":"Functions","text":"Name void clearBound(CFBD_GraphicDevice * handler, CCGraphic_Ellipse * ellipse, const int16_t x_radius, const int16_t y_radius)"},{"location":"api/Files/ellipse_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) SQUARE(X)"},{"location":"api/Files/ellipse_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ellipse_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Ellipse * ellipse,\n    const int16_t x_radius,\n    const int16_t y_radius\n)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ellipse_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-square","title":"define SQUARE","text":"<pre><code>#define SQUARE(\n    X\n)\n((X) * (X))\n</code></pre>"},{"location":"api/Files/ellipse_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ellipse.h\"\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\n#define SQUARE(X) ((X) * (X))\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler,\n                              CCGraphic_Ellipse* ellipse,\n                              const int16_t x_radius,\n                              const int16_t y_radius)\n{\n    int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n    int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n    int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n    int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n    handler-&gt;ops-&gt;update_area(handler,\n                              clamp_u16_from_i32(lx),\n                              clamp_u16_from_i32(ty),\n                              clamp_u16_from_i32(rx - lx + 1),\n                              clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* handler, CCGraphic_Ellipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* handler, CCGraphic_Ellipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n    // Fill the ellipse by drawing vertical lines in the specified range (filled area)\n    for (int16_t j = -y; j &lt; y; j++) {\n        // Draw vertical lines to fill the area of the ellipse\n        DRAW_OFFSET_POINT(0, j);\n        DRAW_OFFSET_POINT(0, j);\n    }\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef SQUARE\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ellipse_8h/","title":"ellipse.h","text":"<p>Ellipse drawing utilities for 2D graphics rendering. </p>"},{"location":"api/Files/ellipse_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Ellipse Represents an ellipse defined by center point and two radii."},{"location":"api/Files/ellipse_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point center; \n    PointBaseType X_Radius;   \n    PointBaseType Y_Radius;   \n} CCGraphic_Ellipse;\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);\n\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* device, CCGraphic_Ellipse* ellipse);\n\n // End of Ellipse_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/external__impl__driver_8h/","title":"lib/oled/configs/external_impl_driver.h","text":"<p>External (platform/application) implementation hooks for OLED driver.  More...</p>"},{"location":"api/Files/external__impl__driver_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C."},{"location":"api/Files/external__impl__driver_8h/#detailed-description","title":"Detailed Description","text":"<p>External (platform/application) implementation hooks for OLED driver. </p> <p>This header defines structures used to pass platform-specific initialization data to the OLED driver. It references the project's I2C/IIC abstraction and the device interface declarations. The structures here are intended to be filled by the board/application code and then passed to the OLED driver during initialization. </p>"},{"location":"api/Files/external__impl__driver_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"driver/device/device_interface.h\"\n\n/* I2C/IIC backend (points to the project I2C driver) */\n#include \"../iic/iic.h\"\n\ntypedef struct\n{\n    CFBD_I2CHandle* i2cHandle;\n\n    uint32_t accepted_time_delay;\n\n    uint16_t device_address;\n\n    CFBD_OLED_DeviceSpecific* device_specifics;\n\n    void (*iic_transition_callback)(int status);\n} CFBD_OLED_IICInitsParams;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8c/","title":"lib/gpio/gpio-stm-impl.c","text":""},{"location":"api/Files/gpio-stm-impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"gpio-stm-impl.h\"\n#include \"lib_settings.h\"\n#include \"gpio.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n\n#if defined (CFBD_IS_ST)\n\nstatic inline void GPIO_CLK_Enable(GPIO_TypeDef *GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n    } else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_ENABLE();\n    } else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n    } else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_ENABLE();\n    } else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_ENABLE();\n    } \n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_ENABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_ENABLE();\n    }\n#endif\n    else {\n        /* \u975e\u6cd5 GPIO\uff0c\u5ffd\u7565\u6216\u65ad\u8a00 */\n    }\n}\n\nstatic inline void GPIO_CLK_Disable(GPIO_TypeDef *GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_DISABLE();\n    } else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_DISABLE();\n    } else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_DISABLE();\n    } else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_DISABLE();\n    } else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_DISABLE();\n    }\n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_DISABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_DISABLE();\n    }\n#endif\n    else {\n        /* \u975e\u6cd5 GPIO\uff0c\u5ffd\u7565\u6216\u65ad\u8a00 */\n    }\n}\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params){\n    CFBD_ST_GPIOInitParams* st_params = (CFBD_ST_GPIOInitParams*)params;\n    handle-&gt;handle_internals_ = st_params-&gt;handle;\n    handle-&gt;pin_internals_ = st_params-&gt;pin;\n    GPIO_CLK_Enable(st_params-&gt;handle);\n    HAL_GPIO_Init(st_params-&gt;handle, &amp;st_params-&gt;initer);\n}\n\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle){\n    HAL_GPIO_WritePin(\n        handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_, GPIO_PIN_SET);\n}\n\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle){\n    HAL_GPIO_WritePin(\n        handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_, GPIO_PIN_RESET);\n}\n\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle){\n    HAL_GPIO_TogglePin(handle-&gt;handle_internals_, \n        handle-&gt;pin_internals_);\n}\n#endif\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8h/","title":"lib/gpio/gpio-stm-impl.h","text":"<p>STM32 specific GPIO implementation details for CFBD.  More...</p>"},{"location":"api/Files/gpio-stm-impl_8h/#detailed-description","title":"Detailed Description","text":"<p>STM32 specific GPIO implementation details for CFBD. </p> <p>This header provides STM32-specific types used by the public GPIO abstraction (<code>[lib/gpio/gpio.h](Files/gpio_8h.md#file-gpio.h)</code>). It is included only when the <code>CFBD_IS_ST</code> macro selects the ST platform implementation. The declarations here reference HAL types from <code>stm32f1xx_hal_gpio.h</code>.</p> <p>The STM32 GPIO backend encapsulates STM HAL initialization parameters and provides the low-level interface for pin configuration, setting, clearing and toggling operations on STM32 microcontrollers.</p>"},{"location":"api/Files/gpio-stm-impl_8h/#stm32-gpio-usage","title":"STM32 GPIO Usage","text":"<p>To use STM32 GPIO functionality:</p> <ol> <li>Include <code>[gpio.h](Files/gpio_8h.md#file-gpio.h)</code> (which conditionally includes this file when CFBD_IS_ST is set)</li> <li>Populate a <code>CFBD_ST_GPIOInitParams</code> structure with HAL types</li> <li>Cast to <code>CFBD_GPIOInitParams</code> and pass to <code>CFBD_GPIOInit</code></li> </ol>"},{"location":"api/Files/gpio-stm-impl_8h/#stm32-gpio-example","title":"STM32 GPIO Example","text":"<pre><code>#include \"lib/gpio/gpio.h\"\n#include &lt;stm32f1xx_hal.h&gt;\n\n// Example: Initialize GPIOA pin 5 as output\nCFBD_ST_GPIOInitParams stm_params;\nstm_params.handle = GPIOA;\nstm_params.pin = GPIO_PIN_5;\nstm_params.initer.Mode = GPIO_MODE_OUTPUT_PP;\nstm_params.initer.Pull = GPIO_NOPULL;\nstm_params.initer.Speed = GPIO_SPEED_FREQ_HIGH;\n\nCFBD_GPIOHandle gpio_handle;\nCFBD_GPIOInit(&amp;gpio_handle, (CFBD_GPIOInitParams)&amp;stm_params);\n\n// Set pin high\nCFBD_GPIOSet(&amp;gpio_handle);\n</code></pre>"},{"location":"api/Files/gpio-stm-impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../config/lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include &lt;stdint.h&gt;\n#include &lt;stm32f1xx_hal_gpio.h&gt;\n\ntypedef struct\n{\n    GPIO_TypeDef* handle;\n\n    uint32_t pin;\n\n    GPIO_InitTypeDef initer;\n} CFBD_ST_GPIOInitParams; \n\n#endif\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/gpio_8h/","title":"lib/gpio/gpio.h","text":"<p>GPIO abstraction and helpers used by platform and application code.  More...</p>"},{"location":"api/Files/gpio_8h/#classes","title":"Classes","text":"Name struct CFBD_GPIOHandle Public GPIO handle combining platform handle and pin id."},{"location":"api/Files/gpio_8h/#types","title":"Types","text":"Name typedef uint32_t GPIO_PinType Integral type used to identify a single GPIO pin. typedef void * GPIO_TypeHandle Opaque handle type referring to platform-specific GPIO state. typedef void * CFBD_GPIOInitParams Opaque pointer type for GPIO initialization parameters."},{"location":"api/Files/gpio_8h/#functions","title":"Functions","text":"Name void CFBD_GPIOInit(CFBD_GPIOHandle * handle, CFBD_GPIOInitParams params)Initialize a GPIO handle for subsequent operations. void CFBD_GPIOSet(CFBD_GPIOHandle * handle)Set (drive high) the GPIO represented by <code>handle</code>. void CFBD_GPIOUnset(CFBD_GPIOHandle * handle)Clear (drive low) the GPIO represented by <code>handle</code>. void CFBD_GPIOToggle(CFBD_GPIOHandle * handle)Toggle the GPIO represented by <code>handle</code>. void CFBD_GPIOSetPin(CFBD_GPIOHandle * handle, CFBD_Bool status)Inline helper to set or clear a GPIO based on <code>status</code>."},{"location":"api/Files/gpio_8h/#detailed-description","title":"Detailed Description","text":"<p>GPIO abstraction and helpers used by platform and application code. </p> <p>Note: The header assumes a platform-specific implementation header (e.g. <code>[gpio-stm-impl.h](Files/gpio-stm-impl_8h.md#file-gpio-stm-impl.h)</code>) supplies the necessary low-level definitions used by the functions declared here. </p> <p>This header provides a minimal, portable GPIO interface used by the CFBD project. It defines lightweight handle types, an initialization parameter opaque type and basic operations for setting, clearing and toggling GPIO lines. The concrete backing implementation is selected by platform macros (for example <code>CFBD_IS_ST</code> includes the STM implementation).</p> <p>The API is intentionally small to keep portability across targets straightforward; callers should ensure the provided handle is valid and the underlying platform driver has been initialized.</p>"},{"location":"api/Files/gpio_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/gpio_8h/#typedef-gpio_pintype","title":"typedef GPIO_PinType","text":"<pre><code>GPIO_PinType;\n</code></pre> <p>Integral type used to identify a single GPIO pin. </p> <p>The concrete meaning (bit-mask, number, encoded port/pin) depends on the platform implementation header. Use <code>GPIO_PinType</code> when storing or passing pin identifiers to the API. </p>"},{"location":"api/Files/gpio_8h/#typedef-gpio_typehandle","title":"typedef GPIO_TypeHandle","text":"<pre><code>GPIO_TypeHandle;\n</code></pre> <p>Opaque handle type referring to platform-specific GPIO state. </p> <p>Implementations should cast this pointer to an internal structure defined by the platform backend. The type is intentionally opaque to keep the public API independent from implementation details. </p>"},{"location":"api/Files/gpio_8h/#typedef-cfbd_gpioinitparams","title":"typedef CFBD_GPIOInitParams","text":"<pre><code>CFBD_GPIOInitParams;\n</code></pre> <p>Opaque pointer type for GPIO initialization parameters. </p> <p>Allows platform or application-specific initialization data to be passed to <code>CFBD_GPIOInit</code>. Cast to the concrete type expected by the underlying implementation when processing. </p>"},{"location":"api/Files/gpio_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/gpio_8h/#function-cfbd_gpioinit","title":"function CFBD_GPIOInit","text":"<pre><code>void CFBD_GPIOInit(\n    CFBD_GPIOHandle * handle,\n    CFBD_GPIOInitParams params\n)\n</code></pre> <p>Initialize a GPIO handle for subsequent operations. </p> <p>Parameters: </p> <ul> <li>handle Pointer to a <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code> structure to initialize. </li> <li>params Opaque initialization parameters (may be NULL). </li> </ul> <p>Performs any required platform-specific setup of <code>handle</code> using the supplied <code>params</code>. After successful initialization the <code>handle</code> should be ready for <code>CFBD_GPIOSet</code>/<code>CFBD_GPIOUnset</code>/<code>CFBD_GPIOToggle</code>.</p>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpioset","title":"function CFBD_GPIOSet","text":"<pre><code>void CFBD_GPIOSet(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Set (drive high) the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiounset","title":"function CFBD_GPIOUnset","text":"<pre><code>void CFBD_GPIOUnset(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Clear (drive low) the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiotoggle","title":"function CFBD_GPIOToggle","text":"<pre><code>void CFBD_GPIOToggle(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Toggle the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiosetpin","title":"function CFBD_GPIOSetPin","text":"<pre><code>static inline void CFBD_GPIOSetPin(\n    CFBD_GPIOHandle * handle,\n    CFBD_Bool status\n)\n</code></pre> <p>Inline helper to set or clear a GPIO based on <code>status</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> <li>status If <code>CFBD_TRUE</code>, set the pin; if <code>CFBD_FALSE</code>, clear it. </li> </ul> <p>Convenience wrapper that calls <code>CFBD_GPIOSet</code> when <code>status</code> is true, otherwise calls <code>CFBD_GPIOUnset</code>.</p>"},{"location":"api/Files/gpio_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include \"../gpio/gpio-stm-impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n\ntypedef uint32_t GPIO_PinType;\n\ntypedef void* GPIO_TypeHandle;\n\ntypedef struct\n{\n    GPIO_TypeHandle handle_internals_;\n\n    GPIO_PinType pin_internals_;\n} CFBD_GPIOHandle;\n\ntypedef void* CFBD_GPIOInitParams;\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params);\n\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle);\n\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle);\n\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle);\n\nstatic void inline CFBD_GPIOSetPin(CFBD_GPIOHandle* handle, CFBD_Bool status)\n{\n    status ? CFBD_GPIOSet(handle) : CFBD_GPIOUnset(handle);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/grapgic__device_8c/","title":"lib/graphic/device/grapgic_device.c","text":""},{"location":"api/Files/grapgic__device_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_BindDevice(CFBD_GraphicDevice * device, CFBDGraphic_DeviceType device_type, CFBDGraphicDeviceHandle internal_handle)"},{"location":"api/Files/grapgic__device_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/grapgic__device_8c/#function-cfbdgraphic_binddevice","title":"function CFBDGraphic_BindDevice","text":"<pre><code>void CFBDGraphic_BindDevice(\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_DeviceType device_type,\n    CFBDGraphicDeviceHandle internal_handle\n)\n</code></pre>"},{"location":"api/Files/grapgic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"graphic_device.h\"\n#include \"oled/oled_graphic_device.h\"\n\nvoid CFBDGraphic_BindDevice(CFBD_GraphicDevice* device,\n                            CFBDGraphic_DeviceType device_type,\n                            /*\n                             * OLED -&gt; CFBD_OLED*\n                             */\n                            CFBDGraphicDeviceHandle internal_handle)\n{\n    device-&gt;internal_handle = internal_handle;\n    device-&gt;device_type = device_type;\n    switch(device_type){\n        case OLED:\n            CFBDGraphic_BindOLEDAsDevice(device, internal_handle);\n            return;\n        default:\n            return;\n        break;\n    }\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/graphic__device_8h/","title":"lib/graphic/device/graphic_device.h","text":"<p>More...</p>"},{"location":"api/Files/graphic__device_8h/#classes","title":"Classes","text":"Name struct CFBD_GraphicDeviceOperation struct _CFBD_GraphicDevice"},{"location":"api/Files/graphic__device_8h/#types","title":"Types","text":"Name enum CFBDGraphic_DeviceType typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height) GraphicAreaOperations GraphicAreaOperations means for the area operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicFrameOperation GraphicFrameOperation indicates the frame related operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicOLEDSelfOperation GraphicOLEDSelfOperation self indicates. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, const char *property, void *args, void *request_data) GraphicOLED_QueryOperation GraphicOLED_QueryOperation device query. typedef void * CFBDGraphicDeviceHandle"},{"location":"api/Files/graphic__device_8h/#functions","title":"Functions","text":"Name CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(CFBD_GraphicDevice * device)Check if each operations should update after the calls. void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(CFBD_GraphicDevice * device, CFBD_Bool requests)Set if each operations should update after the calls. void CFBDGraphic_DeviceClearImmediate(CFBD_GraphicDevice * device) void CFBDGraphic_BindDevice(CFBD_GraphicDevice * device, CFBDGraphic_DeviceType device_type, CFBDGraphicDeviceHandle internal_handle)"},{"location":"api/Files/graphic__device_8h/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-05</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/graphic__device_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/graphic__device_8h/#enum-cfbdgraphic_devicetype","title":"enum CFBDGraphic_DeviceType","text":"Enumerator Value Description OLED"},{"location":"api/Files/graphic__device_8h/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicareaoperations","title":"typedef GraphicAreaOperations","text":"<pre><code>typedef CFBD_Bool(* GraphicAreaOperations) (CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\n</code></pre> <p>GraphicAreaOperations means for the area operations. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicframeoperation","title":"typedef GraphicFrameOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicFrameOperation) (CFBD_GraphicDevice *device);\n</code></pre> <p>GraphicFrameOperation indicates the frame related operations. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicoledselfoperation","title":"typedef GraphicOLEDSelfOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicOLEDSelfOperation) (CFBD_GraphicDevice *device);\n</code></pre> <p>GraphicOLEDSelfOperation self indicates. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-graphicoled_queryoperation","title":"typedef GraphicOLED_QueryOperation","text":"<pre><code>typedef CFBD_Bool(* GraphicOLED_QueryOperation) (CFBD_GraphicDevice *device, const char *property, void *args, void *request_data);\n</code></pre> <p>GraphicOLED_QueryOperation device query. </p>"},{"location":"api/Files/graphic__device_8h/#typedef-cfbdgraphicdevicehandle","title":"typedef CFBDGraphicDeviceHandle","text":"<pre><code>typedef void* CFBDGraphicDeviceHandle;\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_devicerequestupdateatonce","title":"function CFBDGraphic_DeviceRequestUpdateAtOnce","text":"<pre><code>static inline CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device\n)\n</code></pre> <p>Check if each operations should update after the calls. </p> <p>Parameters: </p> <ul> <li>device </li> </ul> <p>Return: CFBD_Bool </p>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_devicesetifrequestupdateatonce","title":"function CFBDGraphic_DeviceSetIfRequestUpdateAtOnce","text":"<pre><code>static inline void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device,\n    CFBD_Bool requests\n)\n</code></pre> <p>Set if each operations should update after the calls. </p> <p>Parameters: </p> <ul> <li>device </li> <li>requests </li> </ul>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_deviceclearimmediate","title":"function CFBDGraphic_DeviceClearImmediate","text":"<pre><code>static inline void CFBDGraphic_DeviceClearImmediate(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#function-cfbdgraphic_binddevice","title":"function CFBDGraphic_BindDevice","text":"<pre><code>void CFBDGraphic_BindDevice(\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_DeviceType device_type,\n    CFBDGraphicDeviceHandle internal_handle\n)\n</code></pre>"},{"location":"api/Files/graphic__device_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n\ntypedef CFBD_Bool (*GraphicAreaOperations)(CFBD_GraphicDevice* device,\n                                           uint16_t x,\n                                           uint16_t y,\n                                           uint16_t width,\n                                           uint16_t height);\ntypedef CFBD_Bool (*GraphicFrameOperation)(CFBD_GraphicDevice* device);\ntypedef CFBD_Bool (*GraphicOLEDSelfOperation)(CFBD_GraphicDevice* device);\n\ntypedef CFBD_Bool (*GraphicOLED_QueryOperation)(CFBD_GraphicDevice* device,\n                                                const char* property, // property for query\n                                                void* args,           // if property request args\n                                                void* request_data);  // contains results\n\ntypedef struct\n{\n    int (*init)(CFBD_GraphicDevice* device, void* init_args);\n\n    // enable the pixel lighten or set brushed color\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y);\n\n    // enable the area lightem or set brushed color\n    CFBD_Bool (*setArea)(CFBD_GraphicDevice* device,\n                         uint16_t x,\n                         uint16_t y,\n                         uint16_t width,\n                         uint16_t height,\n                         uint8_t* source);\n\n    /* Frame-level operations */\n    GraphicFrameOperation update; // update the frame\n    GraphicFrameOperation clear;  // clear the frame\n    GraphicFrameOperation revert; // revert the frame\n\n    /* Area-level operations */\n    GraphicAreaOperations update_area; // update the area given\n    GraphicAreaOperations clear_area;  // clear the area given\n    GraphicAreaOperations revert_area; // revert the area given\n\n    /* Open Close Devices */\n    GraphicOLEDSelfOperation open;\n    GraphicOLEDSelfOperation close;\n\n    /*\n     * Accept Queries:\n     *   rgb    -&gt; CFBD_Bool*\n     *   width  -&gt; uint16_t*\n     *   height -&gt; uint16_t*\n     */\n    GraphicOLED_QueryOperation self_consult;\n} CFBD_GraphicDeviceOperation;\n\ntypedef enum\n{\n    OLED\n} CFBDGraphic_DeviceType;\n\ntypedef void* CFBDGraphicDeviceHandle;\n\ntypedef struct _CFBD_GraphicDevice\n{\n    CFBD_GraphicDeviceOperation* ops;\n    CFBDGraphic_DeviceType device_type;\n    CFBDGraphicDeviceHandle internal_handle; // device handle internal\n    CFBD_Bool immediate_draw;                // mannual / auto updates\n} CFBD_GraphicDevice;\n\nstatic inline CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(CFBD_GraphicDevice* device)\n{\n    return device-&gt;immediate_draw;\n}\n\nstatic inline void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(CFBD_GraphicDevice* device,\n                                                              CFBD_Bool requests)\n{\n    device-&gt;immediate_draw = requests;\n}\n\nstatic inline void CFBDGraphic_DeviceClearImmediate(CFBD_GraphicDevice* device)\n{\n    device-&gt;ops-&gt;clear(device);\n    device-&gt;ops-&gt;update(device);\n}\n\nvoid CFBDGraphic_BindDevice(CFBD_GraphicDevice* device,\n                            CFBDGraphic_DeviceType device_type,\n                            /*\n                             * OLED -&gt; CFBD_OLED*\n                             */\n                            CFBDGraphicDeviceHandle internal_handle);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/helpers_8h/","title":"lib/graphic/widget/base_support/common/helpers.h","text":""},{"location":"api/Files/helpers_8h/#functions","title":"Functions","text":"Name int32_t clamp_i32(int32_t v, int32_t lo, int32_t hi)"},{"location":"api/Files/helpers_8h/#defines","title":"Defines","text":"Name MAX(a, b) MIN(a, b)"},{"location":"api/Files/helpers_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/helpers_8h/#function-clamp_i32","title":"function clamp_i32","text":"<pre><code>static inline int32_t clamp_i32(\n    int32_t v,\n    int32_t lo,\n    int32_t hi\n)\n</code></pre>"},{"location":"api/Files/helpers_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/helpers_8h/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/helpers_8h/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/helpers_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#ifndef MAX\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n\nstatic inline int32_t clamp_i32(int32_t v, int32_t lo, int32_t hi)\n{\n    if (v &lt; lo)\n        return lo;\n    if (v &gt; hi)\n        return hi;\n    return v;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8c/","title":"lib/iic/backend/i2c_stm_impl.c","text":""},{"location":"api/Files/i2c__stm__impl_8c/#functions","title":"Functions","text":"Name void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin)Initialize an STM32 I2C private structure. void stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_error(I2C_HandleTypeDef * hi2c) int stm32_init(CFBD_I2CHandle * bus) int stm32_deinit(CFBD_I2CHandle * bus) int stm32_transfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms) int stm32_is_device_ready(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) int stm32_recover_bus(CFBD_I2CHandle * bus) int stm32_get_error(CFBD_I2CHandle * bus) void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>."},{"location":"api/Files/i2c__stm__impl_8c/#attributes","title":"Attributes","text":"Name const CFBD_I2COperations stm32_i2c_ops"},{"location":"api/Files/i2c__stm__impl_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre> <p>Initialize an STM32 I2C private structure. </p> <p>Parameters: </p> <ul> <li>priv Pointer to the <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code> instance to initialize. </li> <li>hi2c Pointer to a valid <code>I2C_HandleTypeDef</code> (HAL instance). </li> <li>scl_port GPIO port used for SCL (e.g. GPIOA). </li> <li>scl_pin Pin mask/number for SCL. </li> <li>sda_port GPIO port used for SDA (e.g. GPIOA). </li> <li>sda_pin Pin mask/number for SDA. </li> </ul> <p>Populates the <code>priv</code> structure with supplied HAL handles and GPIO pins. This helper does not modify hardware state; it only prepares the private context prior to registering it with the public bus handle via <code>[stm32_i2c_bus_register()](Files/i2c__stm__impl_8h.md#function-stm32-i2c-bus-register)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_tx_cplt","title":"function stm32_i2c_on_master_tx_cplt","text":"<pre><code>void stm32_i2c_on_master_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_rx_cplt","title":"function stm32_i2c_on_master_rx_cplt","text":"<pre><code>void stm32_i2c_on_master_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_tx_cplt","title":"function stm32_i2c_on_mem_tx_cplt","text":"<pre><code>void stm32_i2c_on_mem_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_rx_cplt","title":"function stm32_i2c_on_mem_rx_cplt","text":"<pre><code>void stm32_i2c_on_mem_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_error","title":"function stm32_i2c_on_error","text":"<pre><code>void stm32_i2c_on_error(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_init","title":"function stm32_init","text":"<pre><code>static int stm32_init(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_deinit","title":"function stm32_deinit","text":"<pre><code>static int stm32_deinit(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_transfer","title":"function stm32_transfer","text":"<pre><code>static int stm32_transfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_is_device_ready","title":"function stm32_is_device_ready","text":"<pre><code>static int stm32_is_device_ready(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_recover_bus","title":"function stm32_recover_bus","text":"<pre><code>static int stm32_recover_bus(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_get_error","title":"function stm32_get_error","text":"<pre><code>static int stm32_get_error(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p> <p>Parameters: </p> <ul> <li>bus Pointer to the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> to register. </li> <li>priv Pointer to the initialized <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Associates the backend-private data with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. After registration the I2C handle's <code>ops</code> table should be populated by the STM32 backend implementation to provide operational functions (init, transfer, etc.).</p>"},{"location":"api/Files/i2c__stm__impl_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#variable-stm32_i2c_ops","title":"variable stm32_i2c_ops","text":"<pre><code>static const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"i2c_stm_impl.h\"\n\n#include \"../iic.h\"\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin)\n{\n    priv-&gt;hi2c = hi2c;\n    priv-&gt;scl_pin = scl_pin;\n    priv-&gt;scl_port = scl_port;\n    priv-&gt;sda_port = sda_port;\n    priv-&gt;sda_pin = sda_pin;\n}\n\n/* forward declear */\nvoid stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_error(I2C_HandleTypeDef* hi2c);\n\n/* forward ops */\nstatic int stm32_init(CFBD_I2CHandle* bus);\nstatic int stm32_deinit(CFBD_I2CHandle* bus);\nstatic int\nstm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms);\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus);\nstatic int stm32_get_error(CFBD_I2CHandle* bus);\n\nstatic const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv)\n{\n    bus-&gt;ops = &amp;stm32_i2c_ops;\n    bus-&gt;private_handle = priv;\n}\n\n/* ---------- lifecycle ---------- */\nstatic int stm32_init(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    if (HAL_I2C_GetState(p-&gt;hi2c) == HAL_I2C_STATE_RESET) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_deinit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    if (HAL_I2C_DeInit(p-&gt;hi2c) != HAL_OK) {\n        p-&gt;last_err = I2C_ERR_IO;\n        return I2C_ERR_IO;\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle || !msgs || num &lt;= 0)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    for (int i = 0; i &lt; num; ++i) {\n        CFBD_I2C_Message* m = &amp;msgs[i];\n        uint16_t devAddr = ((m-&gt;addr &amp; 0x7F) &lt;&lt; 1);\n        HAL_StatusTypeDef status;\n\n        if ((m-&gt;flags &amp; I2C_M_RD) == 0) {\n            /* write */\n            if (i + 1 &lt; num) {\n                CFBD_I2C_Message* next = &amp;msgs[i + 1];\n                if (!(next-&gt;flags &amp; I2C_M_RD) &amp;&amp; next-&gt;addr == m-&gt;addr &amp;&amp; m-&gt;len == 1) {\n                    uint16_t memAddr = m-&gt;buf[0];\n\n                    // \u2705 \u4f7f\u7528 DMA\uff08\u5982\u679c\u6709\uff09\u5426\u5219\u8f6e\u8be2\n                    if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                        status = HAL_I2C_Mem_Write_DMA(p-&gt;hi2c,\n                                                       devAddr,\n                                                       memAddr,\n                                                       I2C_MEMADD_SIZE_8BIT,\n                                                       next-&gt;buf,\n                                                       next-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        // \u7b49\u5f85 DMA \u5b8c\u6210\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        // \u56de\u9000\u5230\u8f6e\u8be2\u6a21\u5f0f\n                        status = HAL_I2C_Mem_Write(p-&gt;hi2c,\n                                                   devAddr,\n                                                   memAddr,\n                                                   I2C_MEMADD_SIZE_8BIT,\n                                                   next-&gt;buf,\n                                                   next-&gt;len,\n                                                   timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n\n                    i++;\n                    continue;\n                }\n            }\n\n            // \u666e\u901a\u5199\n            if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                status = HAL_I2C_Master_Transmit_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Transmit(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n        else {\n            /* read */\n            if (i &gt; 0) {\n                CFBD_I2C_Message* prev = &amp;msgs[i - 1];\n                if (!(prev-&gt;flags &amp; I2C_M_RD) &amp;&amp; prev-&gt;addr == m-&gt;addr &amp;&amp;\n                    (prev-&gt;len == 1 || prev-&gt;len == 2)) {\n                    uint16_t mem = 0;\n                    if (prev-&gt;len == 1)\n                        mem = prev-&gt;buf[0];\n                    else\n                        mem = ((uint16_t) prev-&gt;buf[0] &lt;&lt; 8) | prev-&gt;buf[1];\n                    uint16_t memadd =\n                            (prev-&gt;len == 1) ? I2C_MEMADD_SIZE_8BIT : I2C_MEMADD_SIZE_16BIT;\n\n                    // \u4f7f\u7528 DMA \u8bfb\n                    if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                        status =\n                                HAL_I2C_Mem_Read_DMA(p-&gt;hi2c, devAddr, mem, memadd, m-&gt;buf, m-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        status = HAL_I2C_Mem_Read(p-&gt;hi2c,\n                                                  devAddr,\n                                                  mem,\n                                                  memadd,\n                                                  m-&gt;buf,\n                                                  m-&gt;len,\n                                                  timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            // \u666e\u901a\u8bfb\n            if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                status = HAL_I2C_Master_Receive_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Receive(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\n/* ---------- rest (is_device_ready, recover, get_error) ---------- */\n\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    uint16_t devAddr = (addr &amp; 0x7F) &lt;&lt; 1;\n    if (HAL_I2C_IsDeviceReady(p-&gt;hi2c, devAddr, trials, timeout_ms) == HAL_OK) {\n        p-&gt;last_err = I2C_OK;\n        return I2C_OK;\n    }\n    p-&gt;last_err = I2C_ERR_IO;\n    return I2C_ERR_IO;\n}\n\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;scl_port || !p-&gt;sda_port)\n        return I2C_ERR_INVAL;\n\n    if (p-&gt;hi2c)\n        HAL_I2C_DeInit(p-&gt;hi2c);\n\n    GPIO_InitTypeDef gpio = {0};\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    for (int i = 0; i &lt; 9; ++i) {\n        if (HAL_GPIO_ReadPin(p-&gt;sda_port, p-&gt;sda_pin) == GPIO_PIN_SET)\n            break;\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_RESET);\n        HAL_Delay(1);\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n        HAL_Delay(1);\n    }\n\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_RESET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    if (p-&gt;hi2c) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_get_error(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    return p-&gt;last_err;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8h/","title":"lib/iic/backend/i2c_stm_impl.h","text":"<p>STM32 HAL-based I2C backend private types and helpers.  More...</p>"},{"location":"api/Files/i2c__stm__impl_8h/#classes","title":"Classes","text":"Name struct CFBD_ST_I2CPrivate Backend-private state for the STM32 I2C implementation."},{"location":"api/Files/i2c__stm__impl_8h/#functions","title":"Functions","text":"Name I2C_HandleTypeDef * native_handle(CFBD_ST_I2CPrivate * priv)Helper to obtain the native HAL I2C handle from the private struct. void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin)Initialize an STM32 I2C private structure. void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>."},{"location":"api/Files/i2c__stm__impl_8h/#detailed-description","title":"Detailed Description","text":"<p>STM32 HAL-based I2C backend private types and helpers. </p> <p>Note: This header depends on STM32 HAL types such as <code>I2C_HandleTypeDef</code> and <code>GPIO_TypeDef</code> and is only relevant when building for ST platforms. </p> <p>Provides the STM32-specific private handle used by the project's CFBD I2C abstraction. The private handle contains HAL peripheral references and GPIO pin information used for optional bus recovery or low-level operations. Utility functions are provided to initialize the private structure and register it with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8h/#function-native_handle","title":"function native_handle","text":"<pre><code>static inline I2C_HandleTypeDef * native_handle(\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Helper to obtain the native HAL I2C handle from the private struct. </p> <p>Parameters: </p> <ul> <li>priv Pointer to <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Return: I2C_HandleTypeDef* Native HAL handle or NULL if <code>priv</code> is NULL. </p>"},{"location":"api/Files/i2c__stm__impl_8h/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre> <p>Initialize an STM32 I2C private structure. </p> <p>Parameters: </p> <ul> <li>priv Pointer to the <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code> instance to initialize. </li> <li>hi2c Pointer to a valid <code>I2C_HandleTypeDef</code> (HAL instance). </li> <li>scl_port GPIO port used for SCL (e.g. GPIOA). </li> <li>scl_pin Pin mask/number for SCL. </li> <li>sda_port GPIO port used for SDA (e.g. GPIOA). </li> <li>sda_pin Pin mask/number for SDA. </li> </ul> <p>Populates the <code>priv</code> structure with supplied HAL handles and GPIO pins. This helper does not modify hardware state; it only prepares the private context prior to registering it with the public bus handle via <code>[stm32_i2c_bus_register()](Files/i2c__stm__impl_8h.md#function-stm32-i2c-bus-register)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8h/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p> <p>Parameters: </p> <ul> <li>bus Pointer to the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> to register. </li> <li>priv Pointer to the initialized <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Associates the backend-private data with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. After registration the I2C handle's <code>ops</code> table should be populated by the STM32 backend implementation to provide operational functions (init, transfer, etc.).</p>"},{"location":"api/Files/i2c__stm__impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../iic.h\"\n#include \"lib_settings.h\"\n\ntypedef struct\n{\n    I2C_HandleTypeDef* hi2c;\n\n    GPIO_TypeDef* scl_port;\n\n    uint16_t scl_pin;\n\n    GPIO_TypeDef* sda_port;\n\n    uint16_t sda_pin;\n\n    int last_err;\n} CFBD_ST_I2CPrivate;\n\nstatic inline I2C_HandleTypeDef* native_handle(CFBD_ST_I2CPrivate* priv)\n{\n    return priv ? priv-&gt;hi2c : NULL;\n}\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin);\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/iic_8c/","title":"lib/iic/iic.c","text":""},{"location":"api/Files/iic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"iic.h\"\n#include &lt;stdint.h&gt;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/iic_8h/","title":"lib/iic/iic.h","text":"<p>I2C (IIC) abstraction layer for CFBD drivers.  More...</p>"},{"location":"api/Files/iic_8h/#classes","title":"Classes","text":"Name struct _CFBD_I2C_Message struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus. struct _CFBD_I2CHandle struct CFBD_I2C_IORequestParams Helper structure used by convenience read/write helpers."},{"location":"api/Files/iic_8h/#types","title":"Types","text":"Name typedef struct _CFBD_I2C_Message CFBD_I2C_Message typedef void(int status, void *arg) CFBD_I2C_AsyncCallback Signature for asynchronous I2C transfer completion callbacks. typedef struct _CFBD_I2CHandle CFBD_I2CHandle Opaque forward-declared type representing an I2C bus instance. typedef void * CFBD_I2CPrivateHandle Opaque pointer for backend-private state stored in the handle."},{"location":"api/Files/iic_8h/#defines","title":"Defines","text":"Name I2C_M_RD Flag indicating a read transfer (slave -&gt; master). I2C_M_NOSTART Flag to suppress START condition between messages."},{"location":"api/Files/iic_8h/#detailed-description","title":"Detailed Description","text":"<p>I2C (IIC) abstraction layer for CFBD drivers. </p> <p>This header defines a lightweight, backend-pluggable I2C interface used by drivers in the project (for example the OLED driver). The abstraction exposes message-based transfers, device readiness checks, error reporting and optional DMA hooks. Concrete backends implement the <code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code> table and populate <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p>"},{"location":"api/Files/iic_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_message","title":"typedef CFBD_I2C_Message","text":"<pre><code>typedef struct _CFBD_I2C_Message CFBD_I2C_Message;\n</code></pre>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_asynccallback","title":"typedef CFBD_I2C_AsyncCallback","text":"<pre><code>CFBD_I2C_AsyncCallback;\n</code></pre> <p>Signature for asynchronous I2C transfer completion callbacks. </p> <p>Parameters: </p> <ul> <li>status Result status code (I2C_OK or negative error code). </li> <li>arg User-provided argument passed through the async API.</li> </ul> <p>Par: Example - Async Transfer with Callback</p> <pre><code>struct TransferContext {\n    uint8_t *data;\n    size_t len;\n    int error_count;\n} ctx;\n\nvoid transfer_complete_callback(int status, void *arg) {\n    struct TransferContext *ctx = (struct TransferContext *)arg;\n\n    if (status != I2C_OK) {\n        ctx-&gt;error_count++;\n        if (status == I2C_ERR_TIMEOUT) {\n            // Timeout handling\n            schedule_retry();\n        }\n    } else {\n        // Transfer successful\n        process_received_data(ctx-&gt;data, ctx-&gt;len);\n    }\n}\n\n// Initiate async transfer\nctx.data = buffer;\nctx.len = sizeof(buffer);\nCFBD_I2CTransferAsync(bus, msgs, count, transfer_complete_callback, &amp;ctx);\n</code></pre> <p>Called when an asynchronous I2C operation completes. Enables interrupt-driven or DMA-based transfers without blocking the main application thread.</p>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2chandle","title":"typedef CFBD_I2CHandle","text":"<pre><code>typedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n</code></pre> <p>Opaque forward-declared type representing an I2C bus instance. </p> <p>Represents a single I2C bus in the system. The handle combines backend-agnostic operations with platform-specific state. </p>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2cprivatehandle","title":"typedef CFBD_I2CPrivateHandle","text":"<pre><code>CFBD_I2CPrivateHandle;\n</code></pre> <p>Opaque pointer for backend-private state stored in the handle. </p> <p>Backend implementations use this to store any hardware-specific data, such as peripheral base addresses, interrupt handlers, DMA channel info, etc. </p>"},{"location":"api/Files/iic_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/iic_8h/#define-i2c_m_rd","title":"define I2C_M_RD","text":"<pre><code>#define I2C_M_RD 0x0001 /* read data, from slave to master */\n</code></pre> <p>Flag indicating a read transfer (slave -&gt; master). </p> <p>Par: Example - Combined Write-Read Transfer</p> <pre><code>// Many I2C devices require: write address, then read data\nCFBD_I2C_Message msgs[2];\nuint8_t cmd = 0x01;  // Command/register\nuint8_t response[8];\n\n// Write command (no I2C_M_RD flag)\nmsgs[0].addr = 0x50;\nmsgs[0].flags = 0;\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;cmd;\n\n// Read response (with I2C_M_RD flag)\nmsgs[1].addr = 0x50;\nmsgs[1].flags = I2C_M_RD;  // Indicates read operation\nmsgs[1].len = sizeof(response);\nmsgs[1].buf = response;\n\nCFBD_I2CTransfer(bus, msgs, 2, 1000);\n</code></pre> <p>When set in a message's <code>flags</code> field, indicates that the message direction is a read operation (master receives from slave).</p>"},{"location":"api/Files/iic_8h/#define-i2c_m_nostart","title":"define I2C_M_NOSTART","text":"<pre><code>#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n</code></pre> <p>Flag to suppress START condition between messages. </p> <p>When set, prevents generation of a START condition before this message. Used in specialized scenarios (rare) where messages should be combined without intermediate START conditions. </p>"},{"location":"api/Files/iic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"iic_error.h\"\n\n#define I2C_M_RD 0x0001 /* read data, from slave to master */\n\n#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n\ntypedef struct _CFBD_I2C_Message\n{\n    uint16_t addr;  \n    uint16_t flags; \n    uint16_t len;   \n    uint8_t* buf;   \n} CFBD_I2C_Message;\n\n/* Async Callbacks */\ntypedef void CFBD_I2C_AsyncCallback(int status, void* arg);\n\ntypedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n\ntypedef struct\n{\n    int (*init)(CFBD_I2CHandle* handle);\n\n    int (*deinit)(CFBD_I2CHandle* handle);\n\n    int (*transfer)(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\n\n    int (*is_device_ready)(CFBD_I2CHandle* bus,\n                           uint16_t addr,\n                           uint32_t trials,\n                           uint32_t timeout_ms);\n\n    int (*recover_bus)(CFBD_I2CHandle* bus);\n\n    int (*get_error)(CFBD_I2CHandle* bus);\n\n    /* optional DMA hooks */\n    int (*tx_dma_start)(CFBD_I2CHandle* bus, const uint8_t* buf, size_t len);\n\n    int (*rx_dma_start)(CFBD_I2CHandle* bus, uint8_t* buf, size_t len);\n} CFBD_I2COperations;\n\ntypedef void* CFBD_I2CPrivateHandle;\n\ntypedef struct _CFBD_I2CHandle\n{\n    const CFBD_I2COperations* ops;        \n    CFBD_I2CPrivateHandle private_handle; \n} CFBD_I2CHandle;\n\n/* --------- inline wrappers  ---------- */\nstatic inline int CFBD_I2CInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;init)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;init(bus);\n}\n\nstatic inline int CFBD_I2CDeInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;deinit)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;deinit(bus);\n}\n\nstatic inline int\nCFBD_I2CTransfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;transfer)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;transfer(bus, msgs, num, timeout_ms);\n}\n\nstatic inline int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle* bus,\n                                                uint16_t addr,\n                                                uint32_t trials,\n                                                uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;is_device_ready)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;is_device_ready(bus, addr, trials, timeout_ms);\n}\n\nstatic inline int CFBD_I2CRecoverBus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;recover_bus)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;recover_bus(bus);\n}\n\ntypedef struct\n{\n    uint16_t addr7;        \n    uint32_t mem_addr;     \n    uint8_t mem_addr_size; \n    uint8_t* data;         \n    uint16_t len;          \n    uint32_t timeout_ms;   \n} CFBD_I2C_IORequestParams;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\n\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\n\n#include \"lib_settings.h\"\n#if defined(CFBD_IS_ST)\n#include \"backend/i2c_stm_impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/iic__error_8h/","title":"lib/iic/iic_error.h","text":"<p>I2C/IIC error codes used by the CFBD I2C abstraction.  More...</p>"},{"location":"api/Files/iic__error_8h/#detailed-description","title":"Detailed Description","text":"<p>I2C/IIC error codes used by the CFBD I2C abstraction. </p> <p>Small set of error code macros used across the I2C driver infrastructure. Error codes mirror common POSIX/Linux errno-style values to ease mapping to platform-level errors. </p>"},{"location":"api/Files/iic__error_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define I2C_OK 0\n\n#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n\n#define I2C_ERR_NACK -121 /* -EPROTO (nack) */\n\n#define I2C_ERR_BUSY -16 /* -EBUSY */\n\n#define I2C_ERR_IO -5 /* -EIO */\n\n#define I2C_ERR_INVAL -22 /* -EINVAL */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/image_8c/","title":"lib/graphic/widget/base_support/image.c","text":""},{"location":"api/Files/image_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image)"},{"location":"api/Files/image_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8c/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8c/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8c/#source-code","title":"Source code","text":"<pre><code>#include \"image.h\"\n\n#include \"device/graphic_device.h\"\n\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register)\n{\n    image-&gt;image_size = *image_size;\n    image-&gt;point = *tl_point;\n    image-&gt;sources_register = sources_register;\n}\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image)\n{\n    if (!image-&gt;sources_register)\n        return;\n    handler-&gt;ops-&gt;setArea(\n        handler, image-&gt;point.x, image-&gt;point.y,\n        image-&gt;image_size.width, image-&gt;image_size.height, image-&gt;sources_register\n    );\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/image_8h/","title":"lib/graphic/widget/base_support/image.h","text":""},{"location":"api/Files/image_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Image"},{"location":"api/Files/image_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image)"},{"location":"api/Files/image_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8h/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8h/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point point;\n    CFBDGraphicSize image_size;\n    uint8_t* sources_register;\n} CCGraphic_Image;\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register);\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/lib__settings_8h/","title":"lib/config/lib_settings.h","text":""},{"location":"api/Files/lib__settings_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"config/system_settings.h\"\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/line_8c/","title":"line.c","text":""},{"location":"api/Files/line_8c/#functions","title":"Functions","text":"Name void swap_int16(int16_t * val1, int16_t * val2) uint16_t max_uint16(uint16_t val1, uint16_t val2) uint16_t min_uint16(uint16_t val1, uint16_t val2) void clearBounds(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_vertical_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_horizental_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __pvt_BresenhamMethod_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Files/line_8c/#defines","title":"Defines","text":"Name __pvt_fast_draw_point(X, Y)"},{"location":"api/Files/line_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/line_8c/#function-swap_int16","title":"function swap_int16","text":"<pre><code>static inline void swap_int16(\n    int16_t * val1,\n    int16_t * val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-max_uint16","title":"function max_uint16","text":"<pre><code>static inline uint16_t max_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-min_uint16","title":"function min_uint16","text":"<pre><code>static inline uint16_t min_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-clearbounds","title":"function clearBounds","text":"<pre><code>static inline void clearBounds(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_vertical_line","title":"function __on_handle_vertical_line","text":"<pre><code>static void __on_handle_vertical_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_horizental_line","title":"function __on_handle_horizental_line","text":"<pre><code>static void __on_handle_horizental_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__pvt_bresenhammethod_line","title":"function __pvt_BresenhamMethod_line","text":"<pre><code>void __pvt_BresenhamMethod_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/line_8c/#define-__pvt_fast_draw_point","title":"define __pvt_fast_draw_point","text":"<pre><code>#define __pvt_fast_draw_point(\n    X,\n    Y\n)\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/line_8c/#source-code","title":"Source code","text":"<pre><code>#include \"line.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\nstatic inline void swap_int16(int16_t* val1, int16_t* val2)\n{\n    if (*val1 == *val2)\n        return;\n    *val1 ^= *val2;\n    *val2 ^= *val1;\n    *val1 ^= *val2;\n}\n\nstatic inline uint16_t max_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &gt; val2 ? val1 : val2;\n}\n\nstatic inline uint16_t min_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &lt; val2 ? val1 : val2;\n}\n\nstatic inline void clearBounds(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    int32_t lx = asInt32_t(line-&gt;p_left.x);\n    int32_t rx = asInt32_t(line-&gt;p_right.x);\n    int32_t ty = asInt32_t(line-&gt;p_left.y);\n    int32_t by = asInt32_t(line-&gt;p_right.y);\n\n    if (lx &gt; rx) {\n        int32_t t = lx;\n        lx = rx;\n        rx = t;\n    }\n    if (ty &gt; by) {\n        int32_t t = ty;\n        ty = by;\n        by = t;\n    }\n}\n\n/*\n    draw the lines that matches the equal x\n*/\nstatic void __on_handle_vertical_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    PointBaseType max_y = max_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType min_y = min_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType x = line-&gt;p_left.x;\n    PointBaseType y;\n    CFBD_Bool (*setpixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    for (PointBaseType i = min_y; i &lt;= max_y; i++) {\n        y = i;\n        setpixel(handler, x, y);\n    }\n}\n\nstatic void __on_handle_horizental_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    PointBaseType max_x = max_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType min_x = min_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType x;\n    PointBaseType y = line-&gt;p_left.y;\n    for (PointBaseType i = min_x; i &lt;= max_x; i++) {\n        x = i;\n        setPixel(handler, x, y);\n    }\n}\n\n// Bresenham's Line Algorithm, designed to avoid floating point calculations\n// References: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf\n// https://www.bilibili.com/video/BV1364y1d7Lo\nvoid __pvt_BresenhamMethod_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n\n#define __pvt_fast_draw_point(X, Y)                                                                \\\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n\n    // Define initial points for the line: p_left and p_right represent the endpoints\n    int16_t startX = line-&gt;p_left.x;\n    int16_t startY = line-&gt;p_left.y;\n    int16_t endX = line-&gt;p_right.x;\n    int16_t endY = line-&gt;p_right.y;\n\n    // Flags to indicate transformations of coordinates\n    uint8_t isYInverted = 0, isXYInverted = 0;\n    {\n        // If the start point's X coordinate is greater than the end point's X, swap the points\n        if (startX &gt; endX) {\n            // Swap the X and Y coordinates for the start and end points\n            swap_int16(&amp;startX, &amp;endX);\n            swap_int16(&amp;startY, &amp;endY);\n        }\n\n        // If the start point's Y coordinate is greater than the end point's Y, invert the Y\n        // coordinates\n        if (startY &gt; endY) {\n            // Invert Y coordinates to make the line direction consistent in the first quadrant\n            startY = -startY;\n            endY = -endY;\n            // Set the flag indicating Y coordinates were inverted\n            isYInverted = 1;\n        }\n\n        // If the line's slope (dy/dx) is greater than 1, swap X and Y coordinates for a shallower\n        // slope\n        if (endY - startY &gt; endX - startX) {\n            // Swap X and Y coordinates for both points\n            swap_int16(&amp;startX, &amp;startY);\n            swap_int16(&amp;endX, &amp;endY);\n            // Set the flag indicating both X and Y coordinates were swapped\n            isXYInverted = 1;\n        }\n\n        // Calculate differences (dx, dy) and the decision variables for Bresenham's algorithm\n        const int16_t dx = endX - startX;\n        const int16_t dy = endY - startY;\n        const int16_t incrE = 2 * dy;         // Increment for eastward movement\n        const int16_t incrNE = 2 * (dy - dx); // Increment for northeastward movement\n\n        int16_t decision = 2 * dy - dx; // Initial decision variable\n        int16_t x = startX;             // Starting X coordinate\n        int16_t y = startY;             // Starting Y coordinate\n\n        // Draw the starting point and handle coordinate transformations based on flags\n        if (isYInverted &amp;&amp; isXYInverted) {\n            __pvt_fast_draw_point(y, -x);\n        }\n        else if (isYInverted) {\n            __pvt_fast_draw_point(x, -y);\n        }\n        else if (isXYInverted) {\n            __pvt_fast_draw_point(y, x);\n        }\n        else {\n            __pvt_fast_draw_point(x, y);\n        }\n\n        // Iterate through the X-axis to draw the rest of the line\n        while (x &lt; endX) {\n            x++; // Increment X coordinate\n            if (decision &lt; 0) {\n                decision += incrE; // Move eastward if decision variable is negative\n            }\n            else {\n                y++; // Move northeastward if decision variable is positive or zero\n                decision += incrNE;\n            }\n\n            // Draw each point along the line with coordinate transformation as needed\n            if (isYInverted &amp;&amp; isXYInverted) {\n                __pvt_fast_draw_point(y, -x);\n            }\n            else if (isYInverted) {\n                __pvt_fast_draw_point(x, -y);\n            }\n            else if (isXYInverted) {\n                __pvt_fast_draw_point(y, x);\n            }\n            else {\n                __pvt_fast_draw_point(x, y);\n            }\n        }\n    }\n}\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    clearBounds(handler, line);\n    // test if the vertical\n    if (line-&gt;p_left.x == line-&gt;p_right.x)\n        __on_handle_vertical_line(handler, line);\n    if (line-&gt;p_left.y == line-&gt;p_right.y)\n        __on_handle_horizental_line(handler, line);\n    __pvt_BresenhamMethod_line(handler, line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(line-&gt;p_left.x);\n        int32_t rx = asInt32_t(line-&gt;p_right.x);\n        int32_t ty = asInt32_t(line-&gt;p_left.y);\n        int32_t by = asInt32_t(line-&gt;p_right.y);\n\n        if (lx &gt; rx) {\n            int32_t t = lx;\n            lx = rx;\n            rx = t;\n        }\n        if (ty &gt; by) {\n            int32_t t = ty;\n            ty = by;\n            by = t;\n        }\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/line_8h/","title":"line.h","text":"<p>Line drawing utilities for 2D graphics rendering. </p>"},{"location":"api/Files/line_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Line Represents a line segment defined by two endpoints."},{"location":"api/Files/line_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point p_left;  \n    CFBDGraphic_Point p_right; \n} CFBDGraphic_Line;\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line);\n\n // End of Line_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/margin_8h/","title":"lib/graphic/widget/margin.h","text":""},{"location":"api/Files/margin_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Margin"},{"location":"api/Files/margin_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    PointBaseType left, top, right, bottom;\n} CFBDGraphic_Margin;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu_8c/","title":"lib/graphic/widget/menu/menu.c","text":""},{"location":"api/Files/menu_8c/#functions","title":"Functions","text":"Name const uint16_t get_menu_new_item_x(CFBD_Menu * pMenu) const uint16_t get_menu_new_item_height(CFBD_MenuItem * item) const uint16_t get_menu_new_item_y(CFBD_Menu * pMenu) void CFBD_BindMenuItems(CFBD_Menu * pMenu, CFBD_MenuItemGroup * assigned_menu_items) void CFBD_AnimationSet(CFBD_Menu * pMenu, CFBD_BaseAnimation * pBaseAnimation) CFBD_Bool CFBD_MenuAddItems(CFBD_Menu * pMenu, const char * label, Ascii_Font_Size font_size, CFBD_MenuItemCallbackPack * callbacks) void CFBD_DrawMenu(CFBD_Menu * m) void redraw_item(CFBD_Menu * m, int idx) void OLED_Menu_Select(CFBD_Menu * m, int new_index) void reset_tl_points(CFBD_Menu * m, CFBDGraphic_Point * p, CFBD_Bool request_updates) void OLED_Menu_Activate(CFBD_Menu * m) void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width)"},{"location":"api/Files/menu_8c/#attributes","title":"Attributes","text":"Name CFBD_MenuOps _ops"},{"location":"api/Files/menu_8c/#defines","title":"Defines","text":"Name CFBD_MENU_ITEM_Y_GAP MAKE_RECT(rx, ry, rw, rh)"},{"location":"api/Files/menu_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8c/#function-get_menu_new_item_x","title":"function get_menu_new_item_x","text":"<pre><code>static inline const uint16_t get_menu_new_item_x(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_height","title":"function get_menu_new_item_height","text":"<pre><code>static const uint16_t get_menu_new_item_height(\n    CFBD_MenuItem * item\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_y","title":"function get_menu_new_item_y","text":"<pre><code>static const uint16_t get_menu_new_item_y(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_bindmenuitems","title":"function CFBD_BindMenuItems","text":"<pre><code>static void CFBD_BindMenuItems(\n    CFBD_Menu * pMenu,\n    CFBD_MenuItemGroup * assigned_menu_items\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_animationset","title":"function CFBD_AnimationSet","text":"<pre><code>static void CFBD_AnimationSet(\n    CFBD_Menu * pMenu,\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_menuadditems","title":"function CFBD_MenuAddItems","text":"<pre><code>static CFBD_Bool CFBD_MenuAddItems(\n    CFBD_Menu * pMenu,\n    const char * label,\n    Ascii_Font_Size font_size,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_drawmenu","title":"function CFBD_DrawMenu","text":"<pre><code>static void CFBD_DrawMenu(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-redraw_item","title":"function redraw_item","text":"<pre><code>static void redraw_item(\n    CFBD_Menu * m,\n    int idx\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_select","title":"function OLED_Menu_Select","text":"<pre><code>void OLED_Menu_Select(\n    CFBD_Menu * m,\n    int new_index\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-reset_tl_points","title":"function reset_tl_points","text":"<pre><code>static void reset_tl_points(\n    CFBD_Menu * m,\n    CFBDGraphic_Point * p,\n    CFBD_Bool request_updates\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_activate","title":"function OLED_Menu_Activate","text":"<pre><code>static void OLED_Menu_Activate(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu_8c/#variable-_ops","title":"variable _ops","text":"<pre><code>static CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n</code></pre>"},{"location":"api/Files/menu_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/menu_8c/#define-cfbd_menu_item_y_gap","title":"define CFBD_MENU_ITEM_Y_GAP","text":"<pre><code>#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre>"},{"location":"api/Files/menu_8c/#define-make_rect","title":"define MAKE_RECT","text":"<pre><code>#define MAKE_RECT(\n    rx,\n    ry,\n    rw,\n    rh\n)\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n</code></pre>"},{"location":"api/Files/menu_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_config.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/base_support/common/helpers.h\"\n#include \"widget/menu/menu.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\nstatic inline const uint16_t get_menu_new_item_x(CFBD_Menu* pMenu)\n{\n    return pMenu-&gt;tl_point.x + pMenu-&gt;indicator.width + pMenu-&gt;indicator.x +\n           CFBD_MENU_INDICATOR_GAP;\n}\n\nstatic const uint16_t get_menu_new_item_height(CFBD_MenuItem* item)\n{\n    CFBDGraphicSize sz = __fetch_font_size(item-&gt;text_obj.font_size);\n    return (sz.height + 2 * CFBD_MENU_ITEM_Y_GAP);\n}\n\nstatic const uint16_t get_menu_new_item_y(CFBD_Menu* pMenu)\n{\n    uint16_t result = pMenu-&gt;tl_point.y;\n    if (!pMenu || !pMenu-&gt;menu_items) {\n        return result;\n    }\n\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    for (uint8_t i = 0; i &lt; group-&gt;count; i++) {\n        result += get_menu_new_item_height(&amp;group-&gt;pItems[i]);\n    }\n    return result + CFBD_MENU_ITEM_Y_GAP;\n}\n\nstatic void CFBD_BindMenuItems(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items)\n{\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n\nstatic void CFBD_AnimationSet(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation)\n{\n    pMenu-&gt;animation = *pBaseAnimation;\n}\n\nstatic CFBD_Bool CFBD_MenuAddItems(CFBD_Menu* pMenu,\n                                   const char* label,\n                                   Ascii_Font_Size font_size,\n                                   CFBD_MenuItemCallbackPack* callbacks)\n{\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    if (group-&gt;count &gt;= group-&gt;capacity) {\n        return CFBD_FALSE;\n    }\n\n    CFBD_MenuItem* it = &amp;group-&gt;pItems[group-&gt;count];\n    it-&gt;label = (char*) label;\n    CFBDGraphic_Point p = {.x = get_menu_new_item_x(pMenu), .y = get_menu_new_item_y(pMenu)};\n    CFBD_MenuItemInit(it, &amp;p, callbacks);\n    CFBDGraphicSize sz = {.width = pMenu-&gt;max_width,\n                          .height = __fetch_font_size(font_size).height + 2 * CFBD_MENU_ITEM_Y_GAP};\n    /* init text object */\n    CFBDGraphic_InitText(&amp;it-&gt;text_obj, it-&gt;tl, sz, font_size);\n    CFBDGraphic_SetText(&amp;it-&gt;text_obj, it-&gt;label);\n    group-&gt;count++;\n\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_DrawMenu(CFBD_Menu* m)\n{\n    CFBD_GraphicDevice* dev = m-&gt;device;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    for (size_t i = 0; i &lt; group-&gt;count; ++i) {\n        CFBD_MenuItem* it = &amp;group-&gt;pItems[i];\n        CFBDGraphic_DrawText(dev, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    /* draw indicator at selected */\n    if (m-&gt;selected &gt;= 0 &amp;&amp; (size_t) m-&gt;selected &lt; group-&gt;count) {\n        CFBD_MenuItem* sel = &amp;group-&gt;pItems[m-&gt;selected];\n        uint16_t ix = m-&gt;tl_point.x + m-&gt;indicator.x;\n        uint16_t iy = sel-&gt;tl.y;\n        uint16_t ih = rect_height(&amp;sel-&gt;text_obj.text_bounding_rect);\n        CFBD_DrawMenuIndicator(m, ix, iy, m-&gt;indicator.width, ih);\n\n        /* reversed the target */\n        CFBDGraphic_Text* text = &amp;sel-&gt;text_obj;\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    text-&gt;tl_point.x,\n                                    text-&gt;tl_point.y,\n                                    rect_width(&amp;text-&gt;text_bounding_rect),\n                                    ih);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(m-&gt;device)) {\n        m-&gt;device-&gt;ops-&gt;update(m-&gt;device);\n    }\n}\n\nstatic void redraw_item(CFBD_Menu* m, int idx)\n{\n    if (idx &lt; 0 || (size_t) idx &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[idx];\n\n    /* \u4f7f\u7528\u9a71\u52a8\u63d0\u4f9b\u7684 clear_area\uff08clear_rect_area \u5df2\u7ecf\u4f1a\u4ee3\u7406\uff09 */\n    CFBDGraphicSize* size = &amp;it-&gt;text_obj.TexthandleSize;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, it-&gt;tl.x, it-&gt;tl.y, size-&gt;width, size-&gt;height);\n    CFBDGraphic_DrawText(m-&gt;device, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nvoid OLED_Menu_Select(CFBD_Menu* m, int new_index)\n{\n    if (new_index &lt; 0)\n        new_index = 0;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    if (new_index &gt;= (int) group-&gt;count)\n        new_index = (int) group-&gt;count - 1;\n    int old = m-&gt;selected;\n    if (old == new_index)\n        return;\n\n    uint16_t start_y = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? group-&gt;pItems[old].tl.y\n                                                                 : group-&gt;pItems[0].tl.y;\n\n    uint16_t end_y = group-&gt;pItems[new_index].tl.y;\n    int frames = (m-&gt;animation.anim_frames &gt; 1) ? m-&gt;animation.anim_frames : 1;\n\n#define MAKE_RECT(rx, ry, rw, rh)                                                                  \\\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n\n    CFBDGraphicRect global_upd;\n    CFBD_Bool have_global = CFBD_FALSE;\n\n    /* restore old text highlight */\n    uint16_t old_text_x = 0, old_text_w = 0, old_text_h = 0;\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        old_text_x = ot-&gt;tl_point.x;\n        old_text_w = rect_width(&amp;ot-&gt;text_bounding_rect);\n        old_text_h = rect_height(&amp;ot-&gt;text_bounding_rect);\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        CFBDGraphicRect r = MAKE_RECT(old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        global_upd = r;\n        have_global = CFBD_TRUE;\n    }\n\n    /* clear indicator column */\n    uint16_t old_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count)\n                             ? group-&gt;pItems[old].text_obj.TexthandleSize.height\n                             : group-&gt;pItems[0].text_obj.TexthandleSize.height;\n    uint16_t new_h = group-&gt;pItems[new_index].text_obj.TexthandleSize.height;\n    uint16_t miny = MIN(start_y, end_y);\n    uint16_t maxy = MAX(start_y, end_y) + MAX(old_h, new_h);\n    uint16_t colx = m-&gt;tl_point.x + m-&gt;indicator.x, colw = m-&gt;indicator.width;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, miny, colw, maxy - miny);\n    {\n        CFBDGraphicRect r = MAKE_RECT(colx, miny, colw, maxy - miny);\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n        }\n    }\n\n    /* new text parameters */\n    CFBDGraphic_Text* nt = &amp;group-&gt;pItems[new_index].text_obj;\n    uint16_t new_text_x = nt-&gt;tl_point.x;\n    uint16_t new_text_w = rect_width(&amp;nt-&gt;text_bounding_rect);\n    volatile CFBDGraphicRect n = rect_normalize(nt-&gt;text_bounding_rect);\n    uint16_t new_text_h = (uint32_t) asInt32_t(n.br.y) - (uint32_t) asInt32_t(n.tl.y);\n\n    /* prepare interpolation bases (if old missing, base on new) */\n    int base_x = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_x : (int) new_text_x;\n    int base_w = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_w : (int) new_text_w;\n    int base_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_h : (int) new_text_h;\n\n    int last_rev_x = -1, last_rev_y = -1, last_rev_w = 0, last_rev_h = 0;\n\n    for (int f = 0; f &lt;= frames; ++f) {\n        float t = (float) f / (float) frames;\n        float st = t * t * (3.0f - 2.0f * t);\n        int cur_y = (int) (start_y + (end_y - start_y) * st + 0.5f);\n\n        /* interpolated width/pos/height for this frame (smoothly morph) */\n        int cur_x = (int) (base_x + (new_text_x - base_x) * st + 0.5f);\n        int cur_w = (int) (base_w + (new_text_w - base_w) * st + 0.5f);\n        int cur_h = (int) (base_h + (new_text_h - base_h) * st + 0.5f);\n        if (cur_w &lt; 1)\n            cur_w = 1;\n        if (cur_h &lt; 1)\n            cur_h = 1;\n\n        CFBDGraphicRect frame_upd;\n        CFBD_Bool have_frame = CFBD_FALSE;\n\n        /* restore previous frame's revert (before drawing indicator) */\n        if (last_rev_y &gt;= 0) {\n            m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                        (uint16_t) last_rev_x,\n                                        (uint16_t) last_rev_y,\n                                        (uint16_t) last_rev_w,\n                                        (uint16_t) last_rev_h);\n            CFBDGraphicRect r = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n            frame_upd = r;\n            have_frame = CFBD_TRUE;\n        }\n\n        /* draw indicator */\n        uint16_t ih = MAX(old_h, new_h);\n\n        CFBD_DrawMenuIndicator(m, colx, cur_y, colw, ih);\n        {\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        /* apply current-frame text revert (this produces the highlight) */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) cur_x,\n                                    (uint16_t) cur_y,\n                                    (uint16_t) cur_w,\n                                    (uint16_t) cur_h);\n        {\n            CFBDGraphicRect r = MAKE_RECT(cur_x, cur_y, cur_w, cur_h);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        last_rev_x = cur_x;\n        last_rev_y = cur_y;\n        last_rev_w = cur_w;\n        last_rev_h = cur_h;\n\n        if (have_frame) {\n            uint16_t ux = frame_upd.tl.x;\n            uint16_t uy = frame_upd.tl.y;\n            uint16_t uw = (uint16_t) (frame_upd.br.x - frame_upd.tl.x);\n            uint16_t uh = (uint16_t) (frame_upd.br.y - frame_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n            if (!have_global) {\n                global_upd = frame_upd;\n                have_global = CFBD_TRUE;\n            }\n            else\n                global_upd = rect_union(&amp;global_upd, &amp;frame_upd);\n        }\n\n        system_delay_ms(m-&gt;animation.anim_frame_delay_ms);\n\n        /* clear indicator (non-final frame) */\n        if (f != frames) {\n            m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, cur_y, colw, ih);\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_global) {\n                global_upd = r;\n                have_global = CFBD_TRUE;\n            }\n            else {\n                global_upd = rect_union(&amp;global_upd, &amp;r);\n            }\n        }\n    }\n\n    /* redraw old item and include into global update */\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        redraw_item(m, old);\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        CFBDGraphicRect r = MAKE_RECT(ot-&gt;tl_point.x,\n                                      ot-&gt;tl_point.y,\n                                      rect_width(&amp;ot-&gt;text_bounding_rect),\n                                      rect_height(&amp;ot-&gt;text_bounding_rect));\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n    }\n\n    /* final correction: if last_rev differs from exact end, restore and set exact final */\n    if (last_rev_y &gt;= 0 &amp;&amp; (last_rev_y != (int) end_y || last_rev_w != (int) new_text_w ||\n                            last_rev_x != (int) new_text_x || last_rev_h != (int) new_text_h)) {\n        /* restore last */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) last_rev_x,\n                                    (uint16_t) last_rev_y,\n                                    (uint16_t) last_rev_w,\n                                    (uint16_t) last_rev_h);\n        CFBDGraphicRect r1 = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n        if (!have_global) {\n            global_upd = r1;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r1);\n        }\n\n        /* final exact revert at end_y with new size */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, new_text_x, end_y, new_text_w, new_text_h);\n        CFBDGraphicRect r2 = MAKE_RECT(new_text_x, end_y, new_text_w, new_text_h);\n        if (!have_global) {\n            global_upd = r2;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r2);\n        }\n\n        /* flush final small region */\n        uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n        uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n        uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n    }\n    else {\n        if (have_global) {\n            uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n            uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n            uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n        }\n    }\n\n#undef MAKE_RECT\n    m-&gt;selected = new_index;\n}\n\nstatic void reset_tl_points(CFBD_Menu* m, CFBDGraphic_Point* p, CFBD_Bool request_updates)\n{\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device,\n                               m-&gt;tl_point.x,\n                               m-&gt;tl_point.y,\n                               m-&gt;max_width,\n                               get_menu_new_item_y(m) - m-&gt;tl_point.y);\n    m-&gt;tl_point = *p;\n    PointBaseType y_height = CFBD_MENU_ITEM_Y_GAP + m-&gt;tl_point.y;\n    for (int i = 0; i &lt; m-&gt;menu_items-&gt;count; i++) {\n        CFBD_MenuItem* item = &amp;m-&gt;menu_items-&gt;pItems[i];\n        item-&gt;tl.x = get_menu_new_item_x(m);\n        item-&gt;tl.y = y_height;\n        CFBDGraphic_SetTextTLPointPoint(&amp;item-&gt;text_obj, &amp;item-&gt;tl);\n        y_height += get_menu_new_item_height(item) - CFBD_MENU_ITEM_Y_GAP;\n    }\n    if (request_updates) {\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device,\n                                    m-&gt;tl_point.x,\n                                    m-&gt;tl_point.y,\n                                    m-&gt;max_width,\n                                    get_menu_new_item_y(m) - m-&gt;tl_point.y);\n        CFBD_DrawMenu(m);\n    }\n}\n\nstatic void OLED_Menu_Activate(CFBD_Menu* m)\n{\n    if (m-&gt;selected &lt; 0 || (size_t) m-&gt;selected &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[m-&gt;selected];\n    CFBD_MenuItemCallbackPack* pack = &amp;it-&gt;on_select;\n    if (pack-&gt;callback) {\n        pack-&gt;callback(pack-&gt;user_data);\n    }\n}\n\nstatic CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width)\n{\n    pMenu-&gt;operations = &amp;_ops;\n    pMenu-&gt;max_width = max_width;\n    pMenu-&gt;device = devices;\n    pMenu-&gt;tl_point.x = 0;\n    pMenu-&gt;tl_point.y = 0;\n    CFBD_InitBaseAnimation(&amp;pMenu-&gt;animation);\n    CFBD_InitDefaultMenuIndicator(&amp;pMenu-&gt;indicator);\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu_8h/","title":"lib/graphic/widget/menu/menu.h","text":""},{"location":"api/Files/menu_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuOps struct _CFBD_Menu"},{"location":"api/Files/menu_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu"},{"location":"api/Files/menu_8h/#functions","title":"Functions","text":"Name void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width) void OLED_Menu_SelectNext(CFBD_Menu * m) void OLED_Menu_SelectPrev(CFBD_Menu * m)"},{"location":"api/Files/menu_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre>"},{"location":"api/Files/menu_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8h/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectnext","title":"function OLED_Menu_SelectNext","text":"<pre><code>static inline void OLED_Menu_SelectNext(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectprev","title":"function OLED_Menu_SelectPrev","text":"<pre><code>static inline void OLED_Menu_SelectPrev(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n\n#include \"base/point.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/text_config.h\"\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct\n{\n    void (*bind_item_groups_contains)(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items);\n\n    CFBD_Bool (*add_item)(CFBD_Menu* pMenu,\n                          const char* label,\n                          Ascii_Font_Size size,\n                          CFBD_MenuItemCallbackPack* callbacks);\n\n    void (*set_indicator_property)(CFBD_Menu* pMenu, CFBD_MenuIndicator* pIndicator);\n    void (*set_animation)(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation);\n    void (*immediate_draw)(CFBD_Menu* pMenu);\n    void (*select_index)(CFBD_Menu* pMenu, int index);\n    void (*activate_current)(CFBD_Menu* pMenu);\n    void (*reset_tl_points)(CFBD_Menu* pMenu, CFBDGraphic_Point* p, CFBD_Bool request_updates);\n} CFBD_MenuOps;\n\n/* Menu */\ntypedef struct _CFBD_Menu\n{\n    CFBD_MenuOps* operations;\n    CFBD_GraphicDevice* device;\n    CFBD_MenuItemGroup* menu_items;\n    CFBDGraphic_Point tl_point; /* default from 0, 0 */\n    SizeBaseType max_width;     // max widths\n    int selected;               /* current selected index */\n\n    /* indicator config */\n    CFBD_MenuIndicator indicator;\n    /* animation config */\n    CFBD_BaseAnimation animation;\n} CFBD_Menu;\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width);\n\nstatic inline void OLED_Menu_SelectNext(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected + 1) % (int) m-&gt;menu_items-&gt;count;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n\nstatic inline void OLED_Menu_SelectPrev(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected - 1);\n    if (ni &lt; 0)\n        ni = (int) m-&gt;menu_items-&gt;count - 1;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu__config_8h/","title":"lib/graphic/widget/menu/menu_config.h","text":""},{"location":"api/Files/menu__config_8h/#defines","title":"Defines","text":"Name CFBD_MENU_INDICATOR_WIDTH Menu Indicator Configs. CFBD_MENU_INDICATOR_POSX CFBD_MENU_INDICATOR_MAX_WIDTH_PX CFBD_MENU_INDICATOR_MAX_HEIGHT_PX CFBD_MENU_INDICATOR_GAP CFBD_MENU_ITEM_Y_GAP"},{"location":"api/Files/menu__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_width","title":"define CFBD_MENU_INDICATOR_WIDTH","text":"<pre><code>#define CFBD_MENU_INDICATOR_WIDTH (4)\n</code></pre> <p>Menu Indicator Configs. </p>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_posx","title":"define CFBD_MENU_INDICATOR_POSX","text":"<pre><code>#define CFBD_MENU_INDICATOR_POSX (0)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_max_width_px","title":"define CFBD_MENU_INDICATOR_MAX_WIDTH_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_max_height_px","title":"define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_indicator_gap","title":"define CFBD_MENU_INDICATOR_GAP","text":"<pre><code>#define CFBD_MENU_INDICATOR_GAP (4)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#define-cfbd_menu_item_y_gap","title":"define CFBD_MENU_ITEM_Y_GAP","text":"<pre><code>#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre>"},{"location":"api/Files/menu__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_MENU_INDICATOR_WIDTH (4)\n#define CFBD_MENU_INDICATOR_POSX (0)\n\n#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n\n#define CFBD_MENU_INDICATOR_GAP (4)\n\n#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu__indicator_8c/","title":"lib/graphic/widget/menu/menu_indicator.c","text":""},{"location":"api/Files/menu__indicator_8c/#functions","title":"Functions","text":"Name size_t bytes_per_row_px(uint16_t px_width) void blit_fill_rect_bytes(uint8_t * buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte) void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8c/#attributes","title":"Attributes","text":"Name uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf"},{"location":"api/Files/menu__indicator_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#function-bytes_per_row_px","title":"function bytes_per_row_px","text":"<pre><code>static inline size_t bytes_per_row_px(\n    uint16_t px_width\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-blit_fill_rect_bytes","title":"function blit_fill_rect_bytes","text":"<pre><code>static void blit_fill_rect_bytes(\n    uint8_t * buf,\n    uint16_t w_px,\n    uint16_t h_px,\n    uint8_t fill_byte\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#variable-s_indicator_buf","title":"variable s_indicator_buf","text":"<pre><code>static uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf;\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_indicator.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"menu.h\"\n#include \"menu_config.h\"\n\n\nstatic uint8_t s_indicator_buf[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX + 7) / 8) *\n                               CFBD_MENU_INDICATOR_MAX_HEIGHT_PX];\n\n/* compute bytes per row for given pixel width (1bpp) */\nstatic inline size_t bytes_per_row_px(uint16_t px_width)\n{\n    return (px_width + 7) / 8;\n}\n\n/* fill a byte buffer with 0xFF (set pixels) or 0x00 (clear) */\nstatic void blit_fill_rect_bytes(uint8_t* buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte)\n{\n    size_t rowb = bytes_per_row_px(w_px);\n    for (uint16_t r = 0; r &lt; h_px; ++r) {\n        uint8_t* rowp = buf + r * rowb;\n        for (size_t i = 0; i &lt; rowb; ++i) {\n            rowp[i] = fill_byte;\n        }\n    }\n}\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault)\n{\n    menuIndicatorDefault-&gt;width = CFBD_MENU_INDICATOR_WIDTH;\n    menuIndicatorDefault-&gt;x = CFBD_MENU_INDICATOR_POSX;\n}\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_GraphicDevice* dev = menu-&gt;device;\n\n    /* safety clamp (\u9632\u6b62\u8d8a\u754c) */\n    if (w &gt; CFBD_MENU_INDICATOR_MAX_WIDTH_PX || h &gt; CFBD_MENU_INDICATOR_MAX_HEIGHT_PX) {\n        return CFBD_FALSE;\n    }\n\n    blit_fill_rect_bytes(s_indicator_buf, w, h, 0xFF);\n\n    return dev-&gt;ops-&gt;setArea(dev, x, y, w, h, s_indicator_buf);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu__indicator_8h/","title":"lib/graphic/widget/menu/menu_indicator.h","text":""},{"location":"api/Files/menu__indicator_8h/#classes","title":"Classes","text":"Name struct __CFBD_MenuIndicator"},{"location":"api/Files/menu__indicator_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu typedef struct __CFBD_MenuIndicator CFBD_MenuIndicator"},{"location":"api/Files/menu__indicator_8h/#functions","title":"Functions","text":"Name void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menuindicator","title":"typedef CFBD_MenuIndicator","text":"<pre><code>typedef struct __CFBD_MenuIndicator CFBD_MenuIndicator;\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct __CFBD_MenuIndicator\n{\n    uint8_t width; // width of the sliding indicator(pixels), zero for none paints\n    uint8_t x;     // x-position of indicator\n} CFBD_MenuIndicator;\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault);\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu__item_8c/","title":"lib/graphic/widget/menu/menu_item.c","text":""},{"location":"api/Files/menu__item_8c/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8c/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_item.h\"\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks)\n{\n    menuItem-&gt;tl = *tl;\n    menuItem-&gt;on_select = *callbacks;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/menu__item_8h/","title":"lib/graphic/widget/menu/menu_item.h","text":""},{"location":"api/Files/menu__item_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuItemCallbackPack struct __CFBD_MenuItem struct __CFBD_MenuItemArray"},{"location":"api/Files/menu__item_8h/#types","title":"Types","text":"Name typedef void(*)(void *user_data) CFBD_MenuItemCallback typedef struct __CFBD_MenuItem CFBD_MenuItem typedef struct __CFBD_MenuItemArray CFBD_MenuItemGroup"},{"location":"api/Files/menu__item_8h/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemcallback","title":"typedef CFBD_MenuItemCallback","text":"<pre><code>typedef void(* CFBD_MenuItemCallback) (void *user_data);\n</code></pre>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitem","title":"typedef CFBD_MenuItem","text":"<pre><code>typedef struct __CFBD_MenuItem CFBD_MenuItem;\n</code></pre>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemgroup","title":"typedef CFBD_MenuItemGroup","text":"<pre><code>typedef struct __CFBD_MenuItemArray CFBD_MenuItemGroup;\n</code></pre>"},{"location":"api/Files/menu__item_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8h/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"widget/text.h\"\n\ntypedef void (*CFBD_MenuItemCallback)(void* user_data);\ntypedef struct\n{\n    CFBD_MenuItemCallback callback;\n    void* user_data;\n} CFBD_MenuItemCallbackPack;\n\n/* MenuItem */\ntypedef struct __CFBD_MenuItem\n{\n    char* label;                         /* pointer to zero-terminated string (owned by caller) */\n    CFBDGraphic_Point tl;                /* top-left pixel of item label area */\n    CFBD_MenuItemCallbackPack on_select; /* optional callback when this item activated */\n    CFBDGraphic_Text text_obj;           /* internal text object (initialized on add) */\n} CFBD_MenuItem;\n\ntypedef struct __CFBD_MenuItemArray\n{\n    CFBD_MenuItem* pItems;\n    size_t capacity;\n    size_t count;\n} CFBD_MenuItemGroup;\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled_8c/","title":"lib/oled/oled.c","text":""},{"location":"api/Files/oled_8c/#functions","title":"Functions","text":"Name void CFBD_OLED_ImmediateInit(CFBD_OLED * oled) CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8c/#function-cfbd_oled_immediateinit","title":"function CFBD_OLED_ImmediateInit","text":"<pre><code>static inline void CFBD_OLED_ImmediateInit(\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled.h\"\n\n#include \"cfbd_define.h\"\n#include \"driver/backend/oled_iic.h\"\n\nstatic inline void CFBD_OLED_ImmediateInit(CFBD_OLED* oled)\n{\n    const CFBD_OLEDOperations* ops = oled-&gt;ops;\n    ops-&gt;init(oled, NULL);\n    ops-&gt;clear(oled);\n    ops-&gt;update(oled);\n}\n\nCFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED* oled, const CFBD_OLEDDriverType driver_type, \n    CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)\n{\n    switch(driver_type){\n        case CFBD_OLEDDriverType_IIC:\n            CFBD_OLED_IICInit(oled, args);\n        break;\n        default:\n            return CFBD_FALSE;\n        break;\n    }\n\n    if(request_immediate_init){\n        CFBD_OLED_ImmediateInit(oled);\n    }\n\n    return CFBD_TRUE;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled_8h/","title":"lib/oled/oled.h","text":"<p>Generic OLED object and operations exposed to application code. </p>"},{"location":"api/Files/oled_8h/#classes","title":"Classes","text":"Name struct _CFBD_OLED_OPS struct _CFBD_OLED"},{"location":"api/Files/oled_8h/#types","title":"Types","text":"Name enum CFBD_OLEDDriverType { CFBD_OLEDDriverType_IIC, CFBD_OLEDDriverType_SPI}Transport/driver type used to communicate with the OLED device. typedef void * CFBD_OLEDHandle Opaque handle type referencing driver-specific state. typedef struct _CFBD_OLED CFBD_OLED Forward declaration for the OLED object. typedef CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height) AreaOperations Function pointer type for area-based display operations. typedef CFBD_Bool(*)(CFBD_OLED *oled) FrameOperation Function pointer type for full-frame display operations. typedef CFBD_Bool(*)(CFBD_OLED *oled) OLEDSelfOperation Function pointer type for device lifecycle operations. typedef CFBD_Bool(*)(CFBD_OLED *oled, const char *property, void *args, void *request_data) OLED_QueryOperation Function pointer type for querying device-specific properties. typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations typedef void * CFBDOLED_Params_Inits Opaque pointer type for transport-specific initialization parameters."},{"location":"api/Files/oled_8h/#functions","title":"Functions","text":"Name CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/oled_8h/#enum-cfbd_oleddrivertype","title":"enum CFBD_OLEDDriverType","text":"Enumerator Value Description CFBD_OLEDDriverType_IIC I2C (IIC) transport - suitable for displays with I2C interface CFBD_OLEDDriverType_SPI SPI transport - suitable for displays with SPI interface <p>Transport/driver type used to communicate with the OLED device. </p> <p>See: CFBD_GetOLEDHandle()for usage when creating device handles </p> <p>Specifies the underlying communication protocol used to interface with the OLED controller. Different transport types may have different initialization parameters and performance characteristics.</p>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledhandle","title":"typedef CFBD_OLEDHandle","text":"<pre><code>CFBD_OLEDHandle;\n</code></pre> <p>Opaque handle type referencing driver-specific state. </p>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oled","title":"typedef CFBD_OLED","text":"<pre><code>typedef struct _CFBD_OLED CFBD_OLED;\n</code></pre> <p>Forward declaration for the OLED object. </p>"},{"location":"api/Files/oled_8h/#typedef-areaoperations","title":"typedef AreaOperations","text":"<pre><code>AreaOperations;\n</code></pre> <p>Function pointer type for area-based display operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> <li>x X coordinate of the area's top-left corner (origin 0,0 at top-left). </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. Combined with x must not exceed display width. </li> <li>height Height of the area in pixels. Combined with y must not exceed display height.</li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. Failures may include invalid coordinates or driver errors.</p> <p>This function pointer signature is used for operations that target a rectangular area of the display (e.g., update_area, clear_area, revert_area). Implementations should use clipping to handle areas that extend beyond display boundaries.</p>"},{"location":"api/Files/oled_8h/#typedef-frameoperation","title":"typedef FrameOperation","text":"<pre><code>FrameOperation;\n</code></pre> <p>Function pointer type for full-frame display operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>B</p> <p>This function pointer signature handles operations that affect the entire display frame (update, clear, revert operations). Typically used to push local buffer changes to the display, clear all pixels, or restore the previous frame content if supported by the device.</p>"},{"location":"api/Files/oled_8h/#typedef-oledselfoperation","title":"typedef OLEDSelfOperation","text":"<pre><code>OLEDSelfOperation;\n</code></pre> <p>Function pointer type for device lifecycle operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature is used for operations that manage the device lifecycle (open/close/enable/disable). These operations typically handle resource allocation, hardware initialization, and cleanup.</p>"},{"location":"api/Files/oled_8h/#typedef-oled_queryoperation","title":"typedef OLED_QueryOperation","text":"<pre><code>OLED_QueryOperation;\n</code></pre> <p>Function pointer type for querying device-specific properties. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being queried. </li> <li>property Null-terminated string naming the queried property. </li> <li>args Optional input arguments for the query (implementation-defined). Pass NULL if the query doesn't require additional arguments. </li> <li>request_data Output pointer where query results are written. Caller must allocate appropriate buffer based on property type.</li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success (property found and returned), CFBD_FALSE on failure (unknown property or error). </p> <p>This function pointer signature handles runtime queries for device capabilities and properties. Implementations must support standard properties (\"width\", \"height\", \"rgb\") and may support additional device-specific properties.</p> <p>Supported standard properties:</p> <ul> <li>\"width\": returns uint16_t display width in pixels</li> <li>\"height\": returns uint16_t display height in pixels</li> <li>\"rgb\": returns CFBD_Bool indicating RGB vs monochrome support</li> </ul>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledoperations","title":"typedef CFBD_OLEDOperations","text":"<pre><code>typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations;\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbdoled_params_inits","title":"typedef CFBDOLED_Params_Inits","text":"<pre><code>CFBDOLED_Params_Inits;\n</code></pre> <p>Opaque pointer type for transport-specific initialization parameters. </p> <p>See: CFBD_GetOLEDHandle()for usage </p> <p>This typedef abstracts transport-specific parameter structures. For I2C transport: point to CFBD_OLED_IICInitsParams For SPI transport: point to device-specific SPI parameter structure For other transports: point to relevant parameter structure</p>"},{"location":"api/Files/oled_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8h/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef enum\n{\n    CFBD_OLEDDriverType_IIC, \n    CFBD_OLEDDriverType_SPI  \n} CFBD_OLEDDriverType;\n\ntypedef void* CFBD_OLEDHandle;\n\ntypedef struct _CFBD_OLED CFBD_OLED;\n\ntypedef CFBD_Bool (\n        *AreaOperations)(CFBD_OLED* oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\n\ntypedef CFBD_Bool (*FrameOperation)(CFBD_OLED* oled);\n\ntypedef CFBD_Bool (*OLEDSelfOperation)(CFBD_OLED* oled);\n\ntypedef CFBD_Bool (*OLED_QueryOperation)(CFBD_OLED* oled,\n                                         const char* property,\n                                         void* args,\n                                         void* request_data);\n\ntypedef struct _CFBD_OLED_OPS\n{\n    int (*init)(CFBD_OLED* oled, void* init_args);\n\n    CFBD_Bool (*setPixel)(CFBD_OLED* oled, uint16_t x, uint16_t y);\n\n    CFBD_Bool (*setArea)(CFBD_OLED* device,\n                         uint16_t x,\n                         uint16_t y,\n                         uint16_t width,\n                         uint16_t height,\n                         uint8_t* source);\n\n    FrameOperation update;\n\n    FrameOperation clear;\n\n    FrameOperation revert;\n\n    AreaOperations update_area;\n\n    AreaOperations clear_area;\n\n    AreaOperations revert_area;\n\n    OLEDSelfOperation open;\n\n    OLEDSelfOperation close;\n\n    OLED_QueryOperation self_consult;\n} CFBD_OLEDOperations;\n\ntypedef struct _CFBD_OLED\n{\n    const CFBD_OLEDOperations* ops;\n\n    CFBD_OLEDDriverType driver_type;\n\n    CFBD_OLEDHandle oled_internal_handle;\n} CFBD_OLED;\n\ntypedef void* CFBDOLED_Params_Inits;\n\nCFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,\n                             const CFBD_OLEDDriverType driver_type,\n                             CFBDOLED_Params_Inits args,\n                             CFBD_Bool request_immediate_init);\n\n // end of OLED group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled__graphic__device_8c/","title":"lib/graphic/device/oled/oled_graphic_device.c","text":""},{"location":"api/Files/oled__graphic__device_8c/#functions","title":"Functions","text":"Name CFBD_OLED * _get_oled(CFBD_GraphicDevice * device) int graphic_oled_init(CFBD_GraphicDevice * device, void * init_args) CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice * device, uint16_t x, uint16_t y) CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * source) CFBD_Bool graphic_oled_update(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_update_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_clear_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_revert_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_open(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_close(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice * device, const char * property, void * args, void * request_data) void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice * device, CFBD_OLED * oled)"},{"location":"api/Files/oled__graphic__device_8c/#attributes","title":"Attributes","text":"Name CFBD_GraphicDeviceOperation graphic_oled_ops"},{"location":"api/Files/oled__graphic__device_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#function-_get_oled","title":"function _get_oled","text":"<pre><code>static inline CFBD_OLED * _get_oled(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_init","title":"function graphic_oled_init","text":"<pre><code>static int graphic_oled_init(\n    CFBD_GraphicDevice * device,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_setpixel","title":"function graphic_oled_setPixel","text":"<pre><code>static CFBD_Bool graphic_oled_setPixel(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_drawarea","title":"function graphic_oled_drawArea","text":"<pre><code>static CFBD_Bool graphic_oled_drawArea(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * source\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update","title":"function graphic_oled_update","text":"<pre><code>static CFBD_Bool graphic_oled_update(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear","title":"function graphic_oled_clear","text":"<pre><code>static CFBD_Bool graphic_oled_clear(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert","title":"function graphic_oled_revert","text":"<pre><code>static CFBD_Bool graphic_oled_revert(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update_area","title":"function graphic_oled_update_area","text":"<pre><code>static CFBD_Bool graphic_oled_update_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear_area","title":"function graphic_oled_clear_area","text":"<pre><code>static CFBD_Bool graphic_oled_clear_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert_area","title":"function graphic_oled_revert_area","text":"<pre><code>static CFBD_Bool graphic_oled_revert_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_open","title":"function graphic_oled_open","text":"<pre><code>static CFBD_Bool graphic_oled_open(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_close","title":"function graphic_oled_close","text":"<pre><code>static CFBD_Bool graphic_oled_close(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_self_consult","title":"function graphic_oled_self_consult","text":"<pre><code>static CFBD_Bool graphic_oled_self_consult(\n    CFBD_GraphicDevice * device,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-cfbdgraphic_bindoledasdevice","title":"function CFBDGraphic_BindOLEDAsDevice","text":"<pre><code>void CFBDGraphic_BindOLEDAsDevice(\n    CFBD_GraphicDevice * device,\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#variable-graphic_oled_ops","title":"variable graphic_oled_ops","text":"<pre><code>static CFBD_GraphicDeviceOperation graphic_oled_ops = {\n        .init = graphic_oled_init,\n        .setPixel = graphic_oled_setPixel,\n        .setArea = graphic_oled_drawArea,\n\n        .update = graphic_oled_update,\n        .clear = graphic_oled_clear,\n        .revert = graphic_oled_revert,\n\n        .update_area = graphic_oled_update_area,\n        .clear_area = graphic_oled_clear_area,\n        .revert_area = graphic_oled_revert_area,\n\n        .open = graphic_oled_open,\n        .close = graphic_oled_close,\n\n        .self_consult = graphic_oled_self_consult,\n};\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_graphic_device.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n\n\nstatic inline CFBD_OLED* _get_oled(CFBD_GraphicDevice* device)\n{\n    return (CFBD_OLED*) device-&gt;internal_handle;\n}\n\n/* ---------- init ---------- */\n\nstatic int graphic_oled_init(CFBD_GraphicDevice* device, void* init_args)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;init(oled, init_args);\n}\n\n/* ---------- pixel ---------- */\n\nstatic CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice* device, uint16_t x, uint16_t y)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setPixel(oled, x, y);\n}\n\nstatic CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice* device,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* source)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setArea(oled, x, y, width, height, source);\n}\n/* ---------- frame ---------- */\n\nstatic CFBD_Bool graphic_oled_update(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;update(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert(_get_oled(device));\n}\n\n/* ---------- area ---------- */\n\nstatic CFBD_Bool\ngraphic_oled_update_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;update_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_clear_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_revert_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert_area(_get_oled(device), x, y, w, h);\n}\n\n/* ---------- lifecycle ---------- */\n\nstatic CFBD_Bool graphic_oled_open(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;open(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_close(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;close(_get_oled(device));\n}\n\n/* ---------- query ---------- */\n\nstatic CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice* device,\n                                           const char* property,\n                                           void* args,\n                                           void* request_data)\n{\n    return _get_oled(device)-&gt;ops-&gt;self_consult(_get_oled(device), property, args, request_data);\n}\n\nstatic CFBD_GraphicDeviceOperation graphic_oled_ops = {\n        .init = graphic_oled_init,\n        .setPixel = graphic_oled_setPixel,\n        .setArea = graphic_oled_drawArea,\n\n        .update = graphic_oled_update,\n        .clear = graphic_oled_clear,\n        .revert = graphic_oled_revert,\n\n        .update_area = graphic_oled_update_area,\n        .clear_area = graphic_oled_clear_area,\n        .revert_area = graphic_oled_revert_area,\n\n        .open = graphic_oled_open,\n        .close = graphic_oled_close,\n\n        .self_consult = graphic_oled_self_consult,\n};\n\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled)\n{\n    if (device == NULL || oled == NULL || oled-&gt;ops == NULL)\n        return;\n\n    device-&gt;ops = &amp;graphic_oled_ops;\n    device-&gt;device_type = OLED;\n    device-&gt;internal_handle = (CFBDGraphicDeviceHandle) oled;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled__graphic__device_8h/","title":"lib/graphic/device/oled/oled_graphic_device.h","text":""},{"location":"api/Files/oled__graphic__device_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice * device, CFBD_OLED * oled)"},{"location":"api/Files/oled__graphic__device_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__graphic__device_8h/#function-cfbdgraphic_bindoledasdevice","title":"function CFBDGraphic_BindOLEDAsDevice","text":"<pre><code>void CFBDGraphic_BindOLEDAsDevice(\n    CFBD_GraphicDevice * device,\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../oled/oled.h\"\n#include \"device/graphic_device.h\"\n\n/* binders */\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled__iic_8c/","title":"lib/oled/driver/backend/oled_iic.c","text":""},{"location":"api/Files/oled__iic_8c/#functions","title":"Functions","text":"Name CFBD_OLED_IICInitsParams * asIICInitsParams(void * internal) void send_data(CFBD_OLED_IICInitsParams * internal, uint8_t * data, uint16_t len) void send_cmd(CFBD_OLED_IICInitsParams * internal, uint8_t cmd) void __pvt_oled_set_cursor(CFBD_OLED_IICInitsParams * handle, const uint8_t y, const uint8_t x) int init(CFBD_OLED * oled, void * init_args) CFBD_Bool setPixel(CFBD_OLED * handle, uint16_t x, uint16_t y) CFBD_Bool clear(CFBD_OLED * handle) CFBD_Bool update(CFBD_OLED * handle) CFBD_Bool oled_helper_clear_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_draw_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * sources) CFBD_Bool oled_helper_update_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_reverse(CFBD_OLED * handle) CFBD_Bool oled_helper_reversearea(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool open_oled(CFBD_OLED * handle) CFBD_Bool close_oled(CFBD_OLED * handle) CFBD_Bool iic_query(CFBD_OLED * oled, const char * property, void * args, void * request_data)"},{"location":"api/Files/oled__iic_8c/#attributes","title":"Attributes","text":"Name uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM const CFBD_OLEDOperations iic_ops"},{"location":"api/Files/oled__iic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__iic_8c/#function-asiicinitsparams","title":"function asIICInitsParams","text":"<pre><code>static inline CFBD_OLED_IICInitsParams * asIICInitsParams(\n    void * internal\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-send_data","title":"function send_data","text":"<pre><code>static void send_data(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t * data,\n    uint16_t len\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-send_cmd","title":"function send_cmd","text":"<pre><code>static void send_cmd(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t cmd\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-__pvt_oled_set_cursor","title":"function __pvt_oled_set_cursor","text":"<pre><code>static void __pvt_oled_set_cursor(\n    CFBD_OLED_IICInitsParams * handle,\n    const uint8_t y,\n    const uint8_t x\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-init","title":"function init","text":"<pre><code>static int init(\n    CFBD_OLED * oled,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-setpixel","title":"function setPixel","text":"<pre><code>static CFBD_Bool setPixel(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-clear","title":"function clear","text":"<pre><code>static CFBD_Bool clear(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-update","title":"function update","text":"<pre><code>static CFBD_Bool update(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_clear_area","title":"function oled_helper_clear_area","text":"<pre><code>static CFBD_Bool oled_helper_clear_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_draw_area","title":"function oled_helper_draw_area","text":"<pre><code>static CFBD_Bool oled_helper_draw_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * sources\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_update_area","title":"function oled_helper_update_area","text":"<pre><code>static CFBD_Bool oled_helper_update_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_reverse","title":"function oled_helper_reverse","text":"<pre><code>static CFBD_Bool oled_helper_reverse(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-oled_helper_reversearea","title":"function oled_helper_reversearea","text":"<pre><code>static CFBD_Bool oled_helper_reversearea(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-open_oled","title":"function open_oled","text":"<pre><code>static CFBD_Bool open_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-close_oled","title":"function close_oled","text":"<pre><code>static CFBD_Bool close_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#function-iic_query","title":"function iic_query","text":"<pre><code>static CFBD_Bool iic_query(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__iic_8c/#variable-oled_gram","title":"variable OLED_GRAM","text":"<pre><code>static uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM;\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#variable-iic_ops","title":"variable iic_ops","text":"<pre><code>static const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query};\n</code></pre>"},{"location":"api/Files/oled__iic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_iic.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"configs/cache_config.h\"\n#include \"iic.h\"\n#include \"oled.h\"\n\nstatic uint8_t OLED_GRAM[CACHED_HEIGHT][CACHED_WIDTH];\n\nstatic inline CFBD_OLED_IICInitsParams* asIICInitsParams(void* internal)\n{\n    return internal;\n}\n\nstatic void send_data(CFBD_OLED_IICInitsParams* internal, uint8_t* data, uint16_t len)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;data_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = NULL,\n                                        .len = 1,\n                                }};\n    for (uint16_t i = 0; i &lt; len; i++) {\n        cmds[1].buf = &amp;data[i];\n        CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n    }\n}\n\nstatic void send_cmd(CFBD_OLED_IICInitsParams* internal, uint8_t cmd)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;cmd_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;cmd,\n                                        .len = 1,\n                                }};\n    CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n}\n\nstatic void\n__pvt_oled_set_cursor(CFBD_OLED_IICInitsParams* handle, const uint8_t y, const uint8_t x)\n{\n    send_cmd(handle, 0xB0 | y);\n    send_cmd(handle, 0x10 | ((x &amp; 0xF0) &gt;&gt; 4));\n    send_cmd(handle, 0x00 | (x &amp; 0x0F));\n}\n\n// Impls\nstatic int init(CFBD_OLED* oled, void* init_args)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    uint8_t* init_cmds = internal-&gt;device_specifics-&gt;init_session_tables();\n    uint16_t init_cmds_sz = internal-&gt;device_specifics-&gt;init_session_tables_sz;\n    for (int i = 0; i &lt; init_cmds_sz; i++) {\n        send_cmd(internal, init_cmds[i]);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool setPixel(CFBD_OLED* handle, uint16_t x, uint16_t y)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    if (x &lt; internal-&gt;device_specifics-&gt;logic_width &amp;&amp;\n        y &lt; internal-&gt;device_specifics-&gt;logic_height) {\n        OLED_GRAM[y / 8][x] |= 0x01 &lt;&lt; (y % 8);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool clear(CFBD_OLED* handle)\n{\n    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool update(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    for (uint8_t j = 0; j &lt; CACHED_HEIGHT; j++) {\n        __pvt_oled_set_cursor(handle-&gt;oled_internal_handle, j, 0);\n        send_data(handle-&gt;oled_internal_handle,\n                  OLED_GRAM[j],\n                  internal-&gt;device_specifics-&gt;logic_width);\n    }\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_clear_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y; i &lt; y + height; i++) {\n        for (uint8_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] &amp;= ~(0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* sources)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    uint16_t pages = (height + 7) / 8; /* safer\u5199\u6cd5 */\n    for (uint16_t j = 0; j &lt; pages; j++) {\n        uint16_t page_index = y / 8 + j;\n        if (page_index &gt;= CACHED_HEIGHT) {\n            return CFBD_TRUE;\n        }\n        for (uint16_t i = 0; i &lt; width; i++) {\n            uint16_t x_idx = x + i;\n            if (x_idx &gt;= CACHED_WIDTH) {\n                break;\n            }\n\n            uint8_t src = sources[j * width + i];\n            OLED_GRAM[page_index][x_idx] |= (src &lt;&lt; (y % 8));\n\n            if (page_index + 1 &lt; CACHED_HEIGHT) {\n                OLED_GRAM[page_index + 1][x_idx] |= (src &gt;&gt; (8 - (y % 8)));\n            }\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\n// static CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n//                                        uint16_t x,\n//                                        uint16_t y,\n//                                        uint16_t width,\n//                                        uint16_t height,\n//                                        uint8_t* sources)\n// {\n//     CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n//     const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n//     const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n//     if (x &gt;= POINT_X_MAX)\n//         return CFBD_FALSE;\n//     if (y &gt;= POINT_Y_MAX)\n//         return CFBD_FALSE;\n\n//     // clear the area before being set\n//     oled_helper_clear_area(handle, x, y, width, height);\n\n//     for (uint16_t j = 0; j &lt; (height - 1) / 8 + 1; j++) {\n//         for (uint16_t i = 0; i &lt; width; i++) {\n//             if (x + i &gt; CACHED_WIDTH) {\n//                 break;\n//             }\n//             if (y / 8 + j &gt; CACHED_HEIGHT - 1) {\n//                 return CFBD_TRUE;\n//             }\n\n//             OLED_GRAM[y / 8 + j][x + i] |= sources[j * width + i] &lt;&lt; (y % 8);\n\n//             if (y / 8 + j + 1 &gt; CACHED_HEIGHT - 1) {\n//                 continue;\n//             }\n\n//             OLED_GRAM[y / 8 + j + 1][x + i] |= sources[j * width + i] &gt;&gt; (8 - y % 8);\n//         }\n//     }\n\n//     return CFBD_TRUE;\n// }\n\nstatic CFBD_Bool\noled_helper_update_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y / 8; i &lt; (y + height - 1) / 8 + 1; i++) {\n        /*\u8bbe\u7f6e\u5149\u6807\u4f4d\u7f6e\u4e3a\u76f8\u5173\u9875\u7684\u6307\u5b9a\u5217*/\n        __pvt_oled_set_cursor(internal, i, x);\n        /*\u8fde\u7eed\u5199\u5165Width\u4e2a\u6570\u636e\uff0c\u5c06\u663e\u5b58\u6570\u7ec4\u7684\u6570\u636e\u5199\u5165\u5230OLED\u786c\u4ef6*/\n        send_data(internal, &amp;OLED_GRAM[i][x], width);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_reverse(CFBD_OLED* handle)\n{\n    for (uint16_t i = 0; i &lt; CACHED_HEIGHT; i++) {\n        for (uint16_t j = 0; j &lt; CACHED_WIDTH; j++) {\n            OLED_GRAM[i][j] ^= 0xFF;\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_reversearea(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt; POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt; POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint16_t i = y; i &lt; y + height; i++) {\n        for (uint16_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] ^= (0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool open_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x14);\n    send_cmd(internal, 0xAF);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool close_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x10);\n    send_cmd(internal, 0xAE);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool iic_query(CFBD_OLED* oled,\n                           const char* property, // property for query\n                           void* args,           // if property request args\n                           void* request_data)   // contains results\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    if (strcmp(\"rgb\", property) == 0) {\n        CFBD_Bool* support_rgb = (CFBD_Bool*) request_data;\n        *support_rgb = CFBD_FALSE;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"width\", property) == 0) {\n        uint16_t* width = (uint16_t*) request_data;\n        *width = internal-&gt;device_specifics-&gt;logic_width;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"height\", property) == 0) {\n        uint16_t* height = (uint16_t*) request_data;\n        *height = internal-&gt;device_specifics-&gt;logic_height;\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query};\n\nvoid CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle)\n{\n    handle-&gt;oled_internal_handle = pvt_handle;\n    handle-&gt;driver_type = CFBD_OLEDDriverType_IIC;\n    handle-&gt;ops = &amp;iic_ops;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/oled__iic_8h/","title":"lib/oled/driver/backend/oled_iic.h","text":"<p>I2C-backed OLED driver initialization interface.  More...</p>"},{"location":"api/Files/oled__iic_8h/#detailed-description","title":"Detailed Description","text":"<p>I2C-backed OLED driver initialization interface. </p> <p>See: </p> <ul> <li>external_impl_driver.hforCFBD_OLED_IICInitsParams definition </li> <li>oled.hforCFBD_OLED type </li> </ul> <p>This module provides the initialization and configuration interface for OLED devices communicating via I2C (IIC). It bridges the generic OLED driver with platform-specific I2C implementations, handling address configuration, transaction callbacks, and I2C handle binding.</p> <p>Platform/application code should:</p> <ol> <li>Construct a CFBD_OLED_IICInitsParams structure with I2C parameters</li> <li>Create a CFBD_OLED instance</li> <li>Call CFBD_OLED_IICInit() to wire I2C backend to the generic OLED driver</li> </ol>"},{"location":"api/Files/oled__iic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"configs/external_impl_driver.h\"\n#include \"oled.h\"\n\nvoid CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle);\n\n // end of OLED_Backend group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/point_8h/","title":"point.h","text":"<p>Point and Vector data structures and utility functions for 2D graphics. </p>"},{"location":"api/Files/point_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components."},{"location":"api/Files/point_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    PointBaseType x; \n    PointBaseType y; \n} CFBDGraphic_Point;\n\ntypedef struct\n{\n    int32_t x; \n    int32_t y; \n} CFBDGraphic_Vec2i;\n\nstatic inline CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    uint32_t x = (uint32_t) a.x + b.x;\n    uint32_t y = (uint32_t) a.y + b.y;\n\n    if (x &gt; UINT16_MAX)\n        x = UINT16_MAX;\n    if (y &gt; UINT16_MAX)\n        y = UINT16_MAX;\n\n    return (CFBDGraphic_Point) {(uint16_t) x, (uint16_t) y};\n}\n\nstatic inline CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    return (CFBDGraphic_Vec2i) {(int32_t) a.x - (int32_t) b.x, (int32_t) a.y - (int32_t) b.y};\n}\n\n // End of Point_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/progressbar_8c/","title":"lib/graphic/widget/progressbar/progressbar.c","text":""},{"location":"api/Files/progressbar_8c/#functions","title":"Functions","text":"Name void draw_rect_border(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void fill_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void clear_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void compute_inner_box(CFBD_ProgressBar * pb, uint16_t * out_x, uint16_t * out_y, uint16_t * out_w, uint16_t * out_h) float smoothstep(float t) uint16_t compute_fill_width(CFBD_ProgressBar * pb, int32_t value) void CFBD_ProgressBar_Draw(CFBD_ProgressBar * pb) void CFBD_ProgressBar_SetValue(CFBD_ProgressBar * pb, int32_t new_value) CFBD_Bool CFBD_ProgressBar_SetProperty(CFBD_ProgressBar * pb, const char * property, const void * value) void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8c/#attributes","title":"Attributes","text":"Name CFBD_ProgressBarOps ops"},{"location":"api/Files/progressbar_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8c/#function-draw_rect_border","title":"function draw_rect_border","text":"<pre><code>static void draw_rect_border(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-fill_rect","title":"function fill_rect","text":"<pre><code>static void fill_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-clear_rect","title":"function clear_rect","text":"<pre><code>static void clear_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_inner_box","title":"function compute_inner_box","text":"<pre><code>static void compute_inner_box(\n    CFBD_ProgressBar * pb,\n    uint16_t * out_x,\n    uint16_t * out_y,\n    uint16_t * out_w,\n    uint16_t * out_h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-smoothstep","title":"function smoothstep","text":"<pre><code>static float smoothstep(\n    float t\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_fill_width","title":"function compute_fill_width","text":"<pre><code>static uint16_t compute_fill_width(\n    CFBD_ProgressBar * pb,\n    int32_t value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_draw","title":"function CFBD_ProgressBar_Draw","text":"<pre><code>void CFBD_ProgressBar_Draw(\n    CFBD_ProgressBar * pb\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setvalue","title":"function CFBD_ProgressBar_SetValue","text":"<pre><code>void CFBD_ProgressBar_SetValue(\n    CFBD_ProgressBar * pb,\n    int32_t new_value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setproperty","title":"function CFBD_ProgressBar_SetProperty","text":"<pre><code>CFBD_Bool CFBD_ProgressBar_SetProperty(\n    CFBD_ProgressBar * pb,\n    const char * property,\n    const void * value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/progressbar_8c/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n</code></pre>"},{"location":"api/Files/progressbar_8c/#source-code","title":"Source code","text":"<pre><code>#include \"progressbar.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\" /* for system_delay_ms */\n#include \"widget/animation/animation.h\"\n#include \"widget/base_support/common/helpers.h\"\n\n/* Draw rectangle border using setPixel (1px thick) */\nstatic void\ndraw_rect_border(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    /* top/bottom */\n    for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n        SetPixelAction(dev, ix, y);\n        SetPixelAction(dev, ix, y + h - 1);\n    }\n    /* left/right */\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        SetPixelAction(dev, x, iy);\n        SetPixelAction(dev, x + w - 1, iy);\n    }\n}\n\n/* Fill rectangular area with pixels (setPixel) */\nstatic void fill_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n            SetPixelAction(dev, ix, iy);\n        }\n    }\n}\n\n/* Clear area using device-provided clear_area (faster than per-pixel clear) */\nstatic void clear_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    dev-&gt;ops-&gt;clear_area(dev, x, y, w, h);\n}\n\n/* internal: compute inner box (where fill is drawn) */\nstatic void compute_inner_box(CFBD_ProgressBar* pb,\n                              uint16_t* out_x,\n                              uint16_t* out_y,\n                              uint16_t* out_w,\n                              uint16_t* out_h)\n{\n    uint16_t x = pb-&gt;tl.x;\n    uint16_t y = pb-&gt;tl.y;\n    uint16_t w = pb-&gt;size.width;\n    uint16_t h = pb-&gt;size.height;\n\n    uint8_t pad = pb-&gt;padding;\n    if (pb-&gt;border) {\n        /* 1 px border assumed */\n        if (w &lt;= 2)\n            w = 0;\n        else {\n            x += 1;\n            w -= 2;\n        }\n        if (h &lt;= 2)\n            h = 0;\n        else {\n            y += 1;\n            h -= 2;\n        }\n    }\n    /* apply padding inside */\n    if (w &gt; 2 * pad) {\n        x += pad;\n        w -= (uint16_t) (2 * pad);\n    }\n    else\n        w = 0;\n    if (h &gt; 2 * pad) {\n        y += pad;\n        h -= (uint16_t) (2 * pad);\n    }\n    else\n        h = 0;\n\n    *out_x = x;\n    *out_y = y;\n    *out_w = w;\n    *out_h = h;\n}\n\nstatic float smoothstep(float t)\n{\n    /* classic smoothstep: 3t^2 - 2t^3 */\n    return t * t * (3.0f - 2.0f * t);\n}\n\nstatic uint16_t compute_fill_width(CFBD_ProgressBar* pb, int32_t value)\n{\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    if (iw == 0 || pb-&gt;max &lt;= pb-&gt;min)\n        return 0;\n\n    value = clamp_i32(value, pb-&gt;min, pb-&gt;max);\n    float frac = (float) (value - pb-&gt;min) / (float) (pb-&gt;max - pb-&gt;min);\n\n    if (frac &lt; 0.0f)\n        frac = 0.0f;\n    if (frac &gt; 1.0f)\n        frac = 1.0f;\n\n    return (uint16_t) (frac * (float) iw + 0.5f);\n}\n\nvoid CFBD_ProgressBar_Draw(CFBD_ProgressBar* pb)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    CFBD_GraphicDevice* dev = pb-&gt;device;\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    /* clear inner area */\n    clear_rect(dev, ix, iy, iw, ih);\n\n    /* draw filled area */\n    uint16_t fill_w = compute_fill_width(pb, pb-&gt;value);\n    if (fill_w &gt; 0)\n        fill_rect(dev, ix, iy, fill_w, ih);\n\n    /* border */\n    if (pb-&gt;border)\n        draw_rect_border(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n    dev-&gt;ops-&gt;update_area(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n}\n\nvoid CFBD_ProgressBar_SetValue(CFBD_ProgressBar* pb, int32_t new_value)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    new_value = clamp_i32(new_value, pb-&gt;min, pb-&gt;max);\n\n    int32_t old_value = pb-&gt;value;\n    if (pb-&gt;animation.anim_frames &lt;= 1) {\n        pb-&gt;value = new_value;\n        CFBD_ProgressBar_Draw(pb);\n        return;\n    }\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n    if (iw == 0 || ih == 0) {\n        pb-&gt;value = new_value;\n        return;\n    }\n\n    int frames = pb-&gt;animation.anim_frames;\n    int delay = (pb-&gt;animation.anim_frame_delay_ms &gt; 0) ? pb-&gt;animation.anim_frame_delay_ms : 16;\n\n    uint16_t last_fill = compute_fill_width(pb, old_value);\n\n    for (int f = 1; f &lt;= frames; ++f) {\n        float t = (float) f / (float) frames;\n        float st = smoothstep(t);\n\n        int32_t cur_value = old_value + (int32_t) ((float) (new_value - old_value) * st);\n\n        uint16_t cur_fill = compute_fill_width(pb, cur_value);\n\n        /* incremental update only */\n        if (cur_fill &gt; last_fill) {\n            /* grow */\n            fill_rect(pb-&gt;device, ix + last_fill, iy, cur_fill - last_fill, ih);\n        }\n        else if (cur_fill &lt; last_fill) {\n            /* shrink */\n            clear_rect(pb-&gt;device, ix + cur_fill, iy, last_fill - cur_fill, ih);\n        }\n\n        if (pb-&gt;border)\n            draw_rect_border(pb-&gt;device, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n        pb-&gt;device-&gt;ops-&gt;update_area(pb-&gt;device,\n                                     pb-&gt;tl.x,\n                                     pb-&gt;tl.y,\n                                     pb-&gt;size.width,\n                                     pb-&gt;size.height);\n\n        last_fill = cur_fill;\n        pb-&gt;value = cur_value;\n\n        system_delay_ms(delay);\n    }\n\n    pb-&gt;value = new_value;\n}\n\n/*\n *          -&gt; border, uint8_t as boarders\n *          -&gt; padding, uint8_t as padding\n *          -&gt; animation, CFBD_BaseAnimation* passed\n */\nCFBD_Bool\nCFBD_ProgressBar_SetProperty(CFBD_ProgressBar* pb, const char* property, const void* value)\n{\n    if (strcmp(property, \"border\") == 0) {\n        uint8_t border = *(uint8_t*) (value);\n        pb-&gt;border = border;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"padding\") == 0) {\n        uint8_t padding = *(uint8_t*) (value);\n        pb-&gt;padding = padding;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"animation\") == 0) {\n        CFBD_BaseAnimation* animation = (CFBD_BaseAnimation*) (value);\n        pb-&gt;animation = *animation;\n        return CFBD_TRUE;\n    }\n    return CFBD_FALSE;\n}\n\nCFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n\n/* simple setters */\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max)\n{\n    if (!pb)\n        return;\n    memset(pb, 0, sizeof(*pb));\n    pb-&gt;tl = *tl;\n    pb-&gt;size = *sz;\n    pb-&gt;min = min;\n    pb-&gt;max = max;\n    pb-&gt;value = min;\n    pb-&gt;device = device;\n    pb-&gt;border = 1;\n    pb-&gt;padding = 1;\n    pb-&gt;ops = &amp;ops;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/progressbar_8h/","title":"lib/graphic/widget/progressbar/progressbar.h","text":""},{"location":"api/Files/progressbar_8h/#classes","title":"Classes","text":"Name struct CFBD_ProgressBarOps struct __CFBD_ProgressBar"},{"location":"api/Files/progressbar_8h/#types","title":"Types","text":"Name typedef struct __CFBD_ProgressBar CFBD_ProgressBar"},{"location":"api/Files/progressbar_8h/#functions","title":"Functions","text":"Name void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/progressbar_8h/#typedef-cfbd_progressbar","title":"typedef CFBD_ProgressBar","text":"<pre><code>typedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n</code></pre>"},{"location":"api/Files/progressbar_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8h/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/animation/animation.h\"\n\ntypedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n\ntypedef struct\n{\n    void (*immediate_draw)(CFBD_ProgressBar*);\n    void (*set_value)(CFBD_ProgressBar*, int32_t new_value);\n    CFBD_Bool (*set_property)(CFBD_ProgressBar*, const char* property, const void* args);\n} CFBD_ProgressBarOps;\n\ntypedef struct __CFBD_ProgressBar\n{\n    CFBD_ProgressBarOps* ops;\n    CFBDGraphic_Point tl; /* top-left */\n    CFBDGraphicSize size;\n    int32_t min;   /* min value */\n    int32_t max;   /* max value */\n    int32_t value; /* current value */\n    CFBD_GraphicDevice* device;\n\n    /* visual config */\n    uint8_t border;  /* 0 = no border, 1 = border */\n    uint8_t padding; /* inner padding px between border and fill */\n\n    /* animation config */\n    CFBD_BaseAnimation animation;\n} CFBD_ProgressBar;\n\n/* Initialize progressbar (no dynamic allocation). device must be valid. */\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/rectangle_8c/","title":"rectangle.c","text":""},{"location":"api/Files/rectangle_8c/#types","title":"Types","text":"Name enum ____CSCode"},{"location":"api/Files/rectangle_8c/#functions","title":"Functions","text":"Name int cs_compute_code(const CFBDGraphicRect * r, int32_t x, int32_t y)"},{"location":"api/Files/rectangle_8c/#defines","title":"Defines","text":"Name MAX(a, b) MIN(a, b)"},{"location":"api/Files/rectangle_8c/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/rectangle_8c/#enum-____cscode","title":"enum ____CSCode","text":"Enumerator Value Description CS_LEFT 1 &lt;&lt; 0 CS_RIGHT 1 &lt;&lt; 1 CS_BOTTOM 1 &lt;&lt; 2 CS_TOP 1 &lt;&lt; 3"},{"location":"api/Files/rectangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/rectangle_8c/#function-cs_compute_code","title":"function cs_compute_code","text":"<pre><code>static int cs_compute_code(\n    const CFBDGraphicRect * r,\n    int32_t x,\n    int32_t y\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/rectangle_8c/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"rectangle.h\"\n\n#include &lt;math.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"device/graphic_device.h\"\n\ntypedef enum\n{\n    CS_LEFT = 1 &lt;&lt; 0,\n    CS_RIGHT = 1 &lt;&lt; 1,\n    CS_BOTTOM = 1 &lt;&lt; 2,\n    CS_TOP = 1 &lt;&lt; 3\n} ____CSCode;\n\nvoid CFBDGraphic_DrawRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    if (device == NULL || rect == NULL)\n        return;\n    if (device-&gt;ops == NULL)\n        return;\n\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    if (lx == rx &amp;&amp; ty == by) {\n        device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty));\n    }\n    else {\n        /* \u9876\u8fb9\u4e0e\u5e95\u8fb9\uff08\u6c34\u5e73\uff09: x = lx..rx */\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(ty));\n            if (by != ty) /* \u5982\u679c\u9ad8\u5ea6&gt;1 \u518d\u753b\u5e95\u8fb9\uff0c\u9632\u6b62\u91cd\u590d\u753b\u540c\u4e00\u884c */\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(by));\n        }\n        if (by - ty &gt;= 2) {\n            for (int32_t y = ty + 1; y &lt;= by - 1; ++y) {\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(y));\n                if (rx != lx)\n                    device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(rx), clamp_u16_from_i32(y));\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nvoid CFBDGraphic_FillRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    for (int32_t y = ty; y &lt;= by; ++y) {\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(y));\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nstatic int cs_compute_code(const CFBDGraphicRect* r, int32_t x, int32_t y)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t code = 0;\n\n    if (x &lt; asInt32_t(n.tl.x))\n        code |= CS_LEFT;\n    else if (x &gt; asInt32_t(n.br.x))\n        code |= CS_RIGHT;\n\n    if (y &lt; asInt32_t(n.tl.y))\n        code |= CS_TOP;\n    else if (y &gt; asInt32_t(n.br.y))\n        code |= CS_BOTTOM;\n\n    return code;\n}\n\nCFBDGraphicRect rect_intersection(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n#ifndef MAX\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n    int32_t lx = MAX(asInt32_t(A.tl.x), asInt32_t(B.tl.x));\n    int32_t ty = MAX(asInt32_t(A.tl.y), asInt32_t(B.tl.y));\n    int32_t rx = MIN(asInt32_t(A.br.x), asInt32_t(B.br.x));\n    int32_t by = MIN(asInt32_t(A.br.y), asInt32_t(B.br.y));\n#undef MAX\n#undef MIN\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_union(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n    int32_t lx = asInt32_t(A.tl.x) &lt; asInt32_t(B.tl.x) ? asInt32_t(A.tl.x) : asInt32_t(B.tl.x);\n    int32_t ty = asInt32_t(A.tl.y) &lt; asInt32_t(B.tl.y) ? asInt32_t(A.tl.y) : asInt32_t(B.tl.y);\n    int32_t rx = asInt32_t(A.br.x) &gt; asInt32_t(B.br.x) ? asInt32_t(A.br.x) : asInt32_t(B.br.x);\n    int32_t by = asInt32_t(A.br.y) &gt; asInt32_t(B.br.y) ? asInt32_t(A.br.y) : asInt32_t(B.br.y);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_offset(const CFBDGraphicRect* r, int32_t dx, int32_t dy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(asInt32_t(n.tl.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.tl.y) + dy)},\n                              {clamp_u16_from_i32(asInt32_t(n.br.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.br.y) + dy)}};\n}\n\nCFBDGraphicRect\nrect_inset(const CFBDGraphicRect* r, int32_t left, int32_t top, int32_t right, int32_t bottom)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t lx = asInt32_t(n.tl.x) + left;\n    int32_t ty = asInt32_t(n.tl.y) + top;\n    int32_t rx = asInt32_t(n.br.x) - right;\n    int32_t by = asInt32_t(n.br.y) - bottom;\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect* r, float sx, float sy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t cx = (asInt32_t(n.tl.x) + asInt32_t(n.br.x)) / 2;\n    int32_t cy = (asInt32_t(n.tl.y) + asInt32_t(n.br.y)) / 2;\n\n    int32_t hw = asInt32_t(n.br.x) - asInt32_t(n.tl.x);\n    int32_t hh = asInt32_t(n.br.y) - asInt32_t(n.tl.y);\n\n    int32_t new_hw = (int32_t) floorf(hw * sx / 2.0f + 0.5f);\n    int32_t new_hh = (int32_t) floorf(hh * sy / 2.0f + 0.5f);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(cx - new_hw), clamp_u16_from_i32(cy - new_hh)},\n                              {clamp_u16_from_i32(cx + new_hw), clamp_u16_from_i32(cy + new_hh)}};\n}\n\nCFBDGraphicRect\nrect_align_in_parent(const CFBDGraphicRect* parent, const CFBDGraphicRect* child, uint8_t anchor)\n{\n    CFBDGraphicRect P = rect_normalize(*parent);\n    CFBDGraphicRect C = rect_normalize(*child);\n    int32_t pw = asInt32_t(P.br.x) - asInt32_t(P.tl.x);\n    int32_t ph = asInt32_t(P.br.y) - asInt32_t(P.tl.y);\n    int32_t cw = asInt32_t(C.br.x) - asInt32_t(C.tl.x);\n    int32_t ch = asInt32_t(C.br.y) - asInt32_t(C.tl.y);\n    int32_t nx = asInt32_t(P.tl.x);\n    int32_t ny = asInt32_t(P.tl.y); /* \u6c34\u5e73 */\n    if (anchor &amp; RECT_ANCHOR_LEFT) {\n        nx = asInt32_t(P.tl.x);\n    }\n    else if (anchor &amp; RECT_ANCHOR_RIGHT) {\n        nx = asInt32_t(P.br.x) - cw;\n    }\n    else { /* center by default */\n        nx = asInt32_t(P.tl.x) + (pw - cw) / 2;\n    } /* \u5782\u76f4 */\n    if (anchor &amp; RECT_ANCHOR_TOP) {\n        ny = asInt32_t(P.tl.y);\n    }\n    else if (anchor &amp; RECT_ANCHOR_BOTTOM) {\n        ny = asInt32_t(P.br.y) - ch;\n    }\n    else {\n        ny = asInt32_t(P.tl.y) + (ph - ch) / 2;\n    }\n    return rect_from_xywh(nx, ny, cw, ch);\n}\n\n/* ---------- \u6700\u8fd1\u70b9 / \u70b9\u5230\u77e9\u5f62\u8ddd\u79bb ---------- */\n\n/* \u8fd4\u56de\u77e9\u5f62\u5185\u5230\u70b9\u6700\u8fd1\u7684\u70b9\uff08\u5982\u679c\u70b9\u5728\u77e9\u5f62\u5185\uff0c\u5219\u8fd4\u56de\u70b9\u672c\u8eab\uff0c\u7ed3\u679c\u4e3a uint16_t\uff09 */\nCFBDGraphic_Point rect_closest_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t px = asInt32_t(p.x), py = asInt32_t(p.y);\n    int32_t lx = asInt32_t(n.tl.x), ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x), by = asInt32_t(n.br.y);\n    int32_t cx = px &lt; lx ? lx : (px &gt; rx ? rx : px);\n    int32_t cy = py &lt; ty ? ty : (py &gt; by ? by : py);\n    CFBDGraphic_Point out = {clamp_u16_from_i32(cx), clamp_u16_from_i32(cy)};\n    return out;\n}\n\n/* \u70b9\u5230\u77e9\u5f62\u6700\u77ed\u8ddd\u79bb\uff08\u50cf\u7d20\u8ddd\u79bb\uff0c\u82e5\u5728\u77e9\u5f62\u5185\u5219\u4e3a0\uff09*/\nuint32_t rect_distance_to_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphic_Point cp = rect_closest_point(r, p);\n    int32_t dx = asInt32_t(cp.x) - asInt32_t(p.x);\n    int32_t dy = asInt32_t(cp.y) - asInt32_t(p.y);\n    return (uint32_t) (sqrt((double) (dx * dx + dy * dy)));\n}\n\n/* ---------- \u6269\u5c55 / \u5305\u542b\u70b9 ---------- */\nCFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; asInt32_t(p.x) ? asInt32_t(n.tl.x) : asInt32_t(p.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; asInt32_t(p.y) ? asInt32_t(n.tl.y) : asInt32_t(p.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; asInt32_t(p.x) ? asInt32_t(n.br.x) : asInt32_t(p.x);\n    int32_t by = asInt32_t(n.br.y) &gt; asInt32_t(p.y) ? asInt32_t(n.br.y) : asInt32_t(p.y);\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n\nCFBD_Bool rect_clip_line(CFBDGraphicRect* r, CFBDGraphic_Point* p0, CFBDGraphic_Point* p1)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t x0 = asInt32_t(p0-&gt;x), y0 = asInt32_t(p0-&gt;y);\n    int32_t x1 = asInt32_t(p1-&gt;x), y1 = asInt32_t(p1-&gt;y);\n    int code0 = cs_compute_code(&amp;n, x0, y0);\n    int code1 = cs_compute_code(&amp;n, x1, y1);\n    CFBD_Bool accept = CFBD_FALSE;\n    while (1) {\n        if ((code0 | code1) == 0) {\n            accept = CFBD_TRUE;\n            break;\n        }\n        else if (code0 &amp; code1) {\n            accept = CFBD_FALSE;\n            break;\n        }\n        else {\n            int outcode = code0 ? code0 : code1;\n            int32_t nx = 0, ny = 0;\n            if (outcode &amp; CS_TOP) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.tl.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.tl.y);\n            }\n            else if (outcode &amp; CS_BOTTOM) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.br.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.br.y);\n            }\n            else if (outcode &amp; CS_RIGHT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.br.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.br.x);\n            }\n            else if (outcode &amp; CS_LEFT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.tl.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.tl.x);\n            }\n            if (outcode == code0) {\n                x0 = nx;\n                y0 = ny;\n                code0 = cs_compute_code(&amp;n, x0, y0);\n            }\n            else {\n                x1 = nx;\n                y1 = ny;\n                code1 = cs_compute_code(&amp;n, x1, y1);\n            }\n        }\n    }\n    if (accept) {\n        p0-&gt;x = clamp_u16_from_i32(x0);\n        p0-&gt;y = clamp_u16_from_i32(y0);\n        p1-&gt;x = clamp_u16_from_i32(x1);\n        p1-&gt;y = clamp_u16_from_i32(y1);\n    }\n    return accept;\n}\n\n/* ---------- \u591a\u7528\u9014\uff1a\u88c1\u526a\u5230\u5c4f\u5e55\u8fb9\u754c ---------- */\nCFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect* r, uint16_t screen_w, uint16_t screen_h)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; 0 ? 0 : asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; 0 ? 0 : asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; screen_w ? screen_w : asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y) &gt; screen_h ? screen_h : asInt32_t(n.br.y);\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/size_8c/","title":"size.c","text":""},{"location":"api/Files/size_8c/#source-code","title":"Source code","text":"<pre><code>#include \"size.h\"\n#include \"cfbd_graphic_define.h\"\n#include &lt;stddef.h&gt;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize){\n    PointBaseType width, height;\n    device-&gt;ops-&gt;self_consult(device, \"width\", NULL, &amp;width);\n    device-&gt;ops-&gt;self_consult(device, \"height\", NULL, &amp;height);\n    pSize-&gt;height = height;\n    pSize-&gt;width = width;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/size_8h/","title":"size.h","text":"<p>Size data structure and utilities for 2D graphics. </p>"},{"location":"api/Files/size_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area."},{"location":"api/Files/size_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n\ntypedef struct\n{\n    SizeBaseType width;  \n    SizeBaseType height; \n} CFBDGraphicSize;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize);\n\n // End of Size_Module group\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ssd1306_8c/","title":"lib/oled/driver/device/ssd1306/ssd1306.c","text":""},{"location":"api/Files/ssd1306_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1306_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1306_inits_commands CFBD_OLED_DeviceSpecific ssd1306_specific"},{"location":"api/Files/ssd1306_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8c/#function-ssd1306_init_sessions","title":"function ssd1306_init_sessions","text":"<pre><code>static uint8_t * ssd1306_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_inits_commands","title":"variable ssd1306_inits_commands","text":"<pre><code>static uint8_t[] ssd1306_inits_commands = {\n\n};\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_specific","title":"variable ssd1306_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1306_specific;\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1306.h\"\n#include &lt;stdint.h&gt;\n\nstatic uint8_t ssd1306_inits_commands[] = {\n\n};\n\n\nstatic uint8_t* ssd1306_init_sessions(void){\n    return ssd1306_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1306_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific(){\n    ssd1306_specific.init_session_tables = ssd1306_init_sessions;\n    return &amp;ssd1306_specific;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ssd1306_8h/","title":"lib/oled/driver/device/ssd1306/ssd1306.h","text":"<p>SSD1306 device-specific descriptor and factory.  More...</p>"},{"location":"api/Files/ssd1306_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8h/#detailed-description","title":"Detailed Description","text":"<p>SSD1306 device-specific descriptor and factory. </p> <p>See: </p> <ul> <li>CFBD_OLED_DeviceSpecificfor the generic interface </li> <li>device_interface.hfor base types </li> </ul> <p>This module provides the SSD1306-specific implementation of the device descriptor interface. It delivers initialization sequences, GRAM buffers, and communication parameters tailored for SSD1306-based displays.</p> <p>The SSD1306 is a common monochrome OLED controller featuring:</p> <ul> <li>128x64 pixel resolution (typical)</li> <li>I2C or SPI communication interface</li> <li>256-byte graphics RAM</li> <li>Multiplex and COM output configurations</li> </ul>"},{"location":"api/Files/ssd1306_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8h/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"driver/device/device_interface.h\"\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific();\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ssd1309_8c/","title":"lib/oled/driver/device/ssd1309/ssd1309.c","text":""},{"location":"api/Files/ssd1309_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1309_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1309_inits_commands CFBD_OLED_DeviceSpecific ssd1309_specific"},{"location":"api/Files/ssd1309_8c/#defines","title":"Defines","text":"Name CMD_TABLE_SZ"},{"location":"api/Files/ssd1309_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8c/#function-ssd1309_init_sessions","title":"function ssd1309_init_sessions","text":"<pre><code>static uint8_t * ssd1309_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_inits_commands","title":"variable ssd1309_inits_commands","text":"<pre><code>static uint8_t[] ssd1309_inits_commands = {\n        0xAE,       \n        0xFD, 0x12, \n        0xD5,       \n        0xA0,       \n        0xA8,       \n        0x3F,       \n        0xD3,       \n        0x00,       \n        0x40,       \n        0xA1,       \n        0xC8,       \n        0xDA,       \n        0x12,       \n        0x81,       \n        0xBF,       \n        0xD9,       \n        0x25,       \n        0xDB,       \n        0x34,       \n        0xA4,       \n        0xA6,       \n        0xAF        \n};\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_specific","title":"variable ssd1309_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1309_specific;\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1309_8c/#define-cmd_table_sz","title":"define CMD_TABLE_SZ","text":"<pre><code>#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1309.h\"\n\n#include &lt;stdint.h&gt;\n\n\nstatic uint8_t ssd1309_inits_commands[] = {\n        0xAE,       // Turn off OLED panel\n        0xFD, 0x12, // Set display clock divide ratio/oscillator frequency\n        0xD5,       // Set display clock divide ratio\n        0xA0,       // Set multiplex ratio\n        0xA8,       // Set multiplex ratio (1 to 64)\n        0x3F,       // 1/64 duty\n        0xD3,       // Set display offset\n        0x00,       // No offset\n        0x40,       // Set start line address\n        0xA1,       // Set SEG/Column mapping (0xA0 for reverse, 0xA1 for normal)\n        0xC8,       // Set COM/Row scan direction (0xC0 for reverse, 0xC8 for normal)\n        0xDA,       // Set COM pins hardware configuration\n        0x12,       // COM pins configuration\n        0x81,       // Set contrast control register\n        0xBF,       // Set SEG output current brightness\n        0xD9,       // Set pre-charge period\n        0x25,       // Set pre-charge as 15 clocks &amp; discharge as 1 clock\n        0xDB,       // Set VCOMH\n        0x34,       // Set VCOM deselect level\n        0xA4,       // Disable entire display on\n        0xA6,       // Disable inverse display on\n        0xAF        // Turn on the display\n};\n\n#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n\nstatic uint8_t* ssd1309_init_sessions(void)\n{\n    return ssd1309_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1309_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific()\n{\n    ssd1309_specific.init_session_tables = ssd1309_init_sessions;\n    ssd1309_specific.init_session_tables_sz = CMD_TABLE_SZ;\n    ssd1309_specific.cmd_prefix = 0x00;\n    ssd1309_specific.data_prefix = 0x40;\n    ssd1309_specific.logic_height = 64;\n    ssd1309_specific.logic_width = 128;\n\n    return &amp;ssd1309_specific;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/ssd1309_8h/","title":"lib/oled/driver/device/ssd1309/ssd1309.h","text":"<p>SSD1309 device-specific descriptor and factory.  More...</p>"},{"location":"api/Files/ssd1309_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8h/#detailed-description","title":"Detailed Description","text":"<p>SSD1309 device-specific descriptor and factory. </p> <p>See: </p> <ul> <li>CFBD_OLED_DeviceSpecificfor the generic interface </li> <li>device_interface.hfor base types </li> </ul> <p>This module provides the SSD1309-specific implementation of the device descriptor interface. It delivers initialization sequences, GRAM buffers, and communication parameters optimized for SSD1309-based displays.</p> <p>The SSD1309 is an enhanced monochrome OLED controller featuring:</p> <ul> <li>Extended resolution support (typically 128x64 or larger)</li> <li>Improved contrast and brightness control</li> <li>I2C and SPI communication interfaces</li> <li>Advanced timing parameters for various OLED panel types</li> <li>Fixed default I2C address: 0x78</li> </ul>"},{"location":"api/Files/ssd1309_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8h/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"driver/device/device_interface.h\"\n\n#define SSD1309_DRIVER_ADDRESS (0x78)\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific();\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/system__clock_8c/","title":"lib/application/sys_clock/system_clock.c","text":"<p>More...</p>"},{"location":"api/Files/system__clock_8c/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30</p> <p>Copyright: Copyright \u00a9 2025 </p>"},{"location":"api/Files/system__clock_8c/#source-code","title":"Source code","text":"<pre><code>#include \"system_clock.h\"\n#include \"config/system_settings.h\"\n#include \"app.h\"\n#include \"cfbd_define.h\"\n\n\nvoid system_delay_us(uint32_t us)\n{\n    CFBDApplication* app = getApp(CFBD_FALSE);\n\n    uint64_t ticks;                                     // Total number of ticks required for the delay\n    uint32_t prevValue, currentValue, elapsedTicks = 0; // Variables for SysTick counter values and elapsed ticks\n    uint32_t reloadValue = SysTick-&gt;LOAD;               // Value of the SysTick reload register\n    uint32_t sysclk_freq = app-&gt;tick_provider() / 1000000L;\n    ticks = us * sysclk_freq; // Calculate the number of ticks needed for the desired delay in microseconds\n\n    prevValue = SysTick-&gt;VAL; // Store the initial SysTick counter value\n\n    while (1)\n    {\n        currentValue = SysTick-&gt;VAL; // Get the current SysTick counter value\n        if (currentValue != prevValue)\n        {\n            if (currentValue &lt; prevValue)\n            {\n                elapsedTicks += prevValue - currentValue; // Count the elapsed ticks (SysTick is a decrementing counter)\n            }\n            else\n            {\n                elapsedTicks += reloadValue - currentValue + prevValue; // Handle the rollover case\n            }\n            prevValue = currentValue; // Update the previous value to the current value\n\n            if (elapsedTicks &gt;= ticks) // If the elapsed time is greater than or equal to the requested delay\n            {\n                break; // Exit the loop to complete the delay\n            }\n        }\n    }\n}\n\nvoid system_delay_ms(uint32_t delay_ms)\n{\n    for (uint32_t i = 0; i &lt; delay_ms; i++)\n    {\n        system_delay_us(1000);\n    }\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/system__clock_8h/","title":"lib/application/sys_clock/system_clock.h","text":"<p>System timing primitives and delay helpers.  More...</p>"},{"location":"api/Files/system__clock_8h/#detailed-description","title":"Detailed Description","text":"<p>System timing primitives and delay helpers. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30 </p> <p>Note: Units are explicitly milliseconds (<code>ms</code>) and microseconds (<code>us</code>).</p> <p>Copyright: Copyright \u00a9 2025 </p> <p>This header exposes minimal timing helpers used throughout the application code for short, platform-dependent delays. The concrete behavior (blocking, sleep, busy-wait, tick resolution) depends on the platform-specific implementation behind these APIs.</p> <p>Implementations should document any real-time or concurrency restrictions (for example, whether the functions may be called from interrupt context). Consumers of these APIs should avoid long blocking delays in time-critical or interrupt contexts.</p>"},{"location":"api/Files/system__clock_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef SYSCLK_H\n#define SYSCLK_H\n\n#include &lt;stdint.h&gt;\n\nvoid system_delay_ms(uint32_t delay_ms);\n\nvoid system_delay_us(uint32_t us);\n\n#endif /* SYSCLK_H */\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/test__base__graphic_8c/","title":"lib/graphic/fast_test/test_base_graphic.c","text":""},{"location":"api/Files/test__base__graphic_8c/#functions","title":"Functions","text":"Name void test_draw_line(CFBD_GraphicDevice * handler) void test_draw_rectangle(CFBD_GraphicDevice * handler) void test_draw_circle(CFBD_GraphicDevice * handler) void test_draw_ellipse(CFBD_GraphicDevice * handler) void test_draw_triangle(CFBD_GraphicDevice * handler) void test_draw_arc(CFBD_GraphicDevice * handler) void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_line","title":"function test_draw_line","text":"<pre><code>static void test_draw_line(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_rectangle","title":"function test_draw_rectangle","text":"<pre><code>static void test_draw_rectangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_circle","title":"function test_draw_circle","text":"<pre><code>static void test_draw_circle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_ellipse","title":"function test_draw_ellipse","text":"<pre><code>static void test_draw_ellipse(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_triangle","title":"function test_draw_triangle","text":"<pre><code>static void test_draw_triangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_arc","title":"function test_draw_arc","text":"<pre><code>static void test_draw_arc(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"base/arc.h\"\n#include \"base/circle.h\"\n#include \"base/ellipse.h\"\n#include \"base/line.h\"\n#include \"base/rectangle.h\"\n#include \"base/triangle.h\"\n\n// \u6d4b\u8bd5\u76f4\u7ebf\u7ed8\u5236\nstatic void test_draw_line(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u6c34\u5e73\u7ebf\n    CFBDGraphic_Line line1 = {.p_left = {10, 10}, .p_right = {50, 10}};\n    CFBDGraphic_DrawLine(handler, &amp;line1);\n\n    // \u6d4b\u8bd52: \u5782\u76f4\u7ebf\n    CFBDGraphic_Line line2 = {.p_left = {60, 5}, .p_right = {60, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line2);\n\n    // \u6d4b\u8bd53: \u659c\u7ebf\n    CFBDGraphic_Line line3 = {.p_left = {70, 5}, .p_right = {90, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line3);\n}\n\n// \u6d4b\u8bd5\u77e9\u5f62\u7ed8\u5236\nstatic void test_draw_rectangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect1 = {.tl = {5, 30}, .br = {35, 50}};\n    CFBDGraphic_DrawRect(handler, &amp;rect1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect2 = {.tl = {40, 32}, .br = {60, 48}};\n    CFBDGraphic_FillRect(handler, &amp;rect2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f62\u7ed8\u5236\nstatic void test_draw_circle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\n    CFBDGraphicCircle circle1 = {.center = {80, 15}, .radius = 10};\n    CFBDGraphic_DrawCircle(handler, &amp;circle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u5706\n    CFBDGraphicCircle circle2 = {.center = {105, 15}, .radius = 8};\n    CFBDGraphic_DrawFilledCircle(handler, &amp;circle2);\n}\n\n// \u6d4b\u8bd5\u692d\u5706\u7ed8\u5236\nstatic void test_draw_ellipse(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u692d\u5706\n    CCGraphic_Ellipse ellipse1 = {.center = {85, 40}, .X_Radius = 15, .Y_Radius = 10};\n    CFBDGraphic_DrawEllipse(handler, &amp;ellipse1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u692d\u5706\n    CCGraphic_Ellipse ellipse2 = {.center = {110, 55}, .X_Radius = 10, .Y_Radius = 6};\n    CFBDGraphic_DrawFilledEllipse(handler, &amp;ellipse2);\n}\n\n// \u6d4b\u8bd5\u4e09\u89d2\u5f62\u7ed8\u5236\nstatic void test_draw_triangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle1 = {.p1 = {15, 55}, .p2 = {5, 62}, .p3 = {25, 62}};\n    CCGraphic_DrawTriangle(handler, &amp;triangle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle2 = {.p1 = {45, 55}, .p2 = {35, 62}, .p3 = {55, 62}};\n    CCGraphic_DrawFilledTriangle(handler, &amp;triangle2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f27\u7ed8\u5236\nstatic void test_draw_arc(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\u5f27 (0-90\u5ea6)\n    CCGraphic_Arc arc1 = {.center = {20, 15}, .radius = 12, .start_degree = 0, .end_degree = 90};\n    CFBDGraphic_DrawArc(handler, &amp;arc1);\n\n    // \u6d4b\u8bd52: \u7a7a\u5fc3\u5706\u5f27 (180-270\u5ea6)\n    CCGraphic_Arc arc2 = {.center = {45, 15}, .radius = 12, .start_degree = 180, .end_degree = 270};\n    CFBDGraphic_DrawArc(handler, &amp;arc2);\n\n    // \u6d4b\u8bd53: \u5b9e\u5fc3\u5706\u5f27 (45-135\u5ea6)\n    CCGraphic_Arc arc3 = {.center = {70, 55}, .radius = 8, .start_degree = 45, .end_degree = 135};\n    CFBDGraphic_DrawFilledArc(handler, &amp;arc3);\n}\n\n// \u4e3b\u6d4b\u8bd5\u51fd\u6570 - \u6309\u987a\u5e8f\u6d4b\u8bd5\u6240\u6709\u56fe\u5f62\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler)\n{\n    // 1. \u6d4b\u8bd5\u76f4\u7ebf\n    test_draw_line(handler);\n\n    // 2. \u6d4b\u8bd5\u77e9\u5f62\n    test_draw_rectangle(handler);\n\n    // 3. \u6d4b\u8bd5\u5706\u5f62\n    test_draw_circle(handler);\n\n    // 4. \u6d4b\u8bd5\u692d\u5706\n    test_draw_ellipse(handler);\n\n    // 5. \u6d4b\u8bd5\u4e09\u89d2\u5f62\n    test_draw_triangle(handler);\n\n    // 6. \u6d4b\u8bd5\u5706\u5f27\n    test_draw_arc(handler);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/test__base__graphic_8h/","title":"lib/graphic/fast_test/test_base_graphic.h","text":""},{"location":"api/Files/test__base__graphic_8h/#functions","title":"Functions","text":"Name void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8h/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/test__widget_8c/","title":"lib/graphic/fast_test/test_widget.c","text":""},{"location":"api/Files/test__widget_8c/#functions","title":"Functions","text":"Name void test_text(CFBD_GraphicDevice * handler) void menu_example(CFBD_GraphicDevice * dev) void progressbar_usage(CFBD_GraphicDevice * dev) void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8c/#function-test_text","title":"function test_text","text":"<pre><code>static void test_text(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-menu_example","title":"function menu_example","text":"<pre><code>void menu_example(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-progressbar_usage","title":"function progressbar_usage","text":"<pre><code>void progressbar_usage(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#source-code","title":"Source code","text":"<pre><code>#include \"test_widget.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"app.h\"\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"config/system_settings.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/menu/menu.h\"\n#include \"widget/progressbar/progressbar.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\nstatic void test_text(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphic_DeviceClearImmediate(handler);\n    /* print sources */\n    char* source = \"Hello, World!This is Charlie's Speeking!\";\n    CFBDGraphic_Text item;\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;item, p, screen_size, ASCII_6x8);\n\n    CFBDGraphic_SetText(&amp;item, source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    /* after delay, print new_sources */\n    char* new_source = \"May I Help You?\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    // resets everythings\n    CFBDGraphic_DeviceClearImmediate(handler);\n    CFBDGraphic_SetTextIndexedPoint(&amp;item, &amp;p);\n\n    new_source = \"Yes!Please Offer me a lemon juice\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n}\n\nvoid menu_example(CFBD_GraphicDevice* dev)\n{\n    CFBD_MenuItem items_buf[5];\n    CFBD_Menu mymenu;\n    CFBD_MenuItemGroup groups;\n    groups.pItems = items_buf;\n    groups.capacity = 5;\n    groups.count = 0;\n\n    CFBD_InitMenu(&amp;mymenu, dev, &amp;groups, 120);\n\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 1\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 2das\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 3fasd\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item 4fffff\", ASCII_6x8, NULL);\n    mymenu.operations-&gt;add_item(&amp;mymenu, \"Item numbr\", ASCII_6x8, NULL);\n\n    mymenu.operations-&gt;immediate_draw(&amp;mymenu);\n\n    system_delay_ms(500);\n\n    /* auto demo loop */\n    while (1) {\n        for (int i = 1; i &lt; (int) mymenu.menu_items-&gt;count - 1; ++i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        for (int i = (int) mymenu.menu_items-&gt;count - 3; i &gt;= 0; --i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        CFBDGraphic_Point p = {.x = 30, .y = 10};\n        mymenu.operations-&gt;reset_tl_points(&amp;mymenu, &amp;p, CFBD_TRUE);\n\n        for (int i = 1; i &lt; (int) mymenu.menu_items-&gt;count - 1; ++i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        for (int i = (int) mymenu.menu_items-&gt;count - 3; i &gt;= 0; --i) {\n            mymenu.operations-&gt;select_index(&amp;mymenu, i);\n            system_delay_ms(600);\n        }\n\n        p.x = 0;\n        p.y = 0;\n        mymenu.operations-&gt;reset_tl_points(&amp;mymenu, &amp;p, CFBD_TRUE);\n    }\n}\n\n/*\n * Demo: ProgressBar usage\n * OLED: 128x64\n * Effect:\n *  - Title text\n *  - Main progress bar (0 -&gt; 100, smooth + flow light)\n *  - Sub progress bar (busy animation in stages)\n */\n\nvoid progressbar_usage(CFBD_GraphicDevice* dev)\n{\n    /* =======================\n     * Title\n     * ======================= */\n    CFBDGraphic_Text title;\n    CFBDGraphic_Point tp = {.x = 12, .y = 2};\n    CFBDGraphicSize ts = {.width = 104, .height = 10};\n    CFBDGraphic_InitText(&amp;title, tp, ts, ASCII_6x8);\n    CFBDGraphic_SetText(&amp;title, \"System Booting...\");\n\n    /* =======================\n     * Main ProgressBar\n     * ======================= */\n    CFBD_ProgressBar main_pb;\n    CFBDGraphic_Point p = {6, 18};\n    CFBDGraphicSize sz = {116, 12};\n    CFBD_ProgressBar_Init(&amp;main_pb, dev, &amp;p, &amp;sz, 0, 100);\n    uint8_t boarder_and_padding = 1;\n    CFBD_BaseAnimation animation = {.anim_frame_delay_ms = 25, .anim_frames = 10};\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"border\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"padding\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"animation\", &amp;animation);\n\n    /* =======================\n     * Stage ProgressBar\n     * ======================= */\n    CFBD_ProgressBar stage_pb;\n    CFBDGraphic_Point p2 = {20, 38};\n    CFBDGraphicSize sz2 = {88, 8};\n    CFBD_ProgressBar_Init(&amp;stage_pb, dev, &amp;p2, &amp;sz2, 0, 100);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"border\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"padding\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"animation\", &amp;animation);\n    /* =======================\n     * First frame draw\n     * ======================= */\n    dev-&gt;ops-&gt;clear(dev);\n\n    CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_RequestOldPoint);\n\n    main_pb.ops-&gt;immediate_draw(&amp;main_pb);\n    main_pb.ops-&gt;immediate_draw(&amp;stage_pb);\n\n    dev-&gt;ops-&gt;update(dev);\n\n    /* =======================\n     * Demo animation\n     * ======================= */\n    const int stages[] = {0, 20, 45, 70, 100};\n\n    while (1) {\n        for (int s = 0; s &lt; 5; ++s) {\n            /* main progress moves forward */\n            main_pb.ops-&gt;set_value(&amp;main_pb, stages[s]);\n            system_delay_ms(500);\n\n            /* stage progress busy animation */\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 25);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 50);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 75);\n            system_delay_ms(500);\n\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 100);\n            system_delay_ms(500);\n            stage_pb.ops-&gt;set_value(&amp;stage_pb, 0);\n        }\n    }\n}\n\nvoid test_widget(CFBD_GraphicDevice* handler)\n{\n    progressbar_usage(handler);\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/test__widget_8h/","title":"lib/graphic/fast_test/test_widget.h","text":""},{"location":"api/Files/test__widget_8h/#functions","title":"Functions","text":"Name void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8h/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cfbd_graphic_define.h\"\n\nvoid test_widget(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/text_8c/","title":"lib/graphic/widget/text.c","text":""},{"location":"api/Files/text_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_InitText(CFBDGraphic_Text * item, CFBDGraphic_Point tl_point, CFBDGraphicSize textHandleSize, Ascii_Font_Size text_size) void __pvt_draw_char_each(CFBD_GraphicDevice * device_handle, CCGraphic_Image * borrowing_image, const char ch, Ascii_Font_Size size) uint8_t __pvt_should_be_next_line(CFBD_GraphicDevice * device_handle, CFBDGraphic_Point * brpoint, CFBDGraphic_Point * cur_draw_p, Ascii_Font_Size s) CFBDGraphic_Point __pvt_fetch_valid_final_point(CFBD_GraphicDevice * device_handle, CFBDGraphicSize * size, CFBDGraphic_Point * tl) CFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice * device_handle, CFBDGraphic_Text * item, AppendMethod method)"},{"location":"api/Files/text_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text_8c/#function-cfbdgraphic_inittext","title":"function CFBDGraphic_InitText","text":"<pre><code>void CFBDGraphic_InitText(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point tl_point,\n    CFBDGraphicSize textHandleSize,\n    Ascii_Font_Size text_size\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_draw_char_each","title":"function __pvt_draw_char_each","text":"<pre><code>static void __pvt_draw_char_each(\n    CFBD_GraphicDevice * device_handle,\n    CCGraphic_Image * borrowing_image,\n    const char ch,\n    Ascii_Font_Size size\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_should_be_next_line","title":"function __pvt_should_be_next_line","text":"<pre><code>static inline uint8_t __pvt_should_be_next_line(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Point * brpoint,\n    CFBDGraphic_Point * cur_draw_p,\n    Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_fetch_valid_final_point","title":"function __pvt_fetch_valid_final_point","text":"<pre><code>static inline CFBDGraphic_Point __pvt_fetch_valid_final_point(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphicSize * size,\n    CFBDGraphic_Point * tl\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-cfbdgraphic_drawtext","title":"function CFBDGraphic_DrawText","text":"<pre><code>CFBDGraphic_Point CFBDGraphic_DrawText(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Text * item,\n    AppendMethod method\n)\n</code></pre>"},{"location":"api/Files/text_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text.h\"\n\n#include &lt;limits.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/base_helpers.h\"\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"base_support/image.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/text.h\"\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size)\n{\n    item-&gt;font_size = text_size;\n    item-&gt;sources_borrowed = \"\";\n    item-&gt;tl_point = tl_point;\n    item-&gt;indexed_point = tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n}\n\nstatic void __pvt_draw_char_each(CFBD_GraphicDevice* device_handle,\n                                 CCGraphic_Image* borrowing_image,\n                                 const char ch,\n                                 Ascii_Font_Size size)\n{\n    borrowing_image-&gt;image_size = __fetch_font_size(size);\n    uint8_t* ascii = __select_from_ascii_font_size(size, ch);\n    borrowing_image-&gt;sources_register = ascii;\n    CFBDGraphic_DrawImage(device_handle, borrowing_image);\n}\n\nstatic uint8_t inline __pvt_should_be_next_line(CFBD_GraphicDevice* device_handle,\n                                                CFBDGraphic_Point* brpoint,\n                                                CFBDGraphic_Point* cur_draw_p,\n                                                Ascii_Font_Size s)\n{\n    return cur_draw_p-&gt;x + (int16_t) (1.5 * __fetch_font_size(s).width) &gt;= brpoint-&gt;x;\n}\n\nstatic CFBDGraphic_Point inline __pvt_fetch_valid_final_point(CFBD_GraphicDevice* device_handle,\n                                                              CFBDGraphicSize* size,\n                                                              CFBDGraphic_Point* tl)\n{\n    CFBDGraphic_Point br;\n    CFBDGraphicSize device_size;\n    CFBDGraphic_GetScreenSize(device_handle, &amp;device_size);\n\n    br.x = tl-&gt;x + size-&gt;width;\n    br.y = tl-&gt;y + size-&gt;height;\n    if (device_size.width &lt; br.x) {\n        br.x = device_size.width;\n    }\n    if (device_size.height &lt; br.y) {\n        br.y = device_size.height;\n    }\n    return br;\n}\n\nCFBDGraphic_Point\nCFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle, CFBDGraphic_Text* item, AppendMethod method)\n{\n    if (!device_handle || !item || !device_handle-&gt;ops)\n        return item-&gt;tl_point;\n\n    if (strcmp(item-&gt;sources_borrowed, \"\") == 0)\n        return item-&gt;tl_point;\n    CFBDGraphic_Point old = item-&gt;tl_point;\n    CCGraphic_Image handle_draw_image;\n    CFBDGraphic_Point draw_tl_point = item-&gt;indexed_point;\n\n    const Ascii_Font_Size font_size = item-&gt;font_size;\n    const CFBDGraphicSize size = __fetch_font_size(font_size);\n    const SizeBaseType font_width = size.width;\n    const SizeBaseType font_height = size.height;\n\n    CFBDGraphic_Point br = __pvt_fetch_valid_final_point(device_handle,\n                                                         &amp;(item-&gt;TexthandleSize),\n                                                         &amp;(item-&gt;tl_point));\n\n    uint8_t offseterx = 0;\n    uint8_t offsetery = 0;\n\n    int32_t lx = INT32_MAX;\n    int32_t ty = INT32_MAX;\n    int32_t rx = INT32_MIN;\n    int32_t by = INT32_MIN;\n\n    for (uint8_t i = 0; item-&gt;sources_borrowed[i] != '\\0'; i++) {\n        draw_tl_point.x = item-&gt;indexed_point.x + offseterx * font_width;\n        draw_tl_point.y = item-&gt;indexed_point.y + offsetery * font_height;\n\n        handle_draw_image.point = draw_tl_point;\n\n        __pvt_draw_char_each(device_handle,\n                             &amp;handle_draw_image,\n                             item-&gt;sources_borrowed[i],\n                             item-&gt;font_size);\n\n        int32_t cx1 = asInt32_t(draw_tl_point.x);\n        int32_t cy1 = asInt32_t(draw_tl_point.y);\n        int32_t cx2 = cx1 + font_width;\n        int32_t cy2 = cy1 + font_height;\n\n        if (cx1 &lt; lx)\n            lx = cx1;\n        if (cy1 &lt; ty)\n            ty = cy1;\n        if (cx2 &gt; rx)\n            rx = cx2;\n        if (cy2 &gt; by)\n            by = cy2;\n\n        if (__pvt_should_be_next_line(device_handle, &amp;br, &amp;draw_tl_point, font_size)) {\n            offseterx = 0;\n            offsetery++;\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n        }\n        else {\n            offseterx++;\n        }\n    }\n\n    /* \u7f13\u5b58 TextBoundingRect */\n    if (lx &lt;= rx &amp;&amp; ty &lt;= by) {\n        item-&gt;text_bounding_rect.tl.x = clamp_u16_from_i32(lx - CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.tl.y = clamp_u16_from_i32(ty - CFBDGraphic_TEXT_PADDING_HEIGHT);\n        item-&gt;text_bounding_rect.br.x = clamp_u16_from_i32(rx + CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.br.y = clamp_u16_from_i32(by + CFBDGraphic_TEXT_PADDING_HEIGHT);\n    }\n    else {\n        item-&gt;text_bounding_rect.tl = item-&gt;indexed_point;\n        item-&gt;text_bounding_rect.br = item-&gt;indexed_point;\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device_handle)) {\n        device_handle-&gt;ops-&gt;update_area(device_handle,\n                                        clamp_u16_from_i32(lx),\n                                        clamp_u16_from_i32(ty),\n                                        clamp_u16_from_i32(rx - lx + 1),\n                                        clamp_u16_from_i32(by - ty + 1));\n    }\n\n    switch (method) {\n        case CCGraphic_AsciiTextItem_AppendNextLine:\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n            item-&gt;indexed_point.y += font_height;\n            break;\n        case CCGraphic_AsciiTextItem_AppendContinously:\n            item-&gt;indexed_point.x += font_width;\n            break;\n        case CCGraphic_AsciiTextItem_RequestOldPoint:\n            item-&gt;indexed_point = old;\n            break;\n        default:\n            break;\n    }\n\n    return item-&gt;indexed_point;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/text_8h/","title":"lib/graphic/widget/text.h","text":""},{"location":"api/Files/text_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Text"},{"location":"api/Files/text_8h/#types","title":"Types","text":"Name enum AppendMethod"},{"location":"api/Files/text_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_InitText(CFBDGraphic_Text * item, CFBDGraphic_Point tl_point, CFBDGraphicSize textHandleSize, Ascii_Font_Size text_size) void CFBDGraphic_SetText(CFBDGraphic_Text * item, char * text) void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text * item, CFBDGraphic_Point * tl_point, CFBDGraphicSize textHandleSize) CFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice * device_handle, CFBDGraphic_Text * item, AppendMethod method)"},{"location":"api/Files/text_8h/#defines","title":"Defines","text":"Name CFBDGraphic_TEXT_PADDING_WIDTH CFBDGraphic_TEXT_PADDING_HEIGHT"},{"location":"api/Files/text_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/text_8h/#enum-appendmethod","title":"enum AppendMethod","text":"Enumerator Value Description CCGraphic_AsciiTextItem_AppendContinously CCGraphic_AsciiTextItem_AppendNextLine CCGraphic_AsciiTextItem_RequestOldPoint"},{"location":"api/Files/text_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text_8h/#function-cfbdgraphic_inittext","title":"function CFBDGraphic_InitText","text":"<pre><code>void CFBDGraphic_InitText(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point tl_point,\n    CFBDGraphicSize textHandleSize,\n    Ascii_Font_Size text_size\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settext","title":"function CFBDGraphic_SetText","text":"<pre><code>static inline void CFBDGraphic_SetText(\n    CFBDGraphic_Text * item,\n    char * text\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settexttlpointpoint","title":"function CFBDGraphic_SetTextTLPointPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextTLPointPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_settextindexedpoint","title":"function CFBDGraphic_SetTextIndexedPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextIndexedPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-ccgraphicwidget_asciitextitem_relocate","title":"function CCGraphicWidget_AsciiTextItem_relocate","text":"<pre><code>static inline void CCGraphicWidget_AsciiTextItem_relocate(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize textHandleSize\n)\n</code></pre>"},{"location":"api/Files/text_8h/#function-cfbdgraphic_drawtext","title":"function CFBDGraphic_DrawText","text":"<pre><code>CFBDGraphic_Point CFBDGraphic_DrawText(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Text * item,\n    AppendMethod method\n)\n</code></pre>"},{"location":"api/Files/text_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/text_8h/#define-cfbdgraphic_text_padding_width","title":"define CFBDGraphic_TEXT_PADDING_WIDTH","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n</code></pre>"},{"location":"api/Files/text_8h/#define-cfbdgraphic_text_padding_height","title":"define CFBDGraphic_TEXT_PADDING_HEIGHT","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n</code></pre>"},{"location":"api/Files/text_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"text_config.h\"\n\n#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n\ntypedef struct\n{\n    char* sources_borrowed;\n    CFBDGraphic_Point tl_point;\n    CFBDGraphic_Point indexed_point;\n    CFBDGraphicSize TexthandleSize;\n    Ascii_Font_Size font_size;\n    CFBDGraphicRect text_bounding_rect;\n} CFBDGraphic_Text;\n\ntypedef enum\n{\n    CCGraphic_AsciiTextItem_AppendContinously,\n    CCGraphic_AsciiTextItem_AppendNextLine,\n    CCGraphic_AsciiTextItem_RequestOldPoint\n} AppendMethod;\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size);\n\nstatic inline void CFBDGraphic_SetText(CFBDGraphic_Text* item, char* text)\n{\n    item-&gt;sources_borrowed = text;\n}\n\nstatic inline void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;tl_point = *p;\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text* item,\n                                                          CFBDGraphic_Point* tl_point,\n                                                          CFBDGraphicSize textHandleSize)\n{\n    item-&gt;tl_point = *tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n}\n\nCFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle,\n                                       CFBDGraphic_Text* item,\n                                       AppendMethod method);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/text__config_8c/","title":"lib/graphic/widget/text_config.c","text":""},{"location":"api/Files/text__config_8c/#functions","title":"Functions","text":"Name uint8_t * __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)Selects the font data array based on the specified font size. CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)"},{"location":"api/Files/text__config_8c/#attributes","title":"Attributes","text":"Name const uint8_t[][16] ascii8x16_sources const uint8_t[][6] ascii6x8_sources"},{"location":"api/Files/text__config_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text__config_8c/#function-__select_from_ascii_font_size","title":"function __select_from_ascii_font_size","text":"<pre><code>uint8_t * __select_from_ascii_font_size(\n    const Ascii_Font_Size s,\n    const char ch\n)\n</code></pre> <p>Selects the font data array based on the specified font size. </p> <p>Parameters: </p> <ul> <li>s The font size to be selected (from the <code>Ascii_Font_Size</code> enum). </li> <li>ch the character wanna display </li> </ul> <p>Return: A pointer to the font data array corresponding to the selected font size. If an invalid font size is passed, the function returns UNSUPPORTIVE_FONT_SOURCE. </p> <p>This function receives an <code>Ascii_Font_Size</code> value and returns a pointer to the corresponding font data array. The function helps in selecting the appropriate font data for display purposes, allowing for different font sizes (e.g., 8x16, 6x8, etc.).</p>"},{"location":"api/Files/text__config_8c/#function-__fetch_font_size","title":"function __fetch_font_size","text":"<pre><code>CFBDGraphicSize __fetch_font_size(\n    const Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text__config_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/text__config_8c/#variable-ascii8x16_sources","title":"variable ascii8x16_sources","text":"<pre><code>const uint8_t[][16] ascii8x16_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#variable-ascii6x8_sources","title":"variable ascii6x8_sources","text":"<pre><code>const uint8_t[][6] ascii6x8_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text_config.h\"\n\n\nextern const uint8_t ascii8x16_sources[][16];\nextern const uint8_t ascii6x8_sources[][6];\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)\n{\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            return (uint8_t*) (ascii6x8_sources[ch - ' ']);\n#endif\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            return (uint8_t*) (ascii8x16_sources[ch - ' ']);\n#endif\n        /*\n            To programmers, if new ascii like sources is\n            registered, please implement follows\n        */\n        default:\n            return UNSUPPORTIVE_FONT_SOURCE;\n    }\n}\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)\n{\n    CFBDGraphicSize size = {0, 0};\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            size.height = 8;\n            size.width = 6;\n            break;\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            size.height = 16;\n            size.width = 8;\n            break;\n#endif\n        default:\n            break;\n    }\n    return size;\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/text__config_8h/","title":"lib/graphic/widget/text_config.h","text":""},{"location":"api/Files/text__config_8h/#types","title":"Types","text":"Name enum Ascii_Font_Size enum Unicode_Font_Size"},{"location":"api/Files/text__config_8h/#functions","title":"Functions","text":"Name uint8_t * __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)Selects the font data array based on the specified font size. CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)"},{"location":"api/Files/text__config_8h/#defines","title":"Defines","text":"Name UNSUPPORTIVE_FONT_SOURCE"},{"location":"api/Files/text__config_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/text__config_8h/#enum-ascii_font_size","title":"enum Ascii_Font_Size","text":"Enumerator Value Description NO_ASCII_SIZE"},{"location":"api/Files/text__config_8h/#enum-unicode_font_size","title":"enum Unicode_Font_Size","text":"Enumerator Value Description Unicode_16x16"},{"location":"api/Files/text__config_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text__config_8h/#function-__select_from_ascii_font_size","title":"function __select_from_ascii_font_size","text":"<pre><code>uint8_t * __select_from_ascii_font_size(\n    const Ascii_Font_Size s,\n    const char ch\n)\n</code></pre> <p>Selects the font data array based on the specified font size. </p> <p>Parameters: </p> <ul> <li>s The font size to be selected (from the <code>Ascii_Font_Size</code> enum). </li> <li>ch the character wanna display </li> </ul> <p>Return: A pointer to the font data array corresponding to the selected font size. If an invalid font size is passed, the function returns UNSUPPORTIVE_FONT_SOURCE. </p> <p>This function receives an <code>Ascii_Font_Size</code> value and returns a pointer to the corresponding font data array. The function helps in selecting the appropriate font data for display purposes, allowing for different font sizes (e.g., 8x16, 6x8, etc.).</p>"},{"location":"api/Files/text__config_8h/#function-__fetch_font_size","title":"function __fetch_font_size","text":"<pre><code>CFBDGraphicSize __fetch_font_size(\n    const Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/text__config_8h/#define-unsupportive_font_source","title":"define UNSUPPORTIVE_FONT_SOURCE","text":"<pre><code>#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n</code></pre>"},{"location":"api/Files/text__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/size.h\"\n#include \"resource/config.h\"\n\n/*\n    current version we only support\n    6x8 and 8x16. to register more, u should\n    provide the source and implement the functions\n*/\ntypedef enum\n{\n#if ENABLE_ASCII_6x8_SOURCES\n    ASCII_6x8,\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n    ASCII_8x16,\n#endif\n    NO_ASCII_SIZE\n} Ascii_Font_Size;\n\ntypedef enum\n{\n    Unicode_16x16\n} Unicode_Font_Size;\n\n#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch);\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Files/triangle_8c/","title":"triangle.c","text":""},{"location":"api/Files/triangle_8c/#functions","title":"Functions","text":"Name int16_t find_int16min(int16_t * vals, int16_t size) int16_t find_int16max(int16_t * vals, int16_t size) void clearBound(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void update_requests(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) uint8_t __pvt_is_in_triangle(int16_t * triangles_x, int16_t * triangles_y, PointBaseType x, PointBaseType y)"},{"location":"api/Files/triangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/triangle_8c/#function-find_int16min","title":"function find_int16min","text":"<pre><code>static inline int16_t find_int16min(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-find_int16max","title":"function find_int16max","text":"<pre><code>static inline int16_t find_int16max(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static void clearBound(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-update_requests","title":"function update_requests","text":"<pre><code>static void update_requests(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-__pvt_is_in_triangle","title":"function __pvt_is_in_triangle","text":"<pre><code>static uint8_t __pvt_is_in_triangle(\n    int16_t * triangles_x,\n    int16_t * triangles_y,\n    PointBaseType x,\n    PointBaseType y\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"triangle.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"line.h\"\n#include \"point.h\"\n\nstatic inline int16_t find_int16min(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &lt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic inline int16_t find_int16max(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &gt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic void clearBound(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;clear_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void update_requests(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;update_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nvoid CCGraphic_DrawTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBDGraphic_Line line;\n    line.p_left = triangle-&gt;p1;\n    line.p_right = triangle-&gt;p2;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p2;\n    line.p_right = triangle-&gt;p3;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p1;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n\nstatic uint8_t\n__pvt_is_in_triangle(int16_t* triangles_x, int16_t* triangles_y, PointBaseType x, PointBaseType y)\n{\n    uint8_t is_in = 0;\n    /* https://wrfranklin.org/Research/Short_Notes/pnpoly.html */\n    for (uint8_t i = 0, j = 2; i &lt; 3; j = i++) {\n        if (((triangles_y[i] &gt; y) != (triangles_y[j] &gt; y)) &amp;&amp;\n            (x &lt; (triangles_x[j] - triangles_x[i]) * (y - triangles_y[i]) /\n                                 (triangles_y[j] - triangles_y[i]) +\n                         triangles_x[i])) {\n            is_in = !is_in;\n        }\n    }\n    return is_in;\n}\n\nvoid CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handle-&gt;ops-&gt;setPixel;\n\n    int16_t triangles_x[] = {triangle-&gt;p1.x, triangle-&gt;p2.x, triangle-&gt;p3.x};\n\n    int16_t triangles_y[] = {triangle-&gt;p1.y, triangle-&gt;p2.y, triangle-&gt;p3.y};\n\n    int16_t minX = find_int16min(triangles_x, 3);\n    int16_t minY = find_int16min(triangles_y, 3);\n\n    int16_t maxX = find_int16max(triangles_x, 3);\n    int16_t maxY = find_int16max(triangles_y, 3);\n\n    for (int16_t i = minX; i &lt; maxX; i++) {\n        for (int16_t j = minY; j &lt; maxY; j++) {\n            if (__pvt_is_in_triangle(triangles_x, triangles_y, i, j)) {\n                setPixel(handle, i, j);\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Application__Module/","title":"Application Management","text":"<p>Application-level bootstrap and clock providers.  More...</p>"},{"location":"api/Modules/group__Application__Module/#files","title":"Files","text":"Name lib/application/app.h Application descriptor and clock/boot provider interfaces."},{"location":"api/Modules/group__Application__Module/#classes","title":"Classes","text":"Name struct __CFBDApplication Application descriptor."},{"location":"api/Modules/group__Application__Module/#types","title":"Types","text":"Name typedef uint32_t(*)(void) CFBD_ClockFreqProvider Function returning the system clock frequency in Hertz. typedef uint32_t(*)(void) CFBD_ClockTickProvider Function returning a monotonically increasing tick value. typedef struct __CFBDApplication CFBDApplication Application descriptor."},{"location":"api/Modules/group__Application__Module/#functions","title":"Functions","text":"Name CFBDBootTuple * CFBD_AppBootMaker(void )Return a pointer to a boot tuple table for the application. CFBD_ClockFreqProvider CFBD_AppClockProvider(void )Return the application's clock frequency provider. CFBD_ClockTickProvider CFBD_AppTickProvider(void )Return the application's tick provider. CFBDApplication * getApp(CFBD_Bool request_auto_boot)Obtain the global <code>CFBDApplication</code> instance."},{"location":"api/Modules/group__Application__Module/#detailed-description","title":"Detailed Description","text":"<p>Application-level bootstrap and clock providers. </p> <p>Provides the core application descriptor and helper functions for managing application initialization and timing services. This module allows applications to register their bootstrap sequences and clock providers with the CFBD framework. </p>"},{"location":"api/Modules/group__Application__Module/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Application__Module/#typedef-cfbd_clockfreqprovider","title":"typedef CFBD_ClockFreqProvider","text":"<pre><code>CFBD_ClockFreqProvider;\n</code></pre> <p>Function returning the system clock frequency in Hertz. </p> <p>See: </p> <ul> <li>CFBD_ClockTickProvider</li> <li>CFBDApplication</li> </ul> <p>Return: uint32_t Current clock frequency in Hertz (Hz).</p> <p>Par: Example</p> <pre><code>uint32_t stm32_clock_freq(void) {\n    // STM32F103 typically runs at 72 MHz\n    return 72000000;\n}\n</code></pre> <p>Provider returns the current core/system clock frequency in Hz. This value is used by timing helpers and drivers to convert between ticks and wall-clock time. If the platform supports dynamic clock scaling, the provider should return the up-to-date frequency when called.</p> <p>Implementations must ensure the returned value is accurate and stable for use in timing-critical calculations. Typical implementations read clock configuration registers or return a hardcoded constant.</p>"},{"location":"api/Modules/group__Application__Module/#typedef-cfbd_clocktickprovider","title":"typedef CFBD_ClockTickProvider","text":"<pre><code>CFBD_ClockTickProvider;\n</code></pre> <p>Function returning a monotonically increasing tick value. </p> <p>See: </p> <ul> <li>CFBD_ClockFreqProvider</li> <li>CFBDApplication</li> </ul> <p>Return: uint32_t Current tick counter value. Should increment steadily and wrap around gracefully.</p> <p>Par: Example</p> <pre><code>extern volatile uint32_t g_systick_count;\n\nuint32_t get_systick(void) {\n    return g_systick_count;\n}\n</code></pre> <p>Provider returns a tick counter value (units are implementation defined, typically processor ticks or a hardware timer count). The value should be monotonically increasing and suitable for measuring short intervals when combined with the frequency provider.</p> <p>Common implementations include:</p> <ul> <li>System timer (SysTick) count for ARM Cortex-M processors</li> <li>Hardware timer register values</li> <li>Software tick counters incremented by interrupts</li> </ul>"},{"location":"api/Modules/group__Application__Module/#typedef-cfbdapplication","title":"typedef CFBDApplication","text":"<pre><code>typedef struct __CFBDApplication CFBDApplication;\n</code></pre> <p>Application descriptor. </p> <p>See: </p> <ul> <li>getApp()</li> <li>CFBD_AppBootMaker()</li> <li>CFBD_AppClockProvider()</li> <li>CFBD_AppTickProvider()</li> </ul> <p>Aggregates the bootstrap function and clock providers for an application. Typical usage is to expose a single application instance via <code>[getApp()](Modules/group__Application__Module.md#function-getapp)</code> that other framework components query to obtain boot actions and timing sources.</p> <p>The application descriptor serves as a central registry for all application-level services, allowing framework components to access initialization routines and timing information without requiring direct coupling to application code.</p>"},{"location":"api/Modules/group__Application__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Application__Module/#function-cfbd_appbootmaker","title":"function CFBD_AppBootMaker","text":"<pre><code>CFBDBootTuple * CFBD_AppBootMaker(\n    void \n)\n</code></pre> <p>Return a pointer to a boot tuple table for the application. </p> <p>See: </p> <ul> <li>CFBDBootTuple</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Return: CFBDBootTuple* Pointer to the boot tuple table or NULL.</p> <p>The returned pointer typically refers to a static array of <code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code> entries describing ordered bootstrap actions. The caller must not attempt to free the returned pointer. Return value may be NULL if the application exposes no explicit boot table.</p> <p>The boot table provides a declarative way to specify initialization sequences without requiring explicit function calls.</p>"},{"location":"api/Modules/group__Application__Module/#function-cfbd_appclockprovider","title":"function CFBD_AppClockProvider","text":"<pre><code>CFBD_ClockFreqProvider CFBD_AppClockProvider(\n    void \n)\n</code></pre> <p>Return the application's clock frequency provider. </p> <p>See: </p> <ul> <li>CFBD_ClockFreqProvider</li> <li>getApp()</li> </ul> <p>Return: CFBD_ClockFreqProvider Function pointer returning system frequency in Hz, or NULL if not provided.</p> <p>Retrieves the frequency provider function registered with the application descriptor. This allows framework components to query the system clock frequency without direct application coupling.</p>"},{"location":"api/Modules/group__Application__Module/#function-cfbd_apptickprovider","title":"function CFBD_AppTickProvider","text":"<pre><code>CFBD_ClockTickProvider CFBD_AppTickProvider(\n    void \n)\n</code></pre> <p>Return the application's tick provider. </p> <p>See: </p> <ul> <li>CFBD_ClockTickProvider</li> <li>getApp()</li> </ul> <p>Return: CFBD_ClockTickProvider Function pointer returning current tick count, or NULL if not provided.</p> <p>Retrieves the tick provider function registered with the application descriptor. This allows framework components to measure time intervals without direct application coupling.</p>"},{"location":"api/Modules/group__Application__Module/#function-getapp","title":"function getApp","text":"<pre><code>CFBDApplication * getApp(\n    CFBD_Bool request_auto_boot\n)\n</code></pre> <p>Obtain the global <code>CFBDApplication</code> instance. </p> <p>Parameters: </p> <ul> <li>request_auto_boot If <code>CFBD_TRUE</code>, request that the application performs any auto-boot actions before returning (implementation-defined). If <code>CFBD_FALSE</code>, returns the descriptor without triggering bootstrap.</li> </ul> <p>See: </p> <ul> <li>CFBDApplication</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Return: CFBDApplication* Pointer to the application descriptor, or NULL if no application is registered.</p> <p>Par: </p> <ul> <li>Example: Get application with automatic bootstrap</li> </ul> <p><pre><code>CFBDApplication* app = getApp(CFBD_TRUE);\nif (app &amp;&amp; app-&gt;freq_provider) {\n    uint32_t freq = app-&gt;freq_provider();\n}\n</code></pre>   * Example: Get application descriptor without bootstrap</p> <pre><code>CFBDApplication* app = getApp(CFBD_FALSE);\n// Manually call bootstrap if needed\nif (app &amp;&amp; app-&gt;selfBootFunc) {\n    app-&gt;selfBootFunc(app, app-&gt;bootargs);\n}\n</code></pre> <p>Returns a pointer to the global application descriptor. If <code>request_auto_boot</code> is true the function may trigger automatic application bootstrap actions according to the platform policy.</p> <p>This is the primary entry point for framework components to access application-level services.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Arc__Module/","title":"Arc Drawing","text":""},{"location":"api/Modules/group__Arc__Module/#classes","title":"Classes","text":"Name struct CCGraphic_Arc Represents a circular arc defined by center, radius, and angular range. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__BaseHelpers__Module/","title":"Graphic Base Helpers","text":"<p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__Boot/","title":"Boot","text":"<p>Minimal boot/bootstrap types and helpers.  More...</p>"},{"location":"api/Modules/group__CFBD__Boot/#classes","title":"Classes","text":"Name struct CFBDBootTuple"},{"location":"api/Modules/group__CFBD__Boot/#types","title":"Types","text":"Name typedef void * CFBD_BootArgs Opaque pointer to bootstrap-specific arguments. typedef CFBD_Bool(*)(CFBD_BootArgs args) CFBD_BootStrapFunc Function-pointer type for bootstrap/startup routines."},{"location":"api/Modules/group__CFBD__Boot/#detailed-description","title":"Detailed Description","text":"<p>Minimal boot/bootstrap types and helpers. </p> <p>Types used to describe and invoke bootstrap/startup routines.</p> <p>The CFBD_Boot module provides a generic, extensible mechanism for managing application startup sequences. It decouples initialization logic from the main application, enabling a clean modular architecture where each subsystem (hardware, drivers, services) registers its own bootstrap function. </p>"},{"location":"api/Modules/group__CFBD__Boot/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__CFBD__Boot/#typedef-cfbd_bootargs","title":"typedef CFBD_BootArgs","text":"<pre><code>CFBD_BootArgs;\n</code></pre> <p>Opaque pointer to bootstrap-specific arguments. </p> <p>See: </p> <ul> <li>CFBDBootTuple</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Since: 0.1 </p> <p>Par: Example - Basic Argument Casting</p> <pre><code>// Define a boot-time configuration structure\nstruct MyBootConfig {\n    uint32_t clock_frequency;\n    uint8_t device_id;\n} my_config = { 72000000, 0x01 };\n\n// Cast to generic CFBD_BootArgs\nCFBD_BootArgs args = (CFBD_BootArgs)&amp;my_config;\n\n// In the bootstrap function, cast back to concrete type\nCFBD_Bool my_bootstrap(CFBD_BootArgs args) {\n    struct MyBootConfig *cfg = (struct MyBootConfig *)args;\n    initialize_clock(cfg-&gt;clock_frequency);\n    return CFBD_True;\n}\n</code></pre> <p>Bootstrap argument containers are intentionally typedeffed to <code>void*</code> to keep the interface generic. Callers should cast to a concrete structure type known to both the caller and the bootstrap function.</p>"},{"location":"api/Modules/group__CFBD__Boot/#typedef-cfbd_bootstrapfunc","title":"typedef CFBD_BootStrapFunc","text":"<pre><code>CFBD_BootStrapFunc;\n</code></pre> <p>Function-pointer type for bootstrap/startup routines. </p> <p>Parameters: </p> <ul> <li>args Opaque pointer to bootstrap-specific arguments (may be NULL). </li> </ul> <p>See: </p> <ul> <li>CFBD_BootArgs</li> <li>CFBDBootTuple</li> </ul> <p>Return: CFBD_Bool Return <code>CFBD_True</code> on success, <code>CFBD_False</code> on failure.</p> <p>Since: 0.1 </p> <p>Note: The exact concrete type behind <code>CFBD_BootArgs</code> is application specific. Use <code>@ref CFBD_BootArgs</code> casts to access fields.</p> <p>Par: </p> <ul> <li>Example - Simple Bootstrap Function</li> </ul> <p><pre><code>// Hardware initialization bootstrap function\nCFBD_Bool boot_hardware(CFBD_BootArgs args) {\n    struct HwConfig *hw_cfg = (struct HwConfig *)args;\n\n    // Initialize clock\n    if (!init_system_clock(hw_cfg-&gt;clock_freq)) {\n        return CFBD_False;\n    }\n\n    // Initialize GPIO\n    if (!init_gpio_subsystem(hw_cfg-&gt;gpio_config)) {\n        return CFBD_False;\n    }\n\n    return CFBD_True;\n}\n</code></pre>   * Example - Bootstrap Function with Null Arguments</p> <pre><code>// Application initialization that doesn't need configuration\nCFBD_Bool boot_application(CFBD_BootArgs args) {\n    (void)args;  // Unused\n\n    app_init_subsystems();\n    app_start_scheduler();\n\n    return CFBD_True;\n}\n</code></pre> <p>Bootstrap functions receive a single opaque argument (<code>CFBD_BootArgs</code>) and return a <code>CFBD_Bool</code> indicating success (<code>CFBD_True</code>) or failure (<code>CFBD_False</code>). Implementations should perform any necessary initialization and return quickly. Long-running tasks or blocking operations should be avoided unless explicitly required by the platform.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__Core/","title":"Core Definitions","text":"<p>Small portable types and macros used throughout the project.  More...</p>"},{"location":"api/Modules/group__CFBD__Core/#types","title":"Types","text":"Name typedef uint8_t CFBD_Bool Minimal boolean type (1 byte). typedef CFBD_Bool(*)(void *self_handle, void *args) SelfInitFunc Generic initialization callback signature for objects/components. typedef void(*)(void *args) PlainFunc Generic callback taking a single opaque argument and returning void."},{"location":"api/Modules/group__CFBD__Core/#defines","title":"Defines","text":"Name CFBD_FALSE Integer value representing boolean false. CFBD_TRUE Integer value representing boolean true."},{"location":"api/Modules/group__CFBD__Core/#detailed-description","title":"Detailed Description","text":"<p>Small portable types and macros used throughout the project. </p> <p>Provides fundamental building blocks for the CFBD framework including platform-independent boolean type, callback function signatures, and related constants. These definitions are designed to be included widely across platform and application code without introducing unnecessary dependencies. </p>"},{"location":"api/Modules/group__CFBD__Core/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__CFBD__Core/#typedef-cfbd_bool","title":"typedef CFBD_Bool","text":"<pre><code>CFBD_Bool;\n</code></pre> <p>Minimal boolean type (1 byte). </p> <p>See: </p> <ul> <li>CFBD_TRUE</li> <li>CFBD_FALSE</li> </ul> <p>Uses an unsigned 8-bit integer to represent boolean values. The explicit width helps keep ABI and header dependencies predictable on constrained targets. This type is portable across different platforms and compilers, making it suitable for use in headers that must be included in diverse contexts.</p>"},{"location":"api/Modules/group__CFBD__Core/#typedef-selfinitfunc","title":"typedef SelfInitFunc","text":"<pre><code>SelfInitFunc;\n</code></pre> <p>Generic initialization callback signature for objects/components. </p> <p>Parameters: </p> <ul> <li>self_handle Pointer to the instance being initialized (may be NULL). Typically cast to the specific component type. </li> <li>args Opaque pointer to initialization parameters (may be NULL). Interpretation depends on the component implementation. </li> </ul> <p>See: </p> <ul> <li>CFBD_Bool</li> <li>PlainFunc</li> </ul> <p>Return: CFBD_Bool <code>CFBD_TRUE</code> on successful initialization, <code>CFBD_FALSE</code> if initialization failed.</p> <p>Par: Example</p> <pre><code>CFBD_Bool initialize_component(void* self_handle, void* args) {\n    // Cast to actual type\n    ComponentState* component = (ComponentState*)self_handle;\n    ComponentInitArgs* init_args = (ComponentInitArgs*)args;\n\n    if (!component || !init_args) {\n        return CFBD_FALSE;\n    }\n\n    // Perform initialization\n    component-&gt;initialized = CFBD_TRUE;\n    return CFBD_TRUE;\n}\n</code></pre> <p>Initialization callbacks receive an opaque <code>self_handle</code> which is typically a pointer to the object being initialized, and an opaque <code>args</code> pointer for passing platform or application-specific data. Implementations should return <code>CFBD_TRUE</code> on successful initialization or <code>CFBD_FALSE</code> otherwise.</p> <p>This function pointer type enables a plugin-like architecture where components can be initialized through a common interface without requiring type knowledge at call sites.</p>"},{"location":"api/Modules/group__CFBD__Core/#typedef-plainfunc","title":"typedef PlainFunc","text":"<pre><code>PlainFunc;\n</code></pre> <p>Generic callback taking a single opaque argument and returning void. </p> <p>Parameters: </p> <ul> <li>args Opaque pointer passed to the callback (may be NULL). Interpretation and lifetime ownership is defined by the code that registers and invokes the callback.</li> </ul> <p>See: SelfInitFunc</p> <p>Par: Example</p> <pre><code>void on_timer_tick(void* args) {\n    TimerContext* ctx = (TimerContext*)args;\n    ctx-&gt;tick_count++;\n}\n\n// Register callback\nPlainFunc tick_handler = on_timer_tick;\ntick_handler(timer_context);\n</code></pre> <p>Useful for simple callbacks, event handlers or deferred work items where no return status is required. This function pointer type enables flexible callback registration and invocation without type coupling.</p>"},{"location":"api/Modules/group__CFBD__Core/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__Core/#define-cfbd_false","title":"define CFBD_FALSE","text":"<pre><code>#define CFBD_FALSE (0)\n</code></pre> <p>Integer value representing boolean false. </p> <p>See: CFBD_Bool</p> <p>This macro expands to 0, the standard false value. </p>"},{"location":"api/Modules/group__CFBD__Core/#define-cfbd_true","title":"define CFBD_TRUE","text":"<pre><code>#define CFBD_TRUE (1)\n</code></pre> <p>Integer value representing boolean true. </p> <p>See: CFBD_Bool</p> <p>This macro expands to 1, the standard true value. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Backend/","title":"I2C Backend Implementation","text":"<p>Backend implementation interface for I2C drivers.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Backend/#classes","title":"Classes","text":"Name struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus."},{"location":"api/Modules/group__CFBD__IIC__Backend/#detailed-description","title":"Detailed Description","text":"<p>Backend implementation interface for I2C drivers. </p> <p>Device-specific implementations must provide a CFBD_I2COperations table and initialize CFBD_I2CHandle with appropriate values. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/","title":"I2C/IIC Error Codes","text":"<p>Standard error codes for I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#defines","title":"Defines","text":"Name I2C_OK Success return code. I2C_ERR_TIMEOUT Operation timed out (-ETIMEDOUT). I2C_ERR_NACK Protocol error / NACK received (-EPROTO). I2C_ERR_BUSY Bus or peripheral busy (-EBUSY). I2C_ERR_IO Generic I/O error (-EIO). I2C_ERR_INVAL Invalid argument supplied (-EINVAL)."},{"location":"api/Modules/group__CFBD__IIC__Error/#detailed-description","title":"Detailed Description","text":"<p>Standard error codes for I2C operations. </p> <p>This module provides a set of standard error codes for I2C/IIC operations in the CFBD driver suite. All error codes follow POSIX errno conventions. </p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_ok","title":"define I2C_OK","text":"<pre><code>#define I2C_OK 0\n</code></pre> <p>Success return code. </p> <p>Par: Example</p> <pre><code>int status = CFBD_I2CTransfer(bus, msg, count, timeout);\nif (status == I2C_OK) {\n    // Process received data\n    process_data(msg[0].buf, msg[0].len);\n}\n</code></pre> <p>Returned when an I2C operation completes successfully without errors. All subsequent device states are valid and the operation result (if any) is reliable.</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_timeout","title":"define I2C_ERR_TIMEOUT","text":"<pre><code>#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n</code></pre> <p>Operation timed out (-ETIMEDOUT). </p> <p>Par: Recovery Strategy</p> <pre><code>if (status == I2C_ERR_TIMEOUT) {\n    // Option 1: Attempt bus recovery\n    CFBD_I2CRecoverBus(bus);\n\n    // Option 2: Retry with extended timeout\n    delay_ms(50);\n    status = CFBD_I2CTransfer(bus, msg, count, 2000);\n}\n</code></pre> <p>The I2C operation did not complete within the specified timeout period. This typically indicates:</p> <ul> <li>Clock line held low by slave (clock stretching exceeded timeout)</li> <li>No acknowledgment within expected time window</li> <li>Bus unresponsive for entire timeout duration</li> </ul>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_nack","title":"define I2C_ERR_NACK","text":"<pre><code>#define I2C_ERR_NACK -121 /* -EPROTO (nack) */\n</code></pre> <p>Protocol error / NACK received (-EPROTO). </p> <p>Par: Troubleshooting</p> <pre><code>if (status == I2C_ERR_NACK) {\n    // Check if device is ready\n    status = CFBD_I2CTransferIsDeviceReady(bus, addr, 5, 100);\n\n    if (status != I2C_OK) {\n        // Device not present or not responding\n        return -1;  // Abort operation\n    }\n}\n</code></pre> <p>The addressed slave device did not acknowledge the address or data byte. This indicates:</p> <ul> <li>Device not present at specified address</li> <li>Device in error state or not responding</li> <li>Address selection error</li> </ul>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_busy","title":"define I2C_ERR_BUSY","text":"<pre><code>#define I2C_ERR_BUSY -16 /* -EBUSY */\n</code></pre> <p>Bus or peripheral busy (-EBUSY). </p> <p>Par: Recommended Action</p> <pre><code>if (status == I2C_ERR_BUSY) {\n    // Small delay and retry\n    delay_ms(1);\n    status = CFBD_I2CTransfer(bus, msg, count, timeout);\n}\n</code></pre> <p>The I2C bus is currently occupied by another master or the peripheral cannot accept new commands. This is typically a transient condition.</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_io","title":"define I2C_ERR_IO","text":"<pre><code>#define I2C_ERR_IO -5 /* -EIO */\n</code></pre> <p>Generic I/O error (-EIO). </p> <p>A generic I/O error occurred during the I2C transaction. This may indicate hardware malfunction, disconnected bus, or electrical issues. The specific cause requires platform-specific debugging. </p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_inval","title":"define I2C_ERR_INVAL","text":"<pre><code>#define I2C_ERR_INVAL -22 /* -EINVAL */\n</code></pre> <p>Invalid argument supplied (-EINVAL). </p> <p>Par: Validation Example</p> <pre><code>if (addr &gt; 0x7F) {\n    return I2C_ERR_INVAL;  // 7-bit address out of range\n}\nif (num_messages &lt;= 0 || !messages) {\n    return I2C_ERR_INVAL;  // Invalid message array\n}\n</code></pre> <p>Invalid parameters were passed to the I2C function. Common causes:</p> <ul> <li>NULL handle or message pointer</li> <li>Invalid device address (outside 7-bit range)</li> <li>Zero message count</li> <li>Invalid timeout value</li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/","title":"I2C High-Level Helpers","text":"<p>Convenience functions for common I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#functions","title":"Functions","text":"Name int CFBD_I2CRead(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)High-level helper to read from an I2C device using IORequestParams. int CFBD_I2CWrite(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)High-level helper to write to an I2C device using IORequestParams."},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#detailed-description","title":"Detailed Description","text":"<p>Convenience functions for common I2C operations. </p> <p>Simplify typical read/write patterns with automatic message construction. </p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#function-cfbd_i2cread","title":"function CFBD_I2CRead","text":"<pre><code>int CFBD_I2CRead(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre> <p>High-level helper to read from an I2C device using IORequestParams. </p> <p>Parameters: </p> <ul> <li>handle Pointer to I2C bus handle </li> <li>r Pointer to IORequestParams describing the read operation </li> </ul> <p>Return: int I2C_OK on success or negative error code.</p> <p>Par: Example - EEPROM Read</p> <pre><code>uint8_t buffer[16];\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x50,          // EEPROM address\n    .mem_addr = 0x200,      // Byte offset in EEPROM\n    .mem_addr_size = 2,     // 16-bit address\n    .data = buffer,\n    .len = 16,\n    .timeout_ms = 1000\n};\n\nif (CFBD_I2CRead(bus_handle, &amp;req) == I2C_OK) {\n    // Process 16 bytes from EEPROM address 0x200\n}\n</code></pre> <p>Automatically constructs a read transaction that:</p> <ol> <li>Writes the device memory/register address to the device</li> <li>Reads the requested data from that address</li> </ol>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#function-cfbd_i2cwrite","title":"function CFBD_I2CWrite","text":"<pre><code>int CFBD_I2CWrite(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre> <p>High-level helper to write to an I2C device using IORequestParams. </p> <p>Parameters: </p> <ul> <li>handle Pointer to I2C bus handle </li> <li>r Pointer to IORequestParams describing the write operation </li> </ul> <p>Return: int I2C_OK on success or negative error code.</p> <p>Par: Example - Configuration Write</p> <pre><code>uint8_t config_data[] = { 0xAA, 0xBB, 0xCC };\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x30,\n    .mem_addr = 0x10,       // Register offset\n    .mem_addr_size = 1,\n    .data = config_data,\n    .len = sizeof(config_data),\n    .timeout_ms = 500\n};\n\nint status = CFBD_I2CWrite(bus_handle, &amp;req);\n</code></pre> <p>Constructs a write transaction that sends both the device memory/register address and data in a single I2C transaction.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/","title":"I2C Inline Wrappers","text":"<p>Convenience inline functions for I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#functions","title":"Functions","text":"Name int CFBD_I2CInit(CFBD_I2CHandle * bus)Inline helper to initialize an I2C bus using the backend. int CFBD_I2CDeInit(CFBD_I2CHandle * bus)Inline helper to deinitialize an I2C bus. int CFBD_I2CTransfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms)Inline wrapper for message transfers. int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms)Check if a device is ready using the backend provider. int CFBD_I2CRecoverBus(CFBD_I2CHandle * bus)Attempt bus recovery using backend hook."},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#detailed-description","title":"Detailed Description","text":"<p>Convenience inline functions for I2C operations. </p> <p>These inline functions wrap backend operations, adding basic validation and NULL-safety checks before delegating to the backend. </p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2cinit","title":"function CFBD_I2CInit","text":"<pre><code>static inline int CFBD_I2CInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Inline helper to initialize an I2C bus using the backend. </p> <p>Parameters: </p> <ul> <li>bus Pointer to I2C handle </li> </ul> <p>Return: int I2C_OK on success or a negative error code.</p> <p>Par: Example</p> <pre><code>CFBD_I2CHandle bus = get_i2c_bus();\nif (CFBD_I2CInit(&amp;bus) != I2C_OK) {\n    handle_init_error();\n}\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2cdeinit","title":"function CFBD_I2CDeInit","text":"<pre><code>static inline int CFBD_I2CDeInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Inline helper to deinitialize an I2C bus. </p> <p>Parameters: </p> <ul> <li>bus Pointer to I2C handle </li> </ul> <p>Return: int I2C_OK on success or a negative error code. </p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2ctransfer","title":"function CFBD_I2CTransfer","text":"<pre><code>static inline int CFBD_I2CTransfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre> <p>Inline wrapper for message transfers. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>msgs Array of I2C messages </li> <li>num Number of messages in array </li> <li>timeout_ms Operation timeout in milliseconds </li> </ul> <p>Return: int I2C_OK on success or a negative error code.</p> <p>Par: Example - Simple Write</p> <pre><code>uint8_t cmd[] = { 0x01, 0x02, 0x03 };\nCFBD_I2C_Message msg = {\n    .addr = 0x50,\n    .flags = 0,  // Write\n    .len = sizeof(cmd),\n    .buf = cmd\n};\n\nint status = CFBD_I2CTransfer(bus, &amp;msg, 1, 1000);\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2ctransferisdeviceready","title":"function CFBD_I2CTransferIsDeviceReady","text":"<pre><code>static inline int CFBD_I2CTransferIsDeviceReady(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre> <p>Check if a device is ready using the backend provider. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>addr 7-bit device address </li> <li>trials Number of probe attempts </li> <li>timeout_ms Per-trial timeout in milliseconds </li> </ul> <p>Return: int I2C_OK if device ready, negative error code otherwise.</p> <p>Par: Example - Device Presence Check</p> <pre><code>// Wait for device to become ready (useful after power-on)\nint status = CFBD_I2CTransferIsDeviceReady(bus, 0x3C, 10, 100);\nif (status == I2C_OK) {\n    // Device is present and responding\n} else if (status == I2C_ERR_NACK) {\n    // Device not responding\n}\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2crecoverbus","title":"function CFBD_I2CRecoverBus","text":"<pre><code>static inline int CFBD_I2CRecoverBus(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Attempt bus recovery using backend hook. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> </ul> <p>Return: int I2C_OK if recovery successful, error code if failed.</p> <p>Par: Example - Stuck Bus Recovery</p> <pre><code>int retry_count = 0;\nint status;\n\ndo {\n    status = CFBD_I2CTransfer(bus, msgs, count, 100);\n    if (status == I2C_OK) {\n        break;\n    }\n\n    if (status == I2C_ERR_TIMEOUT || status == I2C_ERR_IO) {\n        CFBD_I2CRecoverBus(bus);  // Attempt recovery\n        delay_ms(50);\n    }\n} while (++retry_count &lt; 3);\n</code></pre> <p>Call this when transfers are failing persistently. Recovery typically involves toggling SCL, sending dummy clocks, or issuing STOP conditions.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/","title":"OLED Display Cache Configuration","text":"<p>OLED display framebuffer dimensions and settings.  More...</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#defines","title":"Defines","text":"Name CACHED_HEIGHT Cache height in pixels. CACHED_WIDTH Cache width in pixels."},{"location":"api/Modules/group__CFBD__OLED__Cache/#detailed-description","title":"Detailed Description","text":"<p>OLED display framebuffer dimensions and settings. </p> <p>Configures the off-screen pixel cache used by OLED drivers. These constants define the resolution that display drivers must support and the memory layout for pixel operations. </p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_height","title":"define CACHED_HEIGHT","text":"<pre><code>#define CACHED_HEIGHT (8)\n</code></pre> <p>Cache height in pixels. </p> <p>Note: Changing this requires updating all driver code that references display height or page counts.</p> <p>Par: Calculation</p> <p>Actual vertical pixels = CACHED_HEIGHT \u00d7 8 </p> <p>Specifies the vertical dimension of the display cache. In the typical SSD1306 page-based layout, this represents the number of 8-pixel-tall pages. With CACHED_HEIGHT = 8, the actual vertical resolution is 64 pixels (8 pages \u00d7 8 pixels per page).</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_width","title":"define CACHED_WIDTH","text":"<pre><code>#define CACHED_WIDTH (144)\n</code></pre> <p>Cache width in pixels. </p> <p>Note: Changing this requires updating all driver code that handles horizontal pixel operations, boundaries, and wrapping.</p> <p>Par: </p> <ul> <li>Total Memory</li> </ul> <p>Cache size = (CACHED_HEIGHT \u00d7 8 \u00d7 CACHED_WIDTH) / 8 bytes = (64 \u00d7 144) / 8 = 1152 bytes   * Example - Buffer Allocation</p> <pre><code>// Static allocation of OLED cache\nstatic uint8_t oled_cache[CACHED_HEIGHT * CACHED_WIDTH];\n\n// Total memory: 8 * 144 = 1152 bytes\n</code></pre> <p>Specifies the horizontal dimension of the display cache in pixels. With CACHED_WIDTH = 144, the display can show 144 characters at 6 pixels wide, or 128 characters at standard 5-pixel-wide fonts, depending on text rendering implementation.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__CFBD__OLED__Integration/","title":"OLED Display Integration","text":"<p>OLED driver initialization and platform integration.  More...</p>"},{"location":"api/Modules/group__CFBD__OLED__Integration/#classes","title":"Classes","text":"Name struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C."},{"location":"api/Modules/group__CFBD__OLED__Integration/#detailed-description","title":"Detailed Description","text":"<p>OLED driver initialization and platform integration. </p> <p>Provides structures and patterns for integrating OLED displays with platform-specific I2C buses and device configurations. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Circle__Module/","title":"Circle Drawing","text":""},{"location":"api/Modules/group__Circle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicCircle Represents a circle defined by center point and radius. <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Core__Utilities/","title":"Core System Utilities","text":"<p>System-level utilities for error handling and emergency states.  More...</p>"},{"location":"api/Modules/group__Core__Utilities/#files","title":"Files","text":"Name lib/config/ah_no.h Emergency halt helper used when unrecoverable errors occur."},{"location":"api/Modules/group__Core__Utilities/#functions","title":"Functions","text":"Name void CFBD_AH_NO(void )Enter an infinite halt state for unrecoverable errors."},{"location":"api/Modules/group__Core__Utilities/#detailed-description","title":"Detailed Description","text":"<p>System-level utilities for error handling and emergency states. </p> <p>These utilities provide critical functionality for managing system state during error conditions and emergency scenarios. </p>"},{"location":"api/Modules/group__Core__Utilities/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Core__Utilities/#function-cfbd_ah_no","title":"function CFBD_AH_NO","text":"<pre><code>static inline void CFBD_AH_NO(\n    void \n)\n</code></pre> <p>Enter an infinite halt state for unrecoverable errors. </p> <p>See: </p> <ul> <li>CFBD_Bool</li> <li>CFBD_FALSE</li> <li>CFBD_TRUE</li> </ul> <p>Note: Because the function does not return, callers should ensure any required side-effects (flush logs, disable interrupts, etc.) are performed prior to calling.</p> <p>Warning: This is a blocking operation that yields control indefinitely. It should only be called when recovery is impossible.</p> <p>Par: Example</p> <pre><code>#include \"lib/config/ah_no.h\"\n\nvoid critical_init() {\n    if (!hardware_initialized) {\n        // Could log error here before halt\n        CFBD_AH_NO();  // Never returns\n    }\n}\n</code></pre> <p>This function never returns. It is intended to be called from fatal error paths where continuing execution would be unsafe. Callers may optionally perform architecture-specific diagnostic actions (for example writing to a debug console) before invoking this helper.</p> <p>Common use cases:</p> <ul> <li>Null pointer dereference detection</li> <li>Memory allocation failures in critical subsystems</li> <li>Hardware initialization failures</li> <li>Watchdog timer expiration handling</li> <li>Stack corruption detection</li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Ellipse__Module/","title":"Ellipse Drawing","text":""},{"location":"api/Modules/group__Ellipse__Module/#classes","title":"Classes","text":"Name struct CCGraphic_Ellipse Represents an ellipse defined by center point and two radii."},{"location":"api/Modules/group__Ellipse__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice * device, CCGraphic_Ellipse * ellipse) void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice * device, CCGraphic_Ellipse * ellipse)"},{"location":"api/Modules/group__Ellipse__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Ellipse__Module/#function-cfbdgraphic_drawellipse","title":"function CFBDGraphic_DrawEllipse","text":"<pre><code>void CFBDGraphic_DrawEllipse(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre>"},{"location":"api/Modules/group__Ellipse__Module/#function-cfbdgraphic_drawfilledellipse","title":"function CFBDGraphic_DrawFilledEllipse","text":"<pre><code>void CFBDGraphic_DrawFilledEllipse(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Ellipse * ellipse\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Line__Module/","title":"Line Drawing","text":""},{"location":"api/Modules/group__Line__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Line Represents a line segment defined by two endpoints."},{"location":"api/Modules/group__Line__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawLine(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Modules/group__Line__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Line__Module/#function-cfbdgraphic_drawline","title":"function CFBDGraphic_DrawLine","text":"<pre><code>void CFBDGraphic_DrawLine(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__OLED/","title":"OLED Display Driver","text":"<p>More...</p>"},{"location":"api/Modules/group__OLED/#modules","title":"Modules","text":"Name OLED Backend Implementations Backend transport implementations (I2C, SPI) for OLED drivers. OLED Device Interface Device-specific descriptors and configurations for OLED drivers."},{"location":"api/Modules/group__OLED/#namespaces","title":"Namespaces","text":"Name CFBD::OLED OLED display driver subsystem *."},{"location":"api/Modules/group__OLED/#detailed-description","title":"Detailed Description","text":"<p>See: </p> <ul> <li>driver/device/device_interface.hfor device descriptor interface </li> <li>driver/backend/oled_iic.hfor I2C backend initialization </li> <li>driver/device/ssd1306/ssd1306.hfor SSD1306 implementation </li> <li>driver/device/ssd1309/ssd1309.hfor SSD1309 implementation </li> </ul> <p>Version: 0.1 </p> <p>Date: 2026-01-09</p> <p>This module defines the core OLED subsystem API: the generic CFBD_OLED object, operation table (CFBD_OLEDOperations), and supporting types used throughout the driver ecosystem. Concrete device drivers (SSD1306, SSD1309, etc.) implement and populate the operation table to provide a uniform API to application code.</p> <p>The module provides:</p> <ul> <li>Device abstraction via CFBD_OLED structure</li> <li>Operation tables for rendering, updates, and device management</li> <li>Transport-agnostic driver type selection (I2C or SPI)</li> <li>Query interface for device capabilities</li> <li>Area-based and frame-based operations</li> </ul> <p>Application code should interact primarily through:</p> <ul> <li>CFBD_GetOLEDHandle() for device initialization</li> <li>Operations in the ops table for rendering (setPixel, setArea, update, etc.)</li> <li>Query operations for device properties (resolution, RGB support)</li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__OLED__Backend/","title":"OLED Backend Implementations","text":"<p>Module: OLED Display Driver</p> <p>Backend transport implementations (I2C, SPI) for OLED drivers.  More...</p>"},{"location":"api/Modules/group__OLED__Backend/#files","title":"Files","text":"Name lib/oled/driver/backend/oled_iic.h I2C-backed OLED driver initialization interface."},{"location":"api/Modules/group__OLED__Backend/#functions","title":"Functions","text":"Name void CFBD_OLED_IICInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle)"},{"location":"api/Modules/group__OLED__Backend/#detailed-description","title":"Detailed Description","text":"<p>Backend transport implementations (I2C, SPI) for OLED drivers. </p> <p>This group contains transport-specific implementations for communicating with OLED devices. Each backend (I2C, SPI) provides initialization routines to wire transport parameters with the generic OLED driver.</p> <p>Backends must handle:</p> <ul> <li>Device address/chip-select configuration</li> <li>Transport handle binding</li> <li>Asynchronous transaction notifications</li> <li>Error handling and retry logic<ul> <li> <ul> <li>Backend implementation organization</li> </ul> </li> <li> <ul> <li>Transport abstraction documentation</li> </ul> </li> <li> <ul> <li>Function Documentation:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_IICInit(): Complete I2C initialization with:</li> </ul> </li> <li> <ul> <li>Parameter descriptions</li> </ul> </li> <li> <ul> <li>Step-by-step initialization flow</li> </ul> </li> <li> <ul> <li>Complete working example</li> </ul> </li> <li> <ul> <li>Thread-safety notes</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#example-supported-property-queries","title":"Example: Supported Property Queries","text":"<ul> <li> <ul> <li>The documentation now clearly specifies all supported property queries:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Query display width</code></li> <li><code>uint16_t width = 0;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);</code></li> <li>``</li> <li><code>// Query display height &lt;br&gt;</code></li> <li><code>uint16_t height = 0;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);</code></li> <li>``</li> <li><code>// Query RGB color support</code></li> <li><code>CFBD_bool is_rgb = CFBD_FALSE;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#expected-doxygen-generation","title":"Expected Doxygen Generation","text":"<ul> <li> <ul> <li>When Doxygen processes these enhanced comments, it will generate:</li> </ul> </li> <li> <ul> <li>Modules Tab:</li> </ul> </li> <li> <ul> <li>OLED - OLED Display Driver (main group)</li> </ul> </li> <li> <ul> <li>OLED_Device - OLED Device Interface</li> </ul> </li> <li> <ul> <li>OLED_Backend - OLED Backend Implementations</li> </ul> </li> <li> <ul> <li>Examples Tab:</li> </ul> </li> <li> <ul> <li>Multiple code examples from </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__OLED__Backend/#function-cfbd_oled_iicinit","title":"function CFBD_OLED_IICInit","text":"<pre><code>void CFBD_OLED_IICInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__OLED__Device/","title":"OLED Device Interface","text":"<p>Module: OLED Display Driver</p> <p>Device-specific descriptors and configurations for OLED drivers.  More...</p>"},{"location":"api/Modules/group__OLED__Device/#files","title":"Files","text":"Name lib/oled/driver/device/device_interface.h Generic device descriptor used by OLED drivers. lib/oled/driver/device/ssd1306/ssd1306.h SSD1306 device-specific descriptor and factory. lib/oled/driver/device/ssd1309/ssd1309.h SSD1309 device-specific descriptor and factory."},{"location":"api/Modules/group__OLED__Device/#classes","title":"Classes","text":"Name struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel."},{"location":"api/Modules/group__OLED__Device/#defines","title":"Defines","text":"Name SSD1309_DRIVER_ADDRESS Default I2C address for SSD1309 devices."},{"location":"api/Modules/group__OLED__Device/#detailed-description","title":"Detailed Description","text":"<p>Device-specific descriptors and configurations for OLED drivers. </p> <p>See: </p> <ul> <li>ssd1306.hfor SSD1306 implementation </li> <li>ssd1309.hfor SSD1309 implementation</li> </ul> <p>This module provides the generic device descriptor interface used by all OLED drivers. It abstracts hardware-specific details into a standardized structure that concrete device implementations (SSD1306, SSD1309, etc.) populate with device-specific data.</p> <p>Device drivers must provide:</p> <ul> <li>Initialization command tables</li> <li>GRAM/frame buffer pointers</li> <li>Communication prefixes (for I2C data/command differentiation)</li> <li> <p>Display geometry information</p> </li> <li> <ul> <li>Hierarchical module organization</li> </ul> </li> <li> <ul> <li>Cross-references to device implementations</li> </ul> </li> <li> <ul> <li>Module relationships</li> </ul> </li> <li> <ul> <li>Structure Documentation:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_DeviceSpecific: Comprehensive documentation with:</li> </ul> </li> <li> <ul> <li>Field descriptions</li> </ul> </li> <li> <ul> <li>Implementation requirements</li> </ul> </li> <li> <ul> <li>Usage examples</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#device-driver-enhancements","title":"Device Driver Enhancements","text":"<ul> <li> <ul> <li>ssd1306.h:</li> </ul> </li> <li> <ul> <li>Extended file documentation with SSD1306 capabilities</li> </ul> </li> <li> <ul> <li>getSSD1306Specific(): Complete factory function documentation</li> </ul> </li> <li> <ul> <li>Usage examples and cross-references</li> </ul> </li> <li> <ul> <li>ssd1309.h:</li> </ul> </li> <li> <ul> <li>Extended file documentation with SSD1309 enhancements</li> </ul> </li> <li> <ul> <li>SSD1309_DRIVER_ADDRESS: Address constant documentation</li> </ul> </li> <li> <ul> <li>getSSD1309Specific(): Comprehensive factory documentation</li> </ul> </li> <li> <ul> <li>Multi-example usage patterns</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#oled_iich-enhancements","title":"oled_iic.h Enhancements","text":"<ul> <li> <ul> <li>**New </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__OLED__Device/#define-ssd1309_driver_address","title":"define SSD1309_DRIVER_ADDRESS","text":"<pre><code>#define SSD1309_DRIVER_ADDRESS (0x78)\n</code></pre> <p>Default I2C address for SSD1309 devices. </p> <p>Note: This address is used when initializing I2C communication with the SSD1309 device. </p> <p>The standard I2C address for SSD1309 OLED controllers is 0x78 (0111 1000). This is the primary address used for single-device configurations. Some modules may support alternative addresses via hardware configuration.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Point__Module/","title":"Point Utilities","text":""},{"location":"api/Modules/group__Point__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components."},{"location":"api/Modules/group__Point__Module/#functions","title":"Functions","text":"Name CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b) CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)"},{"location":"api/Modules/group__Point__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Point__Module/#function-point_add","title":"function point_add","text":"<pre><code>static inline CFBDGraphic_Point point_add(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre>"},{"location":"api/Modules/group__Point__Module/#function-point_sub","title":"function point_sub","text":"<pre><code>static inline CFBDGraphic_Vec2i point_sub(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Advanced/","title":"Advanced Rectangle Operations","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Complex rectangle manipulation and analysis functions. </p>"},{"location":"api/Modules/group__RectUtil__Advanced/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_intersection(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_union(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_offset(const CFBDGraphicRect * r, int32_t dx, int32_t dy) CFBDGraphicRect rect_inset(const CFBDGraphicRect * r, int32_t left, int32_t top, int32_t right, int32_t bottom) CFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect * r, float sx, float sy) CFBDGraphicRect rect_align_in_parent(const CFBDGraphicRect * parent, const CFBDGraphicRect * child, uint8_t anchor) CFBDGraphic_Point rect_closest_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) uint32_t rect_distance_to_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_clip_line(CFBDGraphicRect * r, CFBDGraphic_Point * p0, CFBDGraphic_Point * p1) CFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect * r, uint16_t screen_w, uint16_t screen_h) uint32_t rect_area(const CFBDGraphicRect * r) CFBDGraphicSize rect_size(const CFBDGraphicRect * r) uint32_t rect_overlap_area(const CFBDGraphicRect * a, const CFBDGraphicRect * b)"},{"location":"api/Modules/group__RectUtil__Advanced/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_intersection","title":"function rect_intersection","text":"<pre><code>CFBDGraphicRect rect_intersection(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_union","title":"function rect_union","text":"<pre><code>CFBDGraphicRect rect_union(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_offset","title":"function rect_offset","text":"<pre><code>CFBDGraphicRect rect_offset(\n    const CFBDGraphicRect * r,\n    int32_t dx,\n    int32_t dy\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_inset","title":"function rect_inset","text":"<pre><code>CFBDGraphicRect rect_inset(\n    const CFBDGraphicRect * r,\n    int32_t left,\n    int32_t top,\n    int32_t right,\n    int32_t bottom\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_scale_about_center","title":"function rect_scale_about_center","text":"<pre><code>CFBDGraphicRect rect_scale_about_center(\n    const CFBDGraphicRect * r,\n    float sx,\n    float sy\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_align_in_parent","title":"function rect_align_in_parent","text":"<pre><code>CFBDGraphicRect rect_align_in_parent(\n    const CFBDGraphicRect * parent,\n    const CFBDGraphicRect * child,\n    uint8_t anchor\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_closest_point","title":"function rect_closest_point","text":"<pre><code>CFBDGraphic_Point rect_closest_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_distance_to_point","title":"function rect_distance_to_point","text":"<pre><code>uint32_t rect_distance_to_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_expand_to_include_point","title":"function rect_expand_to_include_point","text":"<pre><code>CFBDGraphicRect rect_expand_to_include_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_clip_line","title":"function rect_clip_line","text":"<pre><code>CFBD_Bool rect_clip_line(\n    CFBDGraphicRect * r,\n    CFBDGraphic_Point * p0,\n    CFBDGraphic_Point * p1\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_clamp_to_screen","title":"function rect_clamp_to_screen","text":"<pre><code>CFBDGraphicRect rect_clamp_to_screen(\n    const CFBDGraphicRect * r,\n    uint16_t screen_w,\n    uint16_t screen_h\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_area","title":"function rect_area","text":"<pre><code>static inline uint32_t rect_area(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_size","title":"function rect_size","text":"<pre><code>static inline CFBDGraphicSize rect_size(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_overlap_area","title":"function rect_overlap_area","text":"<pre><code>static inline uint32_t rect_overlap_area(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Anchor/","title":"Anchor Flags","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Flags for specifying rectangle alignment anchors. </p>"},{"location":"api/Modules/group__RectUtil__Anchor/#types","title":"Types","text":"Name enum CCGraphicAnchor { RECT_ANCHOR_LEFT = 1 &lt;&lt; 0, RECT_ANCHOR_HCENTER = 1 &lt;&lt; 1, RECT_ANCHOR_RIGHT = 1 &lt;&lt; 2, RECT_ANCHOR_TOP = 1 &lt;&lt; 3, RECT_ANCHOR_VCENTER = 1 &lt;&lt; 4, RECT_ANCHOR_BOTTOM = 1 &lt;&lt; 5}Defines anchor points for rectangle alignment operations."},{"location":"api/Modules/group__RectUtil__Anchor/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__RectUtil__Anchor/#enum-ccgraphicanchor","title":"enum CCGraphicAnchor","text":"Enumerator Value Description RECT_ANCHOR_LEFT 1 &lt;&lt; 0 Align to left edge (horizontal) RECT_ANCHOR_HCENTER 1 &lt;&lt; 1 Align to horizontal center RECT_ANCHOR_RIGHT 1 &lt;&lt; 2 Align to right edge (horizontal) RECT_ANCHOR_TOP 1 &lt;&lt; 3 Align to top edge (vertical) RECT_ANCHOR_VCENTER 1 &lt;&lt; 4 Align to vertical center RECT_ANCHOR_BOTTOM 1 &lt;&lt; 5 Align to bottom edge (vertical) <p>Defines anchor points for rectangle alignment operations. </p> <p>These flags specify horizontal and vertical anchor positions. Use bitwise OR to combine one horizontal and one vertical flag. </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Containment/","title":"Point and Rectangle Containment","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Functions to check containment and intersection relationships. </p>"},{"location":"api/Modules/group__RectUtil__Containment/#functions","title":"Functions","text":"Name CFBD_Bool rect_contains_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_intersects(const CFBDGraphicRect * a, const CFBDGraphicRect * b)"},{"location":"api/Modules/group__RectUtil__Containment/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Containment/#function-rect_contains_point","title":"function rect_contains_point","text":"<pre><code>static inline CFBD_Bool rect_contains_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Containment/#function-rect_intersects","title":"function rect_intersects","text":"<pre><code>static inline CFBD_Bool rect_intersects(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Conversion/","title":"Rectangle Format Conversion","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Conversion between different rectangle representations. </p>"},{"location":"api/Modules/group__RectUtil__Conversion/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_from_xywh(int32_t x, int32_t y, int32_t w, int32_t h) void rect_to_xywh(const CFBDGraphicRect * r, int32_t * out_x, int32_t * out_y, int32_t * out_w, int32_t * out_h)"},{"location":"api/Modules/group__RectUtil__Conversion/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Conversion/#function-rect_from_xywh","title":"function rect_from_xywh","text":"<pre><code>static inline CFBDGraphicRect rect_from_xywh(\n    int32_t x,\n    int32_t y,\n    int32_t w,\n    int32_t h\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Conversion/#function-rect_to_xywh","title":"function rect_to_xywh","text":"<pre><code>static inline void rect_to_xywh(\n    const CFBDGraphicRect * r,\n    int32_t * out_x,\n    int32_t * out_y,\n    int32_t * out_w,\n    int32_t * out_h\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Dimensions/","title":"Rectangle Dimensions","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Functions to calculate rectangle dimensions. </p>"},{"location":"api/Modules/group__RectUtil__Dimensions/#functions","title":"Functions","text":"Name uint32_t rect_width(const CFBDGraphicRect * r) uint32_t rect_height(const CFBDGraphicRect * r) CFBD_Bool rect_is_empty(const CFBDGraphicRect * r)"},{"location":"api/Modules/group__RectUtil__Dimensions/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_width","title":"function rect_width","text":"<pre><code>static inline uint32_t rect_width(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_height","title":"function rect_height","text":"<pre><code>static inline uint32_t rect_height(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_is_empty","title":"function rect_is_empty","text":"<pre><code>static inline CFBD_Bool rect_is_empty(\n    const CFBDGraphicRect * r\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__RectUtil__Normalization/","title":"Rectangle Normalization","text":"<p>Module: Rectangle Operations</p> <p>Utilities for normalizing rectangle corner points. </p>"},{"location":"api/Modules/group__RectUtil__Normalization/#modules","title":"Modules","text":"Name Rectangle Dimensions Functions to calculate rectangle dimensions. Rectangle Format Conversion Conversion between different rectangle representations. Point and Rectangle Containment Functions to check containment and intersection relationships. Anchor Flags Flags for specifying rectangle alignment anchors. Advanced Rectangle Operations Complex rectangle manipulation and analysis functions."},{"location":"api/Modules/group__RectUtil__Normalization/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_normalize(CFBDGraphicRect r)"},{"location":"api/Modules/group__RectUtil__Normalization/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Normalization/#function-rect_normalize","title":"function rect_normalize","text":"<pre><code>static inline CFBDGraphicRect rect_normalize(\n    CFBDGraphicRect r\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Rectangle__Module/","title":"Rectangle Operations","text":""},{"location":"api/Modules/group__Rectangle__Module/#modules","title":"Modules","text":"Name Rectangle Normalization Utilities for normalizing rectangle corner points."},{"location":"api/Modules/group__Rectangle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicRect Represents a rectangle defined by top-left and bottom-right corner points."},{"location":"api/Modules/group__Rectangle__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) void CFBDGraphic_FillRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect)"},{"location":"api/Modules/group__Rectangle__Module/#attributes","title":"Attributes","text":"Name CFBDGraphic_Point tl CFBDGraphic_Point br"},{"location":"api/Modules/group__Rectangle__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Rectangle__Module/#function-cfbdgraphic_drawrect","title":"function CFBDGraphic_DrawRect","text":"<pre><code>void CFBDGraphic_DrawRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Modules/group__Rectangle__Module/#function-cfbdgraphic_fillrect","title":"function CFBDGraphic_FillRect","text":"<pre><code>void CFBDGraphic_FillRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Modules/group__Rectangle__Module/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Modules/group__Rectangle__Module/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre> <p>Top-left corner point of the rectangle </p>"},{"location":"api/Modules/group__Rectangle__Module/#variable-br","title":"variable br","text":"<pre><code>CFBDGraphic_Point br;\n</code></pre> <p>Bottom-right corner point of the rectangle </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Size__Module/","title":"Size Utilities","text":""},{"location":"api/Modules/group__Size__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area."},{"location":"api/Modules/group__Size__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice * device, CFBDGraphicSize * pSize)"},{"location":"api/Modules/group__Size__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Size__Module/#function-cfbdgraphic_getscreensize","title":"function CFBDGraphic_GetScreenSize","text":"<pre><code>void CFBDGraphic_GetScreenSize(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicSize * pSize\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Timing__Module/","title":"System Clock and Timing","text":"<p>Short blocking delay primitives for timing operations.  More...</p>"},{"location":"api/Modules/group__Timing__Module/#files","title":"Files","text":"Name lib/application/sys_clock/system_clock.h System timing primitives and delay helpers."},{"location":"api/Modules/group__Timing__Module/#functions","title":"Functions","text":"Name void system_delay_ms(uint32_t delay_ms)Delay execution for at least the given number of milliseconds. void system_delay_us(uint32_t us)Delay execution for at least the given number of microseconds."},{"location":"api/Modules/group__Timing__Module/#detailed-description","title":"Detailed Description","text":"<p>Short blocking delay primitives for timing operations. </p> <p>Provides minimal, portable timing helpers for embedded systems development. These primitives are intended for short delays in initialization sequences, debouncing, and protocol timing. For longer or more precise timing requirements, consider using hardware timers or dedicated scheduling systems. </p>"},{"location":"api/Modules/group__Timing__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Timing__Module/#function-system_delay_ms","title":"function system_delay_ms","text":"<pre><code>void system_delay_ms(\n    uint32_t delay_ms\n)\n</code></pre> <p>Delay execution for at least the given number of milliseconds. </p> <p>Parameters: </p> <ul> <li>delay_ms Number of milliseconds to delay (&gt;= 0). A value of 0 should return immediately. Values greater than a few seconds should generally be avoided due to busy-wait power consumption.</li> <li>delay_ms </li> </ul> <p>See: system_delay_us()</p> <p>Since: 0.1 </p> <p>Note: we must use for loop for delay, as the large decrement makes the slow deviation for the delay </p> <p>Par: </p> <ul> <li>Thread-safety</li> </ul> <p>The function may or may not be safe to call from interrupt context; check the platform implementation before invoking from ISRs.   * Performance Notes</p> <p>Implementations typically use busy-wait loops or hardware timers. The actual delay may be slightly longer than requested due to instruction execution overhead.   * Example</p> <pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\n// Wait 100 ms for a sensor to stabilize\nsystem_delay_ms(100);\n\n// Multiple delays in sequence\nfor (int i = 0; i &lt; 5; i++) {\n    system_delay_ms(500);  // 500 ms between actions\n}\n</code></pre> <p>Blocks the calling context for approximately <code>delay_ms</code> milliseconds. The actual resolution and maximum accuracy depend on the platform timer implementation. The function is intended for short delays such as debouncing or simple timing sequences. For longer waits or low power idle, prefer platform-specific sleep APIs if available.</p> <p>Common use cases:</p> <ul> <li>GPIO debouncing (typically 10-50 ms)</li> <li>Sensor settling time</li> <li>UI interaction delays</li> <li>Initialization sequencing</li> </ul> <p>Delay execution for at least the given number of milliseconds.</p>"},{"location":"api/Modules/group__Timing__Module/#function-system_delay_us","title":"function system_delay_us","text":"<pre><code>void system_delay_us(\n    uint32_t us\n)\n</code></pre> <p>Delay execution for at least the given number of microseconds. </p> <p>Parameters: </p> <ul> <li>us Number of microseconds to delay (&gt;= 0). A value of 0 should return immediately. Large values (&gt; 1000000) should generally use <code>[system_delay_ms()](Modules/group__Timing__Module.md#function-system-delay-ms)</code> instead.</li> <li>us </li> </ul> <p>See: system_delay_ms()</p> <p>Since: 0.1 </p> <p>Par: </p> <ul> <li>Performance</li> </ul> <p>Implementations may use busy-wait loops; avoid calling with large values in performance-sensitive or low-power scenarios. Accuracy may degrade for delays shorter than 10 microseconds depending on platform overhead.   * Precision Warning</p> <p>Timing accuracy depends heavily on:</p> <ul> <li>System clock frequency stability</li> <li>Instruction execution time</li> <li>Interrupt latency (if not called from ISR with interrupts disabled) Do not rely on precise timing for critical applications without additional hardware support.</li> <li>Example</li> </ul> <pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\n// Create a small pulse of 5 microseconds\nsystem_delay_us(5);\n\n// Bit-banged I2C start condition timing\nset_sda_low();\nsystem_delay_us(2);  // Setup time\nset_scl_low();\n\n// Multiple sub-millisecond delays\nfor (int bit = 0; bit &lt; 8; bit++) {\n    transmit_bit(bit);\n    system_delay_us(10);  // Inter-bit timing\n}\n</code></pre> <p>Blocks the calling context for approximately <code>us</code> microseconds. This helper is useful for short, sub-millisecond timing (peripheral timing requirements, bit-banged protocols, etc.). Accuracy and minimum granularity depend on the underlying timer implementation.</p> <p>The resolution on most platforms is typically 1-10 microseconds, though exact behavior is implementation-defined. For very precise timing, consider using dedicated hardware peripherals.</p> <p>Common use cases:</p> <ul> <li>I2C/SPI timing sequences</li> <li>Pulse width generation for bit-banging</li> <li>Hardware-specific timing requirements</li> <li>Precise interval measurements below millisecond granularity</li> </ul> <p>Delay execution for at least the given number of microseconds.</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__Triangle__Module/","title":"Triangle Drawing","text":""},{"location":"api/Modules/group__Triangle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Triangle Represents a triangle defined by three vertices."},{"location":"api/Modules/group__Triangle__Module/#functions","title":"Functions","text":"Name void CCGraphic_DrawTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle)"},{"location":"api/Modules/group__Triangle__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Triangle__Module/#function-ccgraphic_drawtriangle","title":"function CCGraphic_DrawTriangle","text":"<pre><code>void CCGraphic_DrawTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Modules/group__Triangle__Module/#function-ccgraphic_drawfilledtriangle","title":"function CCGraphic_DrawFilledTriangle","text":"<pre><code>void CCGraphic_DrawFilledTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__for/","title":"new module concepts","text":"<p>More...</p>"},{"location":"api/Modules/group__for/#detailed-description","title":"Detailed Description","text":"<ul> <li> <ol> <li>Add</li> </ol> </li> <li> <ul> <li>``</li> </ul> </li> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Modules/group__strong/","title":"Group  strong","text":"<p>title: &gt;: Hierarchical organization of related components</p>"},{"location":"api/Modules/group__strong/#-hierarchical-organization-of-related-components","title":"&gt;: Hierarchical organization of related components","text":"<p>More...</p>"},{"location":"api/Modules/group__strong/#detailed-description","title":"Detailed Description","text":"<ul> <li> <ul> <li>**Examples ( **</li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Namespaces/namespaceCFBD/","title":"CFBD","text":"<p>Core Framework Bare Device (CFBD) namespace *.  More...</p>"},{"location":"api/Namespaces/namespaceCFBD/#namespaces","title":"Namespaces","text":"Name CFBD::OLED OLED display driver subsystem *."},{"location":"api/Namespaces/namespaceCFBD/#detailed-description","title":"Detailed Description","text":"<p>Core Framework Bare Device (CFBD) namespace *. </p> <ul> <li> <p>*</p> </li> <li> <p>The CFBD namespace encompasses all core framework types and operations</p> </li> <li>for bare-metal embedded device drivers. This includes display interfaces,</li> <li>communication protocols, and device abstraction layers.</li> <li> <ul> <li>The namespace is organized into several submodules:</li> </ul> </li> <li> <ul> <li>OLED: Generic OLED display driver subsystem</li> </ul> </li> <li> <ul> <li>Device abstraction layers for hardware communication</li> </ul> </li> <li> <ul> <li>Type definitions and constants for device control */</li> </ul> </li> </ul> <p>/**</p> <ul> <li></li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Namespaces/namespaceCFBD_1_1OLED/","title":"CFBD::OLED","text":"<p>Module: OLED Display Driver</p> <p>OLED display driver subsystem *.  More...</p>"},{"location":"api/Namespaces/namespaceCFBD_1_1OLED/#detailed-description","title":"Detailed Description","text":"<p>OLED display driver subsystem *. </p> <ul> <li>The CFBD::OLED namespace contains all OLED-related types, operations,</li> <li>and device drivers. It provides a generic, transport-agnostic interface</li> <li>for controlling OLED displays through various communication backends.</li> <li> <ul> <li>Key components:</li> </ul> </li> <li> <ul> <li>CFBD_OLED: Main device object</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations: Virtual operation table</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType: Transport type enumeration</li> </ul> </li> <li> <ul> <li>Device-specific factories (getSSD1306Specific, getSSD1309Specific) */ </li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Namespaces/namespacefor/","title":"for","text":"<p>More...</p>"},{"location":"api/Namespaces/namespacefor/#detailed-description","title":"Detailed Description","text":"<p>namespace documentation</p> <ul> <li>*/ </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/OLED_Documentation_Summary/","title":"OLED Documentation Summary","text":"<ul> <li> <ul> <li>This page summarizes the comprehensive Doxygen documentation additions made</li> </ul> </li> <li>to the OLED driver subsystem.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Documentation_Summary/#overview-of-enhancements","title":"Overview of Enhancements","text":"<ul> <li> <ul> <li>The OLED driver documentation has been significantly enhanced to support</li> </ul> </li> <li>Doxygen's advanced features, including:</li> <li> <ul> <li> <ul> <li>**Modules ( **</li> </ul> </li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/OLED_Examples/","title":"OLED Driver Examples","text":"<ul> <li> <ul> <li> <ul> <li> <ul> <li>This page contains comprehensive code examples demonstrating how to use</li> </ul> </li> </ul> </li> </ul> </li> <li>the OLED driver for various common tasks.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#basic-device-initialization","title":"Basic Device Initialization","text":"<ul> <li> <ul> <li>The most fundamental example showing device setup and initialization:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"oled.h\"\n* #include \"driver/backend/oled_iic.h\"\n* #include \"driver/device/ssd1309/ssd1309.h\"\n*\n* void example_basic_init(void) {\n*     // Create OLED device structure\n*     CFBD_OLED oled;\n*\n*     // Setup I2C parameters\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,  // Use standard address\n*         .i2c_handle = get_my_i2c_interface(),\n*     };\n*\n*     // Initialize OLED with I2C backend\n*     CFBD_bool success = CFBD_GetOLEDHandle(\n*         &amp;oled,\n*         CFBD_OLEDDriverType_IIC,\n*         &amp;i2c_params,\n*         CFBD_TRUE  // Immediate initialization\n*     );\n*\n*     if (success &amp;&amp; oled.ops-&gt;open(&amp;oled)) {\n*         // Device is now ready for use\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#clear-display","title":"Clear Display","text":"<ul> <li> <ul> <li>Clear all pixels and update the physical display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_clear_display(CFBD_OLED* oled) {\n*     // Clear all pixels in the local buffer\n*     oled-&gt;ops-&gt;clear(oled);\n*\n*     // Synchronize with physical display\n*     oled-&gt;ops-&gt;update(oled);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#drawing-individual-pixels","title":"Drawing Individual Pixels","text":"<ul> <li> <ul> <li>Set individual pixels to create a pattern:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_draw_checkerboard(CFBD_OLED* oled) {\n*     // Get display dimensions\n*     uint16_t width = 0, height = 0;\n*     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n*     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n*\n*     // Draw checkerboard pattern\n*     for (uint16_t y = 0; y &lt; height; y += 2) {\n*         for (uint16_t x = 0; x &lt; width; x += 2) {\n*             if ((x + y) % 4 == 0) {\n*                 oled-&gt;ops-&gt;setPixel(oled, x, y);\n*             }\n*         }\n*     }\n*\n*     // Update display\n*     oled-&gt;ops-&gt;update(oled);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#area-based-drawing","title":"Area-Based Drawing","text":"<ul> <li> <ul> <li>Efficiently update rectangular regions of the display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_draw_rectangle(CFBD_OLED* oled,\n*                             uint16_t x, uint16_t y,\n*                             uint16_t width, uint16_t height) {\n*     // Prepare bitmap data (format depends on device)\n*     uint8_t* bitmap = prepare_rectangle_data(width, height);\n*\n*     // Write the area\n*     CFBD_bool success = oled-&gt;ops-&gt;setArea(oled, x, y, width, height, bitmap);\n*\n*     if (success) {\n*         // Update only this area on the display\n*         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n*     }\n*\n*     free_bitmap_data(bitmap);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#device-property-queries","title":"Device Property Queries","text":"<ul> <li> <ul> <li>Query device capabilities and properties:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_query_device(CFBD_OLED* oled) {\n*     uint16_t width = 0, height = 0;\n*     CFBD_bool is_rgb = CFBD_FALSE;\n*\n*     // Query basic properties\n*     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n*     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n*     oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n*\n*     // Report display information\n*     printf(\"Display Resolution: %u x %u pixels\\n\", width, height);\n*     printf(\"Color Mode: %s\\n\", is_rgb ? \"RGB Color\" : \"Monochrome\");\n*     printf(\"Total Pixels: %u\\n\", (unsigned long)width * height);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#clearing-specific-regions","title":"Clearing Specific Regions","text":"<ul> <li> <ul> <li>Clear only a portion of the display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_clear_area(CFBD_OLED* oled,\n*                        uint16_t x, uint16_t y,\n*                        uint16_t width, uint16_t height) {\n*     // Clear rectangular area in the frame buffer\n*     CFBD_bool success = oled-&gt;ops-&gt;clear_area(oled, x, y, width, height);\n*\n*     if (success) {\n*         // Update the cleared area on the physical display\n*         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#multiple-oled-devices","title":"Multiple OLED Devices","text":"<ul> <li> <ul> <li>Control multiple OLED displays on different I2C addresses:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #define NUM_DISPLAYS 2\n*\n* void example_multiple_displays(void) {\n*     CFBD_OLED oled_displays[NUM_DISPLAYS];\n*\n*     // Configuration for each display\n*     struct {\n*         uint8_t address;\n*     } configs[NUM_DISPLAYS] = {\n*         { 0x78 },  // First device\n*         { 0x7A },  // Second device (alternate address)\n*     };\n*\n*     // Initialize all displays\n*     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n*         CFBD_OLED_IICInitsParams i2c_params = {\n*             .device_address = configs[i].address,\n*             .i2c_handle = get_i2c_interface(),\n*         };\n*\n*         if (CFBD_GetOLEDHandle(&amp;oled_displays[i],\n*                                CFBD_OLEDDriverType_IIC,\n*                                &amp;i2c_params,\n*                                CFBD_TRUE)) {\n*             oled_displays[i].ops-&gt;open(&amp;oled_displays[i]);\n*         }\n*     }\n*\n*     // Use both displays independently\n*     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n*         oled_displays[i].ops-&gt;clear(&amp;oled_displays[i]);\n*         oled_displays[i].ops-&gt;update(&amp;oled_displays[i]);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#deferred-initialization","title":"Deferred Initialization","text":"<ul> <li> <ul> <li>Create device handle but delay initialization:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_deferred_init(void) {\n*     CFBD_OLED oled;\n*\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*\n*     // Create handle without immediate initialization\n*     if (CFBD_GetOLEDHandle(&amp;oled,\n*                            CFBD_OLEDDriverType_IIC,\n*                            &amp;i2c_params,\n*                            CFBD_FALSE)) {  // Deferred init\n*\n*         // ... perform other setup operations ...\n*\n*         // Later, initialize when needed\n*         oled.ops-&gt;init(&amp;oled, NULL);\n*         oled.ops-&gt;open(&amp;oled);\n*\n*         // Now ready for use\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#error-handling","title":"Error Handling","text":"<ul> <li> <ul> <li>Proper error checking throughout device usage:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CFBD_bool safe_display_operation(void) {\n*     CFBD_OLED oled;\n*\n*     // Step 1: Initialize with error checking\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*\n*     if (!CFBD_GetOLEDHandle(&amp;oled,\n*                             CFBD_OLEDDriverType_IIC,\n*                             &amp;i2c_params,\n*                             CFBD_TRUE)) {\n*         printf(\"ERROR: Failed to get OLED handle\\n\");\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 2: Open device with error checking\n*     if (!oled.ops-&gt;open(&amp;oled)) {\n*         printf(\"ERROR: Failed to open OLED device\\n\");\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 3: Perform operations with error checking\n*     if (!oled.ops-&gt;clear(&amp;oled)) {\n*         printf(\"ERROR: Failed to clear display\\n\");\n*         oled.ops-&gt;close(&amp;oled);\n*         return CFBD_FALSE;\n*     }\n*\n*     if (!oled.ops-&gt;update(&amp;oled)) {\n*         printf(\"ERROR: Failed to update display\\n\");\n*         oled.ops-&gt;close(&amp;oled);\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 4: Cleanup\n*     oled.ops-&gt;close(&amp;oled);\n*     return CFBD_TRUE;\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#text-display-pattern","title":"Text Display Pattern","text":"<ul> <li> <ul> <li>Example showing how to structure text display operations:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_display_pattern(CFBD_OLED* oled) {\n*     // Get display dimensions\n*     uint16_t width = 128, height = 64;  // Typical SSD1309\n*\n*     // Clear and prepare\n*     oled-&gt;ops-&gt;clear(oled);\n*     oled-&gt;ops-&gt;update(oled);\n*\n*     // Create a pattern (horizontal lines)\n*     for (uint16_t y = 0; y &lt; height; y += 4) {\n*         for (uint16_t x = 0; x &lt; width; x++) {\n*             oled-&gt;ops-&gt;setPixel(oled, x, y);\n*         }\n*     }\n*\n*     // Update display with new pattern\n*     oled-&gt;ops-&gt;update(oled);\n*\n*     // Alternative: update only affected area for efficiency\n*     // oled-&gt;ops-&gt;update_area(oled, 0, 0, width, height);\n* }\n* \n</code></pre> <ul> <li> <ul> <li>OLED Driver Usage Guidefor detailed usage documentation</li> </ul> </li> <li> <p>CFBD_OLEDfor device structure documentation</p> </li> <li> <p>CFBD_OLEDOperationsfor operation table documentation */ </p> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/OLED_UsageGuide/","title":"OLED Driver Usage Guide","text":""},{"location":"api/Pages/OLED_UsageGuide/#overview","title":"Overview","text":"<ul> <li> <ul> <li>The OLED subsystem provides a generic, transport-agnostic interface for</li> </ul> </li> <li>controlling OLED displays. It supports multiple device types (SSD1306, SSD1309, etc.)</li> <li>and multiple communication backends (I2C, SPI).</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#architecture","title":"Architecture","text":"<ul> <li> <ul> <li>The OLED driver architecture consists of three main layers:</li> </ul> </li> <li> <ul> <li> <ul> <li>Generic OLED Driver: The top-level interface (<code>[oled.h](Files/oled_8h.md#file-oled.h)</code>) that application</li> </ul> </li> </ul> </li> <li>code interacts with. Provides a device-agnostic API for rendering and control.</li> <li> <ul> <li> <ul> <li>Device Drivers: Device-specific implementations (SSD1306, SSD1309) that</li> </ul> </li> </ul> </li> <li>provide device-specific initialization, memory layouts, and communication prefixes.</li> <li> <ul> <li> <ul> <li>Transport Backends: Transport-specific implementations (I2C, SPI) that</li> </ul> </li> </ul> </li> <li>handle the actual hardware communication with the device.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#gettingstarted","title":"GettingStarted","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#include-required-headers","title":"Include Required Headers","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"driver/backend/oled_iic.h\"</code></li> <li><code>#include \"driver/device/ssd1309/ssd1309.h\" *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#initialize-i2c-transport","title":"Initialize I2C Transport","text":"<ul> <li> <ul> <li>Before initializing the OLED device, ensure your I2C interface is properly</li> </ul> </li> <li>configured. Prepare the I2C initialization parameters:</li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) i2c_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS, // 0x78</code></li> <li><code>.i2c_handle = &amp;my_i2c_interface,</code></li> <li><code>.notify_tx_complete = on_i2c_transmit_complete,</code></li> <li><code>.notify_error = on_i2c_error,</code></li> <li><code>}; *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#get-oled-device-handle","title":"Get OLED Device Handle","text":"<ul> <li> <ul> <li>Use <code>[CFBD_GetOLEDHandle()](Files/oled_8c.md#function-cfbd-getoledhandle)</code> to create and initialize an OLED device:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled_device;</code></li> <li>``</li> <li><code>if (CFBD_GetOLEDHandle(&amp;oled_device,</code></li> <li><code>CFBD_OLEDDriverType_IIC,</code></li> <li><code>&amp;i2c_config,</code></li> <li><code>CFBD_TRUE)) { // Request immediate initialization</code></li> <li><code>// Device handle created successfully</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#enable-the-display","title":"Enable the Display","text":"<ul> <li> <ul> <li>Open/enable the OLED display:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>if (oled_device.ops-&gt;open(&amp;oled_device)) {</code></li> <li><code>// Display is now powered on and ready</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#commonoperations","title":"CommonOperations","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#clear-the-entire-display","title":"Clear the Entire Display","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Clear all pixels</code></li> <li><code>oled_device.ops-&gt;clear(&amp;oled_device);</code></li> <li>``</li> <li><code>// Push changes to physical display</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#draw-individual-pixels","title":"Draw Individual Pixels","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Set pixel at (x=64, y=32) to on</code></li> <li><code>CFBD_bool success = oled_device.ops-&gt;setPixel(&amp;oled_device, 64, 32);</code></li> <li>``</li> <li><code>// Update display to show the pixel</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#draw-a-block-of-data","title":"Draw a Block of Data","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Example: Draw a 16x16 bitmap at position (0, 0)</code></li> <li><code>uint8_t bitmap_data[32]; // 16x16 pixels, monochrome format</code></li> <li>``</li> <li><code>oled_device.ops-&gt;setArea(&amp;oled_device,</code></li> <li><code>0, 0, // x, y position</code></li> <li><code>16, 16, // width, height</code></li> <li><code>bitmap_data); // source data</code></li> <li>``</li> <li><code>// Update the area on display</code></li> <li><code>oled_device.ops-&gt;update_area(&amp;oled_device, 0, 0, 16, 16); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#query-display-properties","title":"Query Display Properties","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Query display width</code></li> <li><code>uint16_t width = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);</code></li> <li>``</li> <li><code>// Query display height</code></li> <li><code>uint16_t height = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);</code></li> <li>``</li> <li><code>// Query color support (RGB vs monochrome)</code></li> <li><code>CFBD_bool is_rgb = CFBD_FALSE;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"rgb\", NULL, &amp;is_rgb);</code></li> <li>``</li> <li><code>printf(\"Display: %u x %u, Color Mode: %s\\n\",</code></li> <li><code>width, height, is_rgb ? \"RGB\" : \"Monochrome\"); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#closedisable-the-display","title":"Close/Disable the Display","text":"<ul> <li> <ul> <li>When finished with the display, close it to power off and release resources:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>oled_device.ops-&gt;close(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#completeexample","title":"CompleteExample","text":"<ul> <li> <ul> <li>Here's a complete example demonstrating the OLED driver usage:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"driver/backend/oled_iic.h\"</code></li> <li><code>#include \"driver/device/ssd1309/ssd1309.h\"</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li>``</li> <li><code>void oled_demo(void) {</code></li> <li><code>// Step 1: Setup I2C configuration</code></li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) i2c_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS,</code></li> <li><code>.i2c_handle = get_i2c_interface(),</code></li> <li><code>};</code></li> <li>``</li> <li><code>// Step 2: Get OLED device handle</code></li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled_device;</code></li> <li><code>if (!CFBD_GetOLEDHandle(&amp;oled_device,</code></li> <li><code>CFBD_OLEDDriverType_IIC,</code></li> <li><code>&amp;i2c_config,</code></li> <li><code>CFBD_TRUE)) {</code></li> <li><code>printf(\"Failed to initialize OLED device\\n\");</code></li> <li><code>return;</code></li> <li><code>}</code></li> <li>``</li> <li><code>// Step 3: Open the display</code></li> <li><code>if (!oled_device.ops-&gt;open(&amp;oled_device)) {</code></li> <li><code>printf(\"Failed to open OLED device\\n\");</code></li> <li><code>return;</code></li> <li><code>}</code></li> <li>``</li> <li><code>// Step 4: Query and display device information</code></li> <li><code>uint16_t width = 0, height = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);</code></li> <li><code>printf(\"OLED Display: %u x %u pixels\\n\", width, height);</code></li> <li>``</li> <li><code>// Step 5: Clear the display</code></li> <li><code>oled_device.ops-&gt;clear(&amp;oled_device);</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device);</code></li> <li>``</li> <li><code>// Step 6: Draw some pixels</code></li> <li><code>for (uint16_t x = 0; x &lt; width; x += 2) {</code></li> <li><code>oled_device.ops-&gt;setPixel(&amp;oled_device, x, 10);</code></li> <li><code>}</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device);</code></li> <li>``</li> <li><code>// Step 7: Close the display</code></li> <li><code>oled_device.ops-&gt;close(&amp;oled_device);</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#supporteddevices","title":"SupportedDevices","text":"<ul> <li> <ul> <li>Currently supported OLED controller chips:</li> </ul> </li> <li> <ul> <li>SSD1306: Common monochrome controller, 128x64 resolution typical</li> </ul> </li> <li> <ul> <li>SSD1309: Enhanced version with improved contrast and timing control</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#supportedtransports","title":"SupportedTransports","text":"<ul> <li> <ul> <li>Available transport backends:</li> </ul> </li> <li> <ul> <li>I2C (IIC): Two-wire interface, default at 0x78 for SSD1309</li> </ul> </li> <li> <ul> <li>SPI: High-speed serial interface (implementation available)</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#errorhandling","title":"ErrorHandling","text":"<ul> <li> <ul> <li>Most operations return <code>CFBD_bool</code> (TRUE/FALSE) to indicate success or failure.</li> </ul> </li> <li>Common error conditions:</li> <li> <ul> <li>Invalid device address</li> </ul> </li> <li> <ul> <li>I2C communication errors</li> </ul> </li> <li> <ul> <li>Device not initialized or opened</li> </ul> </li> <li> <ul> <li>Out-of-bounds coordinate access</li> </ul> </li> <li> <ul> <li>Always check return values before proceeding with display operations.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#considerations","title":"Considerations","text":"<ul> <li> <ul> <li> <ul> <li>Full frame updates: Use <code>[update()](Files/oled__iic_8c.md#function-update)</code> for complete display refresh</li> </ul> </li> </ul> </li> <li> <ul> <li>Partial updates: Use <code>update_area()</code> for better performance when</li> </ul> </li> <li>updating only specific regions</li> <li> <ul> <li>Buffering: The driver maintains a local frame buffer; changes are</li> </ul> </li> <li>not visible on the display until <code>[update()](Files/oled__iic_8c.md#function-update)</code> or <code>update_area()</code> is called</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <ul> <li>Display not responding: Verify I2C address and electrical connections</li> </ul> </li> <li> <ul> <li>Garbled display: Check frame buffer data format and pixel ordering</li> </ul> </li> <li> <ul> <li>Slow updates: Consider using area-based updates instead of full updates</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#references","title":"References","text":"<ul> <li> <ul> <li> <ul> <li>OLED Display Driver Main OLED driver module</li> </ul> </li> </ul> </li> <li> <ul> <li>OLED Device Interface Device interface documentation</li> </ul> </li> <li> <ul> <li>OLED Backend Implementations Backend transport implementations</li> </ul> </li> <li>*/ </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/_2strong/","title":"2strong","text":"<p>title: &gt;: Comprehensive guides and reference documentation</p>"},{"location":"api/Pages/_2strong/#-comprehensive-guides-and-reference-documentation","title":"&gt;: Comprehensive guides and reference documentation","text":"<ul> <li> <ul> <li>Detailed Comments: Extended sections with implementation guidance</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#module-organization","title":"Module Organization","text":"<ul> <li> <ul> <li>The OLED subsystem is organized into the following modules:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled---main-display-driver","title":"OLED - Main Display Driver","text":"<ul> <li> <ul> <li>Location: oled.h</li> </ul> </li> <li> <ul> <li>Purpose: Generic OLED interface and device operations</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED device structure</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations virtual operation table</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType transport enumeration</li> </ul> </li> <li> <ul> <li>CFBD_GetOLEDHandle() factory function</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_device---device-interface","title":"OLED_Device - Device Interface","text":"<ul> <li> <ul> <li>Location: device_interface.h, ssd1306.h, ssd1309.h</li> </ul> </li> <li> <ul> <li>Purpose: Device-specific configurations and factories</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_DeviceSpecific structure</li> </ul> </li> <li> <ul> <li>getSSD1306Specific() factory function</li> </ul> </li> <li> <ul> <li>getSSD1309Specific() factory function</li> </ul> </li> <li> <ul> <li>SSD1309_DRIVER_ADDRESS constant</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_backend---transport-backends","title":"OLED_Backend - Transport Backends","text":"<ul> <li> <ul> <li>Location: oled_iic.h (and potentially future spi backends)</li> </ul> </li> <li> <ul> <li>Purpose: Transport-specific implementations</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_IICInit() I2C initialization</li> </ul> </li> <li> <ul> <li>Backend parameter structures</li> </ul> </li> <li> <ul> <li>Transport configuration</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#new-documentation-files","title":"New Documentation Files","text":"<ul> <li> <ul> <li>Three comprehensive documentation files have been created:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_usageguidemd-page-oled_usageguide","title":"OLED_UsageGuide.md (@page OLED_UsageGuide)","text":"<ul> <li> <ul> <li>Purpose: Comprehensive user guide for OLED driver usage</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>Architecture overview</li> </ul> </li> <li> <ul> <li>Getting started instructions (steps 1-4)</li> </ul> </li> <li> <ul> <li>Common operations guide</li> </ul> </li> <li> <ul> <li>Complete working example</li> </ul> </li> <li> <ul> <li>Performance considerations</li> </ul> </li> <li> <ul> <li>Troubleshooting guide</li> </ul> </li> <li> <ul> <li>Target Audience: Application developers</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_examplesmd-page-oled_examples","title":"OLED_Examples.md (@page OLED_Examples)","text":"<ul> <li> <ul> <li>Purpose: Collection of practical code examples</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>10+ complete, runnable examples</li> </ul> </li> <li> <ul> <li>Basic initialization</li> </ul> </li> <li> <ul> <li>Display clearing and updating</li> </ul> </li> <li> <ul> <li>Pixel and area drawing</li> </ul> </li> <li> <ul> <li>Device property queries</li> </ul> </li> <li> <ul> <li>Multi-display management</li> </ul> </li> <li> <ul> <li>Error handling patterns</li> </ul> </li> <li> <ul> <li>Deferred initialization</li> </ul> </li> <li> <ul> <li>Target Audience: Developers learning by example</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_namespacemd-page-oled-namespace","title":"OLED_Namespace.md (@page OLED Namespace)","text":"<ul> <li> <ul> <li>Purpose: Namespace organization documentation</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD namespace overview</li> </ul> </li> <li> <ul> <li>CFBD::OLED sub-namespace</li> </ul> </li> <li> <ul> <li>Component organization</li> </ul> </li> <li> <ul> <li>Target Audience: Architecture documentation readers</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#enhanced-inline-documentation","title":"Enhanced Inline Documentation","text":"<ul> <li> <ul> <li>All header files have received extensive documentation improvements:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oledh-enhancements","title":"oled.h Enhancements","text":"<ul> <li> <ul> <li>Enumerations:</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType: Expanded with detailed transport descriptions</li> </ul> </li> <li> <ul> <li>Type Definitions:</li> </ul> </li> <li> <ul> <li>AreaOperations: Enhanced with usage examples</li> </ul> </li> <li> <ul> <li>FrameOperation: Detailed operation semantics</li> </ul> </li> <li> <ul> <li>OLEDSelfOperation: Lifecycle management documentation</li> </ul> </li> <li> <ul> <li>OLED_QueryOperation: Property query protocol and examples</li> </ul> </li> <li> <ul> <li>CFBDOLED_Params_Inits: Transport-specific parameter abstraction</li> </ul> </li> <li> <ul> <li>Structures:</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations: Complete operation table with:</li> </ul> </li> <li> <ul> <li>Field-by-field documentation</li> </ul> </li> <li> <ul> <li>Usage examples</li> </ul> </li> <li> <ul> <li>Supported operation types</li> </ul> </li> <li> <ul> <li>CFBD_OLED: Device object with:</li> </ul> </li> <li> <ul> <li>Member descriptions</li> </ul> </li> <li> <ul> <li>Usage patterns</li> </ul> </li> <li> <ul> <li>Lifecycle documentation</li> </ul> </li> <li> <ul> <li>Functions:</li> </ul> </li> <li> <ul> <li>CFBD_GetOLEDHandle(): Extended documentation with:</li> </ul> </li> <li> <ul> <li>Multiple usage examples</li> </ul> </li> <li> <ul> <li>Transport-specific parameter guidelines</li> </ul> </li> <li> <ul> <li>Error handling guidance</li> </ul> </li> <li> <ul> <li>Two complete code examples</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#device_interfaceh-enhancements","title":"device_interface.h Enhancements","text":"<ul> <li> <ul> <li>**New </li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/application_setup/","title":"Application Initialization and Setup","text":""},{"location":"api/Pages/application_setup/#overview","title":"Overview","text":"<p>The application module provides a unified interface for initializing and managing an embedded application's boot sequence and clock providers. This design allows applications to register their initialization routines and timing sources with the CFBD framework.</p>"},{"location":"api/Pages/application_setup/#architecture","title":"Architecture","text":"<p>The <code>CFBDApplication</code> structure acts as a central registry containing:</p> <ul> <li>Bootstrap function and parameters for system initialization</li> <li>Clock frequency provider for timing calculations</li> <li>Tick counter provider for interval measurement</li> </ul>"},{"location":"api/Pages/application_setup/#basic-application-setup","title":"Basic Application Setup","text":"<pre><code>#include \"lib/application/app.h\"\n\n// Clock providers (from platform code)\nuint32_t get_system_clock_hz(void) {\n    return 72000000;  // STM32F103 at 72 MHz\n}\n\nuint32_t get_tick_count(void) {\n    return SysTick-&gt;VAL;  // Read from system timer\n}\n\n// Application bootstrap\nCFBD_Bool app_bootstrap(void* self_handle, void* args) {\n    // Initialize peripherals\n    init_gpio();\n    init_uart();\n    return CFBD_TRUE;\n}\n\n// Application instance\nCFBDApplication g_app = {\n    .selfBootFunc = app_bootstrap,\n    .bootargs = NULL,\n    .freq_provider = get_system_clock_hz,\n    .tick_provider = get_tick_count\n};\n\n// Application retrieval\nCFBDApplication* getApp(CFBD_Bool request_auto_boot) {\n    if (request_auto_boot &amp;&amp; g_app.selfBootFunc) {\n        g_app.selfBootFunc(&amp;g_app, g_app.bootargs);\n    }\n    return &amp;g_app;\n}\n</code></pre>"},{"location":"api/Pages/application_setup/#timing-and-clock-coordination","title":"Timing and Clock Coordination","text":"<pre><code>// Get current timing information\nCFBDApplication* app = getApp(CFBD_FALSE);\nuint32_t freq = app-&gt;freq_provider();  // Get clock frequency\nuint32_t ticks = app-&gt;tick_provider(); // Get current tick count\n\n// Calculate delay in milliseconds\nuint32_t ms_per_tick = 1000 / freq;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/boot_page/","title":"Boot System Design","text":""},{"location":"api/Pages/boot_page/#introduction","title":"Introduction","text":"<p>The CFBD Boot System provides a lightweight, generic framework for managing application startup sequences. It separates bootstrap logic from main application code, enabling modular initialization of hardware, drivers, and application layers.</p>"},{"location":"api/Pages/boot_page/#architecture","title":"Architecture","text":"<p>The boot system consists of three core components:</p> <ul> <li>Bootstrap Arguments (CFBD_BootArgs): Opaque containers for configuration data</li> <li>Bootstrap Functions (CFBD_BootStrapFunc): Entry points executed during startup</li> <li>Bootstrap Tuples (CFBDBootTuple): Associations between functions and their arguments</li> </ul>"},{"location":"api/Pages/boot_page/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Define boot configuration structures for each initialization stage</li> <li>Create bootstrap functions that operate on those configurations</li> <li>Build a static boot table using <code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code> entries</li> <li>Iterate the table and invoke each function sequentially</li> <li>Handle failures by stopping the sequence or triggering recovery</li> </ol> <p>0.1 </p> <p>2026-01-09 </p> <p>Copyright \u00a9 2026 </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/core_types_guide/","title":"Core Types and Definitions Guide","text":""},{"location":"api/Pages/core_types_guide/#introduction","title":"Introduction","text":"<p>The CFBD core type system provides minimal but essential building blocks for embedded systems development. These types ensure consistent behavior across different platforms and compilers.</p>"},{"location":"api/Pages/core_types_guide/#boolean-type","title":"Boolean Type","text":"<pre><code>#include \"lib/config/cfbd_define.h\"\n\n// Simple boolean usage\nCFBD_Bool is_initialized = CFBD_FALSE;\nif (initialize_system()) {\n    is_initialized = CFBD_TRUE;\n}\n</code></pre>"},{"location":"api/Pages/core_types_guide/#callback-function-types","title":"Callback Function Types","text":"<pre><code>#include \"lib/config/cfbd_define.h\"\n\n// Initialization callback\nCFBD_Bool my_init(void* self_handle, void* args) {\n    // Initialize component\n    return CFBD_TRUE;  // Success\n}\n\n// Simple callback\nvoid my_callback(void* args) {\n    // Handle event\n}\n\n// Use in your component\nSelfInitFunc init = my_init;\nPlainFunc callback = my_callback;\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/documents/","title":"with new information","text":"<ul> <li> <ol> <li>Maintain cross-references between related items</li> </ol> </li> <li> <ol> <li>Keep examples in sync with implementation</li> </ol> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/documents/#doxygen-features-used","title":"Doxygen Features Used","text":"<ul> <li> <ul> <li>This documentation makes use of:</li> </ul> </li> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/error_handling/","title":"Error Handling Guide","text":""},{"location":"api/Pages/error_handling/#overview","title":"Overview","text":"<p>The <code>[ah_no.h](Files/ah__no_8h.md#file-ah-no.h)</code> header provides emergency halt functionality for handling unrecoverable system errors on bare-metal embedded systems. When a fatal error is detected and continuing execution would be unsafe, applications should invoke <code>[CFBD_AH_NO()](Modules/group__Core__Utilities.md#function-cfbd-ah-no)</code> to enter a halt state.</p>"},{"location":"api/Pages/error_handling/#usage-pattern","title":"Usage Pattern","text":"<pre><code>#include \"lib/config/ah_no.h\"\n\n// Example: Halt on critical failure\nif (critical_resource_failed) {\n    // Log or signal error if needed\n    CFBD_AH_NO();  // Enter infinite halt\n    // Execution never reaches here\n}\n</code></pre>"},{"location":"api/Pages/error_handling/#platform-integration","title":"Platform Integration","text":"<p>On many platforms, external mechanisms like watchdogs or debuggers can detect and handle the halt state:</p> <ul> <li>Watchdog timers can trigger system reset</li> <li>Debuggers can break on the infinite loop</li> <li>Custom firmware may signal error indicators before the halt </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/for/","title":"standalone pages","text":"<ul> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/","title":"Arc Drawing and Geometry Guide","text":""},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#arc-fundamentals","title":"Arc Fundamentals","text":"<p>Arcs represent portions of a circle defined by:</p> <ul> <li>Center point and radius (like circles)</li> <li>Angular range (start and end degrees)</li> <li>Direction of sweep (typically counter-clockwise)</li> </ul>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#angular-measurement","title":"Angular Measurement","text":"<p>Angles are specified in degrees (0-359):</p> <ul> <li>0\u00b0 points to the right (3 o'clock position)</li> <li>90\u00b0 points downward (6 o'clock position)</li> <li>180\u00b0 points to the left (9 o'clock position)</li> <li>270\u00b0 points upward (12 o'clock position)</li> <li>Positive angles sweep counter-clockwise</li> <li>Angles wrap at 360\u00b0 boundaries</li> </ul>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#arc-types","title":"Arc Types","text":"<ol> <li>Arc outline: Just the curved edge (CFBDGraphic_DrawArc)</li> <li>Filled arc/sector: Arc plus two radii forming a pie slice (CFBDGraphic_DrawFilledArc)</li> </ol>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#practical-applications","title":"Practical Applications","text":"<ul> <li>Gauges and progress indicators</li> <li>Pie charts and donut charts</li> <li>Circular menus and dial controls</li> <li>Clock and timer displays</li> <li>Compass and rotation indicators</li> <li>Loading animations </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/","title":"Graphic Base Helpers User Guide","text":""},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#overview","title":"Overview","text":"<p>The BaseHelpers module provides lightweight inline conversion utilities designed specifically for the BareMetal graphics system. These helpers ensure safe arithmetic between different numeric types used throughout the graphics library.</p>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#key-features","title":"Key Features","text":"<ul> <li>Type-safe conversions between PointBaseType and 32-bit integers</li> <li>Automatic range clamping to prevent overflow</li> <li>Zero-cost abstraction suitable for embedded systems</li> <li>Inline implementation for optimal performance</li> </ul>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#usage-patterns","title":"Usage Patterns","text":"<pre><code>// Converting unsigned 16-bit point coordinate to signed for calculations\nCFBDGraphic_Point pt = {100, 50};\nint32_t signed_x = asInt32_t(pt.x);  // 100 -&gt; 100 (signed)\nint32_t signed_y = asInt32_t(pt.y);  // 50 -&gt; 50 (signed)\n\n// Clamping coordinates after arithmetic operations\nint32_t new_x = 100 + 50000;  // Might overflow\nPointBaseType safe_x = clamp_u16_from_i32(new_x);\n// Result: UINT16_MAX (65535)\n\n// Handling negative displacements\nint32_t delta = -50;\nPointBaseType pos = clamp_u16_from_i32(delta);  // Result: 0\n</code></pre> <p>Graphics_Module </p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/","title":"Circle Drawing and Geometry Guide","text":""},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#circle-fundamentals","title":"Circle Fundamentals","text":"<p>Circles are defined by their center point and a radius. The BareMetal graphics library provides efficient rendering functions for both circle outlines and filled circles. These functions are optimized for embedded displays.</p>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#circle-structure","title":"Circle Structure","text":"<p>Each circle is represented by:</p> <ul> <li>A center point (CFBDGraphic_Point) specifying the circle's location</li> <li>A radius (SizeBaseType) in device coordinate units</li> </ul>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#rendering-algorithms","title":"Rendering Algorithms","text":"<p>Implementations typically use the Midpoint Circle Algorithm (Bresenham's circle algorithm) for efficient rasterization:</p> <ul> <li>Minimizes floating-point operations</li> <li>Generates anti-aliased appearance on pixel grids</li> <li>Scales well for circles of any size</li> </ul>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>UI buttons with circular shapes</li> <li>Radar displays and gauges</li> <li>Particle effects and animations</li> <li>Collision detection debugging</li> <li>Indicator lights and status displays </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/iic_error_page/","title":"I2C Error Handling","text":""},{"location":"api/Pages/iic_error_page/#introduction","title":"Introduction","text":"<p>The I2C/IIC error subsystem provides a standardized set of error codes compatible with POSIX conventions. This enables consistent error handling across different platforms and I2C implementations within the CFBD project.</p>"},{"location":"api/Pages/iic_error_page/#error-code-reference","title":"Error Code Reference","text":"<p>All I2C operations return an integer status code:</p> <ul> <li>I2C_OK (0): Operation completed successfully</li> <li>I2C_ERR_TIMEOUT (-110): Operation exceeded time limit</li> <li>I2C_ERR_NACK (-121): Device did not acknowledge (protocol error)</li> <li>I2C_ERR_BUSY (-16): Bus or device is currently busy</li> <li>I2C_ERR_IO (-5): Generic I/O error occurred</li> <li>I2C_ERR_INVAL (-22): Invalid arguments provided</li> </ul>"},{"location":"api/Pages/iic_error_page/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"api/Pages/iic_error_page/#basic-error-checking","title":"Basic Error Checking","text":"<pre><code>int status = CFBD_I2CTransfer(bus, messages, num_messages, 1000);\nif (status != I2C_OK) {\n    // Handle error based on type\n    if (status == I2C_ERR_TIMEOUT) {\n        // Timeout occurred - retry or increase timeout\n    } else if (status == I2C_ERR_NACK) {\n        // Device not responding - check address and connections\n    }\n}\n</code></pre>"},{"location":"api/Pages/iic_error_page/#recovery-strategies","title":"Recovery Strategies","text":"<pre><code>int attempt = 0;\nconst int MAX_RETRIES = 3;\nint status;\n\ndo {\n    status = CFBD_I2CTransfer(bus, messages, num_messages, 1000);\n    if (status == I2C_OK) {\n        break;  // Success\n    } else if (status == I2C_ERR_BUSY) {\n        // Wait before retry\n        delay_ms(10);\n    } else if (status == I2C_ERR_NACK || status == I2C_ERR_IO) {\n        // Attempt bus recovery\n        CFBD_I2CRecoverBus(bus);\n        delay_ms(50);\n    }\n} while (++attempt &lt; MAX_RETRIES &amp;&amp; status != I2C_OK);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/iic_integration_page/","title":"I2C Integration Guide","text":""},{"location":"api/Pages/iic_integration_page/#overview","title":"Overview","text":"<p>The CFBD I2C abstraction provides a platform-independent interface for I2C communication. Backend implementations (e.g., STM32) provide concrete device drivers, while the abstraction layer ensures consistent behavior across different hardware platforms.</p>"},{"location":"api/Pages/iic_integration_page/#architecture","title":"Architecture","text":"<p>The I2C system consists of:</p> <ul> <li>Operations Table (<code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code>): Backend implementation hooks</li> <li>I2C Handle (<code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>): Public interface + private backend state</li> <li>Messages (<code>[CFBD_I2C_Message](Classes/structCFBD__I2C__Message.md)</code>): Protocol-level read/write operations</li> <li>High-Level Helpers (<code>CFBD_I2CRead</code>, <code>CFBD_I2CWrite</code>): Convenience functions</li> </ul>"},{"location":"api/Pages/iic_integration_page/#typical-usage-workflow","title":"Typical Usage Workflow","text":""},{"location":"api/Pages/iic_integration_page/#initialization","title":"Initialization","text":"<pre><code>// 1. Create I2C handle (typically done by backend platform code)\nCFBD_I2CHandle i2c_bus = {\n    .ops = &amp;i2c_stm_operations,      // Backend operations table\n    .private_handle = &amp;i2c_hardware  // Platform-specific state\n};\n\n// 2. Initialize the I2C bus\nint status = CFBD_I2CInit(&amp;i2c_bus);\nif (status != I2C_OK) {\n    // Handle initialization error\n}\n</code></pre>"},{"location":"api/Pages/iic_integration_page/#message-transfer","title":"Message Transfer","text":"<pre><code>// Example: Read from OLED at address 0x3C\nCFBD_I2C_Message msgs[2];\nuint8_t reg_addr = 0x00;  // Register to read\nuint8_t data_buffer[32];  // Read buffer\n\n// Message 1: Write register address\nmsgs[0].addr = 0x3C;\nmsgs[0].flags = 0;\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;reg_addr;\n\n// Message 2: Read data (uses I2C_M_RD flag)\nmsgs[1].addr = 0x3C;\nmsgs[1].flags = I2C_M_RD;\nmsgs[1].len = sizeof(data_buffer);\nmsgs[1].buf = data_buffer;\n\n// Execute combined write-read transaction\nstatus = CFBD_I2CTransfer(&amp;i2c_bus, msgs, 2, 1000);\nif (status == I2C_OK) {\n    // data_buffer now contains read data\n}\n</code></pre>"},{"location":"api/Pages/iic_integration_page/#using-convenience-helpers","title":"Using Convenience Helpers","text":"<pre><code>CFBD_I2C_IORequestParams req = {\n    .addr7 = 0x3C,\n    .mem_addr = 0x10,        // Device internal address\n    .mem_addr_size = 1,      // 1 byte address\n    .data = buffer,\n    .len = sizeof(buffer),\n    .timeout_ms = 1000\n};\n\n// Simple high-level read\nstatus = CFBD_I2CRead(&amp;i2c_bus, &amp;req);\n</code></pre> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Documentation__Summary/","title":"OLED_Documentation_Summary","text":"<p>/**</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Examples/","title":"OLED_Examples","text":"<p>/**</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Namespace/","title":"OLED_Namespace","text":"<p>/**</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Usage__Guide/","title":"OLED_Usage_Guide","text":"<p>/**</p> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/oled_cache_page/","title":"OLED Display Cache Architecture","text":""},{"location":"api/Pages/oled_cache_page/#introduction","title":"Introduction","text":"<p>The OLED cache (framebuffer) is a critical component of the display system. It maintains an off-screen representation of the display content, allowing efficient updates and animations while minimizing I2C traffic.</p>"},{"location":"api/Pages/oled_cache_page/#cache-dimensions","title":"Cache Dimensions","text":"<p>The OLED cache is organized as:</p> <ul> <li>Height: CACHED_HEIGHT = 8 pixels (1 byte in vertical compression)</li> <li>Width: CACHED_WIDTH = 144 pixels</li> <li>Total Pixels: 1152 pixels</li> <li>Memory Layout: Packed vertically (8 pixels per byte)</li> </ul>"},{"location":"api/Pages/oled_cache_page/#memory-layout","title":"Memory Layout","text":"<p>The cache uses a page-based layout common to SSD1306-compatible displays: </p> <pre><code>Byte layout (vertical compression):\nBit 7: Page 0, Row 7\nBit 6: Page 0, Row 6\nBit 5: Page 0, Row 5\nBit 4: Page 0, Row 4\nBit 3: Page 0, Row 3\nBit 2: Page 0, Row 2\nBit 1: Page 0, Row 1\nBit 0: Page 0, Row 0\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#typical-cache-operations","title":"Typical Cache Operations","text":""},{"location":"api/Pages/oled_cache_page/#setting-a-pixel","title":"Setting a Pixel","text":"<pre><code>void set_pixel(int x, int y, int color) {\n    if (x &lt; 0 || x &gt;= CACHED_WIDTH || y &lt; 0 || y &gt;= CACHED_HEIGHT * 8) {\n        return;  // Out of bounds\n    }\n\n    int page = y / 8;      // Which byte (page)\n    int bit = y % 8;       // Which bit within byte\n    int offset = page * CACHED_WIDTH + x;\n\n    if (color) {\n        cache[offset] |= (1 &lt;&lt; bit);   // Set pixel\n    } else {\n        cache[offset] &amp;= ~(1 &lt;&lt; bit);  // Clear pixel\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#updating-display-from-cache","title":"Updating Display from Cache","text":"<pre><code>void display_refresh(void) {\n    for (int page = 0; page &lt; CACHED_HEIGHT; page++) {\n        // Set page address command\n        write_command(0xB0 | page);\n\n        // Write entire page (144 bytes)\n        for (int x = 0; x &lt; CACHED_WIDTH; x++) {\n            int offset = page * CACHED_WIDTH + x;\n            write_data(cache[offset]);\n        }\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory: (CACHED_HEIGHT * 8) * CACHED_WIDTH / 8 bytes = 1152 bytes</li> <li>Update Time: Full refresh ~1-2ms at 400kHz I2C</li> <li>Partial Updates: Recommended for animations (update only changed regions) </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/oled_integration_page/","title":"OLED Driver Integration","text":""},{"location":"api/Pages/oled_integration_page/#introduction","title":"Introduction","text":"<p>This module facilitates platform-specific initialization of OLED displays by providing a standardized initialization parameter structure. It decouples the generic OLED driver from platform-specific details (I2C bus selection, display models, timing parameters, etc.).</p>"},{"location":"api/Pages/oled_integration_page/#integration-flow","title":"Integration Flow","text":""},{"location":"api/Pages/oled_integration_page/#platform-code-boardsystem-initialization","title":"Platform Code (board/system initialization)","text":"<ol> <li>Initialize the I2C bus using platform-specific code</li> <li>Create a <code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md)</code> structure with:<ul> <li>I2C bus handle</li> <li>Device address (0x3C or 0x3D for typical OLED displays)</li> <li>Device-specific callbacks and configuration</li> <li>Optional I2C callback for transaction status</li> </ul> </li> <li>Call OLED driver's init function with the parameters</li> </ol>"},{"location":"api/Pages/oled_integration_page/#typical-platform-initialization","title":"Typical Platform Initialization","text":"<pre><code>// In platform/board initialization code\n\n// Step 1: I2C bus is already initialized\nextern CFBD_I2CHandle i2c1_bus;\n\n// Step 2: Define OLED device specifics (e.g., SSD1306)\nextern CFBD_OLED_DeviceSpecific ssd1306_specs;\n\n// Step 3: Create initialization parameters\nCFBD_OLED_IICInitsParams oled_params = {\n    .i2cHandle = &amp;i2c1_bus,\n    .accepted_time_delay = 1,                // 1 tick delay\n    .device_address = 0x3C,                  // SSD1306 default\n    .device_specifics = &amp;ssd1306_specs,\n    .iic_transition_callback = my_iic_handler\n};\n\n// Step 4: Initialize OLED\nint status = CFBD_OLED_Init(&amp;oled_params);\nif (status != OLED_OK) {\n    // Handle initialization error\n    handle_error();\n}\n</code></pre>"},{"location":"api/Pages/oled_integration_page/#supported-device-models","title":"Supported Device Models","text":"<p>The framework supports multiple OLED controller models through the <code>[CFBD_OLED_DeviceSpecific](Classes/structCFBD__OLED__DeviceSpecific.md)</code> structure:</p> <ul> <li>SSD1306: 128\u00d764 I2C OLED displays</li> <li>SSD1309: Enhanced variant with higher speeds</li> <li>SH1106: Alternative controller (less common)</li> </ul>"},{"location":"api/Pages/oled_integration_page/#callback-pattern","title":"Callback Pattern","text":"<p>The I2C transition callback enables asynchronous notification when I2C transactions complete:</p> <pre><code>void my_iic_handler(int status) {\n    if (status == I2C_OK) {\n        // I2C transaction succeeded\n        signal_display_updated();\n    } else if (status == I2C_ERR_NACK) {\n        // Display not responding\n        log_error(\"Display not found on I2C bus\");\n    } else if (status == I2C_ERR_TIMEOUT) {\n        // Transaction timeout\n        log_error(\"Display I2C timeout\");\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_integration_page/#timing-configuration","title":"Timing Configuration","text":"<p>The <code>accepted_time_delay</code> parameter controls inter-transaction delays. This is useful for:</p> <ul> <li>Allowing display controller time to process commands</li> <li>Pacing rapid consecutive updates</li> <li>Accommodating system scheduler granularity </li> </ul> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"},{"location":"api/Pages/timing_guide/","title":"System Timing and Delay Guide","text":""},{"location":"api/Pages/timing_guide/#overview","title":"Overview","text":"<p>The system clock module provides simple delay primitives for timing-dependent operations in embedded applications. These functions are intentionally minimal to work across diverse platform implementations.</p>"},{"location":"api/Pages/timing_guide/#key-concepts","title":"Key Concepts","text":"<ul> <li>Millisecond delays (<code>system_delay_ms</code>) for longer timing sequences</li> <li>Microsecond delays (<code>system_delay_us</code>) for precise sub-millisecond timing</li> <li>Platform-specific implementation for accuracy and power efficiency</li> </ul>"},{"location":"api/Pages/timing_guide/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Debouncing GPIO inputs</li> <li>Timing I2C/SPI transaction sequences</li> <li>Adding delays between hardware initialization steps</li> <li>Bit-banging protocol timing</li> </ul>"},{"location":"api/Pages/timing_guide/#practical-examples","title":"Practical Examples","text":""},{"location":"api/Pages/timing_guide/#gpio-debouncing","title":"GPIO Debouncing","text":"<pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n#include \"lib/gpio/gpio.h\"\n\nCFBD_Bool read_debounced_button(CFBD_GPIOHandle* button_pin) {\n    // Initial read\n    CFBD_Bool first_read = CFBD_GPIORead(button_pin);\n\n    // Wait for switch to settle\n    system_delay_ms(20);\n\n    // Confirm state hasn't changed\n    CFBD_Bool second_read = CFBD_GPIORead(button_pin);\n    return (first_read == second_read) ? first_read : CFBD_FALSE;\n}\n</code></pre>"},{"location":"api/Pages/timing_guide/#i2c-bus-timing","title":"I2C Bus Timing","text":"<pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\nvoid i2c_bit_banged_start_condition(void) {\n    // SDA and SCL high\n    set_sda_high();\n    set_scl_high();\n    system_delay_us(5);\n\n    // Bring SDA low while SCL is high\n    set_sda_low();\n    system_delay_us(5);\n\n    // Bring SCL low\n    set_scl_low();\n}\n</code></pre>"},{"location":"api/Pages/timing_guide/#platform-considerations","title":"Platform Considerations","text":"<ul> <li>Accuracy: Actual delay may vary depending on system load and interrupt activity</li> <li>Interrupt Safety: Check platform documentation for ISR usage restrictions</li> <li>Power: Consider sleep/standby modes for longer waits</li> <li>Busy-wait: Current implementations typically use busy-wait loops</li> </ul>"},{"location":"api/Pages/timing_guide/#best-practices","title":"Best Practices","text":"<ol> <li>Use millisecond delays for non-critical timing sequences</li> <li>Use microsecond delays only when necessary for precision</li> <li>Avoid calling from interrupt handlers (unless documented as safe)</li> <li>Consider application clock frequency when porting between platforms</li> <li>Combine with hardware timers for more accurate long-duration timing </li> </ol> <p>Updated on 2026-01-10 at 03:19:52 +0000</p>"}]}