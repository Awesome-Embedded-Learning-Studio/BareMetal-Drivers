{"config":{"lang":["zh","en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u5355\u7247\u673a\u57fa\u7840\u5e93\u6587\u6863\u6307\u5357","text":""},{"location":"api/index_classes/","title":"Classes","text":"<ul> <li>struct CCGraphic_Image </li> <li>namespace CFBD Core Framework Bare Device (CFBD) namespace *. <ul> <li>namespace OLED OLED display driver subsystem *. </li> </ul> </li> <li>struct CFBDBootTuple </li> <li>struct CFBDGraphicCircle Represents a circle defined by center point and radius. </li> <li>struct CFBDGraphicRect Represents a rectangle defined by top-left and bottom-right corner points. </li> <li>struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area. </li> <li>struct CFBDGraphic_Line Represents a line segment defined by two endpoints. </li> <li>struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. </li> <li>struct CFBDGraphic_Text </li> <li>struct CFBDGraphic_Triangle Represents a triangle defined by three vertices. </li> <li>struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components. </li> <li>struct CFBD_BaseAnimation Base animation state and configuration. </li> <li>struct CFBD_BaseAnimationOps Operation callbacks for animation timing control. </li> <li>struct CFBD_ButtonCreationPack </li> <li>struct CFBD_DemoDescriptor Demo descriptor structure. </li> <li>struct CFBD_GPIOHandle Public GPIO handle combining platform handle and pin id. </li> <li>struct CFBD_GraphicArc Represents a circular arc defined by center, radius, and angular range. </li> <li>struct CFBD_GraphicDevice The main graphics device object. </li> <li>struct CFBD_GraphicDeviceOperation Virtual operation table for graphics device functionality. </li> <li>struct CFBD_GraphicEllipse Represents an ellipse defined by center point and two radii. </li> <li>struct CFBD_I2CHandle Public I2C handle containing the operations table and private state. </li> <li>struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus. </li> <li>struct CFBD_I2C_IORequestParams Helper structure used by convenience read/write helpers. </li> <li>struct CFBD_I2C_Message Single I2C message description used for multi-message transfers. </li> <li>struct CFBD_IconTextMenuItem </li> <li>struct CFBD_LoggerOperations </li> <li>struct CFBD_MenuItemCallbackPack </li> <li>struct CFBD_MenuOps </li> <li>struct CFBD_NativeLoggerOperations </li> <li>struct CFBD_OLED The generic OLED device object exposed to application code. </li> <li>struct CFBD_OLEDOperations Virtual operation table implementing OLED driver functionality. </li> <li>struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel. </li> <li>struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C. </li> <li>struct CFBD_ProgressBarOps </li> <li>struct CFBD_ST_I2CPrivate Backend-private state for the STM32 I2C implementation. </li> <li>struct CFBD_ST_UARTPrivate </li> <li>struct CFBD_ST_UART_AsyncHelper </li> <li>struct CFBD_UART_AsyncCallbacks As C owns no virtual, we need to filled the function processor by users. </li> <li>struct CFBD_WidgetCreationPack </li> <li>struct CFBD_WidgetOperations </li> <li>struct CFBD_WidgetRequestOverrideOperations </li> <li>struct IntrButtonArrayInfo </li> <li>struct _CFBD_GraphicDevice </li> <li>struct _CFBD_I2CHandle </li> <li>struct _CFBD_I2C_Message </li> <li>struct _CFBD_IconTextMenu </li> <li>struct _CFBD_IconTextMenuOps Operation table for icon-text menu. </li> <li>struct _CFBD_Menu </li> <li>struct _CFBD_OLED </li> <li>struct _CFBD_OLED_OPS </li> <li>struct _CFBD_PlainButton </li> <li>struct _CFBD_UARTHandle </li> <li>struct _CFBD_UARTOperations </li> <li>struct __CFBDApplication Application descriptor. </li> <li>struct __CFBDGraphicCircle </li> <li>struct __CFBDInputDeviceBase </li> <li>struct __CFBDInputDeviceBaseOps </li> <li>struct __CFBDInputEvent </li> <li>struct __CFBDInputEventContext </li> <li>struct __CFBDInputEventContextOperations </li> <li>struct __CFBD_BaseAnimation </li> <li>struct __CFBD_DeviceIDGenerator </li> <li>struct __CFBD_GraphicArc </li> <li>struct __CFBD_GraphicEllipse </li> <li>struct __CFBD_Logger </li> <li>struct __CFBD_MenuIndicator </li> <li>struct __CFBD_MenuItem </li> <li>struct __CFBD_MenuItemArray </li> <li>struct __CFBD_ProgressBar </li> <li>struct __CFBD_Widget Clean and LightWighted Containers for the widget sessions. </li> <li>struct __SSD132XPrivateDatas </li> <li>namespace for </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/index_examples/","title":"Examples","text":"<ul> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/device/oled/oled_graphic_device.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/resource/config.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/animation/animation_config.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/base_support/image.h Initialize an image widget structure. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/icontext_menu.h Initialize icon-text menu widget. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu.h Initialize menu widget structure. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu_indicator.h Initialize menu indicator with default values. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu_item.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/progressbar/progressbar.h Render progress bar immediately. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/text.h Initialize text widget structure. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/text_config.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic_130x.h Initialize an I2C-based OLED device instance. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic_132x.h Initialize an I2C-based OLED device instance. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h Factory function: returns the SSD1306 device-specific descriptor. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h Factory function: returns the SSD1309 device-specific descriptor. </li> <li>example /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h </li> <li>example &gt;: Comprehensive guides and reference documentation </li> <li>example blocks </li> <li>example blocks:\\n </li> <li>example blocks\\n </li> <li>example code </li> <li>example standalone pages </li> <li>example if </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/index_files/","title":"Files","text":"<ul> <li>file Graphics_Complete_Examples.md </li> <li>file Graphics_Complete_UserGuide.md </li> <li>file Graphics_Widget_Documentation.md </li> <li>file OLED_Documentation_Summary.md </li> <li>file OLED_Examples.md </li> <li>file OLED_Namespace.md </li> <li>file OLED_Usage_Guide.md </li> <li>file animation_config.h Configuration parameters for the animation framework. </li> <li>file circle.c </li> <li>file circle.h Circle geometry and drawing function declarations. </li> <li>file ellipse.c </li> <li>file ellipse.h Ellipse drawing utilities for 2D graphics rendering. </li> <li>dir lib <ul> <li>dir lib/application <ul> <li>file c </li> <li>file h Application descriptor and clock/boot provider interfaces. </li> <li>dir lib/application/sys_boot <ul> <li>file c </li> <li>file h Boot / startup helpers and types for application bootstrap sequence. </li> </ul> </li> <li>dir lib/application/sys_clock <ul> <li>file c </li> <li>file h System timing primitives and delay helpers. </li> </ul> </li> </ul> </li> <li>dir lib/config <ul> <li>file h Emergency halt helper used when unrecoverable errors occur. </li> <li>file h Core type and macro definitions used across CFBD libraries. </li> <li>file h </li> </ul> </li> <li>dir lib/gpio <ul> <li>file c </li> <li>file h STM32 specific GPIO implementation details for CFBD. </li> <li>file h GPIO abstraction and helpers used by platform and application code. </li> </ul> </li> <li>dir lib/graphic <ul> <li>file h Core graphics type definitions and forward declarations. </li> <li>dir lib/graphic/base <ul> <li>file c </li> <li>file h Arc geometry and drawing prototypes for the graphics subsystem. </li> </ul> </li> <li>dir lib/graphic/benchmark <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/device <ul> <li>file c </li> <li>dir lib/graphic/device/oled <ul> <li>file c </li> <li>file h OLED device binding for the graphics subsystem. </li> </ul> </li> </ul> </li> <li>dir lib/graphic/fast_test <ul> <li>dir lib/graphic/fast_test/demo_support <ul> <li>file c </li> <li>file h Generic demo manager for CFBD-based embedded GUI demonstrations. </li> </ul> </li> <li>dir lib/graphic/fast_test/demos <ul> <li>dir lib/graphic/fast_test/demos/demo_end_screen <ul> <li>file c Final demo end screen. </li> </ul> </li> <li>dir lib/graphic/fast_test/demos/demo_icontext_menu <ul> <li>file c Icon-text menu demonstration (OOP C \u98ce\u683c) </li> <li>file c </li> </ul> </li> <li>dir lib/graphic/fast_test/demos/demo_progressbar <ul> <li>file c Progress bar widget demonstration. </li> </ul> </li> <li>dir lib/graphic/fast_test/demos/demo_text <ul> <li>file c </li> </ul> </li> </ul> </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/graphic/resource <ul> <li>file h Graphics resource configuration and feature toggles. </li> <li>dir lib/graphic/resource/default <ul> <li>file c </li> <li>file c </li> </ul> </li> </ul> </li> <li>dir lib/graphic/widget <ul> <li>dir lib/graphic/widget/animation <ul> <li>file c </li> </ul> </li> <li>dir lib/graphic/widget/base_support <ul> <li>file c </li> <li>file h Image widget for rendering bitmap graphics. </li> <li>dir lib/graphic/widget/base_support/common </li> </ul> </li> <li>dir lib/graphic/widget/menu <ul> <li>file c Icon-text menu widget implementation. </li> <li>file h Icon-text menu widget for scrollable menu display. </li> <li>file c </li> <li>file h Menu widget for hierarchical item selection. </li> <li>file h Menu widget compile-time configuration. </li> <li>file c </li> <li>file h Menu indicator widget for visual selection feedback. </li> <li>file c </li> <li>file h Menu item widget for menu selection options. </li> </ul> </li> <li>dir lib/graphic/widget/progressbar <ul> <li>file c </li> <li>file h Progress bar widget for progress visualization. </li> </ul> </li> <li>dir lib/graphic/widget/widget <ul> <li>file c </li> <li>file h </li> <li>file h Old days designs adapters. </li> </ul> </li> <li>file c </li> <li>file h Text widget for rendering ASCII text strings. </li> <li>file c </li> <li>file h Text widget font configuration and selection. </li> </ul> </li> </ul> </li> <li>dir lib/iic <ul> <li>file c </li> <li>file h I2C (IIC) abstraction layer for CFBD drivers. </li> <li>file h I2C/IIC error codes used by the CFBD I2C abstraction. </li> <li>dir lib/iic/backend <ul> <li>file c </li> <li>file h STM32 HAL-based I2C backend private types and helpers. </li> </ul> </li> </ul> </li> <li>dir lib/input <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> <li>dir lib/input/button_like <ul> <li>dir lib/input/button_like/stm_hal_series <ul> <li>file c </li> </ul> </li> <li>file c </li> <li>file h </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/logger <ul> <li>file c </li> <li>file h </li> <li>file h </li> <li>dir lib/logger/uart_adapts <ul> <li>file c </li> <li>file h </li> </ul> </li> </ul> </li> <li>dir lib/oled <ul> <li>dir lib/oled/configs <ul> <li>file h </li> <li>file h </li> <li>file h External (platform/application) implementation hooks for OLED driver. </li> <li>file h </li> </ul> </li> <li>dir lib/oled/driver <ul> <li>dir lib/oled/driver/backend <ul> <li>file c </li> <li>file h </li> <li>file c </li> <li>file h </li> </ul> </li> <li>dir lib/oled/driver/device <ul> <li>file h Generic device descriptor used by OLED drivers. </li> <li>dir lib/oled/driver/device/ssd1306 <ul> <li>file c </li> <li>file h SSD1306 device-specific descriptor and factory. </li> </ul> </li> <li>dir lib/oled/driver/device/ssd1309 <ul> <li>file c </li> <li>file h SSD1309 device-specific descriptor and factory. </li> </ul> </li> <li>dir lib/oled/driver/device/ssd1327 <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>file h </li> </ul> </li> </ul> </li> <li>file c </li> <li>file h Generic OLED object and operations exposed to application code. </li> <li>file c </li> </ul> </li> <li>dir lib/uart <ul> <li>dir lib/uart/backend <ul> <li>file c </li> <li>file h </li> </ul> </li> <li>file h </li> </ul> </li> </ul> </li> <li>file line.c </li> <li>file line.h Line drawing utilities for 2D graphics rendering. </li> <li>file point.h Point and Vector data structures and utility functions for 2D graphics. </li> <li>file rectangle.c </li> <li>file size.c </li> <li>file size.h Size data structure and utilities for 2D graphics. </li> <li>file triangle.c </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/index_groups/","title":"Modules","text":"<ul> <li>group Application Management Application-level bootstrap and clock providers. </li> <li>group Arc Drawing </li> <li>group Graphic Base Helpers </li> <li>group Boot Minimal boot/bootstrap types and helpers. </li> <li>group Core Definitions Small portable types and macros used throughout the project. </li> <li>group I2C Backend Implementation Backend implementation interface for I2C drivers. </li> <li>group I2C/IIC Error Codes Standard error codes for I2C operations. </li> <li>group I2C High-Level Helpers Convenience functions for common I2C operations. </li> <li>group I2C Inline Wrappers Convenience inline functions for I2C operations. </li> <li>group OLED Display Cache Configuration OLED display framebuffer dimensions and settings. </li> <li>group OLED Display Integration OLED driver initialization and platform integration. </li> <li>group Circle Drawing </li> <li>group Core System Utilities System-level utilities for error handling and emergency states. </li> <li>group Ellipse Drawing </li> <li>group Animation Framework Frame-based animation system for graphics widgets. </li> <li>group Graphics Core Definitions Fundamental type definitions for graphics system. </li> <li>group Graphics Device Abstraction Generic graphics device interface and operations. <ul> <li>group OLED Graphics Device Adapter OLED-specific graphics device implementation. </li> </ul> </li> <li>group Graphics Utility Helpers Utility macros and functions for graphics operations. </li> <li>group Menu Configuration Configuration parameters for menu widget appearance. </li> <li>group Graphics Resources Resource management and configuration for graphics subsystem. </li> <li>group Text Widget System Text rendering and typography system. <ul> <li>group Text Configuration Font size and text rendering configuration. </li> </ul> </li> <li>group Icon-Text Menu Widget Horizontal scrollable menu for icon+text display. </li> <li>group Line Drawing </li> <li>group OLED Display Driver <ul> <li>group OLED Backend Implementations Backend transport implementations (I2C, SPI) for OLED drivers. </li> <li>group OLED Device Interface Device-specific descriptors and configurations for OLED drivers. </li> </ul> </li> <li>group Point Utilities </li> <li>group Rectangle Operations <ul> <li>group Rectangle Normalization Utilities for normalizing rectangle corner points. <ul> <li>group Advanced Rectangle Operations Complex rectangle manipulation and analysis functions. </li> <li>group Anchor Flags Flags for specifying rectangle alignment anchors. </li> <li>group Point and Rectangle Containment Functions to check containment and intersection relationships. </li> <li>group Rectangle Format Conversion Conversion between different rectangle representations. </li> <li>group Rectangle Dimensions Functions to calculate rectangle dimensions. </li> </ul> </li> </ul> </li> <li>group Size Utilities </li> <li>group System Clock and Timing Short blocking delay primitives for timing operations. </li> <li>group Triangle Drawing </li> <li>group new module concepts </li> <li>group &gt;: Hierarchical organization of related components </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/index_namespaces/","title":"Namespaces","text":"<ul> <li>namespace CFBD Core Framework Bare Device (CFBD) namespace *. <ul> <li>namespace OLED OLED display driver subsystem *. </li> </ul> </li> <li>namespace for </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/index_pages/","title":"Pages","text":"<ul> <li>page &gt;: Comprehensive guides and reference documentation </li> <li>page Arc Drawing and Geometry Guide Comprehensive guide to arc drawing and sector rendering. </li> <li>page Graphic Base Helpers User Guide Guide to using numeric conversion and clamping helpers. </li> <li>page Circle Drawing and Geometry Guide Comprehensive guide to drawing circles using the graphics library. </li> <li>page Graphics Framework - Complete Code Examples </li> <li>page Graphics Framework - Complete User Guide </li> <li>page Graphics Widget Documentation Summary </li> <li>page OLED Documentation Summary </li> <li>page OLED Driver Examples </li> <li>page OLED Driver Usage Guide </li> <li>page Application Initialization and Setup </li> <li>page Boot System Design Overview of the Boot System. </li> <li>page Core Types and Definitions Guide </li> <li>page for Pages tab\\n </li> <li>page Error Handling Guide </li> <li>page standalone pages </li> <li>page I2C Error Handling Comprehensive Guide to I2C Error Codes and Recovery. </li> <li>page I2C Integration Guide How to Integrate I2C Devices with the CFBD I2C Abstraction. </li> <li>page Graphics_Complete_Examples </li> <li>page Graphics_Complete_UserGuide </li> <li>page Graphics_Widget_Documentation </li> <li>page OLED_Documentation_Summary </li> <li>page OLED_Examples </li> <li>page OLED_Namespace </li> <li>page OLED_Usage_Guide </li> <li>page OLED Display Cache Architecture Design and Management of OLED Display Framebuffer. </li> <li>page OLED Driver Integration Platform Integration and Initialization for OLED Displays. </li> <li>page System Timing and Delay Guide </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCCGraphic__Image/","title":"CCGraphic_Image","text":"<p><code>#include &lt;image.h&gt;</code></p>"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point point Top-left position of image in pixels. CFBDGraphicSize image_size Dimensions of image in pixels. uint8_t * sources_register Pointer to bitmap data (owned by caller)"},{"location":"api/Classes/structCCGraphic__Image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCCGraphic__Image/#variable-point","title":"variable point","text":"<pre><code>CFBDGraphic_Point point;\n</code></pre> <p>Top-left position of image in pixels. </p>"},{"location":"api/Classes/structCCGraphic__Image/#variable-image_size","title":"variable image_size","text":"<pre><code>CFBDGraphicSize image_size;\n</code></pre> <p>Dimensions of image in pixels. </p>"},{"location":"api/Classes/structCCGraphic__Image/#variable-sources_register","title":"variable sources_register","text":"<pre><code>uint8_t * sources_register;\n</code></pre> <p>Pointer to bitmap data (owned by caller) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDBootTuple/","title":"CFBDBootTuple","text":"<p>Module: Boot</p> <p><code>#include &lt;boot.h&gt;</code></p>"},{"location":"api/Classes/structCFBDBootTuple/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc boot_func Pointer to the bootstrap function to invoke. CFBD_BootArgs args Opaque pointer passed to <code>boot_func</code> when invoked."},{"location":"api/Classes/structCFBDBootTuple/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDBootTuple/#variable-boot_func","title":"variable boot_func","text":"<pre><code>CFBD_BootStrapFunc boot_func;\n</code></pre> <p>Pointer to the bootstrap function to invoke. </p> <p>Must conform to the <code>CFBD_BootStrapFunc</code> contract: accept a <code>CFBD_BootArgs</code> and return <code>CFBD_Bool</code>. </p>"},{"location":"api/Classes/structCFBDBootTuple/#variable-args","title":"variable args","text":"<pre><code>CFBD_BootArgs args;\n</code></pre> <p>Opaque pointer passed to <code>boot_func</code> when invoked. </p> <p>Interpretation of this pointer is implementation-defined and must match what the <code>boot_func</code> expects. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphicCircle/","title":"CFBDGraphicCircle","text":"<p>Module: Circle Drawing</p> <p>Represents a circle defined by center point and radius.  More...</p> <p><code>#include &lt;circle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicCircle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicCircle;\n</code></pre> <p>Represents a circle defined by center point and radius. </p> <p>This structure describes a perfect circle in 2D screen space. The circle is defined mathematically as the set of all points at a fixed distance (radius) from the center point.</p> <p>Circle rendering is performed using efficient integer-based algorithms suitable for embedded displays. The radius should typically be in the range 1-500 pixels for best performance on standard displays. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphicRect/","title":"CFBDGraphicRect","text":"<p>Module: Rectangle Operations</p> <p>Represents a rectangle defined by top-left and bottom-right corner points.  More...</p> <p><code>#include &lt;rectangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicRect/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicRect;\n</code></pre> <p>Represents a rectangle defined by top-left and bottom-right corner points. </p> <p>This structure defines a rectangular region using two diagonal corner points. The corners do not need to be in any particular order; the rect_normalize() function can be used to ensure consistent corner positioning.</p> <p>The rectangle is defined by:</p> <ul> <li><code>tl</code> (top-left): One corner of the rectangle</li> <li><code>br</code> (bottom-right): The diagonal corner of the rectangle</li> </ul> <p>Key properties:</p> <ul> <li>Corners can be specified in any order (will be normalized if needed)</li> <li>Supports all standard rectangle operations (area, width, height, intersection, etc.)</li> <li>Can be empty (zero width or height)</li> <li>Coordinates are clamped to valid range by device driver </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphicSize/","title":"CFBDGraphicSize","text":"<p>Module: Size Utilities</p> <p>Represents dimensions (width and height) of a rectangular area.  More...</p> <p><code>#include &lt;size.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType width SizeBaseType height"},{"location":"api/Classes/structCFBDGraphicSize/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphicSize;\n</code></pre> <p>Represents dimensions (width and height) of a rectangular area. </p> <p>This structure defines the size of a 2D object using width and height components. It is commonly used in conjunction with position information to define layout and rendering areas for UI elements and graphics.</p> <p>The size is defined by:</p> <ul> <li><code>width:</code> The horizontal dimension in pixels</li> <li><code>height:</code> The vertical dimension in pixels</li> </ul> <p>Both dimensions use SizeBaseType (typically uint16_t) for efficient storage and fast computation on embedded systems. </p>"},{"location":"api/Classes/structCFBDGraphicSize/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphicSize/#variable-width","title":"variable width","text":"<pre><code>SizeBaseType width;\n</code></pre> <p>The width of the size in pixels </p>"},{"location":"api/Classes/structCFBDGraphicSize/#variable-height","title":"variable height","text":"<pre><code>SizeBaseType height;\n</code></pre> <p>The height of the size in pixels </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Line/","title":"CFBDGraphic_Line","text":"<p>Module: Line Drawing</p> <p>Represents a line segment defined by two endpoints.  More...</p> <p><code>#include &lt;line.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p_left CFBDGraphic_Point p_right"},{"location":"api/Classes/structCFBDGraphic__Line/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Line;\n</code></pre> <p>Represents a line segment defined by two endpoints. </p> <p>This structure defines a line in 2D space using two points. The line segment extends from the left endpoint to the right endpoint, and can be used for rendering, collision detection, and geometric calculations.</p> <p>The naming convention \"left\" and \"right\" refers to the logical order of the endpoints rather than spatial positioning. The endpoints can be at any position, including when p_left is spatially to the right of p_right. </p>"},{"location":"api/Classes/structCFBDGraphic__Line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_left","title":"variable p_left","text":"<pre><code>CFBDGraphic_Point p_left;\n</code></pre> <p>The left endpoint of the line segment </p>"},{"location":"api/Classes/structCFBDGraphic__Line/#variable-p_right","title":"variable p_right","text":"<pre><code>CFBDGraphic_Point p_right;\n</code></pre> <p>The right endpoint of the line segment </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Point/","title":"CFBDGraphic_Point","text":"<p>Module: Point Utilities</p> <p>Represents a 2D point in the graphics coordinate system.  More...</p> <p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes","title":"Public Attributes","text":"Name PointBaseType x PointBaseType y"},{"location":"api/Classes/structCFBDGraphic__Point/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Point;\n</code></pre> <p>Represents a 2D point in the graphics coordinate system. </p> <p>This structure defines a point in 2D space with unsigned 16-bit coordinates. It is used throughout the graphics module for positioning and drawing operations.</p> <p>The coordinates are limited to the range [0, UINT16_MAX] by the PointBaseType definition. This allows for efficient storage and computation on embedded systems. </p>"},{"location":"api/Classes/structCFBDGraphic__Point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Point/#variable-x","title":"variable x","text":"<pre><code>PointBaseType x;\n</code></pre> <p>X-coordinate of the point </p>"},{"location":"api/Classes/structCFBDGraphic__Point/#variable-y","title":"variable y","text":"<pre><code>PointBaseType y;\n</code></pre> <p>Y-coordinate of the point </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Text/","title":"CFBDGraphic_Text","text":"<p>Module: Text Widget System</p> <p><code>#include &lt;text.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes","title":"Public Attributes","text":"Name char * sources_borrowed Text string pointer (borrowed - caller owns memory) CFBDGraphic_Point tl_point Top-left corner position of text area in pixels. CFBDGraphic_Point indexed_point Current position for next character (internal state) CFBDGraphicSize TexthandleSize Allocated size of text rendering area (width x height) in pixels. Ascii_Font_Size font_size Selected font size for text rendering. CFBDGraphicRect text_bounding_rect Bounding rectangle of rendered text (calculated during draw) CFBD_Bool no_wrap"},{"location":"api/Classes/structCFBDGraphic__Text/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Text/#variable-sources_borrowed","title":"variable sources_borrowed","text":"<pre><code>char * sources_borrowed;\n</code></pre> <p>Text string pointer (borrowed - caller owns memory) </p> <p>Zero-terminated C string, must remain valid during rendering </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre> <p>Top-left corner position of text area in pixels. </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-indexed_point","title":"variable indexed_point","text":"<pre><code>CFBDGraphic_Point indexed_point;\n</code></pre> <p>Current position for next character (internal state) </p> <p>Tracks insertion point during multiline rendering </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-texthandlesize","title":"variable TexthandleSize","text":"<pre><code>CFBDGraphicSize TexthandleSize;\n</code></pre> <p>Allocated size of text rendering area (width x height) in pixels. </p> <p>Constrains text layout and line wrapping </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-font_size","title":"variable font_size","text":"<pre><code>Ascii_Font_Size font_size;\n</code></pre> <p>Selected font size for text rendering. </p> <p>Determines character dimensions (6x8 or 8x16 pixels) </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-text_bounding_rect","title":"variable text_bounding_rect","text":"<pre><code>CFBDGraphicRect text_bounding_rect;\n</code></pre> <p>Bounding rectangle of rendered text (calculated during draw) </p>"},{"location":"api/Classes/structCFBDGraphic__Text/#variable-no_wrap","title":"variable no_wrap","text":"<pre><code>CFBD_Bool no_wrap;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/","title":"CFBDGraphic_Triangle","text":"<p>Module: Triangle Drawing</p> <p>Represents a triangle defined by three vertices.  More...</p> <p><code>#include &lt;triangle.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point p1 CFBDGraphic_Point p2 CFBDGraphic_Point p3"},{"location":"api/Classes/structCFBDGraphic__Triangle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Triangle;\n</code></pre> <p>Represents a triangle defined by three vertices. </p> <p>This structure defines a triangle in 2D space using three corner points. Triangles are fundamental geometric shapes used for creating complex graphics, UI elements, and efficient polygon rendering through triangulation.</p> <p>The triangle is defined by:</p> <ul> <li><code>p1:</code> First vertex of the triangle</li> <li><code>p2:</code> Second vertex of the triangle</li> <li><code>p3:</code> Third vertex of the triangle</li> </ul> <p>The vertices can be specified in any order. For consistent rendering and efficient backface culling, vertices are typically ordered counter-clockwise.</p> <p>Key properties:</p> <ul> <li>Vertices can form acute, obtuse, or right triangles</li> <li>Degenerate triangles (collinear points) result in no visible output</li> <li>Rendering may use barycentric interpolation for shading </li> </ul>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p1","title":"variable p1","text":"<pre><code>CFBDGraphic_Point p1;\n</code></pre> <p>First vertex of the triangle </p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p2","title":"variable p2","text":"<pre><code>CFBDGraphic_Point p2;\n</code></pre> <p>Second vertex of the triangle </p>"},{"location":"api/Classes/structCFBDGraphic__Triangle/#variable-p3","title":"variable p3","text":"<pre><code>CFBDGraphic_Point p3;\n</code></pre> <p>Third vertex of the triangle </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/","title":"CFBDGraphic_Vec2i","text":"<p>Module: Point Utilities</p> <p>Represents a 2D vector with signed 32-bit integer components.  More...</p> <p><code>#include &lt;point.h&gt;</code></p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes","title":"Public Attributes","text":"Name int32_t x int32_t y"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBDGraphic_Vec2i;\n</code></pre> <p>Represents a 2D vector with signed 32-bit integer components. </p> <p>This structure is used for vector operations that may result in negative values, such as the difference between two points. The use of 32-bit signed integers allows for proper representation of negative displacements. </p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-x","title":"variable x","text":"<pre><code>int32_t x;\n</code></pre> <p>X-component of the vector </p>"},{"location":"api/Classes/structCFBDGraphic__Vec2i/#variable-y","title":"variable y","text":"<pre><code>int32_t y;\n</code></pre> <p>Y-component of the vector </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__BaseAnimation/","title":"CFBD_BaseAnimation","text":"<p>Module: Animation Framework</p> <p>Base animation state and configuration.  More...</p> <p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__BaseAnimation/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_BaseAnimation;\n</code></pre> <p>Base animation state and configuration. </p> <p>This structure maintains the animation state including the number of frames and delay per frame. It is the core data structure for managing animation timing and progression.</p> <p>Typical usage:</p> <ol> <li>Initialize with CFBD_InitBaseAnimation()</li> <li>Configure anim_frames and anim_frame_delay_ms as needed</li> <li>Use in conjunction with animation callbacks</li> <li>Query anim_frames to compute animation progress </li> </ol> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/","title":"CFBD_BaseAnimationOps","text":"<p>Module: Animation Framework</p> <p>Operation callbacks for animation timing control.  More...</p> <p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(uint32_t ms) delay_ms"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_BaseAnimationOps;\n</code></pre> <p>Operation callbacks for animation timing control. </p> <p>This structure contains function pointers for animation operations, particularly timing and delay management. Applications can provide custom implementations for different delay mechanisms. </p>"},{"location":"api/Classes/structCFBD__BaseAnimationOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__BaseAnimationOps/#variable-delay_ms","title":"variable delay_ms","text":"<pre><code>void(*)(uint32_t ms) delay_ms;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/","title":"CFBD_ButtonCreationPack","text":"<p><code>#include &lt;plain_button.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#public-attributes","title":"Public Attributes","text":"Name CFBD_GPIOHandle * gpio CFBDEventInputHandler callbacks CFBDInputEventContext * input_context CFBD_Bool button_press_state CFBD_Bool isInterruptMode void(*)(CFBD_PlainButton *button) enable_intr"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-gpio","title":"variable gpio","text":"<pre><code>CFBD_GPIOHandle * gpio;\n</code></pre>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-callbacks","title":"variable callbacks","text":"<pre><code>CFBDEventInputHandler callbacks;\n</code></pre>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-input_context","title":"variable input_context","text":"<pre><code>CFBDInputEventContext * input_context;\n</code></pre>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-button_press_state","title":"variable button_press_state","text":"<pre><code>CFBD_Bool button_press_state;\n</code></pre>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-isinterruptmode","title":"variable isInterruptMode","text":"<pre><code>CFBD_Bool isInterruptMode;\n</code></pre>"},{"location":"api/Classes/structCFBD__ButtonCreationPack/#variable-enable_intr","title":"variable enable_intr","text":"<pre><code>void(*)(CFBD_PlainButton *button) enable_intr;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__DemoDescriptor/","title":"CFBD_DemoDescriptor","text":"<p>Demo descriptor structure. </p> <p><code>#include &lt;demo_manager.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__DemoDescriptor/#public-attributes","title":"Public Attributes","text":"Name const char * name CFBD_DemoEntry entry uint32_t duration"},{"location":"api/Classes/structCFBD__DemoDescriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__DemoDescriptor/#variable-name","title":"variable name","text":"<pre><code>const char * name;\n</code></pre> <p>Human-readable demo name </p>"},{"location":"api/Classes/structCFBD__DemoDescriptor/#variable-entry","title":"variable entry","text":"<pre><code>CFBD_DemoEntry entry;\n</code></pre> <p>Demo entry function </p>"},{"location":"api/Classes/structCFBD__DemoDescriptor/#variable-duration","title":"variable duration","text":"<pre><code>uint32_t duration;\n</code></pre> <p>Duration in milliseconds (0 = infinite) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__GPIOHandle/","title":"CFBD_GPIOHandle","text":"<p>Public GPIO handle combining platform handle and pin id.  More...</p> <p><code>#include &lt;gpio.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes","title":"Public Attributes","text":"Name GPIO_TypeHandle handle_internals_ Platform-specific handle or peripheral pointer. GPIO_PinType pin_internals_ Platform-specific pin identifier (see <code>GPIO_PinType</code>)."},{"location":"api/Classes/structCFBD__GPIOHandle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GPIOHandle;\n</code></pre> <p>Public GPIO handle combining platform handle and pin id. </p> <p>This small POD aggregates a platform handle and a pin identifier. It is the primary handle passed to the GPIO API. The <code>handle_internals_</code> field contains the backend-specific state while <code>pin_internals_</code> identifies which pin to operate on. </p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-handle_internals_","title":"variable handle_internals_","text":"<pre><code>GPIO_TypeHandle handle_internals_;\n</code></pre> <p>Platform-specific handle or peripheral pointer. </p>"},{"location":"api/Classes/structCFBD__GPIOHandle/#variable-pin_internals_","title":"variable pin_internals_","text":"<pre><code>GPIO_PinType pin_internals_;\n</code></pre> <p>Platform-specific pin identifier (see <code>GPIO_PinType</code>). </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicArc/","title":"CFBD_GraphicArc","text":"<p>Module: Arc Drawing</p> <p>Represents a circular arc defined by center, radius, and angular range.  More...</p> <p><code>#include &lt;arc.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicArc/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GraphicArc;\n</code></pre> <p>Represents a circular arc defined by center, radius, and angular range. </p> <p>An arc is a portion of a circle specified by a center point, radius, and a pair of angles defining the start and end of the arc.</p> <p>Arc definition:</p> <ul> <li>center: The center point of the circle from which the arc is drawn</li> <li>radius: Distance from center to the arc edge, in device units</li> <li>start_degree: Starting angle in degrees (0-359)</li> <li>end_degree: Ending angle in degrees (0-359)</li> </ul> <p>Angular convention:</p> <ul> <li>0\u00b0 points horizontally right (3 o'clock)</li> <li>Positive angles sweep counter-clockwise</li> <li>Angles are automatically normalized to [0, 359]</li> <li>If start_degree &gt; end_degree, the arc wraps around 0\u00b0 </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicDevice/","title":"CFBD_GraphicDevice","text":"<p>Module: Graphics Device Abstraction</p> <p>The main graphics device object.  More...</p> <p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicDevice/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GraphicDevice;\n</code></pre> <p>The main graphics device object. </p> <p>Note: The internal_handle is opaque and device-specific; do not access it directly. </p> <p>This structure represents a graphics rendering device and encapsulates the operation table, device type, internal state, and drawing mode settings. Application code interacts with devices through this structure.</p> <p>Typical usage flow:</p> <ol> <li>Initialize device via CFBDGraphic_BindDevice()</li> <li>Open device via ops-&gt;open()</li> <li>Perform drawing operations</li> <li>Update display via ops-&gt;update()</li> <li>Close device via ops-&gt;close()</li> </ol> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/","title":"CFBD_GraphicDeviceOperation","text":"<p>Module: Graphics Device Abstraction</p> <p>Virtual operation table for graphics device functionality.  More...</p> <p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_GraphicDevice *device, void *init_args) init Initialize the graphics device. CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel Set a single pixel at (x, y) to the active drawing color. CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea Write a block of pixel data to a rectangular area. GraphicFrameOperation update Push the local frame buffer to the display. GraphicFrameOperation clear Clear the entire display and frame buffer. GraphicFrameOperation revert Revert to the previous frame content (if supported). GraphicAreaOperations update_area Update a rectangular area on the display. GraphicAreaOperations clear_area Clear a rectangular area on the display and buffer. GraphicAreaOperations revert_area Revert a rectangular area to its previous content. GraphicOLEDSelfOperation open Open/enable the graphics device. GraphicOLEDSelfOperation close Close/disable the graphics device. GraphicOLED_QueryOperation self_consult Query device properties and capabilities. GraphicOLED_PropertySetsOperation self_sets Set the properties for devices supports."},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GraphicDeviceOperation;\n</code></pre> <p>Virtual operation table for graphics device functionality. </p> <p>Note: All function pointers must be non-NULL unless explicitly documented otherwise. </p> <p>This structure defines the complete interface for graphics rendering operations. Device implementations populate this table with concrete implementations tailored to specific hardware capabilities.</p> <p>The operation table provides:</p> <ul> <li>Device initialization and lifecycle management</li> <li>Pixel and area rendering operations</li> <li>Frame-level update, clear, and revert operations</li> <li>Device property queries</li> </ul>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_GraphicDevice *device, void *init_args) init;\n</code></pre> <p>Initialize the graphics device. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>init_args Optional device-specific initialization arguments. </li> </ul> <p>Return: int Status code; typically 0 for success, negative for errors. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y) setPixel;\n</code></pre> <p>Set a single pixel at (x, y) to the active drawing color. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>x X coordinate of the pixel. </li> <li>y Y coordinate of the pixel. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre> <p>Write a block of pixel data to a rectangular area. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>x X coordinate of the area's top-left corner. </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. </li> <li>height Height of the area in pixels. </li> <li>source Pointer to source pixel data. Format is device-dependent. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update","title":"variable update","text":"<pre><code>GraphicFrameOperation update;\n</code></pre> <p>Push the local frame buffer to the display. </p> <p>Synchronizes the local frame buffer with the physical display, making all buffered changes visible. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear","title":"variable clear","text":"<pre><code>GraphicFrameOperation clear;\n</code></pre> <p>Clear the entire display and frame buffer. </p> <p>Clears all pixels by writing zero/off states to all display locations. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert","title":"variable revert","text":"<pre><code>GraphicFrameOperation revert;\n</code></pre> <p>Revert to the previous frame content (if supported). </p> <p>Not all devices support frame revert; may return CFBD_FALSE if unavailable. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-update_area","title":"variable update_area","text":"<pre><code>GraphicAreaOperations update_area;\n</code></pre> <p>Update a rectangular area on the display. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-clear_area","title":"variable clear_area","text":"<pre><code>GraphicAreaOperations clear_area;\n</code></pre> <p>Clear a rectangular area on the display and buffer. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-revert_area","title":"variable revert_area","text":"<pre><code>GraphicAreaOperations revert_area;\n</code></pre> <p>Revert a rectangular area to its previous content. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-open","title":"variable open","text":"<pre><code>GraphicOLEDSelfOperation open;\n</code></pre> <p>Open/enable the graphics device. </p> <p>Powers on the device and prepares it for rendering operations. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-close","title":"variable close","text":"<pre><code>GraphicOLEDSelfOperation close;\n</code></pre> <p>Close/disable the graphics device. </p> <p>Powers off the device and releases hardware resources. </p>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-self_consult","title":"variable self_consult","text":"<pre><code>GraphicOLED_QueryOperation self_consult;\n</code></pre> <p>Query device properties and capabilities. </p> <p>Supported standard properties:</p> <ul> <li>\"width\" (uint16_t): Display width in pixels</li> <li>\"height\" (uint16_t): Display height in pixels</li> <li>\"rgb\" (CFBD_Bool): RGB color support indicator </li> </ul>"},{"location":"api/Classes/structCFBD__GraphicDeviceOperation/#variable-self_sets","title":"variable self_sets","text":"<pre><code>GraphicOLED_PropertySetsOperation self_sets;\n</code></pre> <p>Set the properties for devices supports. </p> <ul> <li>\"color\": if the devices supports color, thats it :) </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__GraphicEllipse/","title":"CFBD_GraphicEllipse","text":"<p>Module: Ellipse Drawing</p> <p>Represents an ellipse defined by center point and two radii.  More...</p> <p><code>#include &lt;ellipse.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__GraphicEllipse/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_GraphicEllipse;\n</code></pre> <p>Represents an ellipse defined by center point and two radii. </p> <p>This structure defines an ellipse in 2D space using a center point and separate radii for the X and Y axes. This allows for efficient rendering of circles (when X_Radius == Y_Radius) and ellipses with arbitrary dimensions.</p> <p>The ellipse is defined by:</p> <ul> <li>A center point (center)</li> <li>Horizontal radius extending from center along X-axis (X_Radius)</li> <li>Vertical radius extending from center along Y-axis (Y_Radius)</li> </ul> <p>The rendering is typically done using the Midpoint Ellipse Algorithm, which provides accurate rasterization with good performance. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__I2CHandle/","title":"CFBD_I2CHandle","text":"<p>Public I2C handle containing the operations table and private state.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2CHandle/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2CHandle;\n</code></pre> <p>Public I2C handle containing the operations table and private state. </p> <p>Par: Example - Initializing an I2C Handle</p> <pre><code>// Backend (e.g., STM32) provides its operations\nextern const CFBD_I2COperations stm32_i2c_ops;\nextern void *i2c1_private_state;\n\n// Initialize handle\nCFBD_I2CHandle bus = {\n    .ops = &amp;stm32_i2c_ops,\n    .private_handle = i2c1_private_state\n};\n\n// Now ready for use\nCFBD_I2CInit(&amp;bus);\n</code></pre> <p>Represents a complete I2C bus instance combining platform-independent operations with platform-specific state.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__I2COperations/","title":"CFBD_I2COperations","text":"<p>Module: I2C Backend Implementation</p> <p>Function table that a backend must implement to drive an I2C bus.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_I2CHandle *handle) init Initialize the I2C hardware/peripheral. int(*)(CFBD_I2CHandle *handle) deinit Deinitialize the I2C hardware/peripheral. int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer Perform a sequence of I2C messages. int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready Check whether a device is ready (acknowledges) within trials. int(*)(CFBD_I2CHandle *bus) recover_bus Attempt to recover the I2C bus (clock recovery, toggling lines). int(*)(CFBD_I2CHandle *bus) get_error Retrieve the last backend-specific error code. int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start Initiate DMA transmission (optional). int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start Initiate DMA reception (optional)."},{"location":"api/Classes/structCFBD__I2COperations/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2COperations;\n</code></pre> <p>Function table that a backend must implement to drive an I2C bus. </p> <p>Backends populate this table with pointers to concrete functions that implement initialization, transfers and optional DMA operations. This design enables pluggable I2C backends (STM32, ESP32, etc.) while maintaining a unified public interface. </p>"},{"location":"api/Classes/structCFBD__I2COperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2COperations/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) init;\n</code></pre> <p>Initialize the I2C hardware/peripheral. </p> <p>Return: I2C_OK on success, or negative error code on failure </p> <p>Called once during system startup to configure clock, pins, and I2C peripheral registers.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-deinit","title":"variable deinit","text":"<pre><code>int(*)(CFBD_I2CHandle *handle) deinit;\n</code></pre> <p>Deinitialize the I2C hardware/peripheral. </p> <p>Return: I2C_OK on success, or negative error code on failure </p> <p>Clean shutdown: disables interrupts, releases DMA, powers down hardware.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-transfer","title":"variable transfer","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, CFBD_I2C_Message *msgs, int num, uint32_t timeout_ms) transfer;\n</code></pre> <p>Perform a sequence of I2C messages. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>msgs Array of messages to transfer </li> <li>num Number of messages </li> <li>timeout_ms Operation timeout in milliseconds </li> </ul> <p>Return: I2C_OK on success, or negative error code </p> <p>Core transfer function. Must support multiple messages in a single transaction (write-read patterns, repeated START, etc.).</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-is_device_ready","title":"variable is_device_ready","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) is_device_ready;\n</code></pre> <p>Check whether a device is ready (acknowledges) within trials. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>addr Device address (7-bit) </li> <li>trials Number of probe attempts </li> <li>timeout_ms Per-trial timeout </li> </ul> <p>Return: I2C_OK if device acknowledged, negative error otherwise </p> <p>Probes device presence by attempting multiple transactions. Useful for detecting device hotplug, power-on sequences, etc.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-recover_bus","title":"variable recover_bus","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) recover_bus;\n</code></pre> <p>Attempt to recover the I2C bus (clock recovery, toggling lines). </p> <p>Return: I2C_OK if recovered, negative error if recovery failed </p> <p>Handles stuck bus scenarios by toggling SCL, sending dummy clocks, or performing platform-specific recovery procedures.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-get_error","title":"variable get_error","text":"<pre><code>int(*)(CFBD_I2CHandle *bus) get_error;\n</code></pre> <p>Retrieve the last backend-specific error code. </p> <p>Return: Backend-specific error code </p> <p>Returns additional error details beyond the standard error codes, such as hardware-specific status registers or state flags.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-tx_dma_start","title":"variable tx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, const uint8_t *buf, size_t len) tx_dma_start;\n</code></pre> <p>Initiate DMA transmission (optional). </p> <p>Return: I2C_OK if DMA started, error code otherwise </p> <p>Enables efficient bulk data transmission via DMA. Can return I2C_ERR_INVAL if DMA not supported.</p>"},{"location":"api/Classes/structCFBD__I2COperations/#variable-rx_dma_start","title":"variable rx_dma_start","text":"<pre><code>int(*)(CFBD_I2CHandle *bus, uint8_t *buf, size_t len) rx_dma_start;\n</code></pre> <p>Initiate DMA reception (optional). </p> <p>Return: I2C_OK if DMA started, error code otherwise </p> <p>Enables efficient bulk data reception via DMA.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/","title":"CFBD_I2C_IORequestParams","text":"<p>Helper structure used by convenience read/write helpers.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr7 uint32_t mem_addr uint8_t mem_addr_size uint8_t * data uint16_t len uint32_t timeout_ms"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2C_IORequestParams;\n</code></pre> <p>Helper structure used by convenience read/write helpers. </p> <p>Par: Example - Register Read</p> <pre><code>uint8_t register_value[4];\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x50,           // Device address\n    .mem_addr = 0x0100,      // Register/memory address in device\n    .mem_addr_size = 2,      // 2-byte register address\n    .data = register_value,\n    .len = sizeof(register_value),\n    .timeout_ms = 1000\n};\n\nif (CFBD_I2CRead(bus, &amp;req) == I2C_OK) {\n    // register_value now contains data from address 0x0100\n}\n</code></pre> <p>Simplifies high-level I2C read/write operations by bundling common parameters (address, register offset, buffer, timeout) into a single structure.</p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-addr7","title":"variable addr7","text":"<pre><code>uint16_t addr7;\n</code></pre> <p>7-bit I2C address. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr","title":"variable mem_addr","text":"<pre><code>uint32_t mem_addr;\n</code></pre> <p>Optional device memory/register address. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-mem_addr_size","title":"variable mem_addr_size","text":"<pre><code>uint8_t mem_addr_size;\n</code></pre> <p>Size in bytes of <code>mem_addr</code>. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-data","title":"variable data","text":"<pre><code>uint8_t * data;\n</code></pre> <p>Pointer to data buffer. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre> <p>Length of <code>data</code> in bytes. </p>"},{"location":"api/Classes/structCFBD__I2C__IORequestParams/#variable-timeout_ms","title":"variable timeout_ms","text":"<pre><code>uint32_t timeout_ms;\n</code></pre> <p>Operation timeout in milliseconds. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__I2C__Message/","title":"CFBD_I2C_Message","text":"<p>Single I2C message description used for multi-message transfers.  More...</p> <p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__I2C__Message/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_I2C_Message;\n</code></pre> <p>Single I2C message description used for multi-message transfers. </p> <p>Par: </p> <ul> <li>Message Direction</li> </ul> <p>The <code>flags</code> field determines message direction:</p> <ul> <li>flags = 0: Write (master -&gt; slave)</li> <li>flags = I2C_M_RD: Read (slave -&gt; master)</li> <li>Example - Multi-Message Transaction</li> </ul> <pre><code>// Read register 0x20 from SSD1306 OLED display\nCFBD_I2C_Message msgs[2];\nuint8_t addr_byte = 0x20;\nuint8_t reg_data[2];\n\n// Message 1: Send register address (write)\nmsgs[0].addr = 0x3C;       // OLED I2C address\nmsgs[0].flags = 0;         // Write operation\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;addr_byte;\n\n// Message 2: Read register contents\nmsgs[1].addr = 0x3C;\nmsgs[1].flags = I2C_M_RD;  // Read operation\nmsgs[1].len = 2;\nmsgs[1].buf = reg_data;\n\n// Execute both messages atomically\nint status = CFBD_I2CTransfer(bus, msgs, 2, 1000);\n</code></pre> <p>Provides the address, flags, buffer pointer and length for one message in a potentially multi-message transfer. The <code>addr</code> field contains a 7-bit device address.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/","title":"CFBD_IconTextMenuItem","text":"<p>Module: Icon-Text Menu Widget</p> <p><code>#include &lt;icontext_menu.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#public-attributes","title":"Public Attributes","text":"Name const char * label Item label text (owned by caller, must be static) uint8_t * icon_bitmap Icon bitmap data (48x48 pixels, owned by caller) CFBDGraphicSize icon_size Icon dimensions (typically 48x48) CFBD_IconTextMenuItemState state Current visual state of item. CFBD_MenuItemCallbackPack callback Optional callback when item is selected. CFBDGraphic_Point render_position Calculated top-left position for rendering. CCGraphic_Image icon_widget Image widget for icon rendering (internal) CFBDGraphic_Text text_widget Text widget for label rendering (internal) void * user_data User-defined data pointer."},{"location":"api/Classes/structCFBD__IconTextMenuItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-label","title":"variable label","text":"<pre><code>const char * label;\n</code></pre> <p>Item label text (owned by caller, must be static) </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-icon_bitmap","title":"variable icon_bitmap","text":"<pre><code>uint8_t * icon_bitmap;\n</code></pre> <p>Icon bitmap data (48x48 pixels, owned by caller) </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-icon_size","title":"variable icon_size","text":"<pre><code>CFBDGraphicSize icon_size;\n</code></pre> <p>Icon dimensions (typically 48x48) </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-state","title":"variable state","text":"<pre><code>CFBD_IconTextMenuItemState state;\n</code></pre> <p>Current visual state of item. </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-callback","title":"variable callback","text":"<pre><code>CFBD_MenuItemCallbackPack callback;\n</code></pre> <p>Optional callback when item is selected. </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-render_position","title":"variable render_position","text":"<pre><code>CFBDGraphic_Point render_position;\n</code></pre> <p>Calculated top-left position for rendering. </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-icon_widget","title":"variable icon_widget","text":"<pre><code>CCGraphic_Image icon_widget;\n</code></pre> <p>Image widget for icon rendering (internal) </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-text_widget","title":"variable text_widget","text":"<pre><code>CFBDGraphic_Text text_widget;\n</code></pre> <p>Text widget for label rendering (internal) </p>"},{"location":"api/Classes/structCFBD__IconTextMenuItem/#variable-user_data","title":"variable user_data","text":"<pre><code>void * user_data;\n</code></pre> <p>User-defined data pointer. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__LoggerOperations/","title":"CFBD_LoggerOperations","text":"<p><code>#include &lt;cfbd_log.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__LoggerOperations/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Logger *log_handle, cfbd_log_level_t level, const char *tag, const char *file, int line, const char *fmt,...) log_message"},{"location":"api/Classes/structCFBD__LoggerOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__LoggerOperations/#variable-log_message","title":"variable log_message","text":"<pre><code>void(*)(CFBD_Logger *log_handle, cfbd_log_level_t level, const char *tag, const char *file, int line, const char *fmt,...) log_message;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/","title":"CFBD_MenuItemCallbackPack","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItemCallback callback Callback function to invoke on item selection. void * user_data User data passed to callback (optional)"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-callback","title":"variable callback","text":"<pre><code>CFBD_MenuItemCallback callback;\n</code></pre> <p>Callback function to invoke on item selection. </p>"},{"location":"api/Classes/structCFBD__MenuItemCallbackPack/#variable-user_data","title":"variable user_data","text":"<pre><code>void * user_data;\n</code></pre> <p>User data passed to callback (optional) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__MenuOps/","title":"CFBD_MenuOps","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation void(*)(CFBD_Menu *pMenu) immediate_draw draw immediately void(*)(CFBD_Menu *pMenu, int index) select_index index selectors void(*)(CFBD_Menu *pMenu) activate_current User Activate the Selections, so things goes on. void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points Reset the places."},{"location":"api/Classes/structCFBD__MenuOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__MenuOps/#variable-bind_item_groups_contains","title":"variable bind_item_groups_contains","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuItemGroup *assigned_menu_items) bind_item_groups_contains;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>assigned_menu_items </li> </ul> <p>Note: assigned_menu_items requests long lifetime exsits, recommends being static </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-add_item","title":"variable add_item","text":"<pre><code>CFBD_Bool(*)(CFBD_Menu *pMenu, const char *label, Ascii_Font_Size size, CFBD_MenuItemCallbackPack *callbacks) add_item;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_indicator_property","title":"variable set_indicator_property","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_MenuIndicator *pIndicator) set_indicator_property;\n</code></pre>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-set_animation","title":"variable set_animation","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBD_BaseAnimation *pBaseAnimation) set_animation;\n</code></pre> <p>Parameters: </p> <ul> <li>pMenu </li> <li>pBaseAnimation </li> </ul> <p>Note: pBaseAnimation can be temp, internal assigns </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_Menu *pMenu) immediate_draw;\n</code></pre> <p>draw immediately </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-select_index","title":"variable select_index","text":"<pre><code>void(*)(CFBD_Menu *pMenu, int index) select_index;\n</code></pre> <p>index selectors </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-activate_current","title":"variable activate_current","text":"<pre><code>void(*)(CFBD_Menu *pMenu) activate_current;\n</code></pre> <p>User Activate the Selections, so things goes on. </p>"},{"location":"api/Classes/structCFBD__MenuOps/#variable-reset_tl_points","title":"variable reset_tl_points","text":"<pre><code>void(*)(CFBD_Menu *pMenu, CFBDGraphic_Point *p, CFBD_Bool request_updates) reset_tl_points;\n</code></pre> <p>Reset the places. </p> <p>Note: immediate draw requests, including clear update and redraw is expected to behave! </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__NativeLoggerOperations/","title":"CFBD_NativeLoggerOperations","text":"<p><code>#include &lt;cfbd_log.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__NativeLoggerOperations/#public-attributes","title":"Public Attributes","text":"Name void(*)(void *native_handle, const char *buffer, const uint16_t buffer_size) log_native uint32_t(*)(void *native_handle) timestamp"},{"location":"api/Classes/structCFBD__NativeLoggerOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__NativeLoggerOperations/#variable-log_native","title":"variable log_native","text":"<pre><code>void(*)(void *native_handle, const char *buffer, const uint16_t buffer_size) log_native;\n</code></pre>"},{"location":"api/Classes/structCFBD__NativeLoggerOperations/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t(*)(void *native_handle) timestamp;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__OLED/","title":"CFBD_OLED","text":"<p>The generic OLED device object exposed to application code.  More...</p> <p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED;\n</code></pre> <p>The generic OLED device object exposed to application code. </p> <p>Note: The oled_internal_handle is opaque and device-specific. Do not access it directly; all device interaction must occur through the ops table. </p> <p>This is the primary interface through which application code interacts with OLED displays. It encapsulates the operation table, device type, and backend-specific state into a single, transport-agnostic interface.</p> <p>Typical usage pattern:</p> <ol> <li>Call CFBD_GetOLEDHandle() to obtain and initialize an instance</li> <li>Call ops-&gt;open() to enable the device</li> <li>Use rendering operations (setPixel, setArea, etc.) to draw</li> <li>Call ops-&gt;update() to push changes to the display</li> <li>Call ops-&gt;close() when done</li> </ol> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__OLEDOperations/","title":"CFBD_OLEDOperations","text":"<p>Virtual operation table implementing OLED driver functionality.  More...</p> <p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLEDOperations/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLEDOperations;\n</code></pre> <p>Virtual operation table implementing OLED driver functionality. </p> <p>Note: All function pointers must be non-NULL unless explicitly stated otherwise. Device implementations should handle edge cases (out-of-bounds coordinates) gracefully by clipping or returning error codes. </p> <p>Concrete device drivers populate an instance of this table and assign it to the ops member of a CFBD_OLED object. This structure defines the complete interface for display operations, lifecycle management, and device queries. Callers should only invoke functions through this table after device initialization.</p> <p>The operation table enables:</p> <ul> <li>Device initialization and lifecycle (init, open, close)</li> <li>Pixel and area rendering (setPixel, setArea)</li> <li>Frame operations (update, clear, revert)</li> <li>Rectangular area operations (update_area, clear_area, revert_area)</li> <li>Device capability queries (self_consult)</li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/","title":"CFBD_OLED_DeviceSpecific","text":"<p>Module: OLED Display Driver / OLED Device Interface</p> <p>Device-specific configuration for an OLED panel.  More...</p> <p><code>#include &lt;device_interface.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes","title":"Public Attributes","text":"Name uint8_t ()(void) init_session_tables Optional callback to return initialization command tables. uint8_t ** grams Array of pointers to GRAM/frame buffers used by the device. uint16_t init_session_tables_sz Size (in bytes) of the initialization tables returned by <code>init_session_tables</code>. uint8_t data_prefix Byte prefix to use for data transmissions to the display. uint8_t cmd_prefix Byte prefix to use for command transmissions to the display. uint16_t logic_width Logical width of the display in pixels. uint16_t logic_height Logical height of the display in pixels. const char * iic_pack_type for package iic void * private_data oled specified datas"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED_DeviceSpecific;\n</code></pre> <p>Device-specific configuration for an OLED panel. </p> <p>Note: Implementations must ensure that:</p> <ul> <li>init_session_tables() returns a valid pointer or NULL if no initialization is needed</li> <li>grams points to valid frame buffer pointers</li> <li>All size and geometry fields are correctly populated </li> </ul> <p>Fields in this structure control how the generic OLED driver initializes and communicates with a specific panel. Implementations should populate <code>init_session_tables</code> and <code>grams</code> with pointers to static data describing the initialization sequence and frame buffers respectively.</p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables","title":"variable init_session_tables","text":"<pre><code>uint8_t *(*)(void) init_session_tables;\n</code></pre> <p>Optional callback to return initialization command tables. </p> <p>The callback should allocate or return a pointer to a contiguous block containing the device initialization sequence bytes. If no initialization sequence is required, this may be NULL. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-grams","title":"variable grams","text":"<pre><code>uint8_t ** grams;\n</code></pre> <p>Array of pointers to GRAM/frame buffers used by the device. </p> <p>The driver may expect one or more pointers here depending on the device's memory layout. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-init_session_tables_sz","title":"variable init_session_tables_sz","text":"<pre><code>uint16_t init_session_tables_sz;\n</code></pre> <p>Size (in bytes) of the initialization tables returned by <code>init_session_tables</code>. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-data_prefix","title":"variable data_prefix","text":"<pre><code>uint8_t data_prefix;\n</code></pre> <p>Byte prefix to use for data transmissions to the display. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-cmd_prefix","title":"variable cmd_prefix","text":"<pre><code>uint8_t cmd_prefix;\n</code></pre> <p>Byte prefix to use for command transmissions to the display. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_width","title":"variable logic_width","text":"<pre><code>uint16_t logic_width;\n</code></pre> <p>Logical width of the display in pixels. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-logic_height","title":"variable logic_height","text":"<pre><code>uint16_t logic_height;\n</code></pre> <p>Logical height of the display in pixels. </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-iic_pack_type","title":"variable iic_pack_type","text":"<pre><code>const char * iic_pack_type;\n</code></pre> <p>for package iic </p>"},{"location":"api/Classes/structCFBD__OLED__DeviceSpecific/#variable-private_data","title":"variable private_data","text":"<pre><code>void * private_data;\n</code></pre> <p>oled specified datas </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/","title":"CFBD_OLED_IICInitsParams","text":"<p>Module: OLED Display Integration</p> <p>Initialization parameters for OLED devices using I2C.  More...</p> <p><code>#include &lt;external_impl_driver.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes","title":"Public Attributes","text":"Name CFBD_I2CHandle * i2cHandle Pointer to the I2C handle used for communication. uint32_t accepted_time_delay Minimum or accepted time delay (units implementation-defined). uint16_t device_address 7-bit or 8-bit I2C device address depending on backend. CFBD_OLED_DeviceSpecific * device_specifics Pointer to device-specific configuration and callbacks. void(*)(int status) iic_transition_callback Optional callback invoked on I2C transaction transitions."},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_OLED_IICInitsParams;\n</code></pre> <p>Initialization parameters for OLED devices using I2C. </p> <p>Par: </p> <ul> <li>Field Relationships</li> </ul> <p>All fields must be properly initialized before passing to OLED_Init():</p> <ul> <li><code>i2cHandle</code> must point to an initialized I2C bus</li> <li><code>device_address</code> must match the actual hardware (0x3C or 0x3D typical)</li> <li><code>device_specifics</code> must match the actual display model</li> <li><code>iic_transition_callback</code> may be NULL if polling is acceptable</li> <li>Example - Complete Initialization</li> </ul> <pre><code>// Create and configure the initialization structure\nCFBD_OLED_IICInitsParams params;\n\n// Get I2C bus handle (configured by board layer)\nparams.i2cHandle = get_i2c1_handle();\n\n// Configure device-specific parameters\nparams.device_address = 0x3C;\nparams.accepted_time_delay = 5;           // 5 ticks between ops\nparams.device_specifics = get_ssd1306_config();\nparams.iic_transition_callback = on_iic_complete;\n\n// Initialize OLED\nint result = OLED_Initialize(&amp;params);\n</code></pre> <p>Aggregates the I2C handle, device address, timing parameters and a pointer to device-specific data required by the OLED driver. The optional <code>iic_transition_callback</code> can be supplied by the platform to receive status updates about I2C transaction completion.</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-i2chandle","title":"variable i2cHandle","text":"<pre><code>CFBD_I2CHandle * i2cHandle;\n</code></pre> <p>Pointer to the I2C handle used for communication. </p> <p>Note: The I2C handle remains owned by the board/platform layer. The OLED driver does not take ownership or close it. </p> <p>This should point to a valid <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> provided by the project's I2C driver (<code>lib/iic</code>). The handle must be already initialized before passing to the OLED driver.</p>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-accepted_time_delay","title":"variable accepted_time_delay","text":"<pre><code>uint32_t accepted_time_delay;\n</code></pre> <p>Minimum or accepted time delay (units implementation-defined). </p> <p>Note: The actual timing behavior depends on the OLED driver implementation and the platform's timer/scheduler. </p> <p>Used by the driver to schedule retries or throttling between transactions. Interpret the unit according to the platform's timing conventions (milliseconds, ticks, scheduler quantum, etc.).</p> <p>Typical values:</p> <ul> <li>0-1: No delay (fast polling systems)</li> <li>1-5: Minimal delay (cooperative multitasking)</li> <li>5-10: Small delay (allows other tasks to run)</li> <li>10+: Significant delay (low-priority display updates)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_address","title":"variable device_address","text":"<pre><code>uint16_t device_address;\n</code></pre> <p>7-bit or 8-bit I2C device address depending on backend. </p> <p>Note: The actual interpretation (7-bit vs 8-bit) is backend-specific. Consult the I2C driver documentation for address format.</p> <p>Par: Example - Address Selection by Hardware</p> <pre><code>// Check SA0 pin to determine address\n#ifdef OLED_SA0_HIGH\n    params.device_address = 0x3D;\n#else\n    params.device_address = 0x3C;\n#endif\n</code></pre> <p>Standard OLED display addresses:</p> <ul> <li>0x3C: Most common (SSD1306, SSD1309 default)</li> <li>0x3D: Alternative address (if SA0 pin tied high)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-device_specifics","title":"variable device_specifics","text":"<pre><code>CFBD_OLED_DeviceSpecific * device_specifics;\n</code></pre> <p>Pointer to device-specific configuration and callbacks. </p> <p>See: CFBD_OLED_DeviceSpecific</p> <p>Note: Must not be NULL. The OLED driver requires this to be properly initialized for the specific hardware model.</p> <p>Implementation-defined structure describing device parameters such as display geometry, command set quirks, or initialization sequences. The concrete type is <code>[CFBD_OLED_DeviceSpecific](Classes/structCFBD__OLED__DeviceSpecific.md)</code>.</p> <p>Device-specific data typically includes:</p> <ul> <li>Display resolution (width, height in pixels)</li> <li>Controller model (SSD1306, SSD1309, SH1106)</li> <li>Initialization command sequences</li> <li>Timing constants (frame rate, refresh rate)</li> <li>Feature flags (supports DMA, contrast adjustment, etc.)</li> </ul>"},{"location":"api/Classes/structCFBD__OLED__IICInitsParams/#variable-iic_transition_callback","title":"variable iic_transition_callback","text":"<pre><code>void(*)(int status) iic_transition_callback;\n</code></pre> <p>Optional callback invoked on I2C transaction transitions. </p> <p>See: CFBD_I2C_AsyncCallback</p> <p>Note: May be NULL if the application does not require async notification. In that case, the driver may use polling or ignore completion status.</p> <p>Par: Callback Pattern - Async Notification</p> <pre><code>void on_display_event(int status) {\n    if (status == I2C_OK) {\n        // Display command executed\n        update_display_state();\n    } else {\n        // Display error\n        increment_error_counter();\n        schedule_retry();\n    }\n}\n\nparams.iic_transition_callback = on_display_event;\n</code></pre> <p>The callback receives an integer <code>status</code> describing the result of a transaction (semantics are platform-defined). Use this to signal completion or error conditions back to the application.</p> <p>Typical status values:</p> <ul> <li>I2C_OK: Transaction succeeded</li> <li>I2C_ERR_NACK: Device not responding</li> <li>I2C_ERR_TIMEOUT: Operation timed out</li> <li>I2C_ERR_BUSY: Bus busy, retry needed</li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/","title":"CFBD_ProgressBarOps","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_ProgressBar *) immediate_draw void(*)(CFBD_ProgressBar *, int32_t new_value) set_value CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property"},{"location":"api/Classes/structCFBD__ProgressBarOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_ProgressBar *) immediate_draw;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_value","title":"variable set_value","text":"<pre><code>void(*)(CFBD_ProgressBar *, int32_t new_value) set_value;\n</code></pre>"},{"location":"api/Classes/structCFBD__ProgressBarOps/#variable-set_property","title":"variable set_property","text":"<pre><code>CFBD_Bool(*)(CFBD_ProgressBar *, const char *property, const void *args) set_property;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/","title":"CFBD_ST_I2CPrivate","text":"<p>Backend-private state for the STM32 I2C implementation.  More...</p> <p><code>#include &lt;i2c_stm_impl.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes","title":"Public Attributes","text":"Name I2C_HandleTypeDef * hi2c Pointer to the HAL <code>I2C_HandleTypeDef</code> instance. GPIO_TypeDef * scl_port GPIO port for the SCL line. uint16_t scl_pin GPIO pin number (mask) for SCL. GPIO_TypeDef * sda_port GPIO port for the SDA line. uint16_t sda_pin GPIO pin number (mask) for SDA. int last_err Last backend error code (implementation-defined)."},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_ST_I2CPrivate;\n</code></pre> <p>Backend-private state for the STM32 I2C implementation. </p> <p>Stores references to the HAL I2C peripheral instance and the GPIO pins used for SCL and SDA. The <code>last_err</code> field is available to record the most recent backend error and may be consulted by the public <code>get_error</code> operation in <code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code>. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-hi2c","title":"variable hi2c","text":"<pre><code>I2C_HandleTypeDef * hi2c;\n</code></pre> <p>Pointer to the HAL <code>I2C_HandleTypeDef</code> instance. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_port","title":"variable scl_port","text":"<pre><code>GPIO_TypeDef * scl_port;\n</code></pre> <p>GPIO port for the SCL line. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-scl_pin","title":"variable scl_pin","text":"<pre><code>uint16_t scl_pin;\n</code></pre> <p>GPIO pin number (mask) for SCL. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_port","title":"variable sda_port","text":"<pre><code>GPIO_TypeDef * sda_port;\n</code></pre> <p>GPIO port for the SDA line. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-sda_pin","title":"variable sda_pin","text":"<pre><code>uint16_t sda_pin;\n</code></pre> <p>GPIO pin number (mask) for SDA. </p>"},{"location":"api/Classes/structCFBD__ST__I2CPrivate/#variable-last_err","title":"variable last_err","text":"<pre><code>int last_err;\n</code></pre> <p>Last backend error code (implementation-defined). </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__ST__UARTPrivate/","title":"CFBD_ST_UARTPrivate","text":"<p><code>#include &lt;stm-impl-uart.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ST__UARTPrivate/#public-attributes","title":"Public Attributes","text":"Name UART_HandleTypeDef hal_uart CFBD_UARTHandle * parent_handles"},{"location":"api/Classes/structCFBD__ST__UARTPrivate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ST__UARTPrivate/#variable-hal_uart","title":"variable hal_uart","text":"<pre><code>UART_HandleTypeDef hal_uart;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__UARTPrivate/#variable-parent_handles","title":"variable parent_handles","text":"<pre><code>CFBD_UARTHandle * parent_handles;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/","title":"CFBD_ST_UART_AsyncHelper","text":"<p><code>#include &lt;uart.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/#public-attributes","title":"Public Attributes","text":"Name void(*)(void *native_data) async_send_complete void(*)(void *native_data) async_receive_complete void(*)(void *native_data) async_idle_line"},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/#variable-async_send_complete","title":"variable async_send_complete","text":"<pre><code>void(*)(void *native_data) async_send_complete;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/#variable-async_receive_complete","title":"variable async_receive_complete","text":"<pre><code>void(*)(void *native_data) async_receive_complete;\n</code></pre>"},{"location":"api/Classes/structCFBD__ST__UART__AsyncHelper/#variable-async_idle_line","title":"variable async_idle_line","text":"<pre><code>void(*)(void *native_data) async_idle_line;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/","title":"CFBD_UART_AsyncCallbacks","text":"<p>As C owns no virtual, we need to filled the function processor by users.  More...</p> <p><code>#include &lt;uart.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_UARTHandle *handle) on_send_complete void(*)(CFBD_UARTHandle *handle) on_receive_complete void(*)(CFBD_UARTHandle *handle, uint32_t error_code) on_error void(*)(CFBD_UARTHandle *handle, uint32_t received_len) on_idle_line"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#detailed-description","title":"Detailed Description","text":"<pre><code>struct CFBD_UART_AsyncCallbacks;\n</code></pre> <p>As C owns no virtual, we need to filled the function processor by users. </p> <p>Note: Thinking Callbacks shits, so place NULL, if we dont want to do anything </p>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#variable-on_send_complete","title":"variable on_send_complete","text":"<pre><code>void(*)(CFBD_UARTHandle *handle) on_send_complete;\n</code></pre>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#variable-on_receive_complete","title":"variable on_receive_complete","text":"<pre><code>void(*)(CFBD_UARTHandle *handle) on_receive_complete;\n</code></pre>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#variable-on_error","title":"variable on_error","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, uint32_t error_code) on_error;\n</code></pre>"},{"location":"api/Classes/structCFBD__UART__AsyncCallbacks/#variable-on_idle_line","title":"variable on_idle_line","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, uint32_t received_len) on_idle_line;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/","title":"CFBD_WidgetCreationPack","text":"<p><code>#include &lt;widget.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point tl_point CFBDGraphicSize size CFBD_Widget ** children size_t children_container_sz CFBD_Widget * parent"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__WidgetCreationPack/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#variable-size","title":"variable size","text":"<pre><code>CFBDGraphicSize size;\n</code></pre>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#variable-children","title":"variable children","text":"<pre><code>CFBD_Widget ** children;\n</code></pre>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#variable-children_container_sz","title":"variable children_container_sz","text":"<pre><code>size_t children_container_sz;\n</code></pre>"},{"location":"api/Classes/structCFBD__WidgetCreationPack/#variable-parent","title":"variable parent","text":"<pre><code>CFBD_Widget * parent;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__WidgetOperations/","title":"CFBD_WidgetOperations","text":"<p><code>#include &lt;widget.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__WidgetOperations/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Widget *self, CFBD_Widget *parent) set_parent"},{"location":"api/Classes/structCFBD__WidgetOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__WidgetOperations/#variable-set_parent","title":"variable set_parent","text":"<pre><code>void(*)(CFBD_Widget *self, CFBD_Widget *parent) set_parent;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structCFBD__WidgetRequestOverrideOperations/","title":"CFBD_WidgetRequestOverrideOperations","text":"<p><code>#include &lt;widget.h&gt;</code></p>"},{"location":"api/Classes/structCFBD__WidgetRequestOverrideOperations/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_Widget *w, CFBD_GraphicDevice *graphic_device) paint"},{"location":"api/Classes/structCFBD__WidgetRequestOverrideOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structCFBD__WidgetRequestOverrideOperations/#variable-paint","title":"variable paint","text":"<pre><code>void(*)(CFBD_Widget *w, CFBD_GraphicDevice *graphic_device) paint;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/structIntrButtonArrayInfo/","title":"IntrButtonArrayInfo","text":"<p><code>#include &lt;plain_button.h&gt;</code></p>"},{"location":"api/Classes/structIntrButtonArrayInfo/#public-attributes","title":"Public Attributes","text":"Name CFBDPlainButtonArray array int cnt"},{"location":"api/Classes/structIntrButtonArrayInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structIntrButtonArrayInfo/#variable-array","title":"variable array","text":"<pre><code>CFBDPlainButtonArray array;\n</code></pre>"},{"location":"api/Classes/structIntrButtonArrayInfo/#variable-cnt","title":"variable cnt","text":"<pre><code>int cnt;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/","title":"_CFBD_GraphicDevice","text":"<p>Module: Graphics Device Abstraction</p> <p><code>#include &lt;graphic_device.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes","title":"Public Attributes","text":"Name CFBD_GraphicDeviceOperation * ops Pointer to the operation table. CFBDGraphic_DeviceType device_type The graphics device type. CFBDGraphicDeviceHandle internal_handle Opaque device-specific handle and state. CFBD_Bool immediate_draw Immediate draw mode flag."},{"location":"api/Classes/struct__CFBD__GraphicDevice/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_GraphicDeviceOperation * ops;\n</code></pre> <p>Pointer to the operation table. </p> <p>Device implementations populate this with concrete operations. Must be non-NULL after device initialization. </p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-device_type","title":"variable device_type","text":"<pre><code>CFBDGraphic_DeviceType device_type;\n</code></pre> <p>The graphics device type. </p> <p>Identifies the hardware type (OLED, LCD, etc.). Determines device-specific behavior and capabilities. </p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-internal_handle","title":"variable internal_handle","text":"<pre><code>CFBDGraphicDeviceHandle internal_handle;\n</code></pre> <p>Opaque device-specific handle and state. </p> <p>Contains implementation-specific data such as hardware handles, configuration parameters, and internal buffers. Must not be accessed or modified directly by application code. </p>"},{"location":"api/Classes/struct__CFBD__GraphicDevice/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>CFBD_Bool immediate_draw;\n</code></pre> <p>Immediate draw mode flag. </p> <p>When CFBD_TRUE, each drawing operation automatically updates the display immediately. When CFBD_FALSE, drawing operations modify the frame buffer but do not update the display until ops-&gt;update() is explicitly called (batch mode).</p> <p>This enables flexible control over rendering performance and visual updates. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/","title":"_CFBD_I2CHandle","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes","title":"Public Attributes","text":"Name const CFBD_I2COperations * ops CFBD_I2CPrivateHandle private_handle"},{"location":"api/Classes/struct__CFBD__I2CHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_I2COperations * ops;\n</code></pre> <p>Backend operation table. </p>"},{"location":"api/Classes/struct__CFBD__I2CHandle/#variable-private_handle","title":"variable private_handle","text":"<pre><code>CFBD_I2CPrivateHandle private_handle;\n</code></pre> <p>Backend-specific state. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/","title":"_CFBD_I2C_Message","text":"<p><code>#include &lt;iic.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes","title":"Public Attributes","text":"Name uint16_t addr uint16_t flags uint16_t len uint8_t * buf"},{"location":"api/Classes/struct__CFBD__I2C__Message/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-addr","title":"variable addr","text":"<pre><code>uint16_t addr;\n</code></pre> <p>7-bit address (0..0x7F) </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-flags","title":"variable flags","text":"<pre><code>uint16_t flags;\n</code></pre> <p>I2C Message Flags (see I2C_M_* macros) </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-len","title":"variable len","text":"<pre><code>uint16_t len;\n</code></pre> <p>length of buffer </p>"},{"location":"api/Classes/struct__CFBD__I2C__Message/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t * buf;\n</code></pre> <p>pointer to data </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/","title":"_CFBD_IconTextMenu","text":"<p>Module: Icon-Text Menu Widget</p> <p><code>#include &lt;icontext_menu.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#public-attributes","title":"Public Attributes","text":"Name CFBD_IconTextMenuOps * operations Menu operation table (function pointers) CFBD_IconTextMenuItem * items Array of menu items. size_t item_count Total number of items in menu. size_t capacity Maximum capacity of items array. CFBD_GraphicDevice * device Graphics device for rendering. CFBDGraphicRect viewport Menu viewport rectangle (where menu is displayed) int selected_index Currently selected item index. int first_visible_index First visible item index. int16_t scroll_offset Current scroll offset in pixels (smooth scrolling) int16_t target_scroll_offset Target scroll offset (used by animations) CFBD_IconTextScrollDirection scroll_direction Current scroll direction. CFBD_BaseAnimation scroll_animation Animation state for smooth scrolling. SizeBaseType item_width Width of each menu item in pixels. SizeBaseType item_height Height of each menu item in pixels. uint16_t item_spacing Spacing between menu items in pixels. CFBD_Bool is_circular Whether menu wraps around at edges. CFBD_Bool is_animating Animation currently in progress. int16_t animation_start_offset Animation start offset. uint32_t animation_elapsed_ms Animation elapsed time in ms. int16_t prev_scroll_offset Previous frame scroll offset (for dirty region detection) uint8_t anim_current_frame Current animation frame counter (0 to anim_frames-1) uint16_t selection_border_width"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-operations","title":"variable operations","text":"<pre><code>CFBD_IconTextMenuOps * operations;\n</code></pre> <p>Menu operation table (function pointers) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-items","title":"variable items","text":"<pre><code>CFBD_IconTextMenuItem * items;\n</code></pre> <p>Array of menu items. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-item_count","title":"variable item_count","text":"<pre><code>size_t item_count;\n</code></pre> <p>Total number of items in menu. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-capacity","title":"variable capacity","text":"<pre><code>size_t capacity;\n</code></pre> <p>Maximum capacity of items array. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre> <p>Graphics device for rendering. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-viewport","title":"variable viewport","text":"<pre><code>CFBDGraphicRect viewport;\n</code></pre> <p>Menu viewport rectangle (where menu is displayed) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-selected_index","title":"variable selected_index","text":"<pre><code>int selected_index;\n</code></pre> <p>Currently selected item index. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-first_visible_index","title":"variable first_visible_index","text":"<pre><code>int first_visible_index;\n</code></pre> <p>First visible item index. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-scroll_offset","title":"variable scroll_offset","text":"<pre><code>int16_t scroll_offset;\n</code></pre> <p>Current scroll offset in pixels (smooth scrolling) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-target_scroll_offset","title":"variable target_scroll_offset","text":"<pre><code>int16_t target_scroll_offset;\n</code></pre> <p>Target scroll offset (used by animations) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-scroll_direction","title":"variable scroll_direction","text":"<pre><code>CFBD_IconTextScrollDirection scroll_direction;\n</code></pre> <p>Current scroll direction. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-scroll_animation","title":"variable scroll_animation","text":"<pre><code>CFBD_BaseAnimation scroll_animation;\n</code></pre> <p>Animation state for smooth scrolling. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-item_width","title":"variable item_width","text":"<pre><code>SizeBaseType item_width;\n</code></pre> <p>Width of each menu item in pixels. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-item_height","title":"variable item_height","text":"<pre><code>SizeBaseType item_height;\n</code></pre> <p>Height of each menu item in pixels. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-item_spacing","title":"variable item_spacing","text":"<pre><code>uint16_t item_spacing;\n</code></pre> <p>Spacing between menu items in pixels. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-is_circular","title":"variable is_circular","text":"<pre><code>CFBD_Bool is_circular;\n</code></pre> <p>Whether menu wraps around at edges. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-is_animating","title":"variable is_animating","text":"<pre><code>CFBD_Bool is_animating;\n</code></pre> <p>Animation currently in progress. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-animation_start_offset","title":"variable animation_start_offset","text":"<pre><code>int16_t animation_start_offset;\n</code></pre> <p>Animation start offset. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-animation_elapsed_ms","title":"variable animation_elapsed_ms","text":"<pre><code>uint32_t animation_elapsed_ms;\n</code></pre> <p>Animation elapsed time in ms. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-prev_scroll_offset","title":"variable prev_scroll_offset","text":"<pre><code>int16_t prev_scroll_offset;\n</code></pre> <p>Previous frame scroll offset (for dirty region detection) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-anim_current_frame","title":"variable anim_current_frame","text":"<pre><code>uint8_t anim_current_frame;\n</code></pre> <p>Current animation frame counter (0 to anim_frames-1) </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenu/#variable-selection_border_width","title":"variable selection_border_width","text":"<pre><code>uint16_t selection_border_width;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/","title":"_CFBD_IconTextMenuOps","text":"<p>Module: Icon-Text Menu Widget</p> <p>Operation table for icon-text menu.  More...</p> <p><code>#include &lt;icontext_menu.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#public-attributes","title":"Public Attributes","text":"Name CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, const char *label, uint8_t *icon_bitmap, CFBDGraphicSize *icon_size, CFBD_MenuItemCallbackPack *callback) add_item Add menu item. void(*)(CFBD_IconTextMenu *pMenu, CFBD_IconTextScrollDirection direction) scroll Scroll menu in specified direction. CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, int index) select_index Select item by index. void(*)(CFBD_IconTextMenu *pMenu) activate_current Activate current item. void(*)(CFBD_IconTextMenu *pMenu) immediate_draw Draw menu. CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, uint32_t delta_ms) update Update animation state. void(*)(CFBD_IconTextMenu *pMenu, uint32_t bg_color, uint32_t highlight_color, uint32_t text_color) set_appearance Set appearance properties. void(*)(CFBD_IconTextMenu *pMenu, SizeBaseType width, SizeBaseType height, uint16_t spacing) set_dimensions Set item dimensions. CFBD_IconTextMenuItem ()(CFBD_IconTextMenu *pMenu) get_selected_item Get selected item. CFBD_IconTextMenuItem ()(CFBD_IconTextMenu *pMenu, int index) get_item Get item by index. void(*)(CFBD_IconTextMenu *pMenu, CFBD_Bool is_circular) set_circular Set circular scrolling. void(*)(CFBD_IconTextMenu *pMenu, CFBD_IconTextScrollDirection direction) animate_scroll Animated scroll. void(*)(CFBD_IconTextMenu *pMenu, uint16_t width) set_selection_border"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#detailed-description","title":"Detailed Description","text":"<pre><code>struct _CFBD_IconTextMenuOps;\n</code></pre> <p>Operation table for icon-text menu. </p> <p>Virtual function table for icon-text menu operations </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-add_item","title":"variable add_item","text":"<pre><code>CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, const char *label, uint8_t *icon_bitmap, CFBDGraphicSize *icon_size, CFBD_MenuItemCallbackPack *callback) add_item;\n</code></pre> <p>Add menu item. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-scroll","title":"variable scroll","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, CFBD_IconTextScrollDirection direction) scroll;\n</code></pre> <p>Scroll menu in specified direction. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-select_index","title":"variable select_index","text":"<pre><code>CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, int index) select_index;\n</code></pre> <p>Select item by index. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-activate_current","title":"variable activate_current","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu) activate_current;\n</code></pre> <p>Activate current item. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-immediate_draw","title":"variable immediate_draw","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu) immediate_draw;\n</code></pre> <p>Draw menu. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-update","title":"variable update","text":"<pre><code>CFBD_Bool(*)(CFBD_IconTextMenu *pMenu, uint32_t delta_ms) update;\n</code></pre> <p>Update animation state. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-set_appearance","title":"variable set_appearance","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, uint32_t bg_color, uint32_t highlight_color, uint32_t text_color) set_appearance;\n</code></pre> <p>Set appearance properties. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-set_dimensions","title":"variable set_dimensions","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, SizeBaseType width, SizeBaseType height, uint16_t spacing) set_dimensions;\n</code></pre> <p>Set item dimensions. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-get_selected_item","title":"variable get_selected_item","text":"<pre><code>CFBD_IconTextMenuItem *(*)(CFBD_IconTextMenu *pMenu) get_selected_item;\n</code></pre> <p>Get selected item. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-get_item","title":"variable get_item","text":"<pre><code>CFBD_IconTextMenuItem *(*)(CFBD_IconTextMenu *pMenu, int index) get_item;\n</code></pre> <p>Get item by index. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-set_circular","title":"variable set_circular","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, CFBD_Bool is_circular) set_circular;\n</code></pre> <p>Set circular scrolling. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-animate_scroll","title":"variable animate_scroll","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, CFBD_IconTextScrollDirection direction) animate_scroll;\n</code></pre> <p>Animated scroll. </p>"},{"location":"api/Classes/struct__CFBD__IconTextMenuOps/#variable-set_selection_border","title":"variable set_selection_border","text":"<pre><code>void(*)(CFBD_IconTextMenu *pMenu, uint16_t width) set_selection_border;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__Menu/","title":"_CFBD_Menu","text":"<p><code>#include &lt;menu.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuOps * operations Menu operation table (function pointers) CFBD_GraphicDevice * device Graphics device for menu rendering. CFBD_MenuItemGroup * menu_items Menu items array and metadata. CFBDGraphic_Point tl_point Top-left position of menu (default: 0,0) SizeBaseType max_width Maximum width constraint for menu items in pixels. int selected Currently selected item index (0-based) CFBD_MenuIndicator indicator Indicator bar configuration. CFBD_BaseAnimation animation Animation timing configuration."},{"location":"api/Classes/struct__CFBD__Menu/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__Menu/#variable-operations","title":"variable operations","text":"<pre><code>CFBD_MenuOps * operations;\n</code></pre> <p>Menu operation table (function pointers) </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre> <p>Graphics device for menu rendering. </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-menu_items","title":"variable menu_items","text":"<pre><code>CFBD_MenuItemGroup * menu_items;\n</code></pre> <p>Menu items array and metadata. </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre> <p>Top-left position of menu (default: 0,0) </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-max_width","title":"variable max_width","text":"<pre><code>SizeBaseType max_width;\n</code></pre> <p>Maximum width constraint for menu items in pixels. </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-selected","title":"variable selected","text":"<pre><code>int selected;\n</code></pre> <p>Currently selected item index (0-based) </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-indicator","title":"variable indicator","text":"<pre><code>CFBD_MenuIndicator indicator;\n</code></pre> <p>Indicator bar configuration. </p>"},{"location":"api/Classes/struct__CFBD__Menu/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Animation timing configuration. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED/","title":"_CFBD_OLED","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes","title":"Public Attributes","text":"Name const CFBD_OLEDOperations * ops Pointer to the operation table. CFBD_OLEDDriverType driver_type The underlying transport/driver type used for this device. CFBD_OLEDHandle oled_internal_handle Opaque backend-specific handle and state."},{"location":"api/Classes/struct__CFBD__OLED/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED/#variable-ops","title":"variable ops","text":"<pre><code>const CFBD_OLEDOperations * ops;\n</code></pre> <p>Pointer to the operation table. </p> <p>Device drivers populate this with concrete implementations of all OLED operations. Must be non-NULL after device initialization. </p>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-driver_type","title":"variable driver_type","text":"<pre><code>CFBD_OLEDDriverType driver_type;\n</code></pre> <p>The underlying transport/driver type used for this device. </p> <p>Identifies whether communication occurs via I2C, SPI, or another transport mechanism. Affects the format of initialization parameters and internal implementation details. </p>"},{"location":"api/Classes/struct__CFBD__OLED/#variable-oled_internal_handle","title":"variable oled_internal_handle","text":"<pre><code>CFBD_OLEDHandle oled_internal_handle;\n</code></pre> <p>Opaque backend-specific handle and state. </p> <p>Contains driver-specific state, including transport handles, device addresses, frame buffers, and callback contexts. Callers must not access or dereference this directly. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/","title":"_CFBD_OLED_OPS","text":"<p><code>#include &lt;oled.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes","title":"Public Attributes","text":"Name int(*)(CFBD_OLED *oled, void *init_args) init Initialize the OLED device. CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel Set a single pixel at (x, y) to on/enabled state. CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea Write a block of pixel data to a rectangular area. FrameOperation update Push the local frame buffer to the display. FrameOperation clear Clear the entire display and frame buffer. FrameOperation revert Revert the display to the previous frame content (if supported). AreaOperations update_area Update a rectangular area on the display. AreaOperations clear_area Clear a rectangular area on the display and buffer. AreaOperations revert_area Revert a rectangular area to its previous content (if supported). OLEDSelfOperation open Open/enable the display device. OLEDSelfOperation close Close/disable the display device. OLED_QueryOperation self_consult Query device properties and capabilities. OLED_SetPropertyOperation self_property_setter set device properties and capabilities."},{"location":"api/Classes/struct__CFBD__OLED__OPS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-init","title":"variable init","text":"<pre><code>int(*)(CFBD_OLED *oled, void *init_args) init;\n</code></pre> <p>Initialize the OLED device. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance. </li> <li>init_args Optional device-specific initialization arguments. </li> </ul> <p>Return: int Status code; typically 0 for success, negative for errors. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setpixel","title":"variable setPixel","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y) setPixel;\n</code></pre> <p>Set a single pixel at (x, y) to on/enabled state. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance. </li> <li>x X coordinate of the pixel. </li> <li>y Y coordinate of the pixel. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-setarea","title":"variable setArea","text":"<pre><code>CFBD_Bool(*)(CFBD_OLED *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *source) setArea;\n</code></pre> <p>Write a block of pixel data to a rectangular area. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_OLED instance. </li> <li>x X coordinate of the area's top-left corner. </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. </li> <li>height Height of the area in pixels. </li> <li>source Pointer to source bitmap data. Format is device-dependent. </li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update","title":"variable update","text":"<pre><code>FrameOperation update;\n</code></pre> <p>Push the local frame buffer to the display. </p> <p>Synchronizes the local frame buffer (frame RAM) with the display, making all buffered changes visible on the physical display. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear","title":"variable clear","text":"<pre><code>FrameOperation clear;\n</code></pre> <p>Clear the entire display and frame buffer. </p> <p>Clears all pixels on the display and in the local frame buffer, typically by writing zero bytes to all GRAM locations. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert","title":"variable revert","text":"<pre><code>FrameOperation revert;\n</code></pre> <p>Revert the display to the previous frame content (if supported). </p> <p>Restores the previously displayed content. Not all devices support this operation; implementation may return CFBD_FALSE if unavailable. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-update_area","title":"variable update_area","text":"<pre><code>AreaOperations update_area;\n</code></pre> <p>Update a rectangular area on the display. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-clear_area","title":"variable clear_area","text":"<pre><code>AreaOperations clear_area;\n</code></pre> <p>Clear a rectangular area on the display and buffer. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-revert_area","title":"variable revert_area","text":"<pre><code>AreaOperations revert_area;\n</code></pre> <p>Revert a rectangular area to its previous content (if supported). </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-open","title":"variable open","text":"<pre><code>OLEDSelfOperation open;\n</code></pre> <p>Open/enable the display device. </p> <p>Powers on the display and initializes hardware resources. Must be called before using display operations. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-close","title":"variable close","text":"<pre><code>OLEDSelfOperation close;\n</code></pre> <p>Close/disable the display device. </p> <p>Powers off the display and releases hardware resources. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-self_consult","title":"variable self_consult","text":"<pre><code>OLED_QueryOperation self_consult;\n</code></pre> <p>Query device properties and capabilities. </p> <p>Retrieves device-specific information such as resolution, color depth, and supported features. Implementations must support at least:</p> <ul> <li>\"rgb\" (CFBD_Bool): CFBD_TRUE for RGB, CFBD_FALSE for monochrome</li> <li>\"width\" (uint16_t): Display width in pixels</li> <li>\"height\" (uint16_t): Display height in pixels</li> <li>\"color\" (uint8_t): Some Chips supports grey scale, try query these :)</li> </ul> <p>Additional device-specific properties may be queried as needed. </p>"},{"location":"api/Classes/struct__CFBD__OLED__OPS/#variable-self_property_setter","title":"variable self_property_setter","text":"<pre><code>OLED_SetPropertyOperation self_property_setter;\n</code></pre> <p>set device properties and capabilities. </p> <p>Retrieves device-specific information such as resolution, color depth, and supported features. Implementations must support at least:</p> <ul> <li>\"color\" (uint8_t): Some Chips supports grey scale, you can set this</li> </ul> <p>Additional device-specific properties may be queried as needed. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__PlainButton/","title":"_CFBD_PlainButton","text":"<p><code>#include &lt;plain_button.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__PlainButton/#public-attributes","title":"Public Attributes","text":"Name CFBDInputDeviceBase base_inputs CFBD_GPIOHandle * handle CFBD_PlainButtonMode mode CFBDEventInputHandler stateChangedCb CFBD_PlainButtonEventID current_state_id uint32_t press_time uint32_t release_time uint32_t last_click_time CFBD_Bool is_double_click_pending uint32_t click_pending_time CFBD_Bool is_pressed CFBD_Bool long_press_triggered CFBD_Bool button_press_state"},{"location":"api/Classes/struct__CFBD__PlainButton/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-base_inputs","title":"variable base_inputs","text":"<pre><code>CFBDInputDeviceBase base_inputs;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-handle","title":"variable handle","text":"<pre><code>CFBD_GPIOHandle * handle;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-mode","title":"variable mode","text":"<pre><code>CFBD_PlainButtonMode mode;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-statechangedcb","title":"variable stateChangedCb","text":"<pre><code>CFBDEventInputHandler stateChangedCb;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-current_state_id","title":"variable current_state_id","text":"<pre><code>CFBD_PlainButtonEventID current_state_id;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-press_time","title":"variable press_time","text":"<pre><code>uint32_t press_time;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-release_time","title":"variable release_time","text":"<pre><code>uint32_t release_time;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-last_click_time","title":"variable last_click_time","text":"<pre><code>uint32_t last_click_time;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-is_double_click_pending","title":"variable is_double_click_pending","text":"<pre><code>CFBD_Bool is_double_click_pending;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-click_pending_time","title":"variable click_pending_time","text":"<pre><code>uint32_t click_pending_time;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-is_pressed","title":"variable is_pressed","text":"<pre><code>CFBD_Bool is_pressed;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-long_press_triggered","title":"variable long_press_triggered","text":"<pre><code>CFBD_Bool long_press_triggered;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__PlainButton/#variable-button_press_state","title":"variable button_press_state","text":"<pre><code>CFBD_Bool button_press_state;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__UARTHandle/","title":"_CFBD_UARTHandle","text":"<p><code>#include &lt;uart.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#public-attributes","title":"Public Attributes","text":"Name CFBD_UARTOperations * ops CFBD_UARTAsyncCallback handle_async_callback uint32_t accept_timeout void * backends CFBD_UART_AsyncCallbacks * async_callbacks uint8_t * rx_buffer uint16_t rx_buffer_size"},{"location":"api/Classes/struct__CFBD__UARTHandle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_UARTOperations * ops;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-handle_async_callback","title":"variable handle_async_callback","text":"<pre><code>CFBD_UARTAsyncCallback handle_async_callback;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-accept_timeout","title":"variable accept_timeout","text":"<pre><code>uint32_t accept_timeout;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-backends","title":"variable backends","text":"<pre><code>void * backends;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-async_callbacks","title":"variable async_callbacks","text":"<pre><code>CFBD_UART_AsyncCallbacks * async_callbacks;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-rx_buffer","title":"variable rx_buffer","text":"<pre><code>uint8_t * rx_buffer;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTHandle/#variable-rx_buffer_size","title":"variable rx_buffer_size","text":"<pre><code>uint16_t rx_buffer_size;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct__CFBD__UARTOperations/","title":"_CFBD_UARTOperations","text":"<p><code>#include &lt;uart.h&gt;</code></p>"},{"location":"api/Classes/struct__CFBD__UARTOperations/#public-attributes","title":"Public Attributes","text":"Name void(*)(CFBD_UARTHandle *handle, const uint8_t *buffer, const uint16_t buffer_size) sync_send void(*)(CFBD_UARTHandle *handle, uint8_t *available_buffer, const uint16_t available_buffer_size) sync_receive void(*)(CFBD_UARTHandle *handle, const uint8_t *buffer, const uint16_t buffer_size) async_send void(*)(CFBD_UARTHandle *handle, uint8_t *available_buffer, const uint16_t available_buffer_size) async_receive"},{"location":"api/Classes/struct__CFBD__UARTOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct__CFBD__UARTOperations/#variable-sync_send","title":"variable sync_send","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, const uint8_t *buffer, const uint16_t buffer_size) sync_send;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTOperations/#variable-sync_receive","title":"variable sync_receive","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, uint8_t *available_buffer, const uint16_t available_buffer_size) sync_receive;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTOperations/#variable-async_send","title":"variable async_send","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, const uint8_t *buffer, const uint16_t buffer_size) async_send;\n</code></pre>"},{"location":"api/Classes/struct__CFBD__UARTOperations/#variable-async_receive","title":"variable async_receive","text":"<pre><code>void(*)(CFBD_UARTHandle *handle, uint8_t *available_buffer, const uint16_t available_buffer_size) async_receive;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDApplication/","title":"__CFBDApplication","text":"<p>Module: Application Management</p> <p>Application descriptor.  More...</p> <p><code>#include &lt;app.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes","title":"Public Attributes","text":"Name CFBD_BootStrapFunc selfBootFunc Optional bootstrap function for the application. CFBD_BootArgs bootargs Opaque pointer passed to <code>selfBootFunc</code> when invoked. CFBD_ClockFreqProvider freq_provider Provider that returns the system clock frequency (Hz). CFBD_ClockTickProvider tick_provider Provider that returns a monotonically increasing tick value."},{"location":"api/Classes/struct____CFBDApplication/#detailed-description","title":"Detailed Description","text":"<pre><code>struct __CFBDApplication;\n</code></pre> <p>Application descriptor. </p> <p>See: </p> <ul> <li>getApp()</li> <li>CFBD_AppBootMaker()</li> <li>CFBD_AppClockProvider()</li> <li>CFBD_AppTickProvider()</li> </ul> <p>Aggregates the bootstrap function and clock providers for an application. Typical usage is to expose a single application instance via <code>[getApp()](Modules/group__Application__Module.md#function-getapp)</code> that other framework components query to obtain boot actions and timing sources.</p> <p>The application descriptor serves as a central registry for all application-level services, allowing framework components to access initialization routines and timing information without requiring direct coupling to application code.</p>"},{"location":"api/Classes/struct____CFBDApplication/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDApplication/#variable-selfbootfunc","title":"variable selfBootFunc","text":"<pre><code>CFBD_BootStrapFunc selfBootFunc;\n</code></pre> <p>Optional bootstrap function for the application. </p> <p>Note: If NULL, the application framework will skip this step and rely on explicit boot table instead. </p> <p>When non-NULL, this function will be called during application startup to perform any app-specific initialization. Must match the <code>CFBD_BootStrapFunc</code> signature.</p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-bootargs","title":"variable bootargs","text":"<pre><code>CFBD_BootArgs bootargs;\n</code></pre> <p>Opaque pointer passed to <code>selfBootFunc</code> when invoked. </p> <p>Interpretation is defined by the bootstrap function. Common usage includes passing a configuration structure or application-specific context. </p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-freq_provider","title":"variable freq_provider","text":"<pre><code>CFBD_ClockFreqProvider freq_provider;\n</code></pre> <p>Provider that returns the system clock frequency (Hz). </p> <p>See: CFBD_ClockFreqProvider</p> <p>If NULL, timing calculations will fail. All timing-sensitive operations require this provider to be set.</p>"},{"location":"api/Classes/struct____CFBDApplication/#variable-tick_provider","title":"variable tick_provider","text":"<pre><code>CFBD_ClockTickProvider tick_provider;\n</code></pre> <p>Provider that returns a monotonically increasing tick value. </p> <p>See: CFBD_ClockTickProvider</p> <p>If NULL, interval measurements will be unavailable. Used in conjunction with freq_provider for time calculations.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDGraphicCircle/","title":"__CFBDGraphicCircle","text":"<p><code>#include &lt;circle.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDGraphicCircle/#public-attributes","title":"Public Attributes","text":"Name SizeBaseType radius Radius of the circle in device units. CFBDGraphic_Point center Center coordinate of the circle."},{"location":"api/Classes/struct____CFBDGraphicCircle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDGraphicCircle/#variable-radius","title":"variable radius","text":"<pre><code>SizeBaseType radius;\n</code></pre> <p>Radius of the circle in device units. </p>"},{"location":"api/Classes/struct____CFBDGraphicCircle/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>Center coordinate of the circle. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDInputDeviceBase/","title":"__CFBDInputDeviceBase","text":"<p><code>#include &lt;input_device_base.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDInputDeviceBase/#public-attributes","title":"Public Attributes","text":"Name CFBDInputDeviceID_t device_id CFBDInputEventContext * context CFBDInputDeviceBaseOperation * ops void * device_internals"},{"location":"api/Classes/struct____CFBDInputDeviceBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDInputDeviceBase/#variable-device_id","title":"variable device_id","text":"<pre><code>CFBDInputDeviceID_t device_id;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputDeviceBase/#variable-context","title":"variable context","text":"<pre><code>CFBDInputEventContext * context;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputDeviceBase/#variable-ops","title":"variable ops","text":"<pre><code>CFBDInputDeviceBaseOperation * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputDeviceBase/#variable-device_internals","title":"variable device_internals","text":"<pre><code>void * device_internals;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/","title":"__CFBDInputDeviceBaseOps","text":"<p><code>#include &lt;input_device_base.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/#public-attributes","title":"Public Attributes","text":"Name CFBD_Bool(*)(CFBDInputDeviceBase *device, CFBDInputEventContext *new_context) bind_context CFBD_Bool(*)(CFBDInputDeviceBase *device) unbind_context CFBD_Bool(*)(CFBDInputDeviceBase *device, CFBDInputEvent *event) report_once"},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/#variable-bind_context","title":"variable bind_context","text":"<pre><code>CFBD_Bool(*)(CFBDInputDeviceBase *device, CFBDInputEventContext *new_context) bind_context;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/#variable-unbind_context","title":"variable unbind_context","text":"<pre><code>CFBD_Bool(*)(CFBDInputDeviceBase *device) unbind_context;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputDeviceBaseOps/#variable-report_once","title":"variable report_once","text":"<pre><code>CFBD_Bool(*)(CFBDInputDeviceBase *device, CFBDInputEvent *event) report_once;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDInputEvent/","title":"__CFBDInputEvent","text":"<p><code>#include &lt;input_event.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDInputEvent/#public-attributes","title":"Public Attributes","text":"Name CFBDInputDeviceEventType_t event_indicates CFBDInputDeviceID_t device_id void * event_private_data CFBD_Bool stop_propergate"},{"location":"api/Classes/struct____CFBDInputEvent/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDInputEvent/#variable-event_indicates","title":"variable event_indicates","text":"<pre><code>CFBDInputDeviceEventType_t event_indicates;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEvent/#variable-device_id","title":"variable device_id","text":"<pre><code>CFBDInputDeviceID_t device_id;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEvent/#variable-event_private_data","title":"variable event_private_data","text":"<pre><code>void * event_private_data;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEvent/#variable-stop_propergate","title":"variable stop_propergate","text":"<pre><code>CFBD_Bool stop_propergate;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDInputEventContext/","title":"__CFBDInputEventContext","text":"<p><code>#include &lt;input.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDInputEventContext/#public-attributes","title":"Public Attributes","text":"Name CFBDInputEventContextOperations * ops CFBDEventInputHandler[INPUT_MAX_HANDLER_CNT] handlers uint8_t handler_count CFBDInputEvent[INPUT_EVENT_QUEUE_SIZE] queue volatile uint8_t head volatile uint8_t tail CFBD_Bool stop_propergate_if_failed"},{"location":"api/Classes/struct____CFBDInputEventContext/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-ops","title":"variable ops","text":"<pre><code>CFBDInputEventContextOperations * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-handlers","title":"variable handlers","text":"<pre><code>CFBDEventInputHandler[INPUT_MAX_HANDLER_CNT] handlers;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-handler_count","title":"variable handler_count","text":"<pre><code>uint8_t handler_count;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-queue","title":"variable queue","text":"<pre><code>CFBDInputEvent[INPUT_EVENT_QUEUE_SIZE] queue;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-head","title":"variable head","text":"<pre><code>volatile uint8_t head;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-tail","title":"variable tail","text":"<pre><code>volatile uint8_t tail;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContext/#variable-stop_propergate_if_failed","title":"variable stop_propergate_if_failed","text":"<pre><code>CFBD_Bool stop_propergate_if_failed;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/","title":"__CFBDInputEventContextOperations","text":"<p><code>#include &lt;input.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#public-attributes","title":"Public Attributes","text":"Name CFBD_Bool(*)(CFBDInputEventContext *context, CFBDInputEvent *event) enqueue_event CFBD_Bool(*)(CFBDInputEventContext *context) sync_poll CFBD_Bool(*)(CFBDInputEventContext *context, CFBDEventInputHandler handler) register_handle void(*)(CFBDInputEventContext *context, CFBDEventInputHandler handler) unregister_handler"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#variable-enqueue_event","title":"variable enqueue_event","text":"<pre><code>CFBD_Bool(*)(CFBDInputEventContext *context, CFBDInputEvent *event) enqueue_event;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#variable-sync_poll","title":"variable sync_poll","text":"<pre><code>CFBD_Bool(*)(CFBDInputEventContext *context) sync_poll;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#variable-register_handle","title":"variable register_handle","text":"<pre><code>CFBD_Bool(*)(CFBDInputEventContext *context, CFBDEventInputHandler handler) register_handle;\n</code></pre>"},{"location":"api/Classes/struct____CFBDInputEventContextOperations/#variable-unregister_handler","title":"variable unregister_handler","text":"<pre><code>void(*)(CFBDInputEventContext *context, CFBDEventInputHandler handler) unregister_handler;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/","title":"__CFBD_BaseAnimation","text":"<p>Module: Animation Framework</p> <p><code>#include &lt;animation.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes","title":"Public Attributes","text":"Name uint8_t anim_frames Number of animation frames. uint32_t anim_frame_delay_ms Delay in milliseconds per frame."},{"location":"api/Classes/struct____CFBD__BaseAnimation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frames","title":"variable anim_frames","text":"<pre><code>uint8_t anim_frames;\n</code></pre> <p>Number of animation frames. </p> <p>Total number of frames that comprise the complete animation cycle. Typical values: 4-16 frames for smooth animation perception (minimum 4 frames for noticeable animation, 8+ for smooth transitions). </p>"},{"location":"api/Classes/struct____CFBD__BaseAnimation/#variable-anim_frame_delay_ms","title":"variable anim_frame_delay_ms","text":"<pre><code>uint32_t anim_frame_delay_ms;\n</code></pre> <p>Delay in milliseconds per frame. </p> <p>Time interval between animation frames. Values:</p> <ul> <li>0: No delay (maximum speed, frame timing external)</li> <li>16-33: ~30-60 FPS (typical interactive UI)</li> <li>50+: Slower, cinematic transitions</li> </ul> <p>Total animation duration = anim_frames * anim_frame_delay_ms </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__DeviceIDGenerator/","title":"__CFBD_DeviceIDGenerator","text":"<p><code>#include &lt;input_id_allocator.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__DeviceIDGenerator/#public-attributes","title":"Public Attributes","text":"Name CFBDInputDeviceID_t(*)() get_next"},{"location":"api/Classes/struct____CFBD__DeviceIDGenerator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__DeviceIDGenerator/#variable-get_next","title":"variable get_next","text":"<pre><code>CFBDInputDeviceID_t(*)() get_next;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__GraphicArc/","title":"__CFBD_GraphicArc","text":"<p><code>#include &lt;arc.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__GraphicArc/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center Center point of the arc's parent circle. PointBaseType radius Radius from center to the arc in device units. int16_t start_degree Starting angle in degrees (0-359), measured counter-clockwise from right (3 o'clock). int16_t end_degree Ending angle in degrees (0-359). The arc sweeps from start_degree to end_degree."},{"location":"api/Classes/struct____CFBD__GraphicArc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__GraphicArc/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>Center point of the arc's parent circle. </p>"},{"location":"api/Classes/struct____CFBD__GraphicArc/#variable-radius","title":"variable radius","text":"<pre><code>PointBaseType radius;\n</code></pre> <p>Radius from center to the arc in device units. </p>"},{"location":"api/Classes/struct____CFBD__GraphicArc/#variable-start_degree","title":"variable start_degree","text":"<pre><code>int16_t start_degree;\n</code></pre> <p>Starting angle in degrees (0-359), measured counter-clockwise from right (3 o'clock). </p>"},{"location":"api/Classes/struct____CFBD__GraphicArc/#variable-end_degree","title":"variable end_degree","text":"<pre><code>int16_t end_degree;\n</code></pre> <p>Ending angle in degrees (0-359). The arc sweeps from start_degree to end_degree. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__GraphicEllipse/","title":"__CFBD_GraphicEllipse","text":"<p>Module: Ellipse Drawing</p> <p><code>#include &lt;ellipse.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__GraphicEllipse/#public-attributes","title":"Public Attributes","text":"Name CFBDGraphic_Point center PointBaseType X_Radius PointBaseType Y_Radius"},{"location":"api/Classes/struct____CFBD__GraphicEllipse/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__GraphicEllipse/#variable-center","title":"variable center","text":"<pre><code>CFBDGraphic_Point center;\n</code></pre> <p>The center point of the ellipse </p>"},{"location":"api/Classes/struct____CFBD__GraphicEllipse/#variable-x_radius","title":"variable X_Radius","text":"<pre><code>PointBaseType X_Radius;\n</code></pre> <p>The horizontal radius (semi-major or semi-minor axis) </p>"},{"location":"api/Classes/struct____CFBD__GraphicEllipse/#variable-y_radius","title":"variable Y_Radius","text":"<pre><code>PointBaseType Y_Radius;\n</code></pre> <p>The vertical radius (semi-minor or semi-major axis) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__Logger/","title":"__CFBD_Logger","text":"<p><code>#include &lt;cfbd_log.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__Logger/#public-attributes","title":"Public Attributes","text":"Name CFBD_LoggerOperations * ops CFBD_NativeLoggerOperations * native_logs cfbd_log_level_t filter_off_level uint8_t * buffer_ptr uint16_t buffer_sz void * native_handle CFBD_Bool enable_colorize"},{"location":"api/Classes/struct____CFBD__Logger/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__Logger/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_LoggerOperations * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-native_logs","title":"variable native_logs","text":"<pre><code>CFBD_NativeLoggerOperations * native_logs;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-filter_off_level","title":"variable filter_off_level","text":"<pre><code>cfbd_log_level_t filter_off_level;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-buffer_ptr","title":"variable buffer_ptr","text":"<pre><code>uint8_t * buffer_ptr;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-buffer_sz","title":"variable buffer_sz","text":"<pre><code>uint16_t buffer_sz;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-native_handle","title":"variable native_handle","text":"<pre><code>void * native_handle;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Logger/#variable-enable_colorize","title":"variable enable_colorize","text":"<pre><code>CFBD_Bool enable_colorize;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/","title":"__CFBD_MenuIndicator","text":"<p><code>#include &lt;menu_indicator.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes","title":"Public Attributes","text":"Name uint8_t width Width of sliding indicator bar in pixels. uint8_t x X-position (left edge) of indicator in pixels."},{"location":"api/Classes/struct____CFBD__MenuIndicator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-width","title":"variable width","text":"<pre><code>uint8_t width;\n</code></pre> <p>Width of sliding indicator bar in pixels. </p> <p>Set to 0 to disable indicator drawing </p>"},{"location":"api/Classes/struct____CFBD__MenuIndicator/#variable-x","title":"variable x","text":"<pre><code>uint8_t x;\n</code></pre> <p>X-position (left edge) of indicator in pixels. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItem/","title":"__CFBD_MenuItem","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes","title":"Public Attributes","text":"Name char * label Menu item display label (zero-terminated string, owned by caller) CFBDGraphic_Point tl Top-left pixel position of item label area. CFBD_MenuItemCallbackPack on_select Optional callback invoked when item is activated/selected. CFBDGraphic_Text text_obj Internal text rendering object (initialized on menu add)"},{"location":"api/Classes/struct____CFBD__MenuItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-label","title":"variable label","text":"<pre><code>char * label;\n</code></pre> <p>Menu item display label (zero-terminated string, owned by caller) </p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre> <p>Top-left pixel position of item label area. </p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-on_select","title":"variable on_select","text":"<pre><code>CFBD_MenuItemCallbackPack on_select;\n</code></pre> <p>Optional callback invoked when item is activated/selected. </p>"},{"location":"api/Classes/struct____CFBD__MenuItem/#variable-text_obj","title":"variable text_obj","text":"<pre><code>CFBDGraphic_Text text_obj;\n</code></pre> <p>Internal text rendering object (initialized on menu add) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/","title":"__CFBD_MenuItemArray","text":"<p><code>#include &lt;menu_item.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes","title":"Public Attributes","text":"Name CFBD_MenuItem * pItems Array of menu items. size_t capacity Total allocated capacity. size_t count Current number of items in group."},{"location":"api/Classes/struct____CFBD__MenuItemArray/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-pitems","title":"variable pItems","text":"<pre><code>CFBD_MenuItem * pItems;\n</code></pre> <p>Array of menu items. </p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-capacity","title":"variable capacity","text":"<pre><code>size_t capacity;\n</code></pre> <p>Total allocated capacity. </p>"},{"location":"api/Classes/struct____CFBD__MenuItemArray/#variable-count","title":"variable count","text":"<pre><code>size_t count;\n</code></pre> <p>Current number of items in group. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/","title":"__CFBD_ProgressBar","text":"<p><code>#include &lt;progressbar.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes","title":"Public Attributes","text":"Name CFBD_ProgressBarOps * ops Progress bar operation table. CFBDGraphic_Point tl Top-left position of progress bar in pixels. CFBDGraphicSize size Width and height dimensions of progress bar. int32_t min Minimum value of progress range. int32_t max Maximum value of progress range. int32_t value Current progress value (must be in [min, max]) CFBD_GraphicDevice * device Graphics device for rendering. uint8_t border Border display flag (0=no border, 1=display border) uint8_t padding Inner padding between border and fill in pixels. CFBD_BaseAnimation animation Animation timing configuration for transitions."},{"location":"api/Classes/struct____CFBD__ProgressBar/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps * ops;\n</code></pre> <p>Progress bar operation table. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre> <p>Top-left position of progress bar in pixels. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-size","title":"variable size","text":"<pre><code>CFBDGraphicSize size;\n</code></pre> <p>Width and height dimensions of progress bar. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-min","title":"variable min","text":"<pre><code>int32_t min;\n</code></pre> <p>Minimum value of progress range. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-max","title":"variable max","text":"<pre><code>int32_t max;\n</code></pre> <p>Maximum value of progress range. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-value","title":"variable value","text":"<pre><code>int32_t value;\n</code></pre> <p>Current progress value (must be in [min, max]) </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-device","title":"variable device","text":"<pre><code>CFBD_GraphicDevice * device;\n</code></pre> <p>Graphics device for rendering. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-border","title":"variable border","text":"<pre><code>uint8_t border;\n</code></pre> <p>Border display flag (0=no border, 1=display border) </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-padding","title":"variable padding","text":"<pre><code>uint8_t padding;\n</code></pre> <p>Inner padding between border and fill in pixels. </p>"},{"location":"api/Classes/struct____CFBD__ProgressBar/#variable-animation","title":"variable animation","text":"<pre><code>CFBD_BaseAnimation animation;\n</code></pre> <p>Animation timing configuration for transitions. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____CFBD__Widget/","title":"__CFBD_Widget","text":"<p>Clean and LightWighted Containers for the widget sessions. </p> <p><code>#include &lt;widget.h&gt;</code></p>"},{"location":"api/Classes/struct____CFBD__Widget/#public-attributes","title":"Public Attributes","text":"Name CFBD_Widget * parent CFBD_Widget ** children size_t children_container_sz size_t children_cnt CFBD_WidgetRequestOverrideOperations * override_ops CFBD_WidgetOperations * ops CFBDGraphic_Point tl_point CFBDGraphicSize size void * external_data"},{"location":"api/Classes/struct____CFBD__Widget/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____CFBD__Widget/#variable-parent","title":"variable parent","text":"<pre><code>CFBD_Widget * parent;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-children","title":"variable children","text":"<pre><code>CFBD_Widget ** children;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-children_container_sz","title":"variable children_container_sz","text":"<pre><code>size_t children_container_sz;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-children_cnt","title":"variable children_cnt","text":"<pre><code>size_t children_cnt;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-override_ops","title":"variable override_ops","text":"<pre><code>CFBD_WidgetRequestOverrideOperations * override_ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_WidgetOperations * ops;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-tl_point","title":"variable tl_point","text":"<pre><code>CFBDGraphic_Point tl_point;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-size","title":"variable size","text":"<pre><code>CFBDGraphicSize size;\n</code></pre>"},{"location":"api/Classes/struct____CFBD__Widget/#variable-external_data","title":"variable external_data","text":"<pre><code>void * external_data;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Classes/struct____SSD132XPrivateDatas/","title":"__SSD132XPrivateDatas","text":"<p><code>#include &lt;oled_ssd132x_privates.h&gt;</code></p>"},{"location":"api/Classes/struct____SSD132XPrivateDatas/#public-attributes","title":"Public Attributes","text":"Name uint8_t grey_scale"},{"location":"api/Classes/struct____SSD132XPrivateDatas/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/struct____SSD132XPrivateDatas/#variable-grey_scale","title":"variable grey_scale","text":"<pre><code>uint8_t grey_scale;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h","text":"<pre><code>// Example 1: 90-degree quarter arc\nCFBD_GraphicArc quarter = {\n    .center = {160, 120},\n    .radius = 50,\n    .start_degree = 0,\n    .end_degree = 90\n};\nCFBDGraphic_DrawArc(device, &amp;quarter);\n\n// Example 2: Progress indicator (filled arc)\nCFBD_GraphicArc progress = {\n    .center = {160, 120},\n    .radius = 40,\n    .start_degree = 0,\n    .end_degree = 270  // 75% complete\n};\nCFBDGraphic_DrawFilledArc(device, &amp;progress);\n\n// Example 3: Clock hour markers (12 arcs)\nfor (int i = 0; i &lt; 12; i++) {\n    int angle = (i * 30);  // 30 degrees per hour\n    CFBD_GraphicArc marker = {\n        .center = {160, 120},\n        .radius = 60,\n        .start_degree = angle,\n        .end_degree = angle + 5\n    };\n    CFBDGraphic_DrawArc(device, &amp;marker);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2arc_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct __CFBD_GraphicArc {     CFBDGraphic_Point center;</p> <pre><code>PointBaseType radius;\n\nint16_t start_degree;\n\nint16_t end_degree;\n</code></pre> <p>} CFBD_GraphicArc;</p> <p>void CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* circle);</p> <p>void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* circle);</p> <p>// End of Arc_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/arc.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h","text":"<pre><code>// Example 1: Draw a simple circle outline\nCFBDGraphicCircle indicator = {\\n *     .radius = 20,\n    .center = {160, 120}\n};\nCFBDGraphic_DrawCircle(display_device, &amp;indicator);\n\n// Example 2: Draw filled circles of increasing size\nfor (int r = 10; r &lt; 50; r += 10) {\n    CFBDGraphicCircle circle = {.radius = r, .center = {160, 120}};\n    CFBDGraphic_DrawFilledCircle(display_device, &amp;circle);\n}\n\n// Example 3: Multiple circles for a radar display\nCFBDGraphicCircle radar_rings[] = {\n    {.radius = 30, .center = {160, 120}},\n    {.radius = 60, .center = {160, 120}},\n    {.radius = 90, .center = {160, 120}}\n};\nfor (int i = 0; i &lt; 3; i++) {\n    CFBDGraphic_DrawCircle(device, &amp;radar_rings[i]);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2circle_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct __CFBDGraphicCircle {     SizeBaseType radius;</p> <pre><code>CFBDGraphic_Point center;\n</code></pre> <p>} CFBDGraphicCircle;</p> <p>void CFBDGraphic_DrawCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);</p> <p>void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);</p> <p>// End of Circle_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/circle.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h","text":"<pre><code>// Create a circle with center at (160, 120) and radius 50\nCFBD_GraphicEllipse circle = {\n    {160, 120},  // center\n    50,          // X_Radius\n    50           // Y_Radius\n};\nCFBDGraphic_DrawEllipse(device, &amp;circle);\n\n// Create an ellipse with different horizontal and vertical radii\nCFBD_GraphicEllipse ellipse = {\n    {160, 120},  // center\n    80,          // X_Radius (wider)\n    50           // Y_Radius (narrower)\n};\nCFBDGraphic_DrawEllipse(device, &amp;ellipse);\n\n// Draw a filled ellipse\nCFBD_GraphicEllipse filled_ellipse = {{320, 240}, 30, 40};\nCFBDGraphic_DrawFilledEllipse(device, &amp;filled_ellipse);\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2ellipse_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct __CFBD_GraphicEllipse {     CFBDGraphic_Point center;      PointBaseType X_Radius;      PointBaseType Y_Radius;  } CFBD_GraphicEllipse;</p> <p>void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* device, CFBD_GraphicEllipse* ellipse);</p> <p>void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* device, CFBD_GraphicEllipse* ellipse);</p> <p>// End of Ellipse_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/ellipse.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h","text":"<pre><code>// Create a horizontal line from (50, 100) to (200, 100)\nCFBDGraphic_Line horizontal_line = {\n    {50, 100},   // p_left\n    {200, 100}   // p_right\n};\n\n// Create a diagonal line from (0, 0) to (100, 100)\nCFBDGraphic_Point start = {0, 0};\nCFBDGraphic_Point end = {100, 100};\nCFBDGraphic_Line diagonal = {start, end};\n\n// Using points defined elsewhere\nCFBDGraphic_Line custom_line = {center_point, edge_point};\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2line_8h-example/#include-pointh","title":"include \"point.h\"","text":"<p>typedef struct {     CFBDGraphic_Point p_left;     CFBDGraphic_Point p_right;  } CFBDGraphic_Line;</p> <p>void CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line);</p> <p>// End of Line_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/line.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h","text":"<pre><code>// Create a point at coordinates (100, 200)\nCFBDGraphic_Point my_point = {100, 200};\n\n// Add two points together with automatic clamping\nCFBDGraphic_Point point1 = {50, 75};\nCFBDGraphic_Point point2 = {100, 150};\nCFBDGraphic_Point result = point_add(point1, point2);\n// result: {150, 225}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2point_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":"<p>typedef struct {     PointBaseType x;      PointBaseType y;  } CFBDGraphic_Point;</p> <p>typedef struct {     int32_t x;      int32_t y;  } CFBDGraphic_Vec2i;</p> <p>static inline CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b) {     uint32_t x = (uint32_t) a.x + b.x;     uint32_t y = (uint32_t) a.y + b.y;</p> <pre><code>if (x &gt; UINT16_MAX)\n    x = UINT16_MAX;\nif (y &gt; UINT16_MAX)\n    y = UINT16_MAX;\n\nreturn (CFBDGraphic_Point) {(uint16_t) x, (uint16_t) y};\n</code></pre> <p>}</p> <p>static inline CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b) {     return (CFBDGraphic_Vec2i) {(int32_t) a.x - (int32_t) b.x, (int32_t) a.y - (int32_t) b.y}; }</p> <p>// End of Point_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/point.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h","text":"<pre><code>// Create a size for a 320x240 display\nCFBDGraphicSize screen_size = {320, 240};\n\n// Create a size for a button\nCFBDGraphicSize button_size = {80, 40};\n\n// Get screen size from device\nCFBDGraphicSize dev_size;\nCFBDGraphic_GetScreenSize(graphics_device, &amp;dev_size);\n\n// Use size to calculate area\nuint32_t area = dev_size.width * dev_size.height;\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2base_2size_8h-example/#include-devicegraphic_deviceh","title":"include \"device/graphic_device.h\"","text":"<p>typedef struct {     SizeBaseType width;     SizeBaseType height;  } CFBDGraphicSize;</p> <p>void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize);</p> <p>// End of Size_Module group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/base/size.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2device_2oled_2oled_graphic_device_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/device/oled/oled_graphic_device.h","text":"<pre><code>// Example: Create and use an OLED graphics device\n#include \"oled_graphic_device.h\"\n#include \"oled.h\"\n\nCFBD_OLED oled;\nCFBD_GraphicDevice graphics;\n\n// Initialize OLED display\nCFBD_OLED_IICInitsParams iic_config = {...};\nCFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_config, CFBD_TRUE);\n\n// Bind as graphics device\nCFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\ngraphics.ops-&gt;open(&amp;graphics);\n\n// Use graphics operations\ngraphics.ops-&gt;clear(&amp;graphics);\ngraphics.ops-&gt;setPixel(&amp;graphics, 64, 32);\ngraphics.ops-&gt;update(&amp;graphics);\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2device_2oled_2oled_graphic_device_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2device_2oled_2oled_graphic_device_8h-example/#include-devicegraphic_deviceh","title":"include \"device/graphic_device.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2device_2oled_2oled_graphic_device_8h-example/#include-oledh","title":"include \"oled.h\"","text":"<p>void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled);</p> <p>// end of Graphics_OLED group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/device/oled/oled_graphic_device.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/resource/config.h","text":"<pre><code>// To compile without default fonts:\n#define _USE_NO_DEFAULT_SOURCES\n#include \"config.h\"\n\n// To selectively disable fonts:\n#undef _USE_NO_DEFAULT_SOURCES\n#define DISABLE_ASCII_6X8_SOURCES\n#include \"config.h\"\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#ifndef-ccgraphic_config_h","title":"ifndef CCGraphic_Config_H","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-ccgraphic_config_h","title":"define CCGraphic_Config_H","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#ifdef-_use_no_default_sources","title":"ifdef _USE_NO_DEFAULT_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_6x8_sources-0","title":"define ENABLE_ASCII_6x8_SOURCES 0","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_8x16_sources-0","title":"define ENABLE_ASCII_8X16_SOURCES 0","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#else","title":"else","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_6x8_sources-1","title":"define ENABLE_ASCII_6x8_SOURCES 1","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_8x16_sources-1","title":"define ENABLE_ASCII_8x16_SOURCES 1","text":"<p>/* Selective resource disabling */</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#ifdef-disable_ascii_6x8_sources","title":"ifdef DISABLE_ASCII_6X8_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#undef-enable_ascii_6x8_sources","title":"undef ENABLE_ASCII_6x8_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_6x8_sources-0_1","title":"define ENABLE_ASCII_6x8_SOURCES 0","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#endif","title":"endif","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#ifdef-disable_ascii_8x16_sources","title":"ifdef DISABLE_ASCII_8X16_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#undef-enable_ascii_8x16_sources","title":"undef ENABLE_ASCII_8X16_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#define-enable_ascii_8x16_sources-0_1","title":"define ENABLE_ASCII_8X16_SOURCES 0","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#endif_1","title":"endif","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#endif--for-the-_use_no_default_sources","title":"endif // for the _USE_NO_DEFAULT_SOURCES","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2resource_2config_8h-example/#endif--for-the-no-repeative-include-guard","title":"endif // for the no-repeative include guard","text":"<p>// end of Graphics_Resources group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/resource/config.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2animation_2animation_config_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/animation/animation_config.h","text":"<pre><code>// Default animation would run for (8 frames * 0 ms = 0 ms)\n// or external frame timing if delay_ms is 0\n</code></pre> <pre><code>#pragma once\n\n#define CFBD_BASEANIMATION_FRAME_CNT (8)\n\n#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/animation/animation_config.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2base_support_2image_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/base_support/image.h","text":"<p>Initialize an image widget structure Sets up an image widget with position, size, and bitmap data. All pointer parameters must remain valid for the lifetime of the image structure usage. CCGraphic_Image img; CFBDGraphic_Point pos = {10, 20}; CFBDGraphicSize sz = {32, 32}; uint8_t bitmap[128] = {...}; // 32x32 pixels CFBDGraphic_InitImage(&amp;img, &amp;pos, &amp;sz, bitmap); CFBDGraphic_DrawImage(device, &amp;img); </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2menu_2icontext_menu_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/icontext_menu.h","text":"<p>Initialize icon-text menu widget Configures a new icon-text menu with caller-provided items buffer. No dynamic allocation - caller manages buffer memory. CFBD_IconTextMenuItem items[6]; // Stack allocation CFBD_IconTextMenu menu; CFBDGraphicRect view = {{0, 24}, {128, 104}}; CFBD_InitIconTextMenu(&amp;menu, device, &amp;view, items, 6); menu.operations-&gt;add_item(&amp;menu, \"Home\", icon_data, &amp;icon_size, NULL);</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2menu_2menu_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu.h","text":"<p>Initialize menu widget structure Sets up menu with graphics device, item group, and constraints. Menu is ready to use after initialization.  CFBD_Menu menu; CFBD_MenuItemGroup items = {...}; // Pre-allocated items CFBD_InitMenu(&amp;menu, graphics_device, &amp;items, 128); menu.operations-&gt;add_item(&amp;menu, \"Item 1\", ASCII_8x16, NULL); menu.operations-&gt;immediate_draw(&amp;menu); </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2menu_2menu_indicator_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu_indicator.h","text":"<p>Initialize menu indicator with default values Sets up a menu indicator with default configuration from menu_config.h macros (CFBD_MENU_INDICATOR_WIDTH, CFBD_MENU_INDICATOR_POSX).  CFBD_MenuIndicator indicator; CFBD_InitDefaultMenuIndicator(&amp;indicator); // indicator.width = CFBD_MENU_INDICATOR_WIDTH (4 by default) // indicator.x = CFBD_MENU_INDICATOR_POSX (0 by default) </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2menu_2menu_item_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/menu/menu_item.h","text":"<p>void on_start_selected(void* user_data) { int* app_state = (int*)user_data; *app_state = STATE_RUNNING; } </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/progressbar/progressbar.h","text":"<p>Render progress bar immediately Draws current progress bar state with all visual properties. Updates display immediately if device in immediate mode.  pb-&gt;ops-&gt;immediate_draw(pb); ```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include","title":"include","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include-basepointh","title":"include \"base/point.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include-basesizeh","title":"include \"base/size.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include-cfbd_defineh","title":"include \"cfbd_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include-cfbd_graphic_defineh","title":"include \"cfbd_graphic_define.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2progressbar_2progressbar_8h-example/#include-widgetanimationanimationh","title":"include \"widget/animation/animation.h\" <p>typedef struct __CFBD_ProgressBar CFBD_ProgressBar;</p> <p>typedef struct {     void (immediate_draw)(CFBD_ProgressBar);</p> <pre><code>void (*set_value)(CFBD_ProgressBar*, int32_t new_value);\n\nCFBD_Bool (*set_property)(CFBD_ProgressBar*, const char* property, const void* args);\n</code></pre> <p>} CFBD_ProgressBarOps;</p> <p>typedef struct __CFBD_ProgressBar {     CFBD_ProgressBarOps* ops;</p> <pre><code>CFBDGraphic_Point tl;\n\nCFBDGraphicSize size;\n\nint32_t min;\n\nint32_t max;\n\nint32_t value;\n\nCFBD_GraphicDevice* device;\n\nuint8_t border;\n\nuint8_t padding;\n\nCFBD_BaseAnimation animation;\n</code></pre> <p>} CFBD_ProgressBar;</p> <p>void CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,                            CFBD_GraphicDevice* device,                            CFBDGraphic_Point* tl,                            CFBDGraphicSize* sz,                            int32_t min,                            int32_t max);</p> <p>```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/progressbar/progressbar.h</p>  <p>Updated on 2026-02-03 at 13:21:55 +0000</p>","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/text.h","text":"<p>Initialize text widget structure Sets up text widget with position, bounds, and font configuration. Text content is not set; use CFBDGraphic_SetText() after initialization. CFBDGraphic_Text text; CFBDGraphic_Point pos = {10, 10}; CFBDGraphicSize area = {118, 54}; // 118x54 pixel area CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16); CFBDGraphic_SetText(&amp;text, \"Hello World\"); CFBDGraphic_DrawText(device, &amp;text, CCGraphic_AsciiTextItem_AppendContinously); </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/text_config.h","text":"<p>// Using 8x16 font if enabled #if ENABLE_ASCII_8x16_SOURCES CFBDGraphic_Text text; CFBDGraphic_InitText(&amp;text, pos, sz, ASCII_8x16); #endif ```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#include-basesizeh","title":"include \"base/size.h\"","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#include-resourceconfigh","title":"include \"resource/config.h\"","text":"<p>typedef enum {</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#if-enable_ascii_6x8_sources","title":"if ENABLE_ASCII_6x8_SOURCES","text":"<pre><code>ASCII_6x8,\n</code></pre>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#endif","title":"endif","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#if-enable_ascii_8x16_sources","title":"if ENABLE_ASCII_8x16_SOURCES","text":"<pre><code>ASCII_8x16,\n</code></pre>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#endif_1","title":"endif","text":"<pre><code>NO_ASCII_SIZE\n</code></pre> <p>} Ascii_Font_Size;</p> <p>typedef enum {     Unicode_16x16 } Unicode_Font_Size;</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2graphic_2widget_2text_config_8h-example/#define-unsupportive_font_source-void-0","title":"define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)","text":"<p>uint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch);</p> <p>CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s);</p> <p>```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/graphic/widget/text_config.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2backend_2oled_iic_130x_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic_130x.h","text":"<p>Initialize an I2C-based OLED device instance.Performs the necessary wiring between the generic CFBD_OLED object and the platform-specific I2C implementation described by pvt_handle. This function configures the device address, binds the I2C handle, and sets up callbacks for asynchronous transaction notifications.</p> <p>After calling this function, the OLED object is ready for device operations. The caller must ensure that the I2C interface is properly initialized before calling this function.</p> <pre><code>// Example: Complete I2C OLED initialization flow\n#include \"driver/backend/oled_iic.h\"\n#include \"driver/device/ssd1309/ssd1309.h\"\n\n// Step 1: Prepare I2C parameters\nCFBD_OLED_IICInitsParams iic_params = {\n    .device_address = SSD1309_DRIVER_ADDRESS,\n    .i2c_handle = my_i2c_interface,\n    .notify_tx_complete = on_transaction_complete,\n    .notify_error = on_i2c_error\n};\n\n// Step 2: Create and initialize OLED instance\nCFBD_OLED oled_device;\nCFBD_OLED_IICInit(&amp;oled_device, &amp;iic_params);\n\n// Step 3: Open the device and begin operations\nif (oled_device.ops-&gt;open(&amp;oled_device)) {\n    // Device is ready for use\n    oled_device.ops-&gt;update(&amp;oled_device);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2backend_2oled_iic_132x_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/backend/oled_iic_132x.h","text":"<p>Initialize an I2C-based OLED device instance.Performs the necessary wiring between the generic CFBD_OLED object and the platform-specific I2C implementation described by pvt_handle. This function configures the device address, binds the I2C handle, and sets up callbacks for asynchronous transaction notifications.</p> <p>After calling this function, the OLED object is ready for device operations. The caller must ensure that the I2C interface is properly initialized before calling this function.</p> <pre><code>// Example: Complete I2C OLED initialization flow\n#include \"driver/backend/oled_iic.h\"\n#include \"driver/device/ssd1309/ssd1309.h\"\n\n// Step 1: Prepare I2C parameters\nCFBD_OLED_IICInitsParams iic_params = {\n    .device_address = SSD1309_DRIVER_ADDRESS,\n    .i2c_handle = my_i2c_interface,\n    .notify_tx_complete = on_transaction_complete,\n    .notify_error = on_i2c_error\n};\n\n// Step 2: Create and initialize OLED instance\nCFBD_OLED oled_device;\nCFBD_OLED_IICInit(&amp;oled_device, &amp;iic_params);\n\n// Step 3: Open the device and begin operations\nif (oled_device.ops-&gt;open(&amp;oled_device)) {\n    // Device is ready for use\n    oled_device.ops-&gt;update(&amp;oled_device);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h","text":"<pre><code>// Example: Getting device-specific descriptor and querying geometry\nCFBD_OLED_DeviceSpecific* device_spec = getSSD1306Specific();\nif (device_spec != NULL) {\n    uint16_t width = device_spec-&gt;logic_width;\n    uint16_t height = device_spec-&gt;logic_height;\n    uint8_t* frame_buffer = device_spec-&gt;grams[0];\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/#include","title":"include","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2device_interface_8h-example/#include-configsiic_pack_typeh","title":"include \"configs/iic_pack_type.h\" <p>typedef struct {     uint8_t* (*init_session_tables)(void);</p> <pre><code>uint8_t** grams;\n\nuint16_t init_session_tables_sz;\n\nuint8_t data_prefix;\n\nuint8_t cmd_prefix;\n\nuint16_t logic_width;\n\nuint16_t logic_height;\n\nconst char* iic_pack_type;\n\nvoid* private_data;\n</code></pre> <p>} CFBD_OLED_DeviceSpecific;</p> <p>// end of OLED_Device group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/device_interface.h</p>  <p>Updated on 2026-02-03 at 13:21:55 +0000</p>","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1306_2ssd1306_8h-example/","title":"2home 2runner 2work 2BareMetal Drivers 2BareMetal Drivers 2lib 2oled 2driver 2device 2ssd1306 2ssd1306 8h example","text":"<p>title: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h summary: Factory function: returns the SSD1306 device-specific descriptor. </p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1306_2ssd1306_8h-example/#homerunnerworkbaremetal-driversbaremetal-driversliboleddriverdevicessd1306ssd1306h","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1306/ssd1306.h","text":"<p>Factory function: returns the SSD1306 device-specific descriptor.Retrieves a pointer to the static SSD1306 device descriptor. This descriptor encapsulates all hardware-specific parameters needed to initialize and operate an SSD1306 display via the generic OLED driver interface.</p> <p>The returned descriptor contains:</p> <ul> <li>Initialization command sequences</li> <li>Frame buffer (GRAM) pointers</li> <li>I2C/SPI communication prefixes</li> <li>Display resolution (typically 128x64)</li> </ul> <pre><code>// Example: Obtaining SSD1306 device descriptor for initialization\n#include \"driver/device/ssd1306/ssd1306.h\"\n#include \"oled.h\"\n\nCFBD_OLED_DeviceSpecific* device = getSSD1306Specific();\nCFBD_OLED oled_handle;\nCFBD_OLEDDriverType driver_type = CFBD_OLEDDriverType_IIC;\n\n// The device descriptor is passed implicitly through the driver initialization\nCFBD_GetOLEDHandle(&amp;oled_handle, driver_type, NULL, CFBD_TRUE);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1309_2ssd1309_8h-example/","title":"2home 2runner 2work 2BareMetal Drivers 2BareMetal Drivers 2lib 2oled 2driver 2device 2ssd1309 2ssd1309 8h example","text":"<p>title: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h summary: Factory function: returns the SSD1309 device-specific descriptor. </p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2driver_2device_2ssd1309_2ssd1309_8h-example/#homerunnerworkbaremetal-driversbaremetal-driversliboleddriverdevicessd1309ssd1309h","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/driver/device/ssd1309/ssd1309.h","text":"<p>Factory function: returns the SSD1309 device-specific descriptor.Retrieves a pointer to the static SSD1309 device descriptor. This descriptor encapsulates all hardware-specific parameters needed to initialize and operate an SSD1309 display via the generic OLED driver interface.</p> <p>The returned descriptor contains:</p> <ul> <li>Device-specific initialization command sequences</li> <li>Frame buffer (GRAM) pointers optimized for SSD1309 memory layout</li> <li>I2C/SPI communication prefixes with SSD1309-specific values</li> <li>Display resolution adapted for SSD1309 capabilities</li> <li>Enhanced timing and contrast parameters</li> </ul> <pre><code>// Example: Obtaining SSD1309 device descriptor for I2C initialization\n#include \"driver/device/ssd1309/ssd1309.h\"\n#include \"driver/backend/oled_iic.h\"\n#include \"oled.h\"\n\nCFBD_OLED_DeviceSpecific* device = getSSD1309Specific();\nCFBD_OLED oled_handle;\n\n// Setup I2C parameters for SSD1309\nCFBD_OLED_IICInitsParams iic_params = {\n    .device_address = SSD1309_DRIVER_ADDRESS,\n    // ... other I2C parameters\n};\n\n// Initialize OLED device\nCFBD_GetOLEDHandle(&amp;oled_handle, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/","title":"/home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h","text":"<pre><code>// Example: Clear a rectangular area at (10, 20) with size 64x32\nCFBD_OLED* oled = &amp;my_oled_device;\nCFBD_Bool result = oled-&gt;ops-&gt;clear_area(oled, 10, 20, 64, 32);\nif (result) {\n    oled-&gt;ops-&gt;update_area(oled, 10, 20, 64, 32);\n}\n</code></pre> <p>```cpp</p>"},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/#pragma-once","title":"pragma once","text":""},{"location":"api/Examples/_2home_2runner_2work_2BareMetal-Drivers_2BareMetal-Drivers_2lib_2oled_2oled_8h-example/#include-cfbd_defineh","title":"include \"cfbd_define.h\"","text":"<p>typedef enum {     CFBD_OLEDDriverType_IIC,      CFBD_OLEDDriverType_SPI } CFBD_OLEDDriverType;</p> <p>typedef void* CFBD_OLEDHandle;</p> <p>typedef struct _CFBD_OLED CFBD_OLED;</p> <p>typedef CFBD_Bool (         AreaOperations)(CFBD_OLED oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);</p> <p>typedef CFBD_Bool (FrameOperation)(CFBD_OLED oled);</p> <p>typedef CFBD_Bool (OLEDSelfOperation)(CFBD_OLED oled);</p> <p>typedef CFBD_Bool (OLED_QueryOperation)(CFBD_OLED oled,                                          const char* property,                                          void* args,                                          void* request_data);</p> <p>typedef CFBD_Bool (OLED_SetPropertyOperation)(CFBD_OLED oled,                                                const char* property,                                                void* args,                                                void* request_data); // What to write?</p> <p>typedef struct _CFBD_OLED_OPS {     int (init)(CFBD_OLED oled, void* init_args);</p> <pre><code>CFBD_Bool (*setPixel)(CFBD_OLED* oled, uint16_t x, uint16_t y);\n\nCFBD_Bool (*setArea)(CFBD_OLED* device,\n                     uint16_t x,\n                     uint16_t y,\n                     uint16_t width,\n                     uint16_t height,\n                     uint8_t* source);\n\nFrameOperation update;\n\nFrameOperation clear;\n\nFrameOperation revert;\n\nAreaOperations update_area;\n\nAreaOperations clear_area;\n\nAreaOperations revert_area;\n\nOLEDSelfOperation open;\n\nOLEDSelfOperation close;\n\nOLED_QueryOperation self_consult;\n\nOLED_SetPropertyOperation self_property_setter;\n</code></pre> <p>} CFBD_OLEDOperations;</p> <p>typedef struct _CFBD_OLED {     const CFBD_OLEDOperations* ops;</p> <pre><code>CFBD_OLEDDriverType driver_type;\n\nCFBD_OLEDHandle oled_internal_handle;\n</code></pre> <p>} CFBD_OLED;</p> <p>typedef void* CFBDOLED_Params_Inits;</p> <p>CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,                              const CFBD_OLEDDriverType driver_type,                              CFBDOLED_Params_Inits args,                              CFBD_Bool request_immediate_init);</p> <p>// end of OLED group```</p> <p>Filename: /home/runner/work/BareMetal-Drivers/BareMetal-Drivers/lib/oled/oled.h</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/_2strong-example/","title":"2strong example","text":"<p>title: &gt;: Comprehensive guides and reference documentation</p>"},{"location":"api/Examples/_2strong-example/#-comprehensive-guides-and-reference-documentation","title":"&gt;: Comprehensive guides and reference documentation","text":"<ul> <li>Practical code examples</li> </ul> <ul> <li> <ul> <li>**- Related types/functions</li> </ul> </li> </ul> <p>* **</p>"},{"location":"api/Examples/_2strong-example/#operation-table-documentationn","title":"Operation Table Documentation\\n","text":"<ul> <li>Each operation callback in tables documented with:</li> <li> <ul> <li>Purpose and behavior</li> </ul> </li> <li> <ul> <li>Parameter descriptions with constraints</li> </ul> </li> <li> <ul> <li>Return value semantics</li> </ul> </li> <li> <ul> <li>Usage examples</li> </ul> </li> <li> <ul> <li>Related operations</li> </ul> </li> </ul> <p>* *  **</p>"},{"location":"api/Examples/_2strong-example/#expected-doxygen-outputn","title":"Expected Doxygen Output\\n","text":"<ul> <li>**</li> </ul>"},{"location":"api/Examples/_2strong-example/#modules-tabn","title":"Modules Tab\\n","text":"<ul> <li>Complete widget hierarchy:</li> <li> <ul> <li>Graphics_Widget (parent)</li> </ul> </li> <li> <ul> <li>Graphics_Image with all typedefs and functions</li> </ul> </li> <li> <ul> <li>Graphics_Menu with nested submodules</li> </ul> </li> <li> <ul> <li>Graphics_MenuIndicator</li> </ul> </li> <li> <ul> <li>Graphics_MenuItem</li> </ul> </li> <li> <ul> <li>Graphics_MenuConfig</li> </ul> </li> <li> <ul> <li>Graphics_ProgressBar with all typedefs and functions</li> </ul> </li> </ul> <p>* *  **</p>"},{"location":"api/Examples/_2strong-example/#examples-tabn","title":"Examples Tab\\n","text":"<ul> <li>All ```</li> </ul> <p>Filename: /strong</p> <p>**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/blocks-example/","title":"blocks","text":"<ul> <li> <ul> <li>Complete working programs</li> </ul> </li> <li> <ul> <li>Practical usage demonstrations</li> </ul> </li> <li> <ul> <li>Pages Tab:</li> </ul> </li> <li> <ul> <li>OLED Usage Guide (comprehensive guide)</li> </ul> </li> <li> <ul> <li>OLED Examples (10+ code samples)</li> </ul> </li> <li> <ul> <li>OLED Namespace (namespace organization)</li> </ul> </li> <li> <ul> <li>OLED Documentation Summary (this page)</li> </ul> </li> <li> <ul> <li>Namespaces Tab:</li> </ul> </li> <li> <ul> <li>CFBD - Core Framework Bare Device</li> </ul> </li> <li> <ul> <li>CFBD::OLED - OLED Display Driver</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#documentation-guidelines","title":"Documentation Guidelines","text":"<ul> <li> <ul> <li>The documentation follows these principles:</li> </ul> </li> <li> <ul> <li> <ul> <li>Completeness: All public APIs are documented</li> </ul> </li> </ul> </li> <li> <ul> <li>Clarity: Technical terms are explained</li> </ul> </li> <li> <ul> <li>Examples: Practical code examples included</li> </ul> </li> <li> <ul> <li>Cross-referencing: Related concepts are linked</li> </ul> </li> <li> <ul> <li>Hierarchy: Information is organized logically</li> </ul> </li> <li> <ul> <li>Audience: Both beginners and advanced users are served</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#generating-documentation","title":"Generating Documentation","text":"<ul> <li> <ul> <li>To generate the Doxygen documentation:</li> </ul> </li> <li> <ul> <li><code>bash</code></li> </ul> </li> <li><code>doxygen Doxyfile *</code></li> <li> <ul> <li>The output will be generated in the configured directory (typically <code>documentation/</code>).</li> </ul> </li> <li> <ul> <li>Key configuration points in Doxyfile:</li> </ul> </li> <li> <ul> <li>EXAMPLE_PATH: Directory containing example files</li> </ul> </li> <li> <ul> <li>GENERATE_HTML: HTML output generation</li> </ul> </li> <li> <ul> <li>GENERATE_LATEX: PDF generation</li> </ul> </li> <li> <ul> <li>EXTRACT_ALL: Whether to document all entities</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#related-resources","title":"Related Resources","text":"<ul> <li> <ul> <li> <ul> <li>OLED Driver Usage Guide - Comprehensive guide for developers</li> </ul> </li> </ul> </li> <li> <ul> <li>Code Examples - 10+ practical examples</li> </ul> </li> <li> <ul> <li>README.md - Project overview and build instructions</li> </ul> </li> <li> <ul> <li>Doxyfile - Doxygen configuration</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Examples/blocks-example/#maintaining-documentation","title":"Maintaining Documentation","text":"<ul> <li> <ul> <li>When adding new features to the OLED driver:</li> </ul> </li> <li> <ul> <li> <ol> <li>Add comprehensive comments to header files</li> </ol> </li> </ul> </li> <li> <ol> <li>Use ```</li> </ol> </li> </ul> <p>Filename: blocks</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/blocks_0cn-example/","title":"blocks\\n","text":"<ul> <li>\u2713 Module hierarchy supporting Modules tab</li> <li>\u2713 20+ practical code examples for Examples tab</li> <li>\u2713 3 ```</li> </ul> <p>Filename: blocks\\n</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/blocks_1_0cn-example/","title":"blocks:\\n","text":"<ul> <li> <ul> <li>Image initialization and drawing</li> </ul> </li> <li> <ul> <li>Animated image sequences</li> </ul> </li> <li> <ul> <li>Menu setup and navigation</li> </ul> </li> <li> <ul> <li>Menu with indicators and animations</li> </ul> </li> <li> <ul> <li>Progress bar creation and updates</li> </ul> </li> <li> <ul> <li>Complex multi-widget UIs</li> </ul> </li> <li> <ul> <li>Batch drawing optimization</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#pages-tabn","title":"Pages Tab\\n","text":"<p>*</p> <ul> <li> <ul> <li>Widget_UserGuide (comprehensive usage guide)</li> </ul> </li> <li> <ul> <li>Graphics_Widget_Examples (11+ practical examples)</li> </ul> </li> <li> <ul> <li>Graphics_Widget_Documentation (this page)</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#design-patternsn","title":"Design Patterns\\n","text":"<p>*</p>"},{"location":"api/Examples/blocks_1_0cn-example/#initialize--configure--rendern","title":"Initialize \u2192 Configure \u2192 Render\\n","text":"<p>*</p> <ul> <li>All widgets follow this pattern:</li> </ul> <p>* * </p> <pre><code>\\n\n* 1. Initialize with base properties (Init function)\\n\n* 2. Configure visual/behavioral properties (ops-&gt;set_property)\\n\n* 3. Render (ops-&gt;immediate_draw or equivalent)\\n\n* \n</code></pre> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#operation-tablesn","title":"Operation Tables\\n","text":"<p>*</p> <ul> <li>Polymorphic behavior through function pointer tables enables:</li> <li> <ul> <li>Multiple implementations per widget type</li> </ul> </li> <li> <ul> <li>Compile-time or runtime selection</li> </ul> </li> <li> <ul> <li>Future extensibility</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#caller-ownershipn","title":"Caller Ownership\\n","text":"<p>*</p> <ul> <li> <ul> <li>All structures stack/static allocated</li> </ul> </li> <li> <ul> <li>Caller owns: display device, bitmap data, item arrays</li> </ul> </li> <li> <ul> <li>Widgets reference, don't copy data</li> </ul> </li> <li> <ul> <li>Ensures deterministic memory usage</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#widget-best-practices","title":"Widget Best Practices","text":"<p>*</p>"},{"location":"api/Examples/blocks_1_0cn-example/#initializationn","title":"Initialization\\n","text":"<p>*</p> <ul> <li> <ul> <li>Call *_Init() for all widgets before using</li> </ul> </li> <li> <ul> <li>Initialize in order: dependencies first</li> </ul> </li> <li> <ul> <li>Keep structures valid for entire usage lifetime</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#drawing-order","title":"Drawing Order","text":"<p>*</p> <ul> <li> <ul> <li>Use deferred mode for multiple widgets</li> </ul> </li> <li> <ul> <li>Batch operations then single update()</li> </ul> </li> <li> <ul> <li>Minimize update calls in tight loops</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#animationn","title":"Animation\\n","text":"<p>*</p> <ul> <li> <ul> <li>Use 4-8 frames for UI feedback</li> </ul> </li> <li> <ul> <li>Use 16+ frames for smooth transitions</li> </ul> </li> <li> <ul> <li>Choose delays based on HAL tick resolution (25-50ms typical)</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#error-handling","title":"Error Handling","text":"<p>*</p> <ul> <li> <ul> <li>Always check return values from add_item() - may fail if full</li> </ul> </li> <li> <ul> <li>Always check return values from set_property() - property may not exist</li> </ul> </li> <li> <ul> <li>Validate coordinates before drawing (device-&gt;ops-&gt;setPixel may fail)</li> </ul> </li> </ul> <p>* * </p>"},{"location":"api/Examples/blocks_1_0cn-example/#documentation-maintenancen","title":"Documentation Maintenance\\n","text":"<p>*</p> <ul> <li>When modifying widget code:</li> </ul> <p>* * 1. Update ```</p> <p>Filename: blocks:\\n</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/code-example/","title":"code","text":"<p>blocks for new operations</p> <ul> <li> <ol> <li>Update ```</li> </ol> </li> </ul> <p>Filename: code</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/for-example/","title":"standalone pages","text":"<p>code examples</p> <ul> <li> <ul> <li><code>@code</code>  / for code blocks</li> </ul> </li> <li> <ul> <li><code>@see</code> /standalone pages cross-references</li> </ul> </li> <li> <ul> <li><code>@param</code>  for parameter documentation</li> </ul> </li> <li> <ul> <li><code>@return</code>  for return value documentation</li> </ul> </li> <li> <ul> <li><code>@note</code> /for special notes</li> </ul> </li> <li> <ul> <li><code>\\include</code>  for </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Examples/if-example/","title":"if","text":"<p>new patterns emerge</p> <ul> <li> <ol> <li>Update operation table documentation if callbacks change</li> </ol> </li> <li> <ol> <li>Regenerate Widget_UserGuide.md if major features added</li> </ol> </li> <li> <ol> <li>Update this Graphics_Widget_Documentation page</li> </ol> </li> </ul> <p>* * </p>"},{"location":"api/Examples/if-example/#integration-with-core-graphicsn","title":"Integration with Core Graphics\\n","text":"<p>*</p> <ul> <li>Widgets integrate seamlessly with core Graphics Device:</li> </ul> <p>* * </p> <p><pre><code>\\n\n * Core Graphics Features:          Widget Support:\\n\n * - Immediate/Deferred Mode   \u2192    All widgets respect device mode\\n\n * - Device abstraction        \u2192    All widgets use CFBD_GraphicDevice\\n\n * - Animation framework       \u2192    Built-in CFBD_BaseAnimation support\\n\n * - Multiple device types     \u2192    Works with any device (OLED, LCD, etc.)\\n\n * ```\n\n\n\n *\n* \n\n\n\n# Complete Documentation Structure\\n\n\n*\n\n\n* \n</code></pre> \\n  * Documentation Coverage:\\n  *\\n  * @page layers:\\n  *   - Graphics_UserGuide (core API, 4 drawing modes)\\n  *   - Widget_UserGuide (widget system, initialization patterns)\\n  *   - Graphics_Examples (core device examples)\\n  *   - Graphics_Widget_Examples (11+ widget examples)\\n  *   - Graphics_Documentation_Summary (core module overview)\\n  *   - Graphics_Widget_Documentation (widget module overview) \u2190 THIS PAGE\\n  *\\n  * @defgroup layers:\\n  *   - Graphics (root)\\n  *     - Graphics_Device (core device interface)\\n  *     - Graphics_Widget (widget layer)\\n  *       - Graphics_Image\\n  *       - Graphics_Menu (with sub-modules)\\n  *       - Graphics_ProgressBar\\n  *     - Graphics_Animation (animation framework)\\n  *     - Graphics_Helpers (utility functions)\\n  *     - Graphics_Resources (resource configuration)\\n  *\\n  * @example blocks: 20+ complete, runnable code examples\\n  *\\n  * @namespace CFBD with hierarchical organization\\n  * ```</p> <p>* * </p>"},{"location":"api/Examples/if-example/#summaryn","title":"Summary\\n","text":"<p>*</p> <ul> <li>The Graphics Widget subsystem provides professional-grade UI components</li> <li>with comprehensive Doxygen documentation supporting:</li> </ul> <p>* * \u2713 Complete API documentation with ```</p> <p>Filename: if</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/Graphics__Complete__Examples_8md/","title":"Graphics_Complete_Examples.md","text":""},{"location":"api/Files/Graphics__Complete__Examples_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page Graphics_Complete_Examples Graphics Framework - Complete Code Examples\n *\n * @tableofcontents\n *\n * Comprehensive code examples demonstrating all graphics subsystem features,\n * organized by functional area: device setup, drawing operations, text widgets,\n * and complex UI compositions.\n *\n * ---\n *\n * @section PART_1 PART 1: Graphics Device Foundation\n *\n * @subsection GEx1_BasicGraphicsDevice Basic Graphics Device Setup\n *\n * The simplest example showing graphics device initialization:\n *\n * @code\n * #include \"graphic_device.h\"\n * #include \"oled_graphic_device.h\"\n * #include \"oled.h\"\n *\n * void example_basic_graphics_setup(void) {\n *     // Initialize OLED display\n *     CFBD_OLED oled;\n *     CFBD_OLED_IICInitsParams iic_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n *     oled.ops-&gt;open(&amp;oled);\n *\n *     // Create graphics device and bind to OLED\n *     CFBD_GraphicDevice graphics;\n *     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n *     graphics.ops-&gt;open(&amp;graphics);\n *\n *     // Graphics device is now ready to use\n * }\n * @endcode\n *\n * @subsection GEx2_ImmediateDrawing Immediate Drawing Mode\n *\n * Drawing with immediate updates after each operation:\n *\n * @code\n * void example_immediate_drawing(CFBD_GraphicDevice* graphics) {\n *     // Enable immediate draw mode\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_TRUE);\n *\n *     // Clear display (immediate update)\n *     graphics-&gt;ops-&gt;clear(graphics);\n *\n *     // Each pixel is visible immediately\n *     for (uint16_t x = 0; x &lt; 128; x += 2) {\n *         graphics-&gt;ops-&gt;setPixel(graphics, x, 32);\n *         // Display updates automatically\n *     }\n * }\n * @endcode\n *\n * @subsection GEx3_DeferredDrawing Deferred Drawing Mode\n *\n * Batch drawing operations for better performance:\n *\n * @code\n * void example_deferred_drawing(CFBD_GraphicDevice* graphics) {\n *     // Enable deferred mode (batch operations)\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n *\n *     // Clear display (buffered)\n *     graphics-&gt;ops-&gt;clear(graphics);\n *\n *     // Draw multiple pixels without updating display\n *     for (uint16_t y = 0; y &lt; 64; y += 4) {\n *         for (uint16_t x = 0; x &lt; 128; x += 4) {\n *             graphics-&gt;ops-&gt;setPixel(graphics, x, y);\n *         }\n *     }\n *\n *     // Update display once with all changes\n *     graphics-&gt;ops-&gt;update(graphics);\n * }\n * @endcode\n *\n * @subsection GEx4_AreaOperations Area-Based Drawing\n *\n * Efficient rectangular area operations:\n *\n * @code\n * void example_area_operations(CFBD_GraphicDevice* graphics) {\n *     uint8_t bitmap[32] = {0};  // 16x16 pixel bitmap\n *\n *     // Draw bitmap to area\n *     graphics-&gt;ops-&gt;setArea(graphics, 56, 24, 16, 16, bitmap);\n *\n *     // Update only affected area\n *     graphics-&gt;ops-&gt;update_area(graphics, 56, 24, 16, 16);\n * }\n * @endcode\n *\n * @subsection GEx5_QueryDeviceProperties Query Device Properties\n *\n * Getting display capabilities:\n *\n * @code\n * void example_query_device(CFBD_GraphicDevice* graphics) {\n *     uint16_t width = 0, height = 0;\n *     CFBD_bool is_rgb = CFBD_FALSE;\n *\n *     // Query display dimensions\n *     graphics-&gt;ops-&gt;self_consult(graphics, \"width\", NULL, &amp;width);\n *     graphics-&gt;ops-&gt;self_consult(graphics, \"height\", NULL, &amp;height);\n *\n *     // Query color capability\n *     graphics-&gt;ops-&gt;self_consult(graphics, \"rgb\", NULL, &amp;is_rgb);\n *\n *     printf(\"Display: %u x %u %s\\n\",\n *            width, height,\n *            is_rgb ? \"RGB\" : \"Monochrome\");\n * }\n * @endcode\n *\n * @subsection GEx6_ModeToggling Dynamic Mode Switching\n *\n * Switching between immediate and deferred modes:\n *\n * @code\n * void example_mode_switching(CFBD_GraphicDevice* graphics) {\n *     // Check current mode\n *     if (CFBDGraphic_DeviceRequestUpdateAtOnce(graphics)) {\n *         printf(\"Currently in immediate mode\\n\");\n *     } else {\n *         printf(\"Currently in deferred mode\\n\");\n *     }\n *\n *     // Switch to deferred mode\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n *\n *     // Perform batch operations\n *     for (int i = 0; i &lt; 100; i++) {\n *         graphics-&gt;ops-&gt;setPixel(graphics, i, 32);\n *     }\n *     graphics-&gt;ops-&gt;update(graphics);\n *\n *     // Switch back to immediate\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_TRUE);\n * }\n * @endcode\n *\n * @subsection GEx7_ClearImmediately Clear Display Utility\n *\n * Using the clear immediate convenience function:\n *\n * @code\n * void example_clear_immediate(CFBD_GraphicDevice* graphics) {\n *     // Clear entire display with single operation\n *     CFBDGraphic_DeviceClearImmediate(graphics);\n *\n *     // Equivalent to:\n *     // graphics-&gt;ops-&gt;clear(graphics);\n *     // graphics-&gt;ops-&gt;update(graphics);\n * }\n * @endcode\n *\n * ---\n *\n * @section PART_2 PART 2: Animation and Rendering\n *\n * @subsection GEx8_AnimatedFrames Animated Frame Rendering\n *\n * Smooth animation with frame-based timing:\n *\n * @code\n * void example_animated_frames(CFBD_GraphicDevice* graphics) {\n *     CFBD_BaseAnimation anim;\n *     CFBD_InitBaseAnimation(&amp;anim);\n *     anim.anim_frames = 16;\n *     anim.anim_frame_delay_ms = 50;\n *\n *     // Disable immediate mode for batch updates\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n *\n *     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n *         graphics-&gt;ops-&gt;clear(graphics);\n *\n *         // Draw frame-dependent content\n *         uint16_t y = 16 + (frame * 3);  // Animate Y position\n *         graphics-&gt;ops-&gt;setPixel(graphics, 64, y);\n *\n *         graphics-&gt;ops-&gt;update(graphics);\n *\n *         if (anim.anim_frame_delay_ms &gt; 0) {\n *             HAL_Delay(anim.anim_frame_delay_ms);\n *         }\n *     }\n * }\n * @endcode\n *\n * @subsection GEx9_CompleteAnimation Complete Animated Scene\n *\n * Full example combining multiple concepts:\n *\n * @code\n * #include \"graphic_device.h\"\n * #include \"oled_graphic_device.h\"\n * #include \"oled.h\"\n * #include \"widget/animation/animation.h\"\n * #include \"widget/base_support/common/helpers.h\"\n *\n * void example_complete_animation(void) {\n *     // Initialize OLED\n *     CFBD_OLED oled;\n *     CFBD_OLED_IICInitsParams iic_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n *     oled.ops-&gt;open(&amp;oled);\n *\n *     // Create graphics device\n *     CFBD_GraphicDevice graphics;\n *     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n *     graphics.ops-&gt;open(&amp;graphics);\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n *\n *     // Setup animation\n *     CFBD_BaseAnimation anim;\n *     CFBD_InitBaseAnimation(&amp;anim);\n *     anim.anim_frames = 8;\n *     anim.anim_frame_delay_ms = 50;\n *\n *     // Animate bouncing ball\n *     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n *         graphics.ops-&gt;clear(&amp;graphics);\n *\n *         // Calculate position\n *         int16_t x = 64 + 30 * (frame % 4) - 45;\n *         int16_t y = 32 + (frame * 2);\n *\n *         // Clamp to display bounds\n *         x = clamp_i32(x, 0, 127);\n *         y = clamp_i32(y, 0, 63);\n *\n *         // Draw ball\n *         graphics.ops-&gt;setPixel(&amp;graphics, x, y);\n *         graphics.ops-&gt;update(&amp;graphics);\n *\n *         HAL_Delay(anim.anim_frame_delay_ms);\n *     }\n *\n *     // Cleanup\n *     graphics.ops-&gt;close(&amp;graphics);\n *     oled.ops-&gt;close(&amp;oled);\n * }\n * @endcode\n *\n * @subsection GEx10_UtilityFunctions Using Utility Functions\n *\n * Applying helper utilities in graphics code:\n *\n * @code\n * #include \"widget/base_support/common/helpers.h\"\n *\n * void example_utility_functions(CFBD_GraphicDevice* graphics) {\n *     int width = 128, height = 64;\n *\n *     // Clamp coordinate to valid range\n *     int user_x = get_user_input();\n *     int x = clamp_i32(user_x, 0, width - 1);\n *\n *     // Find center\n *     int center_x = MAX(0, width / 2);\n *     int center_y = MIN(64, height / 2);\n *\n *     // Draw centered point\n *     graphics-&gt;ops-&gt;setPixel(graphics, center_x, center_y);\n *     graphics-&gt;ops-&gt;update(graphics);\n * }\n * @endcode\n *\n * @subsection GEx11_ResourceConfiguration Resource Configuration\n *\n * Configuring graphics resources:\n *\n * @code\n * // In your project, before including graphics headers:\n *\n * // Option 1: Keep all defaults\n * #include \"graphic/resource/config.h\"\n *\n * // Option 2: Disable all, then enable selectively\n * #define _USE_NO_DEFAULT_SOURCES\n * #include \"graphic/resource/config.h\"\n *\n * // Option 3: Disable specific resources\n * #define DISABLE_ASCII_6X8_SOURCES\n * #include \"graphic/resource/config.h\"\n * // Now only 8x16 font is available\n * @endcode\n *\n * ---\n *\n * @section PART_3 PART 3: Text Widget Examples\n *\n * @subsection TEx1_BasicText Basic Text Rendering\n *\n * Simple text display on graphics device:\n *\n * @code\n * void example_basic_text(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 16};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     CFBDGraphic_SetText(&amp;text, \"Hello!\");\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx2_MultipleTexts Multiple Text Elements\n *\n * Rendering multiple independent text widgets:\n *\n * @code\n * void example_multiple_texts(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text title, status;\n *\n *     // Title at top\n *     CFBDGraphic_Point title_pos = {0, 0};\n *     CFBDGraphicSize title_area = {128, 16};\n *     CFBDGraphic_InitText(&amp;title, title_pos, title_area, ASCII_8x16);\n *     CFBDGraphic_SetText(&amp;title, \"Game Status\");\n *     CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Status at bottom\n *     CFBDGraphic_Point status_pos = {0, 50};\n *     CFBDGraphicSize status_area = {128, 14};\n *     CFBDGraphic_InitText(&amp;status, status_pos, status_area, ASCII_6x8);\n *     CFBDGraphic_SetText(&amp;status, \"Running... 60FPS\");\n *     CFBDGraphic_DrawText(dev, &amp;status, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx3_MultilineText Multiline Text with Breaks\n *\n * Multiple lines with explicit line breaks:\n *\n * @code\n * void example_multiline_text(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 64};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     // First line\n *     CFBDGraphic_SetText(&amp;text, \"Line 1\");\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Second line\n *     CFBDGraphic_SetText(&amp;text, \"Line 2\");\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     // Third line\n *     CFBDGraphic_SetText(&amp;text, \"Line 3\");\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx4_ContinuousText Continuous Text with Auto-Wrap\n *\n * Text that wraps automatically:\n *\n * @code\n * void example_continuous_text(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 64};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n *\n *     // Long text automatically wraps\n *     CFBDGraphic_SetText(&amp;text, \"This is a long text that will wrap\");\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx5_DynamicText Dynamic Text with sprintf\n *\n * Formatted text with variables:\n *\n * @code\n * void example_dynamic_text(CFBD_GraphicDevice* dev, int score, int lives) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 55};\n *     CFBDGraphicSize area = {128, 8};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n *\n *     char buffer[32];\n *     sprintf(buffer, \"Score:%d Lives:%d\", score, lives);\n *     CFBDGraphic_SetText(&amp;text, buffer);\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx6_FontSelection Font Selection with Config\n *\n * Conditional font usage based on compile-time configuration:\n *\n * @code\n * void example_font_selection(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 20};\n *\n * #if ENABLE_ASCII_8x16_SOURCES\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *     CFBDGraphic_SetText(&amp;text, \"Large Text\");\n * #elif ENABLE_ASCII_6x8_SOURCES\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n *     CFBDGraphic_SetText(&amp;text, \"Small Text\");\n * #else\n *     printf(\"No ASCII fonts available\\n\");\n *     return;\n * #endif\n *\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx7_TextMetrics Querying Text Metrics\n *\n * Get text size without rendering:\n *\n * @code\n * void example_text_metrics(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 64};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     // Query text size\n *     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n *     printf(\"Font size: %u x %u pixels\\n\", font_size.width, font_size.height);\n *\n *     // Query next position without drawing\n *     CFBDGraphic_SetText(&amp;text, \"Sample\");\n *     CFBDGraphic_Point end_pos = CFBDGraphic_DrawText(\n *         dev, &amp;text,\n *         CCGraphic_AsciiTextItem_RequestOldPoint\n *     );\n *     printf(\"Text would end at (%u, %u)\\n\", end_pos.x, end_pos.y);\n * }\n * @endcode\n *\n * @subsection TEx8_TextRepositioning Repositioning Text\n *\n * Dynamic repositioning of text elements:\n *\n * @code\n * void example_reposition_text(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 32};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     CFBDGraphic_SetText(&amp;text, \"Hello\");\n *\n *     // Draw at original position\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *     dev-&gt;ops-&gt;update(dev);\n *     HAL_Delay(500);\n *\n *     // Move to new position\n *     CFBDGraphic_Point new_pos = {30, 25};\n *     CFBDGraphic_SetTextTLPointPoint(&amp;text, &amp;new_pos);\n *\n *     dev-&gt;ops-&gt;clear(dev);\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx9_CenteredText Centered Text\n *\n * Centering text horizontally:\n *\n * @code\n * void example_centered_text(CFBD_GraphicDevice* dev, const char* text_str) {\n *     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n *\n *     // Calculate text width\n *     size_t text_len = strlen(text_str);\n *     int text_width = text_len * (font_size.width + CFBDGraphic_TEXT_PADDING_WIDTH);\n *\n *     // Center horizontally (128 pixel display)\n *     int center_x = (128 - text_width) / 2;\n *     CFBDGraphic_Point pos = {center_x, 25};\n *\n *     CFBDGraphic_Text text;\n *     CFBDGraphicSize area = {text_width + 5, 16};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *     CFBDGraphic_SetText(&amp;text, (char*)text_str);\n *     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx10_ScrollingText Scrolling Text Effect\n *\n * Horizontal text scrolling:\n *\n * @code\n * void example_scrolling_text(CFBD_GraphicDevice* dev) {\n *     const char* text_str = \"Scrolling Text Example\";\n *     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n *     int text_width = strlen(text_str) * (font_size.width + 1);\n *\n *     // Scroll from right to left\n *     for (int x = 128; x &gt; -text_width; x -= 2) {\n *         CFBDGraphic_Text text;\n *         CFBDGraphic_Point pos = {x, 25};\n *         CFBDGraphicSize area = {text_width + 5, 16};\n *         CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *         CFBDGraphic_SetText(&amp;text, (char*)text_str);\n *\n *         dev-&gt;ops-&gt;clear(dev);\n *         CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n *         dev-&gt;ops-&gt;update(dev);\n *\n *         HAL_Delay(50);\n *     }\n * }\n * @endcode\n *\n * ---\n *\n * @section PART_4 PART 4: Graphics Widget Examples (Image, Menu, Progress Bar)\n *\n * @subsection WEx1_BasicImage Basic Image Drawing\n *\n * Simple bitmap rendering:\n *\n * @code\n * void example_draw_bitmap(CFBD_GraphicDevice* dev) {\n *     uint8_t heart_bitmap[64] = {\n *         0x00, 0x00, 0x00, 0x00,\n *         0x66, 0x99, 0x99, 0x66,\n *         0xFF, 0xFF, 0xFF, 0xFF,\n *         0xFF, 0xFF, 0xFF, 0xFF,\n *         // ... (16x16 bitmap)\n *     };\n *\n *     CCGraphic_Image heart;\n *     CFBDGraphic_Point pos = {56, 24};\n *     CFBDGraphicSize size = {16, 16};\n *     CFBDGraphic_InitImage(&amp;heart, &amp;pos, &amp;size, heart_bitmap);\n *\n *     dev-&gt;ops-&gt;clear(dev);\n *     CFBDGraphic_DrawImage(dev, &amp;heart);\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection WEx2_AnimatedImage Animated Image Transitions\n *\n * Multiple images with frame-based animation:\n *\n * @code\n * void example_animated_image(CFBD_GraphicDevice* dev) {\n *     CCGraphic_Image frames[4];\n *     uint8_t frame_data[4][64] = {...};  // 4 animation frames\n *     CFBDGraphic_Point pos = {48, 24};\n *     CFBDGraphicSize size = {32, 16};\n *\n *     // Initialize all frames\n *     for (int i = 0; i &lt; 4; i++) {\n *         CFBDGraphic_InitImage(&amp;frames[i], &amp;pos, &amp;size, frame_data[i]);\n *     }\n *\n *     // Animate through frames\n *     CFBD_BaseAnimation anim = {4, 100};  // 4 frames, 100ms each\n *     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n *         dev-&gt;ops-&gt;clear(dev);\n *         CFBDGraphic_DrawImage(dev, &amp;frames[frame % 4]);\n *         dev-&gt;ops-&gt;update(dev);\n *         HAL_Delay(anim.anim_frame_delay_ms);\n *     }\n * }\n * @endcode\n *\n * @subsection WEx3_SimpleMenu Basic Menu\n *\n * Minimal menu with 3 items:\n *\n * @code\n * void on_item_selected(void* ctx) {\n *     printf(\"Item selected!\\n\");\n * }\n *\n * void example_simple_menu(CFBD_GraphicDevice* dev) {\n *     // Allocate item array\n *     CFBD_MenuItem items[3];\n *     CFBD_MenuItemGroup item_group = {items, 3, 0};\n *\n *     // Initialize menu\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n *\n *     // Add items\n *     CFBD_MenuItemCallbackPack cb = {on_item_selected, NULL};\n *     menu.operations-&gt;add_item(&amp;menu, \"Start\", ASCII_8x16, &amp;cb);\n *     menu.operations-&gt;add_item(&amp;menu, \"Options\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n *\n *     // Draw menu\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n * }\n * @endcode\n *\n * @subsection WEx4_MenuNavigation Interactive Menu Navigation\n *\n * Simulated keyboard input and menu selection:\n *\n * @code\n * void example_menu_navigation(CFBD_GraphicDevice* dev) {\n *     // Setup menu (from previous example)\n *     CFBD_MenuItem items[5];\n *     CFBD_MenuItemGroup item_group = {items, 5, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n *\n *     for (int i = 0; i &lt; 5; i++) {\n *         char label[16];\n *         sprintf(label, \"Item %d\", i + 1);\n *         menu.operations-&gt;add_item(&amp;menu, label, ASCII_6x8, NULL);\n *     }\n *\n *     // Simulate navigation\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n *\n *     // Down arrow - move to next item\n *     OLED_Menu_SelectNext(&amp;menu);\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n *     HAL_Delay(300);\n *\n *     // Down arrow again\n *     OLED_Menu_SelectNext(&amp;menu);\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n *     HAL_Delay(300);\n *\n *     // Up arrow - move to previous\n *     OLED_Menu_SelectPrev(&amp;menu);\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n *     HAL_Delay(300);\n *\n *     // Enter - activate current item\n *     menu.operations-&gt;activate_current(&amp;menu);\n * }\n * @endcode\n *\n * @subsection WEx5_MenuWithIndicator Menu with Custom Indicator\n *\n * Menu with styled selection indicator:\n *\n * @code\n * void example_menu_with_indicator(CFBD_GraphicDevice* dev) {\n *     CFBD_MenuItem items[4];\n *     CFBD_MenuItemGroup item_group = {items, 4, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 120);\n *\n *     // Configure indicator\n *     CFBD_MenuIndicator indicator;\n *     CFBD_InitDefaultMenuIndicator(&amp;indicator);\n *     indicator.width = 6;      // 6-pixel wide indicator\n *     indicator.x = 2;          // 2 pixels from left edge\n *     menu.operations-&gt;set_indicator_property(&amp;menu, &amp;indicator);\n *\n *     // Add items with callbacks\n *     CFBD_MenuItemCallbackPack cb1 = {on_item_selected, (void*)1};\n *     CFBD_MenuItemCallbackPack cb2 = {on_item_selected, (void*)2};\n *     menu.operations-&gt;add_item(&amp;menu, \"Play\", ASCII_8x16, &amp;cb1);\n *     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, &amp;cb2);\n *     menu.operations-&gt;add_item(&amp;menu, \"About\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n *\n *     // Draw\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n * }\n * @endcode\n *\n * @subsection WEx6_MenuWithAnimation Menu with Transitions\n *\n * Menu with animated selection changes:\n *\n * @code\n * void example_animated_menu(CFBD_GraphicDevice* dev) {\n *     CFBD_MenuItem items[3];\n *     CFBD_MenuItemGroup item_group = {items, 3, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n *\n *     menu.operations-&gt;add_item(&amp;menu, \"One\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Two\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Three\", ASCII_8x16, NULL);\n *\n *     // Enable animation\n *     CFBD_BaseAnimation anim = {6, 40};  // 6 frames, 40ms per frame\n *     menu.operations-&gt;set_animation(&amp;menu, &amp;anim);\n *\n *     // Navigate with visual feedback\n *     for (int i = 0; i &lt; 3; i++) {\n *         OLED_Menu_SelectNext(&amp;menu);\n *         for (int f = 0; f &lt; anim.anim_frames; f++) {\n *             menu.operations-&gt;immediate_draw(&amp;menu);\n *             HAL_Delay(anim.anim_frame_delay_ms);\n *         }\n *     }\n * }\n * @endcode\n *\n * @subsection WEx7_BasicProgressBar Simple Progress Bar\n *\n * Basic progress bar with fill animation:\n *\n * @code\n * void example_progress_bar(CFBD_GraphicDevice* dev) {\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point pos = {10, 32};\n *     CFBDGraphicSize size = {108, 8};\n *     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n *\n *     // Draw at different values\n *     for (int val = 0; val &lt;= 100; val += 10) {\n *         dev-&gt;ops-&gt;clear(dev);\n *         progress.ops-&gt;set_value(&amp;progress, val);\n *         progress.ops-&gt;immediate_draw(&amp;progress);\n *         dev-&gt;ops-&gt;update(dev);\n *         HAL_Delay(100);\n *     }\n * }\n * @endcode\n *\n * @subsection WEx8_ProgressBarWithBorder Progress Bar with Border\n *\n * Styled progress bar with border and padding:\n *\n * @code\n * void example_styled_progress(CFBD_GraphicDevice* dev) {\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point pos = {10, 32};\n *     CFBDGraphicSize size = {108, 10};\n *     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n *\n *     // Enable border and padding\n *     uint8_t border = 1;\n *     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n *     uint8_t padding = 1;\n *     progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n *\n *     // Animate from 0 to 100\n *     for (int val = 0; val &lt;= 100; val += 5) {\n *         dev-&gt;ops-&gt;clear(dev);\n *         progress.ops-&gt;set_value(&amp;progress, val);\n *         progress.ops-&gt;immediate_draw(&amp;progress);\n *         dev-&gt;ops-&gt;update(dev);\n *         HAL_Delay(50);\n *     }\n * }\n * @endcode\n *\n * @subsection WEx9_ProgressWithAnimation Progress Bar with Transitions\n *\n * Progress bar with frame-based animation:\n *\n * @code\n * void example_animated_progress(CFBD_GraphicDevice* dev) {\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point pos = {10, 32};\n *     CFBDGraphicSize size = {108, 8};\n *     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n *\n *     // Configure animation\n *     CFBD_BaseAnimation anim = {4, 50};  // 4-frame, 50ms transitions\n *     progress.ops-&gt;set_property(&amp;progress, \"animation\", &amp;anim);\n *\n *     // Smooth progress animation\n *     for (int target = 10; target &lt;= 100; target += 10) {\n *         for (int frame = 0; frame &lt; anim.anim_frames; frame++) {\n *             int current = (progress.value * (anim.anim_frames - frame) +\n *                           target * frame) / anim.anim_frames;\n *             dev-&gt;ops-&gt;clear(dev);\n *             progress.ops-&gt;set_value(&amp;progress, current);\n *             progress.ops-&gt;immediate_draw(&amp;progress);\n *             dev-&gt;ops-&gt;update(dev);\n *             HAL_Delay(anim.anim_frame_delay_ms);\n *         }\n *     }\n * }\n * @endcode\n *\n * ---\n *\n * @section PART_5 PART 5: Complex UI Compositions\n *\n * @subsection TEx11_MenuText Menu with Text Items\n *\n * Text-based menu display:\n *\n * @code\n * void example_menu_text(CFBD_GraphicDevice* dev) {\n *     CFBDGraphic_Text menu;\n *     CFBDGraphic_Point pos = {10, 10};\n *     CFBDGraphicSize area = {108, 54};\n *     CFBDGraphic_InitText(&amp;menu, pos, area, ASCII_8x16);\n *\n *     dev-&gt;ops-&gt;clear(dev);\n *\n *     // Title\n *     CFBDGraphic_SetText(&amp;menu, \"MENU\");\n *     CFBDGraphic_DrawText(dev, &amp;menu, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Menu items\n *     const char* items[] = {\"Start\", \"Settings\", \"Exit\"};\n *     for (int i = 0; i &lt; 3; i++) {\n *         char item_text[16];\n *         sprintf(item_text, \"%d. %s\", i + 1, items[i]);\n *         CFBDGraphic_SetText(&amp;menu, item_text);\n *         CFBDGraphic_DrawText(dev, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n *     }\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection TEx12_CompleteUI Complete UI with Mixed Text\n *\n * Complex interface combining multiple text elements:\n *\n * @code\n * void example_complete_ui(CFBD_GraphicDevice* dev, int score, int level) {\n *     CFBDGraphic_Text title, body, footer;\n *\n *     // Title\n *     CFBDGraphic_Point title_pos = {0, 0};\n *     CFBDGraphicSize title_size = {128, 16};\n *     CFBDGraphic_InitText(&amp;title, title_pos, title_size, ASCII_8x16);\n *     CFBDGraphic_SetText(&amp;title, \"Game Screen\");\n *     CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Body text\n *     CFBDGraphic_Point body_pos = {0, 20};\n *     CFBDGraphicSize body_size = {128, 36};\n *     CFBDGraphic_InitText(&amp;body, body_pos, body_size, ASCII_6x8);\n *     CFBDGraphic_SetText(&amp;body, \"Level in progress...\");\n *     CFBDGraphic_DrawText(dev, &amp;body, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Footer with stats\n *     CFBDGraphic_Point footer_pos = {0, 55};\n *     CFBDGraphicSize footer_size = {128, 8};\n *     CFBDGraphic_InitText(&amp;footer, footer_pos, footer_size, ASCII_6x8);\n *     char footer_text[32];\n *     sprintf(footer_text, \"Score:%d Level:%d\", score, level);\n *     CFBDGraphic_SetText(&amp;footer, footer_text);\n *     CFBDGraphic_DrawText(dev, &amp;footer, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     dev-&gt;ops-&gt;update(dev);\n * }\n * @endcode\n *\n * @subsection WEx10_MultipleWidgets Multiple Widgets Together\n *\n * Complex UI with image, menu, and progress bar:\n *\n * @code\n * // Global state\n * typedef enum {\n *     SCREEN_MENU,\n *     SCREEN_LOADING,\n *     SCREEN_GAME\n * } ScreenState;\n *\n * void example_multi_widget_ui(CFBD_GraphicDevice* dev) {\n *     ScreenState screen = SCREEN_MENU;\n *\n *     // Setup menu\n *     CFBD_MenuItem items[3];\n *     CFBD_MenuItemGroup item_group = {items, 3, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n *     menu.operations-&gt;add_item(&amp;menu, \"Start Game\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n *\n *     // Setup progress bar for loading screen\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point prog_pos = {10, 50};\n *     CFBDGraphicSize prog_sz = {108, 8};\n *     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;prog_pos, &amp;prog_sz, 0, 100);\n *     uint8_t border = 1;\n *     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n *\n *     // Setup image for loading screen\n *     uint8_t logo_bitmap[128] = {...};  // 32x32 logo\n *     CCGraphic_Image logo;\n *     CFBDGraphic_Point logo_pos = {48, 8};\n *     CFBDGraphicSize logo_sz = {32, 32};\n *     CFBDGraphic_InitImage(&amp;logo, &amp;logo_pos, &amp;logo_sz, logo_bitmap);\n *\n *     while (1) {\n *         switch (screen) {\n *         case SCREEN_MENU:\n *             dev-&gt;ops-&gt;clear(dev);\n *             menu.operations-&gt;immediate_draw(&amp;menu);\n *             // Handle input to change screen\n *             break;\n *\n *         case SCREEN_LOADING:\n *             CFBDGraphic_DrawImage(dev, &amp;logo);\n *             for (int i = 0; i &lt;= 100; i += 10) {\n *                 progress.ops-&gt;set_value(&amp;progress, i);\n *                 progress.ops-&gt;immediate_draw(&amp;progress);\n *                 dev-&gt;ops-&gt;update(dev);\n *                 HAL_Delay(100);\n *             }\n *             screen = SCREEN_GAME;\n *             break;\n *         }\n *     }\n * }\n * @endcode\n *\n * @subsection WEx11_WidgetBatching Batch Drawing for Performance\n *\n * Multiple widgets with deferred updates:\n *\n * @code\n * void example_batch_widgets(CFBD_GraphicDevice* dev) {\n *     // Enable deferred mode\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(dev, CFBD_FALSE);\n *\n *     // Setup widgets\n *     CCGraphic_Image bg;\n *     CFBDGraphic_InitImage(&amp;bg, &amp;(CFBDGraphic_Point){0, 0},\n *                          &amp;(CFBDGraphicSize){128, 64}, background_data);\n *\n *     CFBD_MenuItem items[2];\n *     CFBD_MenuItemGroup item_group = {items, 2, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n *     menu.operations-&gt;add_item(&amp;menu, \"Option 1\", ASCII_6x8, NULL);\n *     menu.operations-&gt;add_item(&amp;menu, \"Option 2\", ASCII_6x8, NULL);\n *\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point p = {20, 55};\n *     CFBDGraphicSize s = {88, 6};\n *     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;p, &amp;s, 0, 100);\n *\n *     // Draw all widgets, update only once\n *     dev-&gt;ops-&gt;clear(dev);\n *     CFBDGraphic_DrawImage(dev, &amp;bg);\n *     menu.operations-&gt;immediate_draw(&amp;menu);\n *     progress.ops-&gt;set_value(&amp;progress, 75);\n *     progress.ops-&gt;immediate_draw(&amp;progress);\n *     dev-&gt;ops-&gt;update(dev);  // Single update for all widgets\n * }\n * @endcode\n *\n * ---\n *\n * @see @ref Graphics_UserGuide - Detailed graphics framework guide\n * @see @ref Widget_UserGuide - Complete widget guide\n * @see @ref Text_UserGuide - Complete text guide\n * @see CFBD_GraphicDevice - Device structure\n * @see CFBD_Menu - Menu structure\n * @see CFBD_ProgressBar - Progress bar structure\n * @see CCGraphic_Image - Image structure\n * @see CFBDGraphic_Text - Text structure\n * @see CFBD_BaseAnimation - Animation structure\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/Graphics__Complete__UserGuide_8md/","title":"Graphics_Complete_UserGuide.md","text":""},{"location":"api/Files/Graphics__Complete__UserGuide_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page Graphics_Complete_UserGuide Graphics Framework - Complete User Guide\n *\n * @tableofcontents\n *\n * ---\n *\n * @section PART_I PART I: Graphics Subsystem Overview\n *\n * @section GraphicsOverview Overview\n *\n * The Graphics subsystem provides a complete framework for rendering graphical\n * content on various display devices. It is built on a modular architecture\n * consisting of:\n *\n * - **Graphics Device Abstraction**: Unified interface for different display hardware\n * - **OLED Device Binding**: Integration with OLED displays\n * - **Animation Framework**: Smooth transitions and visual effects\n * - **Widget System**: High-level UI components (Text, Menu, ProgressBar, Image)\n * - **Resource Management**: Fonts, textures, and other rendering assets\n *\n * @section GraphicsArchitecture Architecture\n *\n * The Graphics subsystem is organized in layers:\n *\n * ```\n * Application Code\n *        |\n *        v\n * Widget Framework (text, menu, animation, image, etc.)\n *        |\n *        v\n * Graphics Device Abstraction (graphic_device.h)\n *        |\n *        +-&gt; OLED Device Binding (oled_graphic_device.h)\n *        |\n *        v\n * Hardware Drivers (OLED, LCD, etc.)\n * ```\n *\n * @section GettingStartedGraphics Getting Started with Graphics\n *\n * @subsection Step1_Headers Include Required Headers\n *\n * ```cpp\n * #include \"graphic_device.h\"\n * #include \"oled_graphic_device.h\"\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * ```\n *\n * @subsection Step2_InitializeOLED Initialize OLED Display\n *\n * ```cpp\n * CFBD_OLED oled;\n * CFBD_OLED_IICInitsParams iic_config = {\n *     .device_address = SSD1309_DRIVER_ADDRESS,\n *     .i2c_handle = &amp;my_i2c,\n * };\n *\n * CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_config, CFBD_TRUE);\n * oled.ops-&gt;open(&amp;oled);\n * ```\n *\n * @subsection Step3_CreateGraphicsDevice Create Graphics Device\n *\n * ```cpp\n * CFBD_GraphicDevice graphics;\n * CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n * graphics.ops-&gt;open(&amp;graphics);\n * ```\n *\n * @subsection Step4_RenderContent Render Graphics Content\n *\n * ```cpp\n * graphics.ops-&gt;clear(&amp;graphics);\n * graphics.ops-&gt;setPixel(&amp;graphics, 64, 32);\n * graphics.ops-&gt;update(&amp;graphics);\n * ```\n *\n * @section DrawingModes Drawing Modes\n *\n * The graphics device supports two drawing modes:\n *\n * **Immediate Mode**: Each drawing operation immediately updates the display\n * ```cpp\n * CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_TRUE);\n * graphics.ops-&gt;setPixel(&amp;graphics, 64, 32);  // Visible immediately\n * ```\n *\n * **Deferred Mode**: Drawing operations are buffered; display is updated explicitly\n * ```cpp\n * CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n * graphics.ops-&gt;setPixel(&amp;graphics, 64, 32);\n * graphics.ops-&gt;setPixel(&amp;graphics, 65, 32);\n * graphics.ops-&gt;update(&amp;graphics);  // Both pixels visible now\n * ```\n *\n * @section AnimationUsage Using Animations\n *\n * The Animation framework provides frame-based animations:\n *\n * ```cpp\n * // Initialize animation with defaults\n * CFBD_BaseAnimation anim;\n * CFBD_InitBaseAnimation(&amp;anim);\n * anim.anim_frames = 16;\n * anim.anim_frame_delay_ms = 30;\n *\n * // Use in animation loop\n * for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n *     float progress = (float)frame / anim.anim_frames;\n *     // Render frame based on progress\n *     if (anim.anim_frame_delay_ms &gt; 0) {\n *         HAL_Delay(anim.anim_frame_delay_ms);\n *     }\n * }\n * ```\n *\n * @section ResourceConfiguration Resource Configuration\n *\n * Graphics resources (fonts, etc.) are configured in resource/config.h:\n *\n * ```cpp\n * // Enable/disable font resources\n * #define ENABLE_ASCII_6x8_SOURCES 1\n * #define ENABLE_ASCII_8x16_SOURCES 1\n *\n * // Or disable all defaults and customize\n * #define _USE_NO_DEFAULT_SOURCES\n * ```\n *\n * @section HelperUtilities Utility Functions\n *\n * The helpers module provides common utilities:\n *\n * ```cpp\n * // Min/Max operations\n * int larger = MAX(100, 200);\n * int smaller = MIN(100, 200);\n *\n * // Value clamping\n * int32_t x = clamp_i32(user_input, 0, 127);\n * ```\n *\n * @section CompleteGraphicsExample Complete Graphics Setup Example\n *\n * ```cpp\n * #include \"graphic_device.h\"\n * #include \"oled_graphic_device.h\"\n * #include \"oled.h\"\n * #include \"widget/animation/animation.h\"\n *\n * void graphics_demo(void) {\n *     // Initialize OLED\n *     CFBD_OLED oled;\n *     CFBD_OLED_IICInitsParams iic_config = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = &amp;my_i2c,\n *     };\n *     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_config, CFBD_TRUE);\n *     oled.ops-&gt;open(&amp;oled);\n *\n *     // Create graphics device\n *     CFBD_GraphicDevice graphics;\n *     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n *     graphics.ops-&gt;open(&amp;graphics);\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n *\n *     // Setup animation\n *     CFBD_BaseAnimation anim;\n *     CFBD_InitBaseAnimation(&amp;anim);\n *     anim.anim_frames = 8;\n *     anim.anim_frame_delay_ms = 50;\n *\n *     // Clear display\n *     graphics.ops-&gt;clear(&amp;graphics);\n *     graphics.ops-&gt;update(&amp;graphics);\n *\n *     // Draw animated pattern\n *     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n *         graphics.ops-&gt;clear(&amp;graphics);\n *\n *         // Draw frame-dependent content\n *         for (uint16_t x = 0; x &lt; 128; x += 2) {\n *             graphics.ops-&gt;setPixel(&amp;graphics, x, 32 + frame);\n *         }\n *\n *         graphics.ops-&gt;update(&amp;graphics);\n *         HAL_Delay(anim.anim_frame_delay_ms);\n *     }\n *\n *     // Cleanup\n *     graphics.ops-&gt;close(&amp;graphics);\n *     oled.ops-&gt;close(&amp;oled);\n * }\n * ```\n *\n * @section GraphicsPerformanceTips Performance Tips\n *\n * - **Deferred Mode**: Use for batch operations to reduce display updates\n * - **Area Updates**: Use update_area() for partial display refresh\n * - **Animation Frames**: 4-8 frames for UI feedback, 16+ for smooth transitions\n * - **Resource Management**: Disable unused resources (fonts) to save memory\n *\n * @section ErrorHandling Error Handling\n *\n * Always check return values for graphics operations:\n *\n * ```cpp\n * if (graphics.ops-&gt;setPixel(&amp;graphics, x, y)) {\n *     // Operation succeeded\n * } else {\n *     // Operation failed (invalid coordinates, device error, etc.)\n * }\n * ```\n *\n * ---\n *\n * @section PART_II PART II: Text Widget System\n *\n * @section text_intro Introduction to Text Widget\n *\n * The Graphics Text Widget provides comprehensive text rendering capabilities\n * with support for multiple monospace fonts, multiline layout, and flexible\n * positioning. Text is rendered character-by-character using pre-compiled\n * font bitmaps.\n *\n * @section text_features Key Features\n *\n * - **Multiple Font Sizes**: 6x8 and 8x16 pixel ASCII fonts\n * - **Multiline Support**: Automatic line wrapping and manual line breaks\n * - **Flexible Layout**: Continuous flow or explicit newlines\n * - **Position Queries**: Get next character position without drawing\n * - **Compile-Time Configuration**: Enable/disable fonts via config macros\n * - **Device Agnostic**: Works with any graphics device (OLED, LCD, etc.)\n *\n * @section text_font_architecture Font System\n *\n * @subsection font_sizes Supported Font Sizes\n *\n * @verbatim\n * ASCII Fonts (Compile-Time Selectable):\n * \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502 ASCII_6x8:  6 pixels wide x 8 pixels tall   \u2502\n * \u2502             Compact, dense text layout      \u2502\n * \u2502             Good for: status messages       \u2502\n * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n * \u2502 ASCII_8x16: 8 pixels wide x 16 pixels tall  \u2502\n * \u2502             Standard readability            \u2502\n * \u2502             Good for: main menu text        \u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * @endverbatim\n *\n * @subsection font_enable Font Enablement\n *\n * Fonts are enabled/disabled via resource/config.h macros:\n *\n * @code\n * // In your project configuration:\n * #define ENABLE_ASCII_6x8_SOURCES    // Enable 6x8 font\n * #define ENABLE_ASCII_8x16_SOURCES   // Enable 8x16 font\n * @endcode\n *\n * @section text_quick_start Quick Start with Text\n *\n * @subsection quick_basic Basic Text Rendering\n *\n * @code\n * #include \"graphic/widget/text.h\"\n *\n * void display_text(CFBD_GraphicDevice* device) {\n *     // Initialize text widget\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 64};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     // Set and render text\n *     CFBDGraphic_SetText(&amp;text, \"Hello World!\");\n *     CFBDGraphic_DrawText(device, &amp;text,\n *                         CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Update display\n *     device-&gt;ops-&gt;update(device);\n * }\n * @endcode\n *\n * @subsection quick_multiline Multiline Text\n *\n * @code\n * void display_multiline(CFBD_GraphicDevice* device) {\n *     CFBDGraphic_Text text;\n *     CFBDGraphic_Point pos = {0, 0};\n *     CFBDGraphicSize area = {128, 64};\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n *\n *     // First line\n *     CFBDGraphic_SetText(&amp;text, \"Menu:\");\n *     CFBDGraphic_DrawText(device, &amp;text,\n *                         CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Second line\n *     CFBDGraphic_SetText(&amp;text, \"1. Start\");\n *     CFBDGraphic_DrawText(device, &amp;text,\n *                         CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     // Third line\n *     CFBDGraphic_SetText(&amp;text, \"2. Settings\");\n *     CFBDGraphic_DrawText(device, &amp;text,\n *                         CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     device-&gt;ops-&gt;update(device);\n * }\n * @endcode\n *\n * @section text_layout Layout Methods\n *\n * @subsection layout_continuous Continuous (Default)\n *\n * Characters flow continuously on same line until width limit, then wrap.\n *\n * @code\n * CCGraphic_AsciiTextItem_AppendContinously\n * @endcode\n *\n * Use for: Paragraph text, automatic wrapping, word processing\n *\n * @subsection layout_newline Explicit Newline\n *\n * Forces next text segment to start on new line.\n *\n * @code\n * CCGraphic_AsciiTextItem_AppendNextLine\n * @endcode\n *\n * Use for: Menu items, structured lists, formatted text\n *\n * @subsection layout_query Query Position\n *\n * Get position after hypothetical rendering without actual drawing.\n *\n * @code\n * CCGraphic_AsciiTextItem_RequestOldPoint\n * @endcode\n *\n * Use for: Calculate text metrics, layout planning, responsive design\n *\n * @section text_positioning Positioning and Layout\n *\n * @subsection pos_setup Initial Setup\n *\n * @code\n * CFBDGraphic_Text text;\n * CFBDGraphic_Point pos = {x_start, y_start};\n * CFBDGraphicSize area = {width, height};\n * CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n * @endcode\n *\n * @subsection pos_relocate Repositioning\n *\n * @code\n * // Move text to new position and resize area\n * CFBDGraphic_Point new_pos = {20, 30};\n * CFBDGraphicSize new_area = {88, 34};\n * CCGraphicWidget_AsciiTextItem_relocate(&amp;text, &amp;new_pos, new_area);\n * @endcode\n *\n * @subsection pos_resume Resume at Position\n *\n * @code\n * // Continue text at specific position\n * CFBDGraphic_Point continue_pos = {0, 16};  // Next line\n * CFBDGraphic_SetTextIndexedPoint(&amp;text, &amp;continue_pos);\n * @endcode\n *\n * @section text_font_selection Font Selection\n *\n * @subsection font_compile Compile-Time Selection\n *\n * @code\n * // In project config:\n * #define ENABLE_ASCII_8x16_SOURCES  // Enable 8x16 only\n * #undef ENABLE_ASCII_6x8_SOURCES    // Disable 6x8\n *\n * // In code:\n * #if ENABLE_ASCII_8x16_SOURCES\n *     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n * #else\n *     printf(\"8x16 font not available\\n\");\n * #endif\n * @endcode\n *\n * @subsection font_runtime Runtime Query\n *\n * @code\n * // Get font dimensions\n * CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n * printf(\"Font: %u x %u pixels\\n\", font_size.width, font_size.height);\n *\n * // Get character bitmap\n * uint8_t* char_bitmap = __select_from_ascii_font_size(ASCII_8x16, 'A');\n * if (char_bitmap == UNSUPPORTIVE_FONT_SOURCE) {\n *     printf(\"Font not available\\n\");\n * }\n * @endcode\n *\n * @section text_padding Spacing and Padding\n *\n * @code\n * // Character horizontal spacing (padding between chars)\n * #define CFBDGraphic_TEXT_PADDING_WIDTH (1)  // 1 pixel\n *\n * // Line vertical spacing\n * #define CFBDGraphic_TEXT_PADDING_HEIGHT (0) // 0 pixels\n * @endcode\n *\n * Configure these macros to adjust text layout density.\n *\n * @section text_best_practices Text Best Practices\n *\n * @subsection bp_font_check Always Check Font Availability\n *\n * @code\n * uint8_t* font = __select_from_ascii_font_size(ASCII_8x16, 'A');\n * if (font == UNSUPPORTIVE_FONT_SOURCE) {\n *     // Font not enabled - provide fallback\n *     return handle_missing_font();\n * }\n * @endcode\n *\n * @subsection bp_string_validity Maintain String Validity\n *\n * @code\n * // GOOD: Static string\n * CFBDGraphic_SetText(&amp;text, \"Static Text\");\n * CFBDGraphic_DrawText(device, &amp;text, ...);\n *\n * // GOOD: Stack buffer in local scope\n * char buffer[32];\n * sprintf(buffer, \"Score: %d\", score);\n * CFBDGraphic_SetText(&amp;text, buffer);\n * CFBDGraphic_DrawText(device, &amp;text, ...);\n * // buffer still valid during draw\n *\n * // BAD: Pointer to temporary\n * CFBDGraphic_SetText(&amp;text, \"Value: \");\n * // sprintf result to temporary - DON'T DO THIS\n * @endcode\n *\n * @subsection bp_deferred_mode Use Deferred Mode for Multiple Texts\n *\n * @code\n * // Multiple text elements - use deferred mode\n * CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(device, CFBD_FALSE);\n *\n * // Draw multiple text elements\n * CFBDGraphic_DrawText(device, &amp;title_text, ...);\n * CFBDGraphic_DrawText(device, &amp;body_text, ...);\n * CFBDGraphic_DrawText(device, &amp;footer_text, ...);\n *\n * // Single update for all\n * device-&gt;ops-&gt;update(device);\n * @endcode\n *\n * @subsection bp_bounds_check Plan for Text Bounds\n *\n * @code\n * // Calculate required size\n * CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n * int text_width = 11 * (font_size.width + CFBDGraphic_TEXT_PADDING_WIDTH);\n * int text_height = font_size.height;\n *\n * // Allocate adequate area\n * CFBDGraphicSize area = {text_width + 10, text_height + 10};\n * CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n * @endcode\n *\n * @section text_complete_example Complete Text System Example\n *\n * @code\n * #include \"graphic/device/graphic_device.h\"\n * #include \"graphic/widget/text.h\"\n *\n * void display_system_menu(CFBD_GraphicDevice* device) {\n *     // Initialize text for title\n *     CFBDGraphic_Text title;\n *     CFBDGraphic_Point title_pos = {0, 0};\n *     CFBDGraphicSize title_area = {128, 16};\n *     CFBDGraphic_InitText(&amp;title, title_pos, title_area, ASCII_8x16);\n *\n *     // Initialize text for menu items\n *     CFBDGraphic_Text menu;\n *     CFBDGraphic_Point menu_pos = {10, 18};\n *     CFBDGraphicSize menu_area = {108, 46};\n *     CFBDGraphic_InitText(&amp;menu, menu_pos, menu_area, ASCII_8x16);\n *\n *     // Draw title\n *     CFBDGraphic_SetText(&amp;title, \"MENU\");\n *     CFBDGraphic_DrawText(device, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     // Draw menu items\n *     CFBDGraphic_SetText(&amp;menu, \"Start\");\n *     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     CFBDGraphic_SetText(&amp;menu, \"Settings\");\n *     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     CFBDGraphic_SetText(&amp;menu, \"About\");\n *     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     CFBDGraphic_SetText(&amp;menu, \"Exit\");\n *     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n *\n *     // Update display\n *     device-&gt;ops-&gt;update(device);\n * }\n *\n * void display_score(CFBD_GraphicDevice* device, int score) {\n *     CFBDGraphic_Text score_text;\n *     CFBDGraphic_Point pos = {80, 55};\n *     CFBDGraphicSize area = {48, 8};\n *     CFBDGraphic_InitText(&amp;score_text, pos, area, ASCII_6x8);\n *\n *     char score_buf[12];\n *     sprintf(score_buf, \"Score:%d\", score);\n *     CFBDGraphic_SetText(&amp;score_text, score_buf);\n *     CFBDGraphic_DrawText(device, &amp;score_text, CCGraphic_AsciiTextItem_AppendContinously);\n *\n *     device-&gt;ops-&gt;update(device);\n * }\n * @endcode\n *\n * ---\n *\n * @section PART_III PART III: Widget System\n *\n * @section widget_intro Introduction to Graphics Widgets\n *\n * The Graphics Widget system provides reusable, customizable UI components\n * built on top of the core Graphics Device abstraction. Widgets include:\n *\n * - **Image** - Bitmap rendering at arbitrary positions\n * - **Menu** - Hierarchical item selection with navigation\n * - **ProgressBar** - Progress visualization with animation\n * - **Text** - Text rendering (documented in previous section)\n * - **Animation** - Frame-based timing framework\n *\n * @section widget_architecture Widget Architecture\n *\n * @verbatim\n *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502      Graphics Widgets                       \u2502\n *  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n *  \u2502 Image | Menu | ProgressBar | Text          \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *                      \u2193\n *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502    Graphics Device Abstraction              \u2502\n *  \u2502  (immediate_draw, deferred_draw, update)    \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *                      \u2193\n *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502    Display Driver (OLED, LCD, etc.)         \u2502\n *  \u2502              Transport Layer                 \u2502\n *  \u2502              (I2C, SPI, GPIO)               \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * @endverbatim\n *\n * @section widget_design Design Principles\n *\n * - **No Dynamic Allocation** - All widgets use stack-allocated structures\n * - **Reference-Based** - Widgets reference device and data structures owned by caller\n * - **Operation Tables** - Callbacks enable polymorphic behavior without inheritance\n * - **Animation Support** - All visual widgets support frame-based animation\n * - **Flexible Drawing** - Immediate or deferred mode for optimization\n *\n * @section widget_animation_framework Animation Framework\n *\n * All widgets support frame-based animation through CFBD_BaseAnimation:\n *\n * @code\n * #include \"graphic/widget/animation/animation.h\"\n *\n * // Animation configuration\n * CFBD_BaseAnimation anim;\n * CFBD_InitBaseAnimation(&amp;anim);\n * anim.anim_frames = 16;        // 16 frames\n * anim.anim_frame_delay_ms = 25; // 25ms per frame = ~400ms total\n *\n * // Typical frame counts:\n * // UI feedback: 4-8 frames\n * // Smooth transitions: 8-16 frames\n * // Detailed animations: 16-32 frames\n * @endcode\n *\n * @section widget_image_guide Image Widget\n *\n * @subsection image_overview Overview\n *\n * The Image widget renders bitmap data at specified positions. Images must be\n * pre-allocated as arrays, and the widget references this data.\n *\n * @subsection image_init Initialization\n *\n * @code\n * #include \"graphic/widget/base_support/image.h\"\n *\n * // Create bitmap data (32x32 pixels, 1 byte per pixel)\n * uint8_t logo_bitmap[128] = {\n *     0xFF, 0xFF, ...,  // Row 0\n *     0x00, 0xFF, ...,  // Row 1\n *     // ...\n * };\n *\n * // Initialize image\n * CCGraphic_Image logo;\n * CFBDGraphic_Point pos = {48, 16};      // X=48, Y=16\n * CFBDGraphicSize sz = {32, 32};        // 32x32 pixels\n * CFBDGraphic_InitImage(&amp;logo, &amp;pos, &amp;sz, logo_bitmap);\n * @endcode\n *\n * @subsection image_drawing Drawing\n *\n * @code\n * // Draw image on graphics device\n * CFBDGraphic_DrawImage(graphics_device, &amp;logo);\n *\n * // If in deferred mode, manually update\n * graphics_device-&gt;ops-&gt;update(graphics_device);\n * @endcode\n *\n * @section widget_menu_guide Menu Widget\n *\n * @subsection menu_overview Overview\n *\n * The Menu widget provides interactive list selection with:\n * - Keyboard navigation (next/previous item)\n * - Visual indicator bar showing current selection\n * - Callback support for item activation\n * - Animated transitions\n * - Configurable dimensions and fonts\n *\n * @subsection menu_init Initialization\n *\n * @code\n * #include \"graphic/widget/menu/menu.h\"\n * #include \"graphic/widget/menu/menu_indicator.h\"\n * #include \"graphic/widget/animation/animation.h\"\n *\n * // Pre-allocate menu items array\n * #define MAX_MENU_ITEMS 8\n * CFBD_MenuItem item_array[MAX_MENU_ITEMS];\n * CFBD_MenuItemGroup items = {\n *     .pItems = item_array,\n *     .capacity = MAX_MENU_ITEMS,\n *     .count = 0\n * };\n *\n * // Initialize menu\n * CFBD_Menu menu;\n * CFBDGraphic_Point menu_pos = {0, 0};\n * CFBD_InitMenu(&amp;menu, graphics_device, &amp;items, 128);\n * menu.tl_point = menu_pos;\n * @endcode\n *\n * @subsection menu_add_items Adding Items\n *\n * @code\n * // Callback when item selected\n * void on_start_game(void* ctx) {\n *     int* state = (int*)ctx;\n *     *state = STATE_RUNNING;\n * }\n *\n * // Configure indicator\n * CFBD_MenuIndicator indicator;\n * CFBD_InitDefaultMenuIndicator(&amp;indicator);\n * indicator.width = 4;\n * menu.operations-&gt;set_indicator_property(&amp;menu, &amp;indicator);\n *\n * // Add menu items\n * CFBD_MenuItemCallbackPack cb = {on_start_game, &amp;app_state};\n * menu.operations-&gt;add_item(&amp;menu, \"Start\", ASCII_8x16, &amp;cb);\n * menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n * menu.operations-&gt;add_item(&amp;menu, \"About\", ASCII_8x16, NULL);\n * @endcode\n *\n * @subsection menu_render Rendering\n *\n * @code\n * // Draw menu on graphics device\n * menu.operations-&gt;immediate_draw(&amp;menu);\n * @endcode\n *\n * @subsection menu_nav Navigation\n *\n * @code\n * // Handle keyboard events\n * void on_up_button(CFBD_Menu* menu) {\n *     OLED_Menu_SelectPrev(menu);\n *     menu-&gt;operations-&gt;immediate_draw(menu);\n * }\n *\n * void on_down_button(CFBD_Menu* menu) {\n *     OLED_Menu_SelectNext(menu);\n *     menu-&gt;operations-&gt;immediate_draw(menu);\n * }\n *\n * void on_select_button(CFBD_Menu* menu) {\n *     menu-&gt;operations-&gt;activate_current(menu);\n * }\n * @endcode\n *\n * @subsection menu_animation Menu Animation\n *\n * @code\n * // Enable smooth transitions\n * CFBD_BaseAnimation anim = {\n *     .anim_frames = 8,\n *     .anim_frame_delay_ms = 30\n * };\n * menu.operations-&gt;set_animation(&amp;menu, &amp;anim);\n * @endcode\n *\n * @section widget_progressbar_guide ProgressBar Widget\n *\n * @subsection progressbar_overview Overview\n *\n * The ProgressBar widget visualizes numeric progress with:\n * - Configurable min/max value range\n * - Optional border and padding\n * - Animated fill transitions\n * - Custom properties via property map\n *\n * @subsection progressbar_init Initialization\n *\n * @code\n * #include \"graphic/widget/progressbar/progressbar.h\"\n *\n * // Create progress bar\n * CFBD_ProgressBar progress;\n * CFBDGraphic_Point pos = {10, 50};\n * CFBDGraphicSize sz = {108, 8};\n * CFBD_ProgressBar_Init(&amp;progress, graphics_device, &amp;pos, &amp;sz, 0, 100);\n * @endcode\n *\n * @subsection progressbar_config Configuration\n *\n * @code\n * // Enable border\n * uint8_t border = 1;\n * progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n *\n * // Set padding (space between border and fill)\n * uint8_t padding = 2;\n * progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n *\n * // Configure animation\n * CFBD_BaseAnimation anim = {4, 50};  // 4 frames, 50ms each\n * progress.ops-&gt;set_property(&amp;progress, \"animation\", &amp;anim);\n * @endcode\n *\n * @subsection progressbar_update Progress Updates\n *\n * @code\n * // Update progress (0-100)\n * for (int value = 0; value &lt;= 100; value += 5) {\n *     progress.ops-&gt;set_value(&amp;progress, value);\n *     progress.ops-&gt;immediate_draw(&amp;progress);\n *     HAL_Delay(100);\n * }\n * @endcode\n *\n * @section widget_best_practices Widget Best Practices\n *\n * @subsection bp_memory Memory Management\n *\n * - Pre-allocate all widget structures statically or on stack\n * - Pass pointers to graphics device and supporting data\n * - Ensure pointers remain valid for widget lifetime\n * - Use static arrays for menu items and bitmap data\n *\n * @subsection bp_performance Performance\n *\n * - Use deferred mode (request_updates = false) for batch widget updates\n * - Call device-&gt;ops-&gt;update() once after drawing multiple widgets\n * - Minimize animation frame delay for UI responsiveness (25-50ms recommended)\n * - Disable animations for constrained environments\n *\n * @subsection bp_drawing Drawing Order\n *\n * @code\n * // Recommended drawing order:\n * graphics-&gt;ops-&gt;clear(graphics);\n * CFBDGraphic_DrawImage(graphics, &amp;bg_image);      // Background\n * menu.operations-&gt;immediate_draw(&amp;menu);           // UI elements\n * progress.ops-&gt;immediate_draw(&amp;progress);          // Foreground elements\n * graphics-&gt;ops-&gt;update(graphics);                  // Commit all changes\n * @endcode\n *\n * @subsection bp_error_handling Error Handling\n *\n * @code\n * // Always check return values\n * if (!graphics-&gt;ops-&gt;setPixel(graphics, x, y)) {\n *     // Handle coordinate out of bounds\n * }\n *\n * if (!menu.operations-&gt;add_item(&amp;menu, \"Item\", size, &amp;cb)) {\n *     // Handle menu full (no more item slots)\n * }\n *\n * if (!progress.ops-&gt;set_property(&amp;progress, \"unknown\", NULL)) {\n *     // Handle unknown property\n * }\n * @endcode\n *\n * @section widget_complete_example Complete Widget Integration\n *\n * @code\n * #include \"graphic/device/graphic_device.h\"\n * #include \"graphic/device/oled/oled_graphic_device.h\"\n * #include \"graphic/widget/base_support/image.h\"\n * #include \"graphic/widget/menu/menu.h\"\n * #include \"graphic/widget/progressbar/progressbar.h\"\n *\n * // Global state\n * int app_state = STATE_MENU;\n * int selected_game = 0;\n * int progress_percent = 0;\n *\n * // Callback for menu selection\n * void on_game_selected(void* ctx) {\n *     int* state = (int*)ctx;\n *     *state = STATE_LOADING;\n * }\n *\n * void main(void) {\n *     // Initialize OLED\n *     CFBD_OLED oled;\n *     CFBD_OLED_IICInitsParams iic = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = i2c_interface,\n *     };\n *     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic, CFBD_TRUE);\n *     oled.ops-&gt;open(&amp;oled);\n *\n *     // Bind graphics device\n *     CFBD_GraphicDevice graphics;\n *     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n *     graphics.ops-&gt;open(&amp;graphics);\n *     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n *\n *     // Setup menu\n *     CFBD_MenuItem items[4];\n *     CFBD_MenuItemGroup item_group = {items, 4, 0};\n *     CFBD_Menu menu;\n *     CFBD_InitMenu(&amp;menu, &amp;graphics, &amp;item_group, 128);\n *\n *     CFBD_MenuItemCallbackPack cb = {on_game_selected, &amp;app_state};\n *     menu.operations-&gt;add_item(&amp;menu, \"Tetris\", ASCII_8x16, &amp;cb);\n *     menu.operations-&gt;add_item(&amp;menu, \"Breakout\", ASCII_8x16, &amp;cb);\n *     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n *\n *     // Setup progress bar for loading\n *     CFBD_ProgressBar progress;\n *     CFBDGraphic_Point prog_pos = {10, 50};\n *     CFBDGraphicSize prog_sz = {108, 8};\n *     CFBD_ProgressBar_Init(&amp;progress, &amp;graphics, &amp;prog_pos, &amp;prog_sz, 0, 100);\n *\n *     uint8_t border = 1, padding = 1;\n *     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n *     progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n *\n *     // Main loop\n *     while (1) {\n *         switch (app_state) {\n *         case STATE_MENU:\n *             menu.operations-&gt;immediate_draw(&amp;menu);\n *             handle_menu_input(&amp;menu);\n *             break;\n *\n *         case STATE_LOADING:\n *             graphics.ops-&gt;clear(&amp;graphics);\n *             CFBDGraphic_DrawImage(&amp;graphics, &amp;loading_image);\n *             for (int i = 0; i &lt;= 100; i += 10) {\n *                 progress.ops-&gt;set_value(&amp;progress, i);\n *                 progress.ops-&gt;immediate_draw(&amp;progress);\n *                 graphics.ops-&gt;update(&amp;graphics);\n *                 HAL_Delay(100);\n *             }\n *             app_state = STATE_GAME;\n *             break;\n *         }\n *     }\n * }\n * @endcode\n *\n * ---\n *\n * @section References Complete Documentation References\n *\n * - @ref Graphics_Device \"Graphics Device Abstraction\"\n * - @ref Graphics_Animation \"Animation Framework\"\n * - @ref Graphics_Helpers \"Utility Helpers\"\n * - @ref Graphics_Resources \"Resource Configuration\"\n * - @ref Graphics_Examples \"Code Examples\"\n * - @ref Graphics_Widget_Examples \"Widget Examples\"\n * - @ref Graphics_Complete_Examples \"Complete Examples\"\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/Graphics__Widget__Documentation_8md/","title":"Graphics_Widget_Documentation.md","text":""},{"location":"api/Files/Graphics__Widget__Documentation_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page Graphics_Widget_Documentation Graphics Widget Documentation Summary\n *\n * @tableofcontents\n *\n * @section widget_intro Introduction\n *\n * This document summarizes comprehensive Doxygen documentation enhancements\n * made to the Graphics Widget subsystem, complementing the core Graphics Device\n * abstraction with reusable UI components.\\n\n *\\n\n * @section widget_module_hierarchy Widget Module Hierarchy\\n\n *\\n\n * @verbatim\\n\n * Graphics\\n\n * \u251c\u2500\u2500 Graphics_Widget (Main Widget Module)\\n\n * \u2502   \u251c\u2500\u2500 Graphics_Image (Bitmap widget)\\n\n * \u2502   \u251c\u2500\u2500 Graphics_Menu (Menu widget with subcomponents)\\n\n * \u2502   \u2502   \u251c\u2500\u2500 Graphics_MenuItem (Individual menu items)\\n\n * \u2502   \u2502   \u251c\u2500\u2500 Graphics_MenuIndicator (Selection indicator)\\n\n * \u2502   \u2502   \u2514\u2500\u2500 Graphics_MenuConfig (Compile-time configuration)\\n\n * \u2502   \u2514\u2500\u2500 Graphics_ProgressBar (Progress visualization)\\n\n * \u2514\u2500\u2500 [existing Graphics_Device, Graphics_Animation, etc.]\\n\n * @endverbatim\\n\n *\\n\n * @section widget_image_module Graphics_Image Module\\n\n *\\n\n * **Location**: lib/graphic/widget/base_support/image.h\\n\n *\\n\n * **Purpose**: Bitmap image rendering at arbitrary positions\\n\n *\\n\n * **Key Components**:\\n\n * - @c CCGraphic_Image - Image structure (point, size, bitmap pointer)\\n\n * - @c CFBDGraphic_InitImage() - Initialize image with data\\n\n * - @c CFBDGraphic_DrawImage() - Render image to graphics device\\n\n *\\n\n * **Features**:\\n\n * - Flexible bitmap data ownership (caller owned)\\n\n * - No size restrictions (limited by device resolution)\\n\n * - Respects device drawing mode (immediate/deferred)\\n\n *\\n\n * **Usage Pattern**:\\n\n * @code\\n\n * 1. Create bitmap data array\\n\n * 2. Call CFBDGraphic_InitImage() with position and size\\n\n * 3. Call CFBDGraphic_DrawImage() to render\\n\n * 4. Update device if in deferred mode\\n\n * @endcode\\n\n *\\n\n * @section widget_menu_module Graphics_Menu Module\\n\n *\\n\n * **Location**: lib/graphic/widget/menu/menu.h (with config, indicator, item support)\\n\n *\\n\n * **Purpose**: Interactive menu system with navigation and selection\\n\n *\\n\n * **Submodules**:\\n\n *\\n\n * @subsection menu_indicator Graphics_MenuIndicator\\n\n *\\n\n * **Purpose**: Visual selection indicator bar\\n\n *\\n\n * **Components**:\\n\n * - @c CFBD_MenuIndicator - Configuration (width, x position)\\n\n * - @c CFBD_InitDefaultMenuIndicator() - Initialize from config macros\\n\n * - @c CFBD_DrawMenuIndicator() - Render indicator\\n\n *\\n\n * **Configuration**:\\n\n * - Width: 0-8 pixels (0 = disabled)\\n\n * - X position: Left edge in pixels\\n\n *\\n\n * @subsection menu_item Graphics_MenuItem\\n\n *\\n\n * **Purpose**: Individual menu items with labels and callbacks\\n\n *\\n\n * **Components**:\\n\n * - @c CFBD_MenuItem - Single item structure\\n\n * - @c CFBD_MenuItemGroup - Array container\\n\n * - @c CFBD_MenuItemCallback - Callback function type\\n\n * - @c CFBD_MenuItemCallbackPack - Callback + user data wrapper\\n\n * - @c CFBD_MenuItemInit() - Initialize item\\n\n *\\n\n * **Features**:\\n\n * - Zero-terminated string labels (caller owned)\\n\n * - Optional selection callback with user data\\n\n * - Configurable text rendering properties\\n\n *\\n\n * @subsection menu_config Graphics_MenuConfig\\n\n *\\n\n * **Purpose**: Compile-time menu appearance configuration\\n\n *\\n\n * **Configuration Macros**:\\n\n * - @c CFBD_MENU_INDICATOR_WIDTH - Default indicator width (4px)\\n\n * - @c CFBD_MENU_INDICATOR_POSX - Default indicator X position (0)\\n\n * - @c CFBD_MENU_INDICATOR_MAX_WIDTH_PX - Maximum width (8px)\\n\n * - @c CFBD_MENU_INDICATOR_MAX_HEIGHT_PX - Maximum height (16px)\\n\n * - @c CFBD_MENU_INDICATOR_GAP - Gap between indicator and items (4px)\\n\n * - @c CFBD_MENU_ITEM_Y_GAP - Vertical spacing between items (0px)\\n\n *\\n\n * @subsection menu_main Graphics_Menu (Main)\\n\n *\\n\n * **Key Components**:\\n\n * - @c CFBD_Menu - Main menu structure\\n\n * - @c CFBD_MenuOps - Operation table with 8 callbacks\\n\n * - @c CFBD_InitMenu() - Initialize menu\\n\n * - @c OLED_Menu_SelectNext() - Navigate down (inline)\\n\n * - @c OLED_Menu_SelectPrev() - Navigate up (inline)\\n\n *\\n\n * **Operations**:\\n\n * - bind_item_groups_contains() - Associate items array\\n\n * - add_item() - Add item dynamically\\n\n * - set_indicator_property() - Configure indicator\\n\n * - set_animation() - Set transition animation\\n\n * - immediate_draw() - Render complete menu\\n\n * - select_index() - Change selection\\n\n * - activate_current() - Invoke item callback\\n\n * - reset_tl_points() - Reposition menu\\n\n *\\n\n * @section widget_progressbar_module Graphics_ProgressBar Module\\n\n *\\n\n * **Location**: lib/graphic/widget/progressbar/progressbar.h\\n\n *\\n\n * **Purpose**: Progress visualization with fill animation\\n\n *\\n\n * **Key Components**:\\n\n * - @c CFBD_ProgressBar - Main structure\\n\n * - @c CFBD_ProgressBarOps - Operation table\\n\n * - @c CFBD_ProgressBar_Init() - Initialize progress bar\\n\n *\\n\n * **Operations**:\\n\n * - immediate_draw() - Render current progress\\n\n * - set_value() - Update progress value\\n\n * - set_property() - Configure visual properties\\n\n *\\n\n * **Configuration**:\\n\n * - \\\"border\\\" (uint8_t) - Border enabled/disabled\\n\n * - \\\"padding\\\" (uint8_t) - Inner padding (0-8px)\\n\n * - \\\"animation\\\" (CFBD_BaseAnimation*) - Transition timing\\n\n *\\n\n * @section widget_enhancements Documentation Enhancements\\n\n *\\n\n * @subsection enhancement_file_level File-Level Documentation\\n\n *\\n\n * Every widget header enhanced with:\\n\n * - **@file** - Comprehensive file description\\n\n * - **@brief** - One-line purpose\\n\n * - **@details** - Detailed explanation with features/capabilities\\n\n * - **@ingroup Graphics_Widget** - Hierarchy placement\\n\n * - **@{/@}** - Doxygen module markers\\n\n *\\n\n * Example:\\n\n * @code\\n\n * /**\\n\n *  * @file image.h\\n\n *  * @brief Image widget for rendering bitmap graphics\\n\n *  * @details Provides image structures and functions for drawing bitmap data\\n\n *  *          at specified positions on graphics devices.\\n\n *  * @ingroup Graphics_Widget Graphics_Image\\n\n *  * @{\\n\n *  */\\n\n * @endcode\\n\n *\\n\n * @subsection enhancement_typedefs Type Documentation\\n\n *\\n\n * All typedefs and structures documented with:\\n\n * - **@typedef/@struct** - Type designation\\n\n * - **@brief** - Purpose summary\\n\n * - **@details** - Semantics and usage patterns\\n\n * - **Member documentation** - Field-level @brief comments\\n\n * - **@see** - Cross-references\\n\n *\\n\n * @subsection enhancement_functions Function Documentation\\n\n *\\n\n * All functions documented with:\\n\n * - **@brief** - One-line purpose\\n\n * - **@details** - Behavior, side effects, constraints\\n\n * - **@param[in/out]** - Parameter descriptions with constraints\\n\n * - **@return** - Return value semantics\\n\n * - **@note** - Important usage information\\n\n * - **@example** - Practical code examples\\n\n * - **@see** - Related types/functions\\n\n *\\n\n * @subsection enhancement_callbacks Operation Table Documentation\\n\n *\\n\n * Each operation callback in tables documented with:\\n\n * - Purpose and behavior\\n\n * - Parameter descriptions with constraints\\n\n * - Return value semantics\\n\n * - Usage examples\\n\n * - Related operations\\n\n *\\n\n * @section widget_doxygen_output Expected Doxygen Output\\n\n *\\n\n * @subsection output_modules Modules Tab\\n\n *\\n\n * Complete widget hierarchy:\\n\n * - Graphics_Widget (parent)\\n\n *   - Graphics_Image with all typedefs and functions\\n\n *   - Graphics_Menu with nested submodules\\n\n *     - Graphics_MenuIndicator\\n\n *     - Graphics_MenuItem\\n\n *     - Graphics_MenuConfig\\n\n *   - Graphics_ProgressBar with all typedefs and functions\\n\n *\\n\n * @subsection output_examples Examples Tab\\n\n *\\n\n * All @example blocks:\\n\n * - Image initialization and drawing\\n\n * - Animated image sequences\\n\n * - Menu setup and navigation\\n\n * - Menu with indicators and animations\\n\n * - Progress bar creation and updates\\n\n * - Complex multi-widget UIs\\n\n * - Batch drawing optimization\\n\n *\\n\n * @subsection output_pages Pages Tab\\n\n *\\n\n * - Widget_UserGuide (comprehensive usage guide)\\n\n * - Graphics_Widget_Examples (11+ practical examples)\\n\n * - Graphics_Widget_Documentation (this page)\\n\n *\\n\n * @section widget_design_patterns Design Patterns\\n\n *\\n\n * @subsection pattern_init_render Initialize \u2192 Configure \u2192 Render\\n\n *\\n\n * All widgets follow this pattern:\\n\n *\\n\n * @code\\n\n * 1. Initialize with base properties (Init function)\\n\n * 2. Configure visual/behavioral properties (ops-&gt;set_property)\\n\n * 3. Render (ops-&gt;immediate_draw or equivalent)\\n\n * @endcode\\n\n *\\n\n * @subsection pattern_operation_tables Operation Tables\\n\n *\\n\n * Polymorphic behavior through function pointer tables enables:\\n\n * - Multiple implementations per widget type\\n\n * - Compile-time or runtime selection\\n\n * - Future extensibility\\n\n *\\n\n * @subsection pattern_memory_ownership Caller Ownership\\n\n *\\n\n * - All structures stack/static allocated\\n\n * - Caller owns: display device, bitmap data, item arrays\\n\n * - Widgets reference, don't copy data\\n\n * - Ensures deterministic memory usage\\n\n *\\n\n * @section widget_best_practices Best Practices\\n\n *\\n\n * @subsection bp_initialization Initialization\\n\n *\\n\n * - Call *_Init() for all widgets before using\\n\n * - Initialize in order: dependencies first\\n\n * - Keep structures valid for entire usage lifetime\\n\n *\\n\n * @subsection bp_drawing Drawing\\n\n *\\n\n * - Use deferred mode for multiple widgets\\n\n * - Batch operations then single update()\\n\n * - Minimize update calls in tight loops\\n\n *\\n\n * @subsection bp_animation Animation\\n\n *\\n\n * - Use 4-8 frames for UI feedback\\n\n * - Use 16+ frames for smooth transitions\\n\n * - Choose delays based on HAL tick resolution (25-50ms typical)\\n\n *\\n\n * @subsection bp_error_handling Error Checking\\n\n *\\n\n * - Always check return values from add_item() - may fail if full\\n\n * - Always check return values from set_property() - property may not exist\\n\n * - Validate coordinates before drawing (device-&gt;ops-&gt;setPixel may fail)\\n\n *\\n\n * @section widget_maintenance Documentation Maintenance\\n\n *\\n\n * When modifying widget code:\\n\n *\\n\n * 1. Update @file/@brief/@details comments\\n\n * 2. Update member documentation if structure changes\\n\n * 3. Add @example if new patterns emerge\\n\n * 4. Update operation table documentation if callbacks change\\n\n * 5. Regenerate Widget_UserGuide.md if major features added\\n\n * 6. Update this Graphics_Widget_Documentation page\\n\n *\\n\n * @section widget_integration Integration with Core Graphics\\n\n *\\n\n * Widgets integrate seamlessly with core Graphics Device:\\n\n *\\n\n * @verbatim\\n\n * Core Graphics Features:          Widget Support:\\n\n * - Immediate/Deferred Mode   \u2192    All widgets respect device mode\\n\n * - Device abstraction        \u2192    All widgets use CFBD_GraphicDevice\\n\n * - Animation framework       \u2192    Built-in CFBD_BaseAnimation support\\n\n * - Multiple device types     \u2192    Works with any device (OLED, LCD, etc.)\\n\n * @endverbatim\\n\n *\\n\n * @section widget_complete_hierarchy Complete Documentation Structure\\n\n *\\n\n * @verbatim\\n\n * Documentation Coverage:\\n\n *\\n\n * @page layers:\\n\n *   - Graphics_UserGuide (core API, 4 drawing modes)\\n\n *   - Widget_UserGuide (widget system, initialization patterns)\\n\n *   - Graphics_Examples (core device examples)\\n\n *   - Graphics_Widget_Examples (11+ widget examples)\\n\n *   - Graphics_Documentation_Summary (core module overview)\\n\n *   - Graphics_Widget_Documentation (widget module overview) \u2190 THIS PAGE\\n\n *\\n\n * @defgroup layers:\\n\n *   - Graphics (root)\\n\n *     - Graphics_Device (core device interface)\\n\n *     - Graphics_Widget (widget layer)\\n\n *       - Graphics_Image\\n\n *       - Graphics_Menu (with sub-modules)\\n\n *       - Graphics_ProgressBar\\n\n *     - Graphics_Animation (animation framework)\\n\n *     - Graphics_Helpers (utility functions)\\n\n *     - Graphics_Resources (resource configuration)\\n\n *\\n\n * @example blocks: 20+ complete, runnable code examples\\n\n *\\n\n * @namespace CFBD with hierarchical organization\\n\n * @endverbatim\\n\n *\\n\n * @section widget_summary Summary\\n\n *\\n\n * The Graphics Widget subsystem provides professional-grade UI components\\n\n * with comprehensive Doxygen documentation supporting:\\n\n *\\n\n * \u2713 Complete API documentation with @example blocks\\n\n * \u2713 Module hierarchy supporting Modules tab\\n\n * \u2713 20+ practical code examples for Examples tab\\n\n * \u2713 3 @page documents for Pages tab\\n\n * \u2713 CFBD namespace organization for Namespaces tab\\n\n * \u2713 Hierarchical structure (Graphics \u2192 Widget \u2192 Image/Menu/ProgressBar)\\n\n * \u2713 Best practices and maintenance guidelines\\n\n *\\n\n * @see @ref Widget_UserGuide - Start here for widget usage\\n\n * @see @ref Graphics_Widget_Examples - Copy-paste ready examples\\n\n * @see @ref Graphics_UserGuide - Core graphics system\\n\n * @see @ref CFBD_GraphicDevice - Core device interface\\n\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/OLED__Documentation__Summary_8md/","title":"OLED_Documentation_Summary.md","text":""},{"location":"api/Files/OLED__Documentation__Summary_8md/#namespaces","title":"Namespaces","text":"Name for"},{"location":"api/Files/OLED__Documentation__Summary_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_Documentation_Summary OLED Documentation Summary\n *\n * This page summarizes the comprehensive Doxygen documentation additions made\n * to the OLED driver subsystem.\n *\n * @section DocumentationEnhancements Overview of Enhancements\n *\n * The OLED driver documentation has been significantly enhanced to support\n * Doxygen's advanced features, including:\n *\n * - **Modules (@defgroup)**: Hierarchical organization of related components\n * - **Examples (@example)**: Practical code examples demonstrating usage\n * - **Pages (@page)**: Comprehensive guides and reference documentation\n * - **Detailed Comments**: Extended @details sections with implementation guidance\n *\n * @section ModuleHierarchy Module Organization\n *\n * The OLED subsystem is organized into the following modules:\n *\n * @subsection MainModule OLED - Main Display Driver\n * - **Location**: oled.h\n * - **Purpose**: Generic OLED interface and device operations\n * - **Contents**:\n *   - CFBD_OLED device structure\n *   - CFBD_OLEDOperations virtual operation table\n *   - CFBD_OLEDDriverType transport enumeration\n *   - CFBD_GetOLEDHandle() factory function\n *\n * @subsection DeviceModule OLED_Device - Device Interface\n * - **Location**: device_interface.h, ssd1306.h, ssd1309.h\n * - **Purpose**: Device-specific configurations and factories\n * - **Contents**:\n *   - CFBD_OLED_DeviceSpecific structure\n *   - getSSD1306Specific() factory function\n *   - getSSD1309Specific() factory function\n *   - SSD1309_DRIVER_ADDRESS constant\n *\n * @subsection BackendModule OLED_Backend - Transport Backends\n * - **Location**: oled_iic.h (and potentially future spi backends)\n * - **Purpose**: Transport-specific implementations\n * - **Contents**:\n *   - CFBD_OLED_IICInit() I2C initialization\n *   - Backend parameter structures\n *   - Transport configuration\n *\n * @section DocumentationFiles New Documentation Files\n *\n * Three comprehensive documentation files have been created:\n *\n * @subsection UsageGuideFile OLED_UsageGuide.md (@page OLED_UsageGuide)\n * - **Purpose**: Comprehensive user guide for OLED driver usage\n * - **Contents**:\n *   - Architecture overview\n *   - Getting started instructions (steps 1-4)\n *   - Common operations guide\n *   - Complete working example\n *   - Performance considerations\n *   - Troubleshooting guide\n * - **Target Audience**: Application developers\n *\n * @subsection ExamplesFile OLED_Examples.md (@page OLED_Examples)\n * - **Purpose**: Collection of practical code examples\n * - **Contents**:\n *   - 10+ complete, runnable examples\n *   - Basic initialization\n *   - Display clearing and updating\n *   - Pixel and area drawing\n *   - Device property queries\n *   - Multi-display management\n *   - Error handling patterns\n *   - Deferred initialization\n * - **Target Audience**: Developers learning by example\n *\n * @subsection NamespaceFile OLED_Namespace.md (@page OLED Namespace)\n * - **Purpose**: Namespace organization documentation\n * - **Contents**:\n *   - CFBD namespace overview\n *   - CFBD::OLED sub-namespace\n *   - Component organization\n * - **Target Audience**: Architecture documentation readers\n *\n * @section EnhancedDocumentation Enhanced Inline Documentation\n *\n * All header files have received extensive documentation improvements:\n *\n * @subsection oledh_enhancements oled.h Enhancements\n *\n * **Enumerations**:\n * - @ref CFBD_OLEDDriverType: Expanded with detailed transport descriptions\n *\n * **Type Definitions**:\n * - @ref AreaOperations: Enhanced with usage examples\n * - @ref FrameOperation: Detailed operation semantics\n * - @ref OLEDSelfOperation: Lifecycle management documentation\n * - @ref OLED_QueryOperation: Property query protocol and examples\n * - @ref CFBDOLED_Params_Inits: Transport-specific parameter abstraction\n *\n * **Structures**:\n * - @ref CFBD_OLEDOperations: Complete operation table with:\n *   - Field-by-field documentation\n *   - Usage examples\n *   - Supported operation types\n * - @ref CFBD_OLED: Device object with:\n *   - Member descriptions\n *   - Usage patterns\n *   - Lifecycle documentation\n *\n * **Functions**:\n * - @ref CFBD_GetOLEDHandle(): Extended documentation with:\n *   - Multiple usage examples\n *   - Transport-specific parameter guidelines\n *   - Error handling guidance\n *   - Two complete code examples\n *\n * @subsection device_interface_enhancements device_interface.h Enhancements\n *\n * **New @defgroup OLED_Device**:\n * - Hierarchical module organization\n * - Cross-references to device implementations\n * - Module relationships\n *\n * **Structure Documentation**:\n * - @ref CFBD_OLED_DeviceSpecific: Comprehensive documentation with:\n *   - Field descriptions\n *   - Implementation requirements\n *   - Usage examples\n *\n * @subsection device_drivers_enhancements Device Driver Enhancements\n *\n * **ssd1306.h**:\n * - Extended file documentation with SSD1306 capabilities\n * - @ref getSSD1306Specific(): Complete factory function documentation\n * - Usage examples and cross-references\n *\n * **ssd1309.h**:\n * - Extended file documentation with SSD1309 enhancements\n * - @ref SSD1309_DRIVER_ADDRESS: Address constant documentation\n * - @ref getSSD1309Specific(): Comprehensive factory documentation\n * - Multi-example usage patterns\n *\n * @subsection backend_enhancements oled_iic.h Enhancements\n *\n * **New @defgroup OLED_Backend**:\n * - Backend implementation organization\n * - Transport abstraction documentation\n *\n * **Function Documentation**:\n * - @ref CFBD_OLED_IICInit(): Complete I2C initialization with:\n *   - Parameter descriptions\n *   - Step-by-step initialization flow\n *   - Complete working example\n *   - Thread-safety notes\n *\n * @section ExampleProgramming Example: Supported Property Queries\n *\n * The documentation now clearly specifies all supported property queries:\n *\n * ```cpp\n * // Query display width\n * uint16_t width = 0;\n * oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *\n * // Query display height  \n * uint16_t height = 0;\n * oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *\n * // Query RGB color support\n * CFBD_bool is_rgb = CFBD_FALSE;\n * oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n * ```\n *\n * @section DoxygenOutput Expected Doxygen Generation\n *\n * When Doxygen processes these enhanced comments, it will generate:\n *\n * **Modules Tab**:\n * - OLED - OLED Display Driver (main group)\n *   - OLED_Device - OLED Device Interface\n *   - OLED_Backend - OLED Backend Implementations\n *\n * **Examples Tab**:\n * - Multiple code examples from @example blocks\n * - Complete working programs\n * - Practical usage demonstrations\n *\n * **Pages Tab**:\n * - OLED Usage Guide (comprehensive guide)\n * - OLED Examples (10+ code samples)\n * - OLED Namespace (namespace organization)\n * - OLED Documentation Summary (this page)\n *\n * **Namespaces Tab**:\n * - CFBD - Core Framework Bare Device\n *   - CFBD::OLED - OLED Display Driver\n *\n * @section DocumentationGuidelines Documentation Guidelines\n *\n * The documentation follows these principles:\n *\n * - **Completeness**: All public APIs are documented\n * - **Clarity**: Technical terms are explained\n * - **Examples**: Practical code examples included\n * - **Cross-referencing**: Related concepts are linked\n * - **Hierarchy**: Information is organized logically\n * - **Audience**: Both beginners and advanced users are served\n *\n * @section GeneratingDocumentation Generating Documentation\n *\n * To generate the Doxygen documentation:\n *\n * ```bash\n * doxygen Doxyfile\n * ```\n *\n * The output will be generated in the configured directory (typically `documentation/`).\n *\n * **Key configuration points in Doxyfile**:\n * - EXAMPLE_PATH: Directory containing example files\n * - GENERATE_HTML: HTML output generation\n * - GENERATE_LATEX: PDF generation\n * - EXTRACT_ALL: Whether to document all entities\n *\n * @section RelatedDocumentation Related Resources\n *\n * - @ref OLED_UsageGuide \"OLED Driver Usage Guide\" - Comprehensive guide for developers\n * - @ref OLED_Examples \"Code Examples\" - 10+ practical examples\n * - README.md - Project overview and build instructions\n * - Doxyfile - Doxygen configuration\n *\n * @section DocumentationMaintenance Maintaining Documentation\n *\n * When adding new features to the OLED driver:\n *\n * 1. Add comprehensive comments to header files\n * 2. Use @defgroup for new module concepts\n * 3. Add @example code blocks for new operations\n * 4. Update @page documents with new information\n * 5. Maintain cross-references between related items\n * 6. Keep examples in sync with implementation\n *\n * @section SupportedDoxygenFeatures Doxygen Features Used\n *\n * This documentation makes use of:\n * - @c @file for file documentation\n * - @c @brief for brief descriptions\n * - @c @details for detailed documentation\n * - @c @defgroup for module grouping\n * - @c @ingroup for hierarchical organization\n * - @c @page for standalone pages\n * - @c @example for code examples\n * - @c @code/@endcode for code blocks\n * - @c @see/@ref for cross-references\n * - @c @param for parameter documentation\n * - @c @return for return value documentation\n * - @c @note/@warning for special notes\n * - @c @namespace for namespace documentation\n *\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/OLED__Examples_8md/","title":"OLED_Examples.md","text":""},{"location":"api/Files/OLED__Examples_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_Examples OLED Driver Examples\n *\n * @tableofcontents\n *\n * This page contains comprehensive code examples demonstrating how to use\n * the OLED driver for various common tasks.\n *\n * @section Example1_BasicInitialization Basic Device Initialization\n *\n * The most fundamental example showing device setup and initialization:\n *\n * @code\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n *\n * void example_basic_init(void) {\n *     // Create OLED device structure\n *     CFBD_OLED oled;\n *\n *     // Setup I2C parameters\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,  // Use standard address\n *         .i2c_handle = get_my_i2c_interface(),\n *     };\n *\n *     // Initialize OLED with I2C backend\n *     CFBD_bool success = CFBD_GetOLEDHandle(\n *         &amp;oled,\n *         CFBD_OLEDDriverType_IIC,\n *         &amp;i2c_params,\n *         CFBD_TRUE  // Immediate initialization\n *     );\n *\n *     if (success &amp;&amp; oled.ops-&gt;open(&amp;oled)) {\n *         // Device is now ready for use\n *     }\n * }\n * @endcode\n *\n * @section Example2_ClearAndDisplay Clear Display\n *\n * Clear all pixels and update the physical display:\n *\n * @code\n * void example_clear_display(CFBD_OLED* oled) {\n *     // Clear all pixels in the local buffer\n *     oled-&gt;ops-&gt;clear(oled);\n *\n *     // Synchronize with physical display\n *     oled-&gt;ops-&gt;update(oled);\n * }\n * @endcode\n *\n * @section Example3_DrawingPixels Drawing Individual Pixels\n *\n * Set individual pixels to create a pattern:\n *\n * @code\n * void example_draw_checkerboard(CFBD_OLED* oled) {\n *     // Get display dimensions\n *     uint16_t width = 0, height = 0;\n *     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *\n *     // Draw checkerboard pattern\n *     for (uint16_t y = 0; y &lt; height; y += 2) {\n *         for (uint16_t x = 0; x &lt; width; x += 2) {\n *             if ((x + y) % 4 == 0) {\n *                 oled-&gt;ops-&gt;setPixel(oled, x, y);\n *             }\n *         }\n *     }\n *\n *     // Update display\n *     oled-&gt;ops-&gt;update(oled);\n * }\n * @endcode\n *\n * @section Example4_AreaOperations Area-Based Drawing\n *\n * Efficiently update rectangular regions of the display:\n *\n * @code\n * void example_draw_rectangle(CFBD_OLED* oled,\n *                             uint16_t x, uint16_t y,\n *                             uint16_t width, uint16_t height) {\n *     // Prepare bitmap data (format depends on device)\n *     uint8_t* bitmap = prepare_rectangle_data(width, height);\n *\n *     // Write the area\n *     CFBD_bool success = oled-&gt;ops-&gt;setArea(oled, x, y, width, height, bitmap);\n *\n *     if (success) {\n *         // Update only this area on the display\n *         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n *     }\n *\n *     free_bitmap_data(bitmap);\n * }\n * @endcode\n *\n * @section Example5_DeviceQueries Device Property Queries\n *\n * Query device capabilities and properties:\n *\n * @code\n * void example_query_device(CFBD_OLED* oled) {\n *     uint16_t width = 0, height = 0;\n *     CFBD_bool is_rgb = CFBD_FALSE;\n *\n *     // Query basic properties\n *     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n *     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n *     oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n *\n *     // Report display information\n *     printf(\"Display Resolution: %u x %u pixels\\n\", width, height);\n *     printf(\"Color Mode: %s\\n\", is_rgb ? \"RGB Color\" : \"Monochrome\");\n *     printf(\"Total Pixels: %u\\n\", (unsigned long)width * height);\n * }\n * @endcode\n *\n * @section Example6_AreaClear Clearing Specific Regions\n *\n * Clear only a portion of the display:\n *\n * @code\n * void example_clear_area(CFBD_OLED* oled,\n *                        uint16_t x, uint16_t y,\n *                        uint16_t width, uint16_t height) {\n *     // Clear rectangular area in the frame buffer\n *     CFBD_bool success = oled-&gt;ops-&gt;clear_area(oled, x, y, width, height);\n *\n *     if (success) {\n *         // Update the cleared area on the physical display\n *         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n *     }\n * }\n * @endcode\n *\n * @section Example7_MultipleDevices Multiple OLED Devices\n *\n * Control multiple OLED displays on different I2C addresses:\n *\n * @code\n * #define NUM_DISPLAYS 2\n *\n * void example_multiple_displays(void) {\n *     CFBD_OLED oled_displays[NUM_DISPLAYS];\n *\n *     // Configuration for each display\n *     struct {\n *         uint8_t address;\n *     } configs[NUM_DISPLAYS] = {\n *         { 0x78 },  // First device\n *         { 0x7A },  // Second device (alternate address)\n *     };\n *\n *     // Initialize all displays\n *     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n *         CFBD_OLED_IICInitsParams i2c_params = {\n *             .device_address = configs[i].address,\n *             .i2c_handle = get_i2c_interface(),\n *         };\n *\n *         if (CFBD_GetOLEDHandle(&amp;oled_displays[i],\n *                                CFBD_OLEDDriverType_IIC,\n *                                &amp;i2c_params,\n *                                CFBD_TRUE)) {\n *             oled_displays[i].ops-&gt;open(&amp;oled_displays[i]);\n *         }\n *     }\n *\n *     // Use both displays independently\n *     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n *         oled_displays[i].ops-&gt;clear(&amp;oled_displays[i]);\n *         oled_displays[i].ops-&gt;update(&amp;oled_displays[i]);\n *     }\n * }\n * @endcode\n *\n * @section Example8_DeferredInitialization Deferred Initialization\n *\n * Create device handle but delay initialization:\n *\n * @code\n * void example_deferred_init(void) {\n *     CFBD_OLED oled;\n *\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     // Create handle without immediate initialization\n *     if (CFBD_GetOLEDHandle(&amp;oled,\n *                            CFBD_OLEDDriverType_IIC,\n *                            &amp;i2c_params,\n *                            CFBD_FALSE)) {  // Deferred init\n *\n *         // ... perform other setup operations ...\n *\n *         // Later, initialize when needed\n *         oled.ops-&gt;init(&amp;oled, NULL);\n *         oled.ops-&gt;open(&amp;oled);\n *\n *         // Now ready for use\n *     }\n * }\n * @endcode\n *\n * @section Example9_ErrorHandling Error Handling\n *\n * Proper error checking throughout device usage:\n *\n * @code\n * CFBD_bool safe_display_operation(void) {\n *     CFBD_OLED oled;\n *\n *     // Step 1: Initialize with error checking\n *     CFBD_OLED_IICInitsParams i2c_params = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     if (!CFBD_GetOLEDHandle(&amp;oled,\n *                             CFBD_OLEDDriverType_IIC,\n *                             &amp;i2c_params,\n *                             CFBD_TRUE)) {\n *         printf(\"ERROR: Failed to get OLED handle\\n\");\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 2: Open device with error checking\n *     if (!oled.ops-&gt;open(&amp;oled)) {\n *         printf(\"ERROR: Failed to open OLED device\\n\");\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 3: Perform operations with error checking\n *     if (!oled.ops-&gt;clear(&amp;oled)) {\n *         printf(\"ERROR: Failed to clear display\\n\");\n *         oled.ops-&gt;close(&amp;oled);\n *         return CFBD_FALSE;\n *     }\n *\n *     if (!oled.ops-&gt;update(&amp;oled)) {\n *         printf(\"ERROR: Failed to update display\\n\");\n *         oled.ops-&gt;close(&amp;oled);\n *         return CFBD_FALSE;\n *     }\n *\n *     // Step 4: Cleanup\n *     oled.ops-&gt;close(&amp;oled);\n *     return CFBD_TRUE;\n * }\n * @endcode\n *\n * @section Example10_DisplayText Text Display Pattern\n *\n * Example showing how to structure text display operations:\n *\n * @code\n * void example_display_pattern(CFBD_OLED* oled) {\n *     // Get display dimensions\n *     uint16_t width = 128, height = 64;  // Typical SSD1309\n *\n *     // Clear and prepare\n *     oled-&gt;ops-&gt;clear(oled);\n *     oled-&gt;ops-&gt;update(oled);\n *\n *     // Create a pattern (horizontal lines)\n *     for (uint16_t y = 0; y &lt; height; y += 4) {\n *         for (uint16_t x = 0; x &lt; width; x++) {\n *             oled-&gt;ops-&gt;setPixel(oled, x, y);\n *         }\n *     }\n *\n *     // Update display with new pattern\n *     oled-&gt;ops-&gt;update(oled);\n *\n *     // Alternative: update only affected area for efficiency\n *     // oled-&gt;ops-&gt;update_area(oled, 0, 0, width, height);\n * }\n * @endcode\n *\n * @see @ref OLED_UsageGuide for detailed usage documentation\n * @see CFBD_OLED for device structure documentation\n * @see CFBD_OLEDOperations for operation table documentation\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/OLED__Namespace_8md/","title":"OLED_Namespace.md","text":""},{"location":"api/Files/OLED__Namespace_8md/#namespaces","title":"Namespaces","text":"Name CFBD Core Framework Bare Device (CFBD) namespace *. CFBD::OLED OLED display driver subsystem *."},{"location":"api/Files/OLED__Namespace_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @namespace CFBD\n * @brief Core Framework Bare Device (CFBD) namespace\n *\n * @details\n * The CFBD namespace encompasses all core framework types and operations\n * for bare-metal embedded device drivers. This includes display interfaces,\n * communication protocols, and device abstraction layers.\n *\n * The namespace is organized into several submodules:\n * - OLED: Generic OLED display driver subsystem\n * - Device abstraction layers for hardware communication\n * - Type definitions and constants for device control\n */\n\n/**\n * @namespace CFBD::OLED\n * @ingroup OLED\n * @brief OLED display driver subsystem\n *\n * @details\n * The CFBD::OLED namespace contains all OLED-related types, operations,\n * and device drivers. It provides a generic, transport-agnostic interface\n * for controlling OLED displays through various communication backends.\n *\n * Key components:\n * - @ref CFBD_OLED: Main device object\n * - @ref CFBD_OLEDOperations: Virtual operation table\n * - @ref CFBD_OLEDDriverType: Transport type enumeration\n * - Device-specific factories (getSSD1306Specific, getSSD1309Specific)\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/OLED__Usage__Guide_8md/","title":"OLED_Usage_Guide.md","text":""},{"location":"api/Files/OLED__Usage__Guide_8md/#source-code","title":"Source code","text":"<pre><code>/**\n * @page OLED_UsageGuide OLED Driver Usage Guide\n *\n * @tableofcontents\n *\n * @section Overview\n *\n * The OLED subsystem provides a generic, transport-agnostic interface for\n * controlling OLED displays. It supports multiple device types (SSD1306, SSD1309, etc.)\n * and multiple communication backends (I2C, SPI).\n *\n * @section Architecture\n *\n * The OLED driver architecture consists of three main layers:\n *\n * - **Generic OLED Driver**: The top-level interface (`oled.h`) that application\n *   code interacts with. Provides a device-agnostic API for rendering and control.\n *\n * - **Device Drivers**: Device-specific implementations (SSD1306, SSD1309) that\n *   provide device-specific initialization, memory layouts, and communication prefixes.\n *\n * - **Transport Backends**: Transport-specific implementations (I2C, SPI) that\n *   handle the actual hardware communication with the device.\n *\n * @section GettingStarted\n *\n * @subsection Step1_HeaderFiles Include Required Headers\n *\n * ```cpp\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n * ```\n *\n * @subsection Step2_InitializeI2C Initialize I2C Transport\n *\n * Before initializing the OLED device, ensure your I2C interface is properly\n * configured. Prepare the I2C initialization parameters:\n *\n * ```cpp\n * CFBD_OLED_IICInitsParams i2c_config = {\n *     .device_address = SSD1309_DRIVER_ADDRESS,  // 0x78\n *     .i2c_handle = &amp;my_i2c_interface,\n *     .notify_tx_complete = on_i2c_transmit_complete,\n *     .notify_error = on_i2c_error,\n * };\n * ```\n *\n * @subsection Step3_ObtainOLEDHandle Get OLED Device Handle\n *\n * Use `CFBD_GetOLEDHandle()` to create and initialize an OLED device:\n *\n * ```cpp\n * CFBD_OLED oled_device;\n *\n * if (CFBD_GetOLEDHandle(&amp;oled_device,\n *                        CFBD_OLEDDriverType_IIC,\n *                        &amp;i2c_config,\n *                        CFBD_TRUE)) {  // Request immediate initialization\n *     // Device handle created successfully\n * }\n * ```\n *\n * @subsection Step4_EnableDisplay Enable the Display\n *\n * Open/enable the OLED display:\n *\n * ```cpp\n * if (oled_device.ops-&gt;open(&amp;oled_device)) {\n *     // Display is now powered on and ready\n * }\n * ```\n *\n * @section CommonOperations\n *\n * @subsection ClearDisplay Clear the Entire Display\n *\n * ```cpp\n * // Clear all pixels\n * oled_device.ops-&gt;clear(&amp;oled_device);\n *\n * // Push changes to physical display\n * oled_device.ops-&gt;update(&amp;oled_device);\n * ```\n *\n * @subsection DrawPixel Draw Individual Pixels\n *\n * ```cpp\n * // Set pixel at (x=64, y=32) to on\n * CFBD_bool success = oled_device.ops-&gt;setPixel(&amp;oled_device, 64, 32);\n *\n * // Update display to show the pixel\n * oled_device.ops-&gt;update(&amp;oled_device);\n * ```\n *\n * @subsection DrawArea Draw a Block of Data\n *\n * ```cpp\n * // Example: Draw a 16x16 bitmap at position (0, 0)\n * uint8_t bitmap_data[32];  // 16x16 pixels, monochrome format\n *\n * oled_device.ops-&gt;setArea(&amp;oled_device,\n *                          0, 0,           // x, y position\n *                          16, 16,         // width, height\n *                          bitmap_data);   // source data\n *\n * // Update the area on display\n * oled_device.ops-&gt;update_area(&amp;oled_device, 0, 0, 16, 16);\n * ```\n *\n * @subsection QueryDeviceProperties Query Display Properties\n *\n * ```cpp\n * // Query display width\n * uint16_t width = 0;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);\n *\n * // Query display height\n * uint16_t height = 0;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);\n *\n * // Query color support (RGB vs monochrome)\n * CFBD_bool is_rgb = CFBD_FALSE;\n * oled_device.ops-&gt;self_consult(&amp;oled_device, \"rgb\", NULL, &amp;is_rgb);\n *\n * printf(\"Display: %u x %u, Color Mode: %s\\n\",\n *        width, height, is_rgb ? \"RGB\" : \"Monochrome\");\n * ```\n *\n * @subsection CloseDisplay Close/Disable the Display\n *\n * When finished with the display, close it to power off and release resources:\n *\n * ```cpp\n * oled_device.ops-&gt;close(&amp;oled_device);\n * ```\n *\n * @section CompleteExample\n *\n * Here's a complete example demonstrating the OLED driver usage:\n *\n * ```cpp\n * #include \"oled.h\"\n * #include \"driver/backend/oled_iic.h\"\n * #include \"driver/device/ssd1309/ssd1309.h\"\n * #include &lt;stdio.h&gt;\n *\n * void oled_demo(void) {\n *     // Step 1: Setup I2C configuration\n *     CFBD_OLED_IICInitsParams i2c_config = {\n *         .device_address = SSD1309_DRIVER_ADDRESS,\n *         .i2c_handle = get_i2c_interface(),\n *     };\n *\n *     // Step 2: Get OLED device handle\n *     CFBD_OLED oled_device;\n *     if (!CFBD_GetOLEDHandle(&amp;oled_device,\n *                             CFBD_OLEDDriverType_IIC,\n *                             &amp;i2c_config,\n *                             CFBD_TRUE)) {\n *         printf(\"Failed to initialize OLED device\\n\");\n *         return;\n *     }\n *\n *     // Step 3: Open the display\n *     if (!oled_device.ops-&gt;open(&amp;oled_device)) {\n *         printf(\"Failed to open OLED device\\n\");\n *         return;\n *     }\n *\n *     // Step 4: Query and display device information\n *     uint16_t width = 0, height = 0;\n *     oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);\n *     oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);\n *     printf(\"OLED Display: %u x %u pixels\\n\", width, height);\n *\n *     // Step 5: Clear the display\n *     oled_device.ops-&gt;clear(&amp;oled_device);\n *     oled_device.ops-&gt;update(&amp;oled_device);\n *\n *     // Step 6: Draw some pixels\n *     for (uint16_t x = 0; x &lt; width; x += 2) {\n *         oled_device.ops-&gt;setPixel(&amp;oled_device, x, 10);\n *     }\n *     oled_device.ops-&gt;update(&amp;oled_device);\n *\n *     // Step 7: Close the display\n *     oled_device.ops-&gt;close(&amp;oled_device);\n * }\n * ```\n *\n * @section SupportedDevices\n *\n * Currently supported OLED controller chips:\n * - **SSD1306**: Common monochrome controller, 128x64 resolution typical\n * - **SSD1309**: Enhanced version with improved contrast and timing control\n *\n * @section SupportedTransports\n *\n * Available transport backends:\n * - **I2C (IIC)**: Two-wire interface, default at 0x78 for SSD1309\n * - **SPI**: High-speed serial interface (implementation available)\n *\n * @section ErrorHandling\n *\n * Most operations return `CFBD_bool` (TRUE/FALSE) to indicate success or failure.\n * Common error conditions:\n * - Invalid device address\n * - I2C communication errors\n * - Device not initialized or opened\n * - Out-of-bounds coordinate access\n *\n * Always check return values before proceeding with display operations.\n *\n * @section Performance Considerations\n *\n * - **Full frame updates**: Use `update()` for complete display refresh\n * - **Partial updates**: Use `update_area()` for better performance when\n *   updating only specific regions\n * - **Buffering**: The driver maintains a local frame buffer; changes are\n *   not visible on the display until `update()` or `update_area()` is called\n *\n * @section Troubleshooting\n *\n * **Display not responding**: Verify I2C address and electrical connections\n *\n * **Garbled display**: Check frame buffer data format and pixel ordering\n *\n * **Slow updates**: Consider using area-based updates instead of full updates\n *\n * @section References\n *\n * - @ref OLED Main OLED driver module\n * - @ref OLED_Device Device interface documentation\n * - @ref OLED_Backend Backend transport implementations\n *\n */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ah__no_8h/","title":"lib/config/ah_no.h","text":"<p>Emergency halt helper used when unrecoverable errors occur.  More...</p>"},{"location":"api/Files/ah__no_8h/#detailed-description","title":"Detailed Description","text":"<p>Emergency halt helper used when unrecoverable errors occur. </p> <p>Provides a tiny, platform-agnostic panic/halt routine intended for fatal error paths where recovery is not possible. The function is implemented as an infinite loop to halt program execution. On many embedded targets a debugger or watchdog will be used to recover from this state; platform-specific implementations may extend this function to signal error LEDs, log information, or trigger a reset.</p> <p>Use with caution \u2014 this function does not return. </p>"},{"location":"api/Files/ah__no_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nstatic inline void CFBD_AH_NO(void)\n{\n    while (1)\n        ;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/animation_8c/","title":"lib/graphic/widget/animation/animation.c","text":""},{"location":"api/Files/animation_8c/#source-code","title":"Source code","text":"<pre><code>#include \"animation.h\"\n\n#include \"animation_config.h\"\n\nvoid CFBD_InitBaseAnimation(CFBD_BaseAnimation* pBaseAnimation)\n{\n    pBaseAnimation-&gt;anim_frame_delay_ms = CFBD_BASEANIMATION_DELAY_MS;\n    pBaseAnimation-&gt;anim_frames = CFBD_BASEANIMATION_FRAME_CNT;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/animation__config_8h/","title":"animation_config.h","text":"<p>Configuration parameters for the animation framework.  More...</p>"},{"location":"api/Files/animation__config_8h/#defines","title":"Defines","text":"Name CFBD_BASEANIMATION_FRAME_CNT Default number of frames for base animations. CFBD_BASEANIMATION_DELAY_MS Default delay per animation frame in milliseconds."},{"location":"api/Files/animation__config_8h/#detailed-description","title":"Detailed Description","text":"<p>Configuration parameters for the animation framework. </p> <p>See: </p> <ul> <li>[animation.h]for the animation framework </li> <li>CFBD_BaseAnimationfor animation structure </li> </ul> <p>This header defines compile-time configuration for animation behavior. Adjust these values to tune animation characteristics and visual smoothness for your application.</p>"},{"location":"api/Files/animation__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_frame_cnt","title":"define CFBD_BASEANIMATION_FRAME_CNT","text":"<pre><code>#define CFBD_BASEANIMATION_FRAME_CNT (8)\n</code></pre> <p>Default number of frames for base animations. </p> <p>See: CFBD_InitBaseAnimation()for animation initialization</p> <p>Note: Individual animations can override this value after initialization. </p> <p>The default frame count for newly created animations. Typical values:</p> <ul> <li>4-8: Fast transitions (UI feedback)</li> <li>8-16: Smooth animations (visual effects)</li> <li>16-32: Slow, cinematic transitions</li> </ul>"},{"location":"api/Files/animation__config_8h/#define-cfbd_baseanimation_delay_ms","title":"define CFBD_BASEANIMATION_DELAY_MS","text":"<pre><code>#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre> <p>Default delay per animation frame in milliseconds. </p> <p>Note: Individual animations can override this value after initialization. </p> <p>Time between animation frames in the default configuration.</p> <ul> <li>0: No delay (frame timing handled externally)</li> <li>16: ~60 FPS animation speed</li> <li>33: ~30 FPS animation speed</li> <li>50-100: Slower transitions</li> </ul> <p>Actual animation duration = frame_count * delay_per_frame</p>"},{"location":"api/Files/animation__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_BASEANIMATION_FRAME_CNT (8)\n\n#define CFBD_BASEANIMATION_DELAY_MS (0)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/app_8c/","title":"lib/application/app.c","text":""},{"location":"api/Files/app_8c/#functions","title":"Functions","text":"Name void _private_init_app()"},{"location":"api/Files/app_8c/#attributes","title":"Attributes","text":"Name CFBDApplication _app"},{"location":"api/Files/app_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/app_8c/#function-_private_init_app","title":"function _private_init_app","text":"<pre><code>static inline void _private_init_app()\n</code></pre>"},{"location":"api/Files/app_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/app_8c/#variable-_app","title":"variable _app","text":"<pre><code>static CFBDApplication _app;\n</code></pre>"},{"location":"api/Files/app_8c/#source-code","title":"Source code","text":"<pre><code>#include \"app.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"ah_no.h\"\n#include \"cfbd_define.h\"\n\nstatic CFBDApplication _app;\n\nstatic inline void _private_init_app()\n{\n    CFBDBootTuple* pBootTuple = CFBD_AppBootMaker();\n    _app.bootargs = pBootTuple ? pBootTuple-&gt;args : NULL;\n    _app.selfBootFunc = pBootTuple ? pBootTuple-&gt;boot_func : NULL;\n    _app.freq_provider = CFBD_AppClockProvider();\n    _app.tick_provider = CFBD_AppTickProvider();\n    if (!_app.freq_provider) {\n        CFBD_AH_NO();\n    }\n}\n\nCFBDApplication* getApp(CFBD_Bool request_autoboot)\n{\n    _private_init_app();\n\n    if (request_autoboot) {\n        _app.selfBootFunc(_app.bootargs);\n    }\n\n    return &amp;_app;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/app_8h/","title":"lib/application/app.h","text":"<p>Application descriptor and clock/boot provider interfaces.  More...</p>"},{"location":"api/Files/app_8h/#classes","title":"Classes","text":"Name struct __CFBDApplication Application descriptor."},{"location":"api/Files/app_8h/#detailed-description","title":"Detailed Description","text":"<p>Application descriptor and clock/boot provider interfaces. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-10 </p> <p>This header defines the <code>CFBDApplication</code> structure which aggregates application-specific bootstrap and clock provider hooks used by the framework. It also declares helper functions to obtain the global application's boot table and clock/tick providers.</p> <p>Implementations in the application layer should provide matching definitions for the providers declared here. Keep these interfaces small to allow linking a minimal runtime for constrained targets.</p>"},{"location":"api/Files/app_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"sys_boot/boot.h\"\n\ntypedef uint32_t (*CFBD_ClockFreqProvider)(void);\n\ntypedef uint32_t (*CFBD_ClockTickProvider)(void);\n\ntypedef struct __CFBDApplication\n{\n    CFBD_BootStrapFunc selfBootFunc;\n\n    CFBD_BootArgs bootargs;\n\n    CFBD_ClockFreqProvider freq_provider;\n\n    CFBD_ClockTickProvider tick_provider;\n} CFBDApplication;\n\nextern CFBDBootTuple* CFBD_AppBootMaker(void);\n\nextern CFBD_ClockFreqProvider CFBD_AppClockProvider(void);\n\nextern CFBD_ClockTickProvider CFBD_AppTickProvider(void);\n\nCFBDApplication* getApp(CFBD_Bool request_auto_boot);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/arc_8c/","title":"lib/graphic/base/arc.c","text":""},{"location":"api/Files/arc_8c/#functions","title":"Functions","text":"Name CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end) void clearArea(CFBD_GraphicDevice * device, CFBD_GraphicArc * arc) void updateArea(CFBD_GraphicDevice * device, CFBD_GraphicArc * arc) void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CFBD_GraphicArc * arc) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CFBD_GraphicArc * arc)"},{"location":"api/Files/arc_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) DRAW_IF_IN(offsetx, offsety)"},{"location":"api/Files/arc_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8c/#function-__pvt_is_in_angle","title":"function __pvt_is_in_angle","text":"<pre><code>static CFBD_Bool __pvt_is_in_angle(\n    int16_t x,\n    int16_t y,\n    int16_t start,\n    int16_t end\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cleararea","title":"function clearArea","text":"<pre><code>static void clearArea(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-updatearea","title":"function updateArea","text":"<pre><code>static void updateArea(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * arc\n)\n</code></pre>"},{"location":"api/Files/arc_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/arc_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#define-draw_if_in","title":"define DRAW_IF_IN","text":"<pre><code>#define DRAW_IF_IN(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/arc_8c/#source-code","title":"Source code","text":"<pre><code>#include \"arc.h\"\n\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n\nstatic CFBD_Bool __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end)\n{\n    int16_t point_angle = (atan2(y, x) / 3.14 * 180);\n    return start &lt; end ? (start &lt; point_angle &amp;&amp; point_angle &lt; end)\n                       : (start &gt; point_angle || point_angle &gt; end);\n}\n\nstatic void clearArea(CFBD_GraphicDevice* device, CFBD_GraphicArc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void updateArea(CFBD_GraphicDevice* device, CFBD_GraphicArc* arc)\n{\n    int32_t cx = asInt32_t(arc-&gt;center.x);\n    int32_t cy = asInt32_t(arc-&gt;center.y);\n    int32_t r = arc-&gt;radius;\n\n    int32_t lx = cx - r;\n    int32_t ty = cy - r;\n    int32_t rx = cx + r;\n    int32_t by = cy + r;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = arc-&gt;center.x + (offsetx);                                                           \\\n        __y = arc-&gt;center.y + (offsety);                                                           \\\n        setPixel(device, __x, __y);                                                                \\\n    } while (0)\n\n#define DRAW_IF_IN(offsetx, offsety)                                                               \\\n    do {                                                                                           \\\n        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle)) {                     \\\n            DRAW_OFFSET_POINT(offsetx, offsety);                                                   \\\n        }                                                                                          \\\n    } while (0)\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* arc)\n{\n    PREANNOUNCE;\n    clearArea(device, arc);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* arc)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            device-&gt;ops-&gt;setPixel;\n    /*\u6b64\u51fd\u6570\u501f\u7528Bresenham\u7b97\u6cd5\u753b\u5706\u7684\u65b9\u6cd5*/\n    int16_t x = 0;\n    int16_t y = arc-&gt;radius;\n    int16_t d = 1 - y;\n    clearArea(device, arc);\n    const int16_t start_angle = arc-&gt;start_degree;\n    const int16_t end_angle = arc-&gt;end_degree;\n    __x = x;\n    __y = y;\n\n    /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n    DRAW_IF_IN(x, y);\n    DRAW_IF_IN(-x, -y);\n    DRAW_IF_IN(y, x);\n    DRAW_IF_IN(-y, -x);\n\n    /*\u904d\u5386\u8d77\u59cb\u70b9Y\u5750\u6807*/\n    for (int16_t j = -y; j &lt; y; j++) {\n        /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(0, j);\n    }\n\n    while (x &lt; y) // \u904d\u5386X\u8f74\u7684\u6bcf\u4e2a\u70b9\n    {\n        x++;\n        if (d &lt; 0) // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u65b9\n        {\n            d += 2 * x + 1;\n        }\n        else // \u4e0b\u4e00\u4e2a\u70b9\u5728\u5f53\u524d\u70b9\u4e1c\u5357\u65b9\n        {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n\n        /*\u5728\u753b\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n        DRAW_IF_IN(x, y);\n        DRAW_IF_IN(y, x);\n        DRAW_IF_IN(-x, -y);\n        DRAW_IF_IN(-y, -x);\n        DRAW_IF_IN(x, -y);\n        DRAW_IF_IN(y, -x);\n        DRAW_IF_IN(-x, y);\n        DRAW_IF_IN(-y, x);\n\n        /*\u904d\u5386\u4e2d\u95f4\u90e8\u5206*/\n        for (int16_t j = -y; j &lt; y; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(x, j);\n            DRAW_IF_IN(-x, j);\n        }\n\n        /*\u904d\u5386\u4e24\u4fa7\u90e8\u5206*/\n        for (int16_t j = -x; j &lt; x; j++) {\n            /*\u5728\u586b\u5145\u5706\u7684\u6bcf\u4e2a\u70b9\u65f6\uff0c\u5224\u65ad\u6307\u5b9a\u70b9\u662f\u5426\u5728\u6307\u5b9a\u89d2\u5ea6\u5185\uff0c\u5728\uff0c\u5219\u753b\u70b9\uff0c\u4e0d\u5728\uff0c\u5219\u4e0d\u505a\u5904\u7406*/\n            DRAW_IF_IN(y, j);\n            DRAW_IF_IN(-y, j);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device) &amp;&amp; device-&gt;ops-&gt;update_area) {\n        updateArea(device, arc);\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef DRAW_IF_IN\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/arc_8h/","title":"lib/graphic/base/arc.h","text":"<p>Arc geometry and drawing prototypes for the graphics subsystem.  More...</p>"},{"location":"api/Files/arc_8h/#classes","title":"Classes","text":"Name struct __CFBD_GraphicArc"},{"location":"api/Files/arc_8h/#types","title":"Types","text":"Name typedef struct __CFBD_GraphicArc CFBD_GraphicArc"},{"location":"api/Files/arc_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawArc(CFBD_GraphicDevice * device, CFBD_GraphicArc * circle) void CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice * device, CFBD_GraphicArc * circle)"},{"location":"api/Files/arc_8h/#detailed-description","title":"Detailed Description","text":"<p>Arc geometry and drawing prototypes for the graphics subsystem. </p> <p>Author: Charliechen114514 </p>"},{"location":"api/Files/arc_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/arc_8h/#typedef-cfbd_graphicarc","title":"typedef CFBD_GraphicArc","text":"<pre><code>typedef struct __CFBD_GraphicArc CFBD_GraphicArc;\n</code></pre>"},{"location":"api/Files/arc_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawarc","title":"function CFBDGraphic_DrawArc","text":"<pre><code>void CFBDGraphic_DrawArc(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#function-cfbdgraphic_drawfilledarc","title":"function CFBDGraphic_DrawFilledArc","text":"<pre><code>void CFBDGraphic_DrawFilledArc(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicArc * circle\n)\n</code></pre>"},{"location":"api/Files/arc_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\n\ntypedef struct __CFBD_GraphicArc\n{\n    CFBDGraphic_Point center;\n\n    PointBaseType radius;\n\n    int16_t start_degree;\n\n    int16_t end_degree;\n} CFBD_GraphicArc;\n\nvoid CFBDGraphic_DrawArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* circle);\n\nvoid CFBDGraphic_DrawFilledArc(CFBD_GraphicDevice* device, CFBD_GraphicArc* circle);\n\n // End of Arc_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ascii6x8_8source_8c/","title":"lib/graphic/resource/default/ascii6x8.source.c","text":""},{"location":"api/Files/ascii6x8_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  6x8 OLED display using 6x8 pixel font representation.\n//  Each character in this font set is defined by an \n//  6x8 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii6x8_sources[][6];\n// ---------------------------------------------\n#if ENABLE_ASCII_6x8_SOURCES\nconst uint8_t ascii6x8_sources[][6] = \n{\n    {0x00,0x00,0x00,0x00,0x00,0x00}, // 0\n    {0x00,0x00,0x00,0x2F,0x00,0x00}, // ! 1\n    {0x00,0x00,0x07,0x00,0x07,0x00}, // \" 2\n    {0x00,0x14,0x7F,0x14,0x7F,0x14}, // # 3\n    {0x00,0x24,0x2A,0x7F,0x2A,0x12}, // $ 4\n    {0x00,0x23,0x13,0x08,0x64,0x62}, // % 5\n    {0x00,0x36,0x49,0x55,0x22,0x50}, // &amp; 6\n    {0x00,0x00,0x00,0x07,0x00,0x00}, // ' 7\n    {0x00,0x00,0x1C,0x22,0x41,0x00}, // ( 8\n    {0x00,0x00,0x41,0x22,0x1C,0x00}, // ) 9\n    {0x00,0x14,0x08,0x3E,0x08,0x14}, // * 10\n    {0x00,0x08,0x08,0x3E,0x08,0x08}, // + 11\n    {0x00,0x00,0x00,0xA0,0x60,0x00}, // , 12\n    {0x00,0x08,0x08,0x08,0x08,0x08}, // - 13\n    {0x00,0x00,0x60,0x60,0x00,0x00}, // . 14\n    {0x00,0x20,0x10,0x08,0x04,0x02}, // / 15\n    {0x00,0x3E,0x51,0x49,0x45,0x3E}, // 0 16\n    {0x00,0x00,0x42,0x7F,0x40,0x00}, // 1 17\n    {0x00,0x42,0x61,0x51,0x49,0x46}, // 2 18\n    {0x00,0x21,0x41,0x45,0x4B,0x31}, // 3 19\n    {0x00,0x18,0x14,0x12,0x7F,0x10}, // 4 20\n    {0x00,0x27,0x45,0x45,0x45,0x39}, // 5 21\n    {0x00,0x3C,0x4A,0x49,0x49,0x30}, // 6 22\n    {0x00,0x01,0x71,0x09,0x05,0x03}, // 7 23\n    {0x00,0x36,0x49,0x49,0x49,0x36}, // 8 24\n    {0x00,0x06,0x49,0x49,0x29,0x1E}, // 9 25\n    {0x00,0x00,0x36,0x36,0x00,0x00}, // : 26\n    {0x00,0x00,0x56,0x36,0x00,0x00}, // ; 27\n    {0x00,0x08,0x14,0x22,0x41,0x00}, // &lt; 28\n    {0x00,0x14,0x14,0x14,0x14,0x14}, // = 29\n    {0x00,0x00,0x41,0x22,0x14,0x08}, // &gt; 30\n    {0x00,0x02,0x01,0x51,0x09,0x06}, // ? 31\n    {0x00,0x3E,0x49,0x55,0x59,0x2E}, // @ 32\n    {0x00,0x7C,0x12,0x11,0x12,0x7C}, // A 33\n    {0x00,0x7F,0x49,0x49,0x49,0x36}, // B 34\n    {0x00,0x3E,0x41,0x41,0x41,0x22}, // C 35\n    {0x00,0x7F,0x41,0x41,0x22,0x1C}, // D 36\n    {0x00,0x7F,0x49,0x49,0x49,0x41}, // E 37\n    {0x00,0x7F,0x09,0x09,0x09,0x01}, // F 38\n    {0x00,0x3E,0x41,0x49,0x49,0x7A}, // G 39\n    {0x00,0x7F,0x08,0x08,0x08,0x7F}, // H 40\n    {0x00,0x00,0x41,0x7F,0x41,0x00}, // I 41\n    {0x00,0x20,0x40,0x41,0x3F,0x01}, // J 42\n    {0x00,0x7F,0x08,0x14,0x22,0x41}, // K 43\n    {0x00,0x7F,0x40,0x40,0x40,0x40}, // L 44\n    {0x00,0x7F,0x02,0x0C,0x02,0x7F}, // M 45\n    {0x00,0x7F,0x04,0x08,0x10,0x7F}, // N 46\n    {0x00,0x3E,0x41,0x41,0x41,0x3E}, // O 47\n    {0x00,0x7F,0x09,0x09,0x09,0x06}, // P 48\n    {0x00,0x3E,0x41,0x51,0x21,0x5E}, // Q 49\n    {0x00,0x7F,0x09,0x19,0x29,0x46}, // R 50\n    {0x00,0x46,0x49,0x49,0x49,0x31}, // S 51\n    {0x00,0x01,0x01,0x7F,0x01,0x01}, // T 52\n    {0x00,0x3F,0x40,0x40,0x40,0x3F}, // U 53\n    {0x00,0x1F,0x20,0x40,0x20,0x1F}, // V 54\n    {0x00,0x3F,0x40,0x38,0x40,0x3F}, // W 55\n    {0x00,0x63,0x14,0x08,0x14,0x63}, // X 56\n    {0x00,0x07,0x08,0x70,0x08,0x07}, // Y 57\n    {0x00,0x61,0x51,0x49,0x45,0x43}, // Z 58\n    {0x00,0x00,0x7F,0x41,0x41,0x00}, // [ 59\n    {0x00,0x02,0x04,0x08,0x10,0x20}, // \\ 60\n    {0x00,0x00,0x41,0x41,0x7F,0x00}, // ] 61\n    {0x00,0x04,0x02,0x01,0x02,0x04}, // ^ 62\n    {0x00,0x40,0x40,0x40,0x40,0x40}, // _ 63\n    {0x00,0x00,0x01,0x02,0x04,0x00}, // ` 64\n    {0x00,0x20,0x54,0x54,0x54,0x78}, // a 65\n    {0x00,0x7F,0x48,0x44,0x44,0x38}, // b 66\n    {0x00,0x38,0x44,0x44,0x44,0x20}, // c 67\n    {0x00,0x38,0x44,0x44,0x48,0x7F}, // d 68\n    {0x00,0x38,0x54,0x54,0x54,0x18}, // e 69\n    {0x00,0x08,0x7E,0x09,0x01,0x02}, // f 70\n    {0x00,0x18,0xA4,0xA4,0xA4,0x7C}, // g 71\n    {0x00,0x7F,0x08,0x04,0x04,0x78}, // h 72\n    {0x00,0x00,0x44,0x7D,0x40,0x00}, // i 73\n    {0x00,0x40,0x80,0x84,0x7D,0x00}, // j 74\n    {0x00,0x7F,0x10,0x28,0x44,0x00}, // k 75\n    {0x00,0x00,0x41,0x7F,0x40,0x00}, // l 76\n    {0x00,0x7C,0x04,0x18,0x04,0x78}, // m 77\n    {0x00,0x7C,0x08,0x04,0x04,0x78}, // n 78\n    {0x00,0x38,0x44,0x44,0x44,0x38}, // o 79\n    {0x00,0xFC,0x24,0x24,0x24,0x18}, // p 80\n    {0x00,0x18,0x24,0x24,0x18,0xFC}, // q 81\n    {0x00,0x7C,0x08,0x04,0x04,0x08}, // r 82\n    {0x00,0x48,0x54,0x54,0x54,0x20}, // s 83\n    {0x00,0x04,0x3F,0x44,0x40,0x20}, // t 84\n    {0x00,0x3C,0x40,0x40,0x20,0x7C}, // u 85\n    {0x00,0x1C,0x20,0x40,0x20,0x1C}, // v 86\n    {0x00,0x3C,0x40,0x30,0x40,0x3C}, // w 87\n    {0x00,0x44,0x28,0x10,0x28,0x44}, // x 88\n    {0x00,0x1C,0xA0,0xA0,0xA0,0x7C}, // y 89\n    {0x00,0x44,0x64,0x54,0x4C,0x44}, // z 90\n    {0x00,0x00,0x08,0x7F,0x41,0x00}, // { 91\n    {0x00,0x00,0x00,0x7F,0x00,0x00}, // | 92\n    {0x00,0x00,0x41,0x7F,0x08,0x00}, // } 93\n    {0x00,0x08,0x04,0x08,0x10,0x08}, // ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ascii8x16_8source_8c/","title":"lib/graphic/resource/default/ascii8x16.source.c","text":""},{"location":"api/Files/ascii8x16_8source_8c/#source-code","title":"Source code","text":"<pre><code>#include \"resource/config.h\"\n#include &lt;stdint.h&gt;\n\n//  This is an array of font data for a \n//  8x16 OLED display using 8x16 pixel font representation.\n//  Each character in this font set is defined by an \n//  8x16 pixel matrix (8 pixels wide, 16 pixels high).\n\n/* \n    sources should be externed copy this for \n    the usage in application level\n*/\n\n// ---------------------------------------------\n// extern const uint8_t ascii8x16_sources[][16];\n// ---------------------------------------------\n#if ENABLE_ASCII_8x16_SOURCES\nconst uint8_t ascii8x16_sources[][16] =\n{\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//   0\n    {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},// ! 1\n    {0x00,0x16,0x0E,0x00,0x16,0x0E,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// \" 2\n    {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,\n    0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},// # 3\n    {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,\n    0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},// $ 4\n    {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,\n    0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},// % 5\n    {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,\n    0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},// &amp; 6\n    {0x00,0x00,0x00,0x16,0x0E,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ' 7\n    {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,\n    0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},// ( 8\n    {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,\n    0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},// ) 9\n    {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,\n    0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},// * 10\n    {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,\n    0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},// + 11\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},// , 12\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},// - 13\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},// . 14\n    {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,\n    0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},// / 15\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},// 0 16\n    {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// 1 17\n    {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},// 2 18\n    {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,\n    0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},// 3 19\n    {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,\n    0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},// 4 20\n    {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,\n    0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},// 5 21\n    {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,\n    0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},// 6 22\n    {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},// 7 23\n    {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,\n    0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},// 8 24\n    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,\n    0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},// 9 25\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},// : 26\n    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,\n    0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00},// ; 27\n    {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,\n    0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},// &lt; 28\n    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,\n    0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},// = 29\n    {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,\n    0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},// &gt; 30\n    {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,\n    0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},// ? 31\n    {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,\n    0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},// @ 32\n    {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,\n    0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},// A 33\n    {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},// B 34\n    {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,\n    0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},// C 35\n    {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},// D 36\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},// E 37\n    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},// F 38\n    {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,\n    0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},// G 39\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},// H 40\n    {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// I 41\n    {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,\n    0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},// J 42\n    {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,\n    0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},// K 43\n    {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,\n    0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},// L 44\n    {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,\n    0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},// M 45\n    {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,\n    0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},// N 46\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},// O 47\n    {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,\n    0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},// P 48\n    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,\n    0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},// Q 49\n    {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,\n    0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},// R 50\n    {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,\n    0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},// S 51\n    {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// T 52\n    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// U 53\n    {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,\n    0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},// V 54\n    {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,\n    0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},// W 55\n    {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,\n    0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},// X 56\n    {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,\n    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},// Y 57\n    {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,\n    0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},// Z 58\n    {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,\n    0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},// [ 59\n    {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},// \\ 60\n    {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},// ] 61\n    {0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ^ 62\n    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},// _ 63\n    {0x00,0x02,0x04,0x08,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// ` 64\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},// a 65\n    {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},// b 66\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},// c 67\n    {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},// d 68\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},// e 69\n    {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// f 70\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},// g 71\n    {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,\n    0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},// h 72\n    {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// i 73\n    {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,\n    0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},// j 74\n    {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},// k 75\n    {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,\n    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},// l 76\n    {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},// m 77\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x00,0x00,\n    0x00,0x20,0x3F,0x21,0x00,0x20,0x3F,0x20},// n 78\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},// o 79\n    {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,\n    0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},// p 80\n    {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},// q 81\n    {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},// r 82\n    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},// s 83\n    {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,\n    0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},// t 84\n    {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,\n    0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},// u 85\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},// v 86\n    {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,\n    0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},// w 87\n    {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,\n    0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},// x 88\n    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,\n    0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},// y 89\n    {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,\n    0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},// z 90\n    {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,\n    0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},// { 91\n    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},// | 92\n    {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,\n    0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},// } 93\n    {0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x80,\n    0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00},// ~ 94\n};\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/benchmark_8c/","title":"lib/graphic/benchmark/benchmark.c","text":""},{"location":"api/Files/benchmark_8c/#functions","title":"Functions","text":"Name void test_fps_benchmark(CFBD_GraphicDevice * handler) void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8c/#function-test_fps_benchmark","title":"function test_fps_benchmark","text":"<pre><code>static void test_fps_benchmark(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"config/system_settings.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\n// FPS\u6027\u80fd\u6d4b\u8bd5 - \u5728OLED\u5c4f\u5e55\u4e0a\u663e\u793a\u5237\u65b0\u7387\nstatic void test_fps_benchmark(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n\n    CFBDGraphic_Text fps_text;\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;fps_text, p, screen_size, ASCII_8x16);\n\n    uint32_t frame_count = 0;\n    uint32_t last_time = HAL_GetTick();\n\n    uint32_t fps_x10 = 0;\n    char buffer[64];\n\n    uint32_t test_start = HAL_GetTick();\n    uint32_t test_duration = 30000;\n\n    while ((HAL_GetTick() - test_start) &lt; test_duration) {\n        // CFBDGraphic_DeviceClearImmediate(handler);\n\n        frame_count++;\n        uint32_t current_time = HAL_GetTick();\n        uint32_t elapsed = current_time - last_time;\n\n        // \u6bcf 500ms \u66f4\u65b0\u4e00\u6b21 FPS\n        if (elapsed &gt;= 500) {\n            // fps_x10 = frame_count * 1000 * 10 / elapsed\n            fps_x10 = (frame_count * 10000U) / elapsed;\n\n            frame_count = 0;\n            last_time = current_time;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"FPS: %lu.%lu \"\n                 \"Time: %lus\",\n                 fps_x10 / 10,\n                 fps_x10 % 10,\n                 (HAL_GetTick() - test_start) / 1000);\n        // CFBDGraphic_DeviceClearImmediate(handler);\n        CFBDGraphic_SetText(&amp;fps_text, buffer);\n        CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    CFBDGraphic_DeviceClearImmediate(handler);\n    snprintf(buffer,\n             sizeof(buffer),\n             \"Test Complete! \"\n             \"Final FPS: %lu.%lu\",\n             fps_x10 / 10,\n             fps_x10 % 10);\n\n    CFBDGraphic_SetText(&amp;fps_text, buffer);\n    CFBDGraphic_DrawText(handler, &amp;fps_text, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nvoid test_fps(CFBD_GraphicDevice* handler)\n{\n    test_fps_benchmark(handler);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/benchmark_8h/","title":"lib/graphic/benchmark/benchmark.h","text":""},{"location":"api/Files/benchmark_8h/#functions","title":"Functions","text":"Name void test_fps(CFBD_GraphicDevice * handler)"},{"location":"api/Files/benchmark_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/benchmark_8h/#function-test_fps","title":"function test_fps","text":"<pre><code>void test_fps(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/benchmark_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_fps(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/boot_8c/","title":"lib/application/sys_boot/boot.c","text":""},{"location":"api/Files/boot_8c/#source-code","title":"Source code","text":"<pre><code>#include \"boot.h\"\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/boot_8h/","title":"lib/application/sys_boot/boot.h","text":"<p>Boot / startup helpers and types for application bootstrap sequence.  More...</p>"},{"location":"api/Files/boot_8h/#classes","title":"Classes","text":"Name struct CFBDBootTuple"},{"location":"api/Files/boot_8h/#detailed-description","title":"Detailed Description","text":"<p>Boot / startup helpers and types for application bootstrap sequence. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>This header declares the lightweight types used by the application's bootstrap sequence. It provides a generic argument container type (<code>CFBD_BootArgs</code>), a function-pointer type for bootstrap entry points (<code>CFBD_BootStrapFunc</code>) and a small tuple type (<code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code>) that associates an entry function with its arguments.</p> <p>The design aims to be minimal and portable across platforms used in this repository. Implementations of bootstrap functions should adhere to the contract documented for <code>CFBD_BootStrapFunc</code>. </p>"},{"location":"api/Files/boot_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef void* CFBD_BootArgs;\n\ntypedef CFBD_Bool (*CFBD_BootStrapFunc)(CFBD_BootArgs args);\n\ntypedef struct\n{\n    CFBD_BootStrapFunc boot_func;\n\n    CFBD_BootArgs args;\n} CFBDBootTuple;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cache__config-ssd130x_8h/","title":"lib/oled/configs/cache_config-ssd130x.h","text":""},{"location":"api/Files/cache__config-ssd130x_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CACHED_HEIGHT (8)\n\n#define CACHED_WIDTH (144)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cache__config-ssd132x_8h/","title":"lib/oled/configs/cache_config-ssd132x.h","text":""},{"location":"api/Files/cache__config-ssd132x_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CACHED_HEIGHT (96)\n\n#define CACHED_WIDTH (64)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cfbd__define_8h/","title":"lib/config/cfbd_define.h","text":"<p>Core type and macro definitions used across CFBD libraries.  More...</p>"},{"location":"api/Files/cfbd__define_8h/#detailed-description","title":"Detailed Description","text":"<p>Core type and macro definitions used across CFBD libraries. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-01 </p> <p>This header centralizes small, portable typedefs and helper macros used by the CFBD (CF BareMetal Drivers) project. It intentionally contains only minimal, dependency-free declarations so it can be included widely in both platform and application code.</p> <p>The types defined here are lightweight building blocks such as a boolean type and common function-pointer signatures used for component initialization or simple callbacks.</p>"},{"location":"api/Files/cfbd__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\ntypedef uint8_t CFBD_Bool;\n\n#define CFBD_FALSE (0)\n\n#define CFBD_TRUE (1)\n\ntypedef CFBD_Bool (*SelfInitFunc)(void* self_handle, void* args);\n\ntypedef void (*PlainFunc)(void* args);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cfbd__graphic__define_8h/","title":"lib/graphic/cfbd_graphic_define.h","text":"<p>Core graphics type definitions and forward declarations.  More...</p>"},{"location":"api/Files/cfbd__graphic__define_8h/#detailed-description","title":"Detailed Description","text":"<p>Core graphics type definitions and forward declarations. </p> <p>Provides fundamental type aliases and forward declarations used throughout the graphics system, establishing the foundation for point, size, and device abstractions. </p>"},{"location":"api/Files/cfbd__graphic__define_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef uint16_t PointBaseType;\n\ntypedef PointBaseType SizeBaseType;\n\ntypedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cfbd__log_8c/","title":"lib/logger/cfbd_log.c","text":"<p>More...</p>"},{"location":"api/Files/cfbd__log_8c/#functions","title":"Functions","text":"Name const char * extract_filename(const char * path) int safe_vsnprintf(char * buffer, size_t size, const char * format, va_list args) void cfbd_log_message_impl(CFBD_Logger * log_handle, cfbd_log_level_t level, const char * tag, const char * file, int line, const char * fmt, ... ) void CFBD_InitLogger(CFBD_Logger * logger, CFBD_NativeLoggerOperations * native_send, void * native_handle, cfbd_log_level_t filter_level, uint8_t * buffer_ptr, uint16_t buffer_sz)"},{"location":"api/Files/cfbd__log_8c/#attributes","title":"Attributes","text":"Name const char *[] level_tags const char *[] level_colors CFBD_LoggerOperations default_logger_ops"},{"location":"api/Files/cfbd__log_8c/#defines","title":"Defines","text":"Name CFBD_LOGF(handle, fmt, ...) COLOR_RESET"},{"location":"api/Files/cfbd__log_8c/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-02-01</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/cfbd__log_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/cfbd__log_8c/#function-extract_filename","title":"function extract_filename","text":"<pre><code>static const char * extract_filename(\n    const char * path\n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#function-safe_vsnprintf","title":"function safe_vsnprintf","text":"<pre><code>static int safe_vsnprintf(\n    char * buffer,\n    size_t size,\n    const char * format,\n    va_list args\n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#function-cfbd_log_message_impl","title":"function cfbd_log_message_impl","text":"<pre><code>static void cfbd_log_message_impl(\n    CFBD_Logger * log_handle,\n    cfbd_log_level_t level,\n    const char * tag,\n    const char * file,\n    int line,\n    const char * fmt,\n    ... \n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#function-cfbd_initlogger","title":"function CFBD_InitLogger","text":"<pre><code>void CFBD_InitLogger(\n    CFBD_Logger * logger,\n    CFBD_NativeLoggerOperations * native_send,\n    void * native_handle,\n    cfbd_log_level_t filter_level,\n    uint8_t * buffer_ptr,\n    uint16_t buffer_sz\n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/cfbd__log_8c/#variable-level_tags","title":"variable level_tags","text":"<pre><code>static const char *[] level_tags = {\n        \"V\", \n        \"D\", \n        \"I\", \n        \"W\", \n        \"E\", \n        \"F\"  \n};\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#variable-level_colors","title":"variable level_colors","text":"<pre><code>static const char *[] level_colors = {\n        \"\\033[37m\", \n        \"\\033[36m\", \n        \"\\033[32m\", \n        \"\\033[33m\", \n        \"\\033[31m\", \n        \"\\033[35m\"  \n};\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#variable-default_logger_ops","title":"variable default_logger_ops","text":"<pre><code>static CFBD_LoggerOperations default_logger_ops = {.log_message = cfbd_log_message_impl};\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/cfbd__log_8c/#define-cfbd_logf","title":"define CFBD_LOGF","text":"<pre><code>#define CFBD_LOGF(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_F(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#define-color_reset","title":"define COLOR_RESET","text":"<pre><code>#define COLOR_RESET \"\\033[0m\"\n</code></pre>"},{"location":"api/Files/cfbd__log_8c/#source-code","title":"Source code","text":"<pre><code>#include \"cfbd_log.h\"\n\n#include &lt;stdarg.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nstatic const char* level_tags[] = {\n        \"V\", // VERBOSE\n        \"D\", // DEBUG\n        \"I\", // INFO\n        \"W\", // WARN\n        \"E\", // ERROR\n        \"F\"  // FATAL\n};\n\nstatic const char* level_colors[] = {\n        \"\\033[37m\", /* VERBOSE - \u767d\u8272 */\n        \"\\033[36m\", /* DEBUG - \u9752\u8272 */\n        \"\\033[32m\", /* INFO - \u7eff\u8272 */\n        \"\\033[33m\", /* WARN - \u9ec4\u8272 */\n        \"\\033[31m\", /* ERROR - \u7ea2\u8272 */\n        \"\\033[35m\"  /* FATAL - \u7d2b\u8272 */\n};\n\n#define COLOR_RESET \"\\033[0m\"\n\nstatic const char* extract_filename(const char* path)\n{\n    if (path == NULL) {\n        return \"\";\n    }\n\n    const char* filename = path;\n    const char* p = path;\n\n    while (*p != '\\0') {\n        if (*p == '/' || *p == '\\\\') {\n            filename = p + 1;\n        }\n        p++;\n    }\n\n    return filename;\n}\n\nstatic int safe_vsnprintf(char* buffer, size_t size, const char* format, va_list args)\n{\n    int ret = vsnprintf(buffer, size, format, args);\n    if (ret &lt; 0) {\n        return 0;\n    }\n    if ((size_t) ret &gt;= size) {\n        return size - 1;\n    }\n    return ret;\n}\n\nstatic void cfbd_log_message_impl(CFBD_Logger* log_handle,\n                                  cfbd_log_level_t level,\n                                  const char* tag,\n                                  const char* file,\n                                  int line,\n                                  const char* fmt,\n                                  ...)\n{\n    if (log_handle == NULL || fmt == NULL) {\n        return;\n    }\n\n    if (level &lt; log_handle-&gt;filter_off_level || level &gt;= CFBD_LOG_LEVEL_NONE) {\n        return;\n    }\n\n    if (log_handle-&gt;native_logs == NULL) {\n        return;\n    }\n\n    /* \u9759\u6001\u7f13\u51b2\u533a\uff08\u53ef\u4ee5\u6539\u4e3a\u52a8\u6001\u5206\u914d\u6216\u4f7f\u7528logger\u81ea\u5e26\u7684\u7f13\u51b2\u533a\uff09 */\n    char* buffer = (char*) log_handle-&gt;buffer_ptr;\n    const uint16_t buffer_length = log_handle-&gt;buffer_sz;\n    uint16_t offset = 0;\n    int written;\n\n    /* \u6dfb\u52a0\u989c\u8272\u4ee3\u7801 */\n    if (log_handle-&gt;enable_colorize &amp;&amp; level &lt; CFBD_LOG_LEVEL_NONE) {\n        written = snprintf(buffer + offset, buffer_length - offset, \"%s\", level_colors[level]);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    /* \u6dfb\u52a0\u65f6\u95f4\u6233 */\n    uint32_t (*timestamp_handle)(void* native_handle) = log_handle-&gt;native_logs-&gt;timestamp;\n    if (timestamp_handle) {\n        uint32_t timestamp = timestamp_handle(log_handle-&gt;native_handle);\n        written = snprintf(buffer + offset,\n                           buffer_length - offset,\n                           \"[%lu] \",\n                           (unsigned long) timestamp);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    /* \u6dfb\u52a0\u65e5\u5fd7\u7ea7\u522b\u6807\u8bc6 */\n    if (level &lt; CFBD_LOG_LEVEL_NONE) {\n        written = snprintf(buffer + offset, buffer_length - offset, \"[%s] \", level_tags[level]);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    /* \u6dfb\u52a0TAG */\n    if (tag != NULL &amp;&amp; tag[0] != '\\0') {\n        written = snprintf(buffer + offset, buffer_length - offset, \"[%s] \", tag);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    if (file != NULL) {\n        const char* filename = extract_filename(file);\n        written = snprintf(buffer + offset, buffer_length - offset, \"(%s:%d) \", filename, line);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    if (offset &lt; buffer_length) {\n        va_list args;\n        va_start(args, fmt);\n        written = safe_vsnprintf(buffer + offset, buffer_length - offset, fmt, args);\n        va_end(args);\n\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    /* \u6dfb\u52a0\u6362\u884c\u7b26 */\n    if (offset &lt; buffer_length - 1) {\n        buffer[offset++] = '\\r';\n        buffer[offset++] = '\\n';\n    }\n\n    /* \u6dfb\u52a0\u989c\u8272\u91cd\u7f6e */\n    if (log_handle-&gt;enable_colorize &amp;&amp; offset &lt; buffer_length - strlen(COLOR_RESET)) {\n        written = snprintf(buffer + offset, buffer_length - offset, \"%s\", COLOR_RESET);\n        if (written &gt; 0 &amp;&amp; offset + written &lt; buffer_length) {\n            offset += written;\n        }\n    }\n\n    if (offset &gt;= buffer_length) {\n        offset = buffer_length - 1;\n    }\n    buffer[offset] = '\\0';\n\n    log_handle-&gt;native_logs-&gt;log_native(log_handle-&gt;native_handle, buffer, offset);\n}\n\nstatic CFBD_LoggerOperations default_logger_ops = {.log_message = cfbd_log_message_impl};\n\nvoid CFBD_InitLogger(CFBD_Logger* logger,\n                     CFBD_NativeLoggerOperations* native_send,\n                     void* native_handle,\n                     cfbd_log_level_t filter_level,\n                     uint8_t* buffer_ptr,\n                     uint16_t buffer_sz)\n{\n    logger-&gt;ops = &amp;default_logger_ops;\n    logger-&gt;native_logs = native_send;\n    logger-&gt;filter_off_level = filter_level;\n\n    logger-&gt;native_handle = native_handle;\n    logger-&gt;buffer_ptr = buffer_ptr;\n    logger-&gt;buffer_sz = buffer_sz;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cfbd__log_8h/","title":"lib/logger/cfbd_log.h","text":""},{"location":"api/Files/cfbd__log_8h/#classes","title":"Classes","text":"Name struct CFBD_LoggerOperations struct CFBD_NativeLoggerOperations struct __CFBD_Logger"},{"location":"api/Files/cfbd__log_8h/#types","title":"Types","text":"Name enum cfbd_log_level_t typedef struct __CFBD_Logger CFBD_Logger"},{"location":"api/Files/cfbd__log_8h/#functions","title":"Functions","text":"Name void CFBD_InitLogger(CFBD_Logger * logger, CFBD_NativeLoggerOperations * native_send, void * native_handle, cfbd_log_level_t filter_level, uint8_t * buffer_ptr, uint16_t buffer_sz) void CFBD_SetFilteredOffLevel(CFBD_Logger * logger, cfbd_log_level_t filter_off_level)"},{"location":"api/Files/cfbd__log_8h/#defines","title":"Defines","text":"Name CFBD_LOG_V(logger_handle, tag, fmt, ...) CFBD_LOG_D(logger_handle, tag, fmt, ...) CFBD_LOG_I(logger_handle, tag, fmt, ...) CFBD_LOG_W(logger_handle, tag, fmt, ...) CFBD_LOG_E(logger_handle, tag, fmt, ...) CFBD_LOG_F(logger_handle, tag, fmt, ...) CFBD_LOGV(handle, fmt, ...) CFBD_LOGD(handle, fmt, ...) CFBD_LOGI(handle, fmt, ...) CFBD_LOGW(handle, fmt, ...) CFBD_LOGE(handle, fmt, ...) CFBD_LOGF(handle, fmt, ...)"},{"location":"api/Files/cfbd__log_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/cfbd__log_8h/#enum-cfbd_log_level_t","title":"enum cfbd_log_level_t","text":"Enumerator Value Description CFBD_LOG_LEVEL_LOWEST -1 CFBD_LOG_LEVEL_VERBOSE 0 CFBD_LOG_LEVEL_DEBUG CFBD_LOG_LEVEL_INFO CFBD_LOG_LEVEL_WARN CFBD_LOG_LEVEL_ERROR CFBD_LOG_LEVEL_FATAL CFBD_LOG_LEVEL_NONE"},{"location":"api/Files/cfbd__log_8h/#typedef-cfbd_logger","title":"typedef CFBD_Logger","text":"<pre><code>typedef struct __CFBD_Logger CFBD_Logger;\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/cfbd__log_8h/#function-cfbd_initlogger","title":"function CFBD_InitLogger","text":"<pre><code>void CFBD_InitLogger(\n    CFBD_Logger * logger,\n    CFBD_NativeLoggerOperations * native_send,\n    void * native_handle,\n    cfbd_log_level_t filter_level,\n    uint8_t * buffer_ptr,\n    uint16_t buffer_sz\n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#function-cfbd_setfilteredofflevel","title":"function CFBD_SetFilteredOffLevel","text":"<pre><code>static inline void CFBD_SetFilteredOffLevel(\n    CFBD_Logger * logger,\n    cfbd_log_level_t filter_off_level\n)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_v","title":"define CFBD_LOG_V","text":"<pre><code>#define CFBD_LOG_V(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_VERBOSE,                                        \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_d","title":"define CFBD_LOG_D","text":"<pre><code>#define CFBD_LOG_D(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_DEBUG,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_i","title":"define CFBD_LOG_I","text":"<pre><code>#define CFBD_LOG_I(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_INFO,                                           \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_w","title":"define CFBD_LOG_W","text":"<pre><code>#define CFBD_LOG_W(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_WARN,                                           \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_e","title":"define CFBD_LOG_E","text":"<pre><code>#define CFBD_LOG_E(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_ERROR,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_log_f","title":"define CFBD_LOG_F","text":"<pre><code>#define CFBD_LOG_F(\n    logger_handle,\n    tag,\n    fmt,\n    ...\n)\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_FATAL,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_logv","title":"define CFBD_LOGV","text":"<pre><code>#define CFBD_LOGV(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_V(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_logd","title":"define CFBD_LOGD","text":"<pre><code>#define CFBD_LOGD(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_D(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_logi","title":"define CFBD_LOGI","text":"<pre><code>#define CFBD_LOGI(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_I(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_logw","title":"define CFBD_LOGW","text":"<pre><code>#define CFBD_LOGW(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_W(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_loge","title":"define CFBD_LOGE","text":"<pre><code>#define CFBD_LOGE(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_E(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#define-cfbd_logf","title":"define CFBD_LOGF","text":"<pre><code>#define CFBD_LOGF(\n    handle,\n    fmt,\n    ...\n)\nCFBD_LOG_F(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"api/Files/cfbd__log_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n\n/*\n * Loggers are Loggers, because they are loggers\n */\n\ntypedef enum\n{\n    CFBD_LOG_LEVEL_LOWEST = -1,\n    CFBD_LOG_LEVEL_VERBOSE = 0, /* \u8be6\u7ec6\u4fe1\u606f */\n    CFBD_LOG_LEVEL_DEBUG,       /* \u8c03\u8bd5\u4fe1\u606f */\n    CFBD_LOG_LEVEL_INFO,        /* \u4e00\u822c\u4fe1\u606f */\n    CFBD_LOG_LEVEL_WARN,        /* \u8b66\u544a\u4fe1\u606f */\n    CFBD_LOG_LEVEL_ERROR,       /* \u9519\u8bef\u4fe1\u606f */\n    CFBD_LOG_LEVEL_FATAL,\n    CFBD_LOG_LEVEL_NONE\n} cfbd_log_level_t;\n\ntypedef struct __CFBD_Logger CFBD_Logger;\n\ntypedef struct\n{\n    void (*log_message)(CFBD_Logger* log_handle,\n                        cfbd_log_level_t level,\n                        const char* tag,\n                        const char* file,\n                        int line,\n                        const char* fmt,\n                        ...);\n} CFBD_LoggerOperations;\n\ntypedef struct\n{\n    void (*log_native)(void* native_handle, const char* buffer, const uint16_t buffer_size);\n    uint32_t (*timestamp)(void* native_handle); // If, native handle can access\n} CFBD_NativeLoggerOperations;\n\ntypedef struct __CFBD_Logger\n{\n    CFBD_LoggerOperations* ops;\n    CFBD_NativeLoggerOperations* native_logs; // As expected, dont call these direct\n\n    cfbd_log_level_t filter_off_level;\n\n    uint8_t* buffer_ptr;\n    uint16_t buffer_sz;\n    void* native_handle;\n\n    CFBD_Bool enable_colorize;\n} CFBD_Logger;\n\nvoid CFBD_InitLogger(CFBD_Logger* logger,\n                     CFBD_NativeLoggerOperations* native_send,\n                     void* native_handle,\n                     cfbd_log_level_t filter_level,\n                     uint8_t* buffer_ptr,\n                     uint16_t buffer_sz);\n\nstatic inline void CFBD_SetFilteredOffLevel(CFBD_Logger* logger, cfbd_log_level_t filter_off_level)\n{\n    logger-&gt;filter_off_level = filter_off_level;\n}\n\n#define CFBD_LOG_V(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_VERBOSE,                                        \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOG_D(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_DEBUG,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOG_I(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_INFO,                                           \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOG_W(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_WARN,                                           \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOG_E(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_ERROR,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOG_F(logger_handle, tag, fmt, ...)                                                   \\\n    logger_handle-&gt;ops-&gt;log_message(logger_handle,                                                 \\\n                                    CFBD_LOG_LEVEL_FATAL,                                          \\\n                                    tag,                                                           \\\n                                    __FILE__,                                                      \\\n                                    __LINE__,                                                      \\\n                                    fmt,                                                           \\\n                                    ##__VA_ARGS__)\n\n#define CFBD_LOGV(handle, fmt, ...) CFBD_LOG_V(handle, NULL, fmt, ##__VA_ARGS__)\n#define CFBD_LOGD(handle, fmt, ...) CFBD_LOG_D(handle, NULL, fmt, ##__VA_ARGS__)\n#define CFBD_LOGI(handle, fmt, ...) CFBD_LOG_I(handle, NULL, fmt, ##__VA_ARGS__)\n#define CFBD_LOGW(handle, fmt, ...) CFBD_LOG_W(handle, NULL, fmt, ##__VA_ARGS__)\n#define CFBD_LOGE(handle, fmt, ...) CFBD_LOG_E(handle, NULL, fmt, ##__VA_ARGS__)\n#define CFBD_LOGF(handle, fmt, ...) CFBD_LOG_F(handle, NULL, fmt, ##__VA_ARGS__)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/cfbd__log__configs_8h/","title":"lib/logger/cfbd_log_configs.h","text":""},{"location":"api/Files/cfbd__log__configs_8h/#defines","title":"Defines","text":"Name CFBD_LOG_AS_UART CFBD_LOG_BUFFER_SZ"},{"location":"api/Files/cfbd__log__configs_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/cfbd__log__configs_8h/#define-cfbd_log_as_uart","title":"define CFBD_LOG_AS_UART","text":"<pre><code>#define CFBD_LOG_AS_UART \n</code></pre>"},{"location":"api/Files/cfbd__log__configs_8h/#define-cfbd_log_buffer_sz","title":"define CFBD_LOG_BUFFER_SZ","text":"<pre><code>#define CFBD_LOG_BUFFER_SZ (128)\n</code></pre>"},{"location":"api/Files/cfbd__log__configs_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_LOG_AS_UART // AS UART\n#define CFBD_LOG_BUFFER_SZ (128)\n\n#if CFBD_LOG_BUFFER_SZ &lt;= 0\n#error \"Making CFBD_LOG_BUFFER_SZ less then 1 is never good :(\"\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/circle_8c/","title":"circle.c","text":""},{"location":"api/Files/circle_8c/#functions","title":"Functions","text":"Name void circle_calc_bbox(CFBDGraphicCircle * c, int32_t * lx, int32_t * ty, int32_t * rx, int32_t * by) void clearBound(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * handler, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety)"},{"location":"api/Files/circle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8c/#function-circle_calc_bbox","title":"function circle_calc_bbox","text":"<pre><code>static inline void circle_calc_bbox(\n    CFBDGraphicCircle * c,\n    int32_t * lx,\n    int32_t * ty,\n    int32_t * rx,\n    int32_t * by\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/circle_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/circle_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/circle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"circle.h\"\n\n#include &lt;assert.h&gt;\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = circle-&gt;center.x + (offsetx);                                                        \\\n        __y = circle-&gt;center.y + (offsety);                                                        \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\nstatic inline void\ncircle_calc_bbox(CFBDGraphicCircle* c, int32_t* lx, int32_t* ty, int32_t* rx, int32_t* by)\n{\n    *lx = asInt32_t(c-&gt;center.x) - c-&gt;radius;\n    *ty = asInt32_t(c-&gt;center.y) - c-&gt;radius;\n    *rx = asInt32_t(c-&gt;center.x) + c-&gt;radius;\n    *by = asInt32_t(c-&gt;center.y) + c-&gt;radius;\n}\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    int32_t lx, ty, rx, by;\n    circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n    handler-&gt;ops-&gt;clear_area(handler,\n                             clamp_u16_from_i32(lx),\n                             clamp_u16_from_i32(ty),\n                             clamp_u16_from_i32(rx - lx + 1),\n                             clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    clearBound(handler, circle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    /* Ref Doc: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/\n    /* Ref Toturial: https://www.bilibili.com/video/BV1VM4y1u7wJ*/\n    int16_t d = 3 - circle-&gt;radius / 4;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* handler, CFBDGraphicCircle* circle)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    int16_t d = 1 - circle-&gt;radius;\n    int16_t x = 0;\n    int16_t y = circle-&gt;radius;\n    clearBound(handler, circle);\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(y, x);\n    DRAW_OFFSET_POINT(-y, -x);\n\n    for (int16_t i = -y; i &lt; y; i++)\n        DRAW_OFFSET_POINT(0, i);\n\n    while (x &lt; y) {\n        x++;\n        if (d &lt; 0) {\n            d += 2 * x + 1;\n        }\n        else {\n            y--;\n            d += 2 * (x - y) + 1;\n        }\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(y, x);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-y, -x);\n        DRAW_OFFSET_POINT(x, -y);\n        DRAW_OFFSET_POINT(y, -x);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(-y, x);\n        for (int16_t i = -y; i &lt; y; i++) {\n            DRAW_OFFSET_POINT(x, i);\n            DRAW_OFFSET_POINT(-x, i);\n        }\n        for (int16_t i = -x; i &lt; x; i++) {\n            DRAW_OFFSET_POINT(y, i);\n            DRAW_OFFSET_POINT(-y, i);\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx, ty, rx, by;\n        circle_calc_bbox(circle, &amp;lx, &amp;ty, &amp;rx, &amp;by);\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/circle_8h/","title":"circle.h","text":"<p>Circle geometry and drawing function declarations.  More...</p>"},{"location":"api/Files/circle_8h/#classes","title":"Classes","text":"Name struct __CFBDGraphicCircle"},{"location":"api/Files/circle_8h/#types","title":"Types","text":"Name typedef struct __CFBDGraphicCircle CFBDGraphicCircle"},{"location":"api/Files/circle_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle) void CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice * device, CFBDGraphicCircle * circle)"},{"location":"api/Files/circle_8h/#detailed-description","title":"Detailed Description","text":"<p>Circle geometry and drawing function declarations. </p> <p>Author: Charliechen114514 </p>"},{"location":"api/Files/circle_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/circle_8h/#typedef-cfbdgraphiccircle","title":"typedef CFBDGraphicCircle","text":"<pre><code>typedef struct __CFBDGraphicCircle CFBDGraphicCircle;\n</code></pre>"},{"location":"api/Files/circle_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawcircle","title":"function CFBDGraphic_DrawCircle","text":"<pre><code>void CFBDGraphic_DrawCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#function-cfbdgraphic_drawfilledcircle","title":"function CFBDGraphic_DrawFilledCircle","text":"<pre><code>void CFBDGraphic_DrawFilledCircle(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicCircle * circle\n)\n</code></pre>"},{"location":"api/Files/circle_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct __CFBDGraphicCircle\n{\n    SizeBaseType radius;\n\n    CFBDGraphic_Point center;\n} CFBDGraphicCircle;\n\nvoid CFBDGraphic_DrawCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\n\nvoid CFBDGraphic_DrawFilledCircle(CFBD_GraphicDevice* device, CFBDGraphicCircle* circle);\n\n // End of Circle_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/config_8h/","title":"lib/graphic/resource/config.h","text":"<p>Graphics resource configuration and feature toggles.  More...</p>"},{"location":"api/Files/config_8h/#detailed-description","title":"Detailed Description","text":"<p>Graphics resource configuration and feature toggles. </p> <p>See: </p> <ul> <li>Animation framework </li> <li>Graphics device abstraction </li> </ul> <p>This configuration header controls which graphics resources and features are compiled and available at runtime. It provides conditional compilation flags for optional fonts and resources.</p> <p>Configuration can be controlled in two ways:</p> <ol> <li>Define USE_NO_DEFAULT_SOURCES to disable all resources</li> <li>Define individual DISABLE* macros to selectively disable resources</li> </ol>"},{"location":"api/Files/config_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef CCGraphic_Config_H\n#define CCGraphic_Config_H\n\n#ifdef _USE_NO_DEFAULT_SOURCES\n\n#define ENABLE_ASCII_6x8_SOURCES 0\n\n#define ENABLE_ASCII_8X16_SOURCES 0\n\n#else\n\n#define ENABLE_ASCII_6x8_SOURCES 1\n\n#define ENABLE_ASCII_8x16_SOURCES 1\n\n/* Selective resource disabling */\n\n#ifdef DISABLE_ASCII_6X8_SOURCES\n#undef ENABLE_ASCII_6x8_SOURCES\n#define ENABLE_ASCII_6x8_SOURCES 0\n#endif\n\n#ifdef DISABLE_ASCII_8X16_SOURCES\n#undef ENABLE_ASCII_8X16_SOURCES\n#define ENABLE_ASCII_8X16_SOURCES 0\n#endif\n\n#endif // for the _USE_NO_DEFAULT_SOURCES\n\n#endif // for the no-repeative include guard\n\n // end of Graphics_Resources group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/demo__end__screen_8c/","title":"lib/graphic/fast_test/demos/demo_end_screen/demo_end_screen.c","text":"<p>Final demo end screen.  More...</p>"},{"location":"api/Files/demo__end__screen_8c/#functions","title":"Functions","text":"Name void demo_end_screen(CFBD_GraphicDevice * dev)"},{"location":"api/Files/demo__end__screen_8c/#detailed-description","title":"Detailed Description","text":"<p>Final demo end screen. </p> <p>Displays a simple \"DEMO END\" message. Intended to be the last demo in queue mode. </p>"},{"location":"api/Files/demo__end__screen_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/demo__end__screen_8c/#function-demo_end_screen","title":"function demo_end_screen","text":"<pre><code>void demo_end_screen(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/demo__end__screen_8c/#source-code","title":"Source code","text":"<pre><code>#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/text.h\"\n\nvoid demo_end_screen(CFBD_GraphicDevice* dev)\n{\n    dev-&gt;ops-&gt;clear(dev);\n\n    CFBDGraphic_Text title;\n    CFBDGraphic_Point tp = {.x = 12, .y = 2};\n    CFBDGraphicSize ts = {.width = 104, .height = 10};\n    CFBDGraphic_InitText(&amp;title, tp, ts, ASCII_6x8);\n    CFBDGraphic_SetText(&amp;title, \"End Of the Everythings\");\n\n    CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_RequestOldPoint);\n\n    system_delay_ms(5000);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/demo__manager_8c/","title":"lib/graphic/fast_test/demo_support/demo_manager.c","text":""},{"location":"api/Files/demo__manager_8c/#functions","title":"Functions","text":"Name void CFBD_DemoManager_Run(CFBD_GraphicDevice * dev, const CFBD_DemoDescriptor * demos, uint32_t demo_count, CFBD_DemoRunMode mode, uint32_t index)Run demo list according to mode."},{"location":"api/Files/demo__manager_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/demo__manager_8c/#function-cfbd_demomanager_run","title":"function CFBD_DemoManager_Run","text":"<pre><code>void CFBD_DemoManager_Run(\n    CFBD_GraphicDevice * dev,\n    const CFBD_DemoDescriptor * demos,\n    uint32_t demo_count,\n    CFBD_DemoRunMode mode,\n    uint32_t index\n)\n</code></pre> <p>Run demo list according to mode. </p> <p>Run demos according to selected mode. </p>"},{"location":"api/Files/demo__manager_8c/#source-code","title":"Source code","text":"<pre><code>#include \"demo_manager.h\"\n\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n\nvoid CFBD_DemoManager_Run(CFBD_GraphicDevice* dev,\n                          const CFBD_DemoDescriptor* demos,\n                          uint32_t demo_count,\n                          CFBD_DemoRunMode mode,\n                          uint32_t index)\n{\n    switch (mode) {\n        case CFBD_DEMO_RUN_SINGLE:\n            if (index &lt; demo_count) {\n                dev-&gt;ops-&gt;clear(dev);\n                dev-&gt;ops-&gt;update(dev);\n                demos[index].entry(dev);\n            }\n            break;\n\n        case CFBD_DEMO_RUN_QUEUE:\n            for (uint32_t i = 0; i &lt; demo_count; ++i) {\n                dev-&gt;ops-&gt;clear(dev);\n                dev-&gt;ops-&gt;update(dev);\n                demos[i].entry(dev);\n                if (demos[i].duration &gt; 0) {\n                    system_delay_ms(demos[i].duration);\n                }\n            }\n            break;\n\n        case CFBD_DEMO_RUN_LOOP:\n            while (1) {\n                for (uint32_t i = 0; i &lt; demo_count; ++i) {\n                    dev-&gt;ops-&gt;clear(dev);\n                    dev-&gt;ops-&gt;update(dev);\n                    demos[i].entry(dev);\n                    if (demos[i].duration &gt; 0) {\n                        system_delay_ms(demos[i].duration);\n                    }\n                }\n            }\n            break;\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/demo__manager_8h/","title":"lib/graphic/fast_test/demo_support/demo_manager.h","text":"<p>Generic demo manager for CFBD-based embedded GUI demonstrations.  More...</p>"},{"location":"api/Files/demo__manager_8h/#classes","title":"Classes","text":"Name struct CFBD_DemoDescriptor Demo descriptor structure."},{"location":"api/Files/demo__manager_8h/#types","title":"Types","text":"Name enum CFBD_DemoRunMode { CFBD_DEMO_RUN_SINGLE, CFBD_DEMO_RUN_QUEUE, CFBD_DEMO_RUN_LOOP}Demo run mode. typedef void(*)(CFBD_GraphicDevice *dev) CFBD_DemoEntry"},{"location":"api/Files/demo__manager_8h/#functions","title":"Functions","text":"Name void CFBD_DemoManager_Run(CFBD_GraphicDevice * dev, const CFBD_DemoDescriptor * demos, uint32_t demo_count, CFBD_DemoRunMode mode, uint32_t index)Run demos according to selected mode."},{"location":"api/Files/demo__manager_8h/#detailed-description","title":"Detailed Description","text":"<p>Generic demo manager for CFBD-based embedded GUI demonstrations. </p> <p>Author: CharlieChen </p> <p>This module provides a unified mechanism to:</p> <ul> <li>Register independent demo modules</li> <li>Run a single specified demo</li> <li>Run demos sequentially (queue mode)</li> <li>Run demos in circular rotation (loop mode)</li> </ul> <p>Design goals:</p> <ul> <li>No dynamic memory allocation</li> <li>Pure C, OOP-style abstraction</li> <li>Easy extensibility (add a demo = add one file) </li> </ul>"},{"location":"api/Files/demo__manager_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/demo__manager_8h/#enum-cfbd_demorunmode","title":"enum CFBD_DemoRunMode","text":"Enumerator Value Description CFBD_DEMO_RUN_SINGLE Run only one demo CFBD_DEMO_RUN_QUEUE Run demos sequentially once CFBD_DEMO_RUN_LOOP Run demos continuously in loop <p>Demo run mode. </p>"},{"location":"api/Files/demo__manager_8h/#typedef-cfbd_demoentry","title":"typedef CFBD_DemoEntry","text":"<pre><code>typedef void(* CFBD_DemoEntry) (CFBD_GraphicDevice *dev);\n</code></pre>"},{"location":"api/Files/demo__manager_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/demo__manager_8h/#function-cfbd_demomanager_run","title":"function CFBD_DemoManager_Run","text":"<pre><code>void CFBD_DemoManager_Run(\n    CFBD_GraphicDevice * dev,\n    const CFBD_DemoDescriptor * demos,\n    uint32_t demo_count,\n    CFBD_DemoRunMode mode,\n    uint32_t index\n)\n</code></pre> <p>Run demos according to selected mode. </p> <p>Parameters: </p> <ul> <li>dev Graphic device </li> <li>demos Demo descriptor array </li> <li>demo_count Number of demos </li> <li>mode Run mode </li> <li>index Index used only in SINGLE mode</li> </ul> <p>Run demos according to selected mode. </p>"},{"location":"api/Files/demo__manager_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_graphic_define.h\"\n\n\ntypedef void (*CFBD_DemoEntry)(CFBD_GraphicDevice* dev);\n\ntypedef struct\n{\n    const char* name;     \n    CFBD_DemoEntry entry; \n    uint32_t duration;    \n} CFBD_DemoDescriptor;\n\ntypedef enum\n{\n    CFBD_DEMO_RUN_SINGLE, \n    CFBD_DEMO_RUN_QUEUE,  \n    CFBD_DEMO_RUN_LOOP    \n} CFBD_DemoRunMode;\n\nvoid CFBD_DemoManager_Run(CFBD_GraphicDevice* dev,\n                          const CFBD_DemoDescriptor* demos,\n                          uint32_t demo_count,\n                          CFBD_DemoRunMode mode,\n                          uint32_t index);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/demo__progressbar_8c/","title":"lib/graphic/fast_test/demos/demo_progressbar/demo_progressbar.c","text":"<p>Progress bar widget demonstration.  More...</p>"},{"location":"api/Files/demo__progressbar_8c/#functions","title":"Functions","text":"Name void demo_progressbar(CFBD_GraphicDevice * dev)"},{"location":"api/Files/demo__progressbar_8c/#detailed-description","title":"Detailed Description","text":"<p>Progress bar widget demonstration. </p> <p>Author: CharlieChen </p> <p>Demonstrates:</p> <ul> <li>Linear progress bar rendering</li> <li>Smooth incremental animation</li> <li>No visual artifacts (no flowing light)</li> </ul> <p>This demo automatically completes and returns. </p>"},{"location":"api/Files/demo__progressbar_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/demo__progressbar_8c/#function-demo_progressbar","title":"function demo_progressbar","text":"<pre><code>void demo_progressbar(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/demo__progressbar_8c/#source-code","title":"Source code","text":"<pre><code>#include \"sys_clock/system_clock.h\"\n#include \"widget/progressbar/progressbar.h\"\n#include \"widget/text.h\"\n\nvoid demo_progressbar(CFBD_GraphicDevice* dev)\n{\n    /* =======================\n     * Title\n     * ======================= */\n    CFBDGraphic_Text title;\n    CFBDGraphic_Point tp = {.x = 12, .y = 2};\n    CFBDGraphicSize ts = {.width = 104, .height = 10};\n    CFBDGraphic_InitText(&amp;title, tp, ts, ASCII_6x8);\n    CFBDGraphic_SetText(&amp;title, \"System Booting...\");\n\n    /* =======================\n     * Main ProgressBar\n     * ======================= */\n    CFBD_ProgressBar main_pb;\n    CFBDGraphic_Point p = {6, 18};\n    CFBDGraphicSize sz = {116, 12};\n    CFBD_ProgressBar_Init(&amp;main_pb, dev, &amp;p, &amp;sz, 0, 100);\n    uint8_t boarder_and_padding = 1;\n    CFBD_BaseAnimation animation = {.anim_frame_delay_ms = 25, .anim_frames = 10};\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"border\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"padding\", &amp;boarder_and_padding);\n    main_pb.ops-&gt;set_property(&amp;main_pb, \"animation\", &amp;animation);\n\n    /* =======================\n     * Stage ProgressBar\n     * ======================= */\n    CFBD_ProgressBar stage_pb;\n    CFBDGraphic_Point p2 = {20, 38};\n    CFBDGraphicSize sz2 = {88, 8};\n    CFBD_ProgressBar_Init(&amp;stage_pb, dev, &amp;p2, &amp;sz2, 0, 100);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"border\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"padding\", &amp;boarder_and_padding);\n    stage_pb.ops-&gt;set_property(&amp;stage_pb, \"animation\", &amp;animation);\n    /* =======================\n     * First frame draw\n     * ======================= */\n    dev-&gt;ops-&gt;clear(dev);\n\n    CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_RequestOldPoint);\n\n    main_pb.ops-&gt;immediate_draw(&amp;main_pb);\n    main_pb.ops-&gt;immediate_draw(&amp;stage_pb);\n\n    dev-&gt;ops-&gt;update(dev);\n\n    /* =======================\n     * Demo animation\n     * ======================= */\n    const int stages[] = {0, 20, 45, 70, 100};\n\n    for (int s = 0; s &lt; 5; ++s) {\n        /* main progress moves forward */\n        main_pb.ops-&gt;set_value(&amp;main_pb, stages[s]);\n        system_delay_ms(100);\n\n        /* stage progress busy animation */\n        stage_pb.ops-&gt;set_value(&amp;stage_pb, 25);\n        system_delay_ms(100);\n\n        stage_pb.ops-&gt;set_value(&amp;stage_pb, 50);\n        system_delay_ms(100);\n\n        stage_pb.ops-&gt;set_value(&amp;stage_pb, 75);\n        system_delay_ms(500);\n\n        stage_pb.ops-&gt;set_value(&amp;stage_pb, 100);\n        system_delay_ms(100);\n        stage_pb.ops-&gt;set_value(&amp;stage_pb, 0);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/demo__text_8c/","title":"lib/graphic/fast_test/demos/demo_text/demo_text.c","text":""},{"location":"api/Files/demo__text_8c/#functions","title":"Functions","text":"Name void test_text(CFBD_GraphicDevice * handler)"},{"location":"api/Files/demo__text_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/demo__text_8c/#function-test_text","title":"function test_text","text":"<pre><code>void test_text(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/demo__text_8c/#source-code","title":"Source code","text":"<pre><code>#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/text.h\"\n\nvoid test_text(CFBD_GraphicDevice* handler)\n{\n    CFBDGraphic_DeviceClearImmediate(handler);\n    /* print sources */\n    char* source = \"Hello, World!This is Charlie's Speeking!\";\n    CFBDGraphic_Text item;\n    CFBDGraphicSize screen_size;\n    CFBDGraphic_GetScreenSize(handler, &amp;screen_size);\n    CFBDGraphic_Point p = {0, 0};\n    CFBDGraphic_InitText(&amp;item, p, screen_size, ASCII_6x8);\n\n    CFBDGraphic_SetText(&amp;item, source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    /* after delay, print new_sources */\n    char* new_source = \"May I Help You?\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n    system_delay_ms(1000);\n\n    // resets everythings\n    CFBDGraphic_DeviceClearImmediate(handler);\n    CFBDGraphic_SetTextIndexedPoint(&amp;item, &amp;p);\n\n    new_source = \"Yes!Please Offer me a lemon juice\";\n    CFBDGraphic_SetText(&amp;item, new_source);\n    CFBDGraphic_DrawText(handler, &amp;item, CCGraphic_AsciiTextItem_AppendContinously);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/device__interface_8h/","title":"lib/oled/driver/device/device_interface.h","text":"<p>Generic device descriptor used by OLED drivers.  More...</p>"},{"location":"api/Files/device__interface_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel."},{"location":"api/Files/device__interface_8h/#detailed-description","title":"Detailed Description","text":"<p>Generic device descriptor used by OLED drivers. </p> <p>See: CFBD_OLED_DeviceSpecificfor the main interface structure. </p> <p>This module encapsulates device-specific information required by the generic OLED driver, including pointers to initialization tables, GRAM buffers and logical geometry. Concrete device drivers (e.g. SSD1306/SSD1309) provide instances of this structure.</p>"},{"location":"api/Files/device__interface_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"configs/iic_pack_type.h\"\n\ntypedef struct\n{\n    uint8_t* (*init_session_tables)(void);\n\n    uint8_t** grams;\n\n    uint16_t init_session_tables_sz;\n\n    uint8_t data_prefix;\n\n    uint8_t cmd_prefix;\n\n    uint16_t logic_width;\n\n    uint16_t logic_height;\n\n    const char* iic_pack_type;\n\n    void* private_data;\n} CFBD_OLED_DeviceSpecific;\n\n // end of OLED_Device group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/","title":"lib/graphic/fast_test","text":""},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/#directories","title":"Directories","text":"Name lib/graphic/fast_test/demo_support lib/graphic/fast_test/demos"},{"location":"api/Files/dir_01d206d9bf4bfa67625bb0969948b4e8/#files","title":"Files","text":"Name lib/graphic/fast_test/test_base_graphic.c lib/graphic/fast_test/test_base_graphic.h lib/graphic/fast_test/test_widget.c lib/graphic/fast_test/test_widget.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_05d62ef249342f73f4413e915e91c7ff/","title":"lib/input","text":""},{"location":"api/Files/dir_05d62ef249342f73f4413e915e91c7ff/#directories","title":"Directories","text":"Name lib/input/button_like"},{"location":"api/Files/dir_05d62ef249342f73f4413e915e91c7ff/#files","title":"Files","text":"Name lib/input/input.c lib/input/input.h lib/input/input_config.h lib/input/input_device_base.c lib/input/input_device_base.h lib/input/input_event.c lib/input/input_event.h lib/input/input_id_allocator.c lib/input/input_id_allocator.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/","title":"lib/config","text":""},{"location":"api/Files/dir_10e48b983f378c59dcd859736018b16d/#files","title":"Files","text":"Name lib/config/ah_no.h Emergency halt helper used when unrecoverable errors occur. lib/config/cfbd_define.h Core type and macro definitions used across CFBD libraries. lib/config/lib_settings.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_12e2fe4740f7511fcd6d71b389ebaeed/","title":"lib/graphic/fast_test/demos/demo_progressbar","text":""},{"location":"api/Files/dir_12e2fe4740f7511fcd6d71b389ebaeed/#files","title":"Files","text":"Name lib/graphic/fast_test/demos/demo_progressbar/demo_progressbar.c Progress bar widget demonstration. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/","title":"lib/graphic","text":""},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#directories","title":"Directories","text":"Name lib/graphic/base lib/graphic/benchmark lib/graphic/device lib/graphic/fast_test lib/graphic/resource lib/graphic/widget"},{"location":"api/Files/dir_13ce4da507591e7e0d521d0b2bd8e1ff/#files","title":"Files","text":"Name lib/graphic/cfbd_graphic_define.h Core graphics type definitions and forward declarations. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_2cefe00e574d2aa1b0869ca1afca5427/","title":"lib/logger","text":""},{"location":"api/Files/dir_2cefe00e574d2aa1b0869ca1afca5427/#directories","title":"Directories","text":"Name lib/logger/uart_adapts"},{"location":"api/Files/dir_2cefe00e574d2aa1b0869ca1afca5427/#files","title":"Files","text":"Name lib/logger/cfbd_log.c lib/logger/cfbd_log.h lib/logger/cfbd_log_configs.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/","title":"lib/graphic/resource","text":""},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#directories","title":"Directories","text":"Name lib/graphic/resource/default"},{"location":"api/Files/dir_3854440a4dd5ecb35ecad2d66003f363/#files","title":"Files","text":"Name lib/graphic/resource/config.h Graphics resource configuration and feature toggles. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/","title":"lib/oled/driver","text":""},{"location":"api/Files/dir_3a43b532e3dacbec08288b03dcc128a4/#directories","title":"Directories","text":"Name lib/oled/driver/backend lib/oled/driver/device <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_3eeceab722ce895561f98e974ae01b1e/","title":"lib/oled/driver/device/ssd1327","text":""},{"location":"api/Files/dir_3eeceab722ce895561f98e974ae01b1e/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1327/ssd1327.c lib/oled/driver/device/ssd1327/ssd1327.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/","title":"lib/application/sys_boot","text":""},{"location":"api/Files/dir_3f4cd17a8f6090e0f2b09c99913f2a8b/#files","title":"Files","text":"Name lib/application/sys_boot/boot.c lib/application/sys_boot/boot.h Boot / startup helpers and types for application bootstrap sequence. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/","title":"lib/oled","text":""},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#directories","title":"Directories","text":"Name lib/oled/configs lib/oled/driver"},{"location":"api/Files/dir_43acfda8ae2a7dc79d6ffc7268040542/#files","title":"Files","text":"Name lib/oled/oled.c lib/oled/oled.h Generic OLED object and operations exposed to application code. lib/oled/oled_concreate_iic.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/","title":"lib/oled/driver/device/ssd1306","text":""},{"location":"api/Files/dir_447e2551f4d7067d2051fefee79cab92/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1306/ssd1306.c lib/oled/driver/device/ssd1306/ssd1306.h SSD1306 device-specific descriptor and factory. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/","title":"lib/graphic/device","text":""},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#directories","title":"Directories","text":"Name lib/graphic/device/oled"},{"location":"api/Files/dir_4d06d991007fa22fa49ac8a2013667af/#files","title":"Files","text":"Name lib/graphic/device/grapgic_device.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_4e06a20dee22bfe3f880343ca75ecf7b/","title":"lib/input/button_like/stm_hal_series","text":""},{"location":"api/Files/dir_4e06a20dee22bfe3f880343ca75ecf7b/#files","title":"Files","text":"Name lib/input/button_like/stm_hal_series/plain_button_impl.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_5111c55e4f09e10680f6987980d1e048/","title":"lib/graphic/fast_test/demos/demo_text","text":""},{"location":"api/Files/dir_5111c55e4f09e10680f6987980d1e048/#files","title":"Files","text":"Name lib/graphic/fast_test/demos/demo_text/demo_text.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/","title":"lib/gpio","text":""},{"location":"api/Files/dir_541432474389f3d0c2d8c34c147b933c/#files","title":"Files","text":"Name lib/gpio/gpio-stm-impl.c lib/gpio/gpio-stm-impl.h STM32 specific GPIO implementation details for CFBD. lib/gpio/gpio.h GPIO abstraction and helpers used by platform and application code. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/","title":"lib/graphic/widget/menu","text":""},{"location":"api/Files/dir_658b3b1277acc01a195fce862b6ad438/#files","title":"Files","text":"Name lib/graphic/widget/menu/icontext_menu.c Icon-text menu widget implementation. lib/graphic/widget/menu/icontext_menu.h Icon-text menu widget for scrollable menu display. lib/graphic/widget/menu/menu.c lib/graphic/widget/menu/menu.h Menu widget for hierarchical item selection. lib/graphic/widget/menu/menu_config.h Menu widget compile-time configuration. lib/graphic/widget/menu/menu_indicator.c lib/graphic/widget/menu/menu_indicator.h Menu indicator widget for visual selection feedback. lib/graphic/widget/menu/menu_item.c lib/graphic/widget/menu/menu_item.h Menu item widget for menu selection options. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/","title":"lib/graphic/base","text":""},{"location":"api/Files/dir_69b35bb1a41a89909899ce0477d06756/#files","title":"Files","text":"Name lib/graphic/base/arc.c lib/graphic/base/arc.h Arc geometry and drawing prototypes for the graphics subsystem. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_6bb3bd38db98b2e2ebf59e2cc1962835/","title":"lib/graphic/fast_test/demos/demo_end_screen","text":""},{"location":"api/Files/dir_6bb3bd38db98b2e2ebf59e2cc1962835/#files","title":"Files","text":"Name lib/graphic/fast_test/demos/demo_end_screen/demo_end_screen.c Final demo end screen. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/","title":"lib/application/sys_clock","text":""},{"location":"api/Files/dir_6d269e6c39ba7ab851bb09015c4fcdac/#files","title":"Files","text":"Name lib/application/sys_clock/system_clock.c lib/application/sys_clock/system_clock.h System timing primitives and delay helpers. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/","title":"lib/oled/configs","text":""},{"location":"api/Files/dir_6fbd3c9de87db2bf215f5a13a20f864c/#files","title":"Files","text":"Name lib/oled/configs/cache_config-ssd130x.h lib/oled/configs/cache_config-ssd132x.h lib/oled/configs/external_impl_driver.h External (platform/application) implementation hooks for OLED driver. lib/oled/configs/iic_pack_type.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/","title":"lib/graphic/benchmark","text":""},{"location":"api/Files/dir_791167db08eb14c682f8ce2d65612e86/#files","title":"Files","text":"Name lib/graphic/benchmark/benchmark.c lib/graphic/benchmark/benchmark.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/","title":"lib/graphic/widget","text":""},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#directories","title":"Directories","text":"Name lib/graphic/widget/animation lib/graphic/widget/base_support lib/graphic/widget/menu lib/graphic/widget/progressbar lib/graphic/widget/widget"},{"location":"api/Files/dir_7954e7abe7d3ca5bce20ba61ab3cf2b8/#files","title":"Files","text":"Name lib/graphic/widget/text.c lib/graphic/widget/text.h Text widget for rendering ASCII text strings. lib/graphic/widget/text_config.c lib/graphic/widget/text_config.h Text widget font configuration and selection. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/","title":"lib/graphic/widget/progressbar","text":""},{"location":"api/Files/dir_7f04fa6f0f28851ac74b126c7e61ab0a/#files","title":"Files","text":"Name lib/graphic/widget/progressbar/progressbar.c lib/graphic/widget/progressbar/progressbar.h Progress bar widget for progress visualization. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_80d60da94dfe5b68231e1e4f605f379b/","title":"lib/graphic/fast_test/demos/demo_icontext_menu","text":""},{"location":"api/Files/dir_80d60da94dfe5b68231e1e4f605f379b/#files","title":"Files","text":"Name lib/graphic/fast_test/demos/demo_icontext_menu/icon_text_menu_demo.c Icon-text menu demonstration (OOP C \u98ce\u683c) lib/graphic/fast_test/demos/demo_icontext_menu/icons.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_8825d8f3ac3ca15ea5ab657ff1ab2afb/","title":"lib/graphic/widget/widget","text":""},{"location":"api/Files/dir_8825d8f3ac3ca15ea5ab657ff1ab2afb/#files","title":"Files","text":"Name lib/graphic/widget/widget/widget.c lib/graphic/widget/widget/widget.h lib/graphic/widget/widget/widget_wrappers.h Old days designs adapters. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_89e7cccdf63b5048b6866aff3eca1d83/","title":"lib/input/button_like","text":""},{"location":"api/Files/dir_89e7cccdf63b5048b6866aff3eca1d83/#directories","title":"Directories","text":"Name lib/input/button_like/stm_hal_series"},{"location":"api/Files/dir_89e7cccdf63b5048b6866aff3eca1d83/#files","title":"Files","text":"Name lib/input/button_like/plain_button.c lib/input/button_like/plain_button.h lib/input/button_like/plain_button_impl.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/","title":"lib/oled/driver/device/ssd1309","text":""},{"location":"api/Files/dir_920e6634b24bd941567eef5fc32320bb/#files","title":"Files","text":"Name lib/oled/driver/device/ssd1309/ssd1309.c lib/oled/driver/device/ssd1309/ssd1309.h SSD1309 device-specific descriptor and factory. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/","title":"lib","text":""},{"location":"api/Files/dir_97aefd0d527b934f1d99a682da8fe6a9/#directories","title":"Directories","text":"Name lib/application lib/config lib/gpio lib/graphic lib/iic lib/input lib/logger lib/oled lib/uart <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/","title":"lib/graphic/resource/default","text":""},{"location":"api/Files/dir_9f40a4ec61c12605eebff30f8e44b477/#files","title":"Files","text":"Name lib/graphic/resource/default/ascii6x8.source.c lib/graphic/resource/default/ascii8x16.source.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_a3b72efd50d241459148d53aaf7a650d/","title":"lib/logger/uart_adapts","text":""},{"location":"api/Files/dir_a3b72efd50d241459148d53aaf7a650d/#files","title":"Files","text":"Name lib/logger/uart_adapts/uart_inits.c lib/logger/uart_adapts/uart_inits.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_a8f1750d0a41a383dad6047e5488708b/","title":"lib/graphic/fast_test/demo_support","text":""},{"location":"api/Files/dir_a8f1750d0a41a383dad6047e5488708b/#files","title":"Files","text":"Name lib/graphic/fast_test/demo_support/demo_manager.c lib/graphic/fast_test/demo_support/demo_manager.h Generic demo manager for CFBD-based embedded GUI demonstrations. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/","title":"lib/application","text":""},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#directories","title":"Directories","text":"Name lib/application/sys_boot lib/application/sys_clock"},{"location":"api/Files/dir_aac103eaf1289eab21d6aadd3933cb20/#files","title":"Files","text":"Name lib/application/app.c lib/application/app.h Application descriptor and clock/boot provider interfaces. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_ab8a7e4486a1338d69823067575daa4e/","title":"lib/graphic/fast_test/demos","text":""},{"location":"api/Files/dir_ab8a7e4486a1338d69823067575daa4e/#directories","title":"Directories","text":"Name lib/graphic/fast_test/demos/demo_end_screen lib/graphic/fast_test/demos/demo_icontext_menu lib/graphic/fast_test/demos/demo_progressbar lib/graphic/fast_test/demos/demo_text <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/","title":"lib/oled/driver/device","text":""},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#directories","title":"Directories","text":"Name lib/oled/driver/device/ssd1306 lib/oled/driver/device/ssd1309 lib/oled/driver/device/ssd1327"},{"location":"api/Files/dir_b356985a404e53e99e018c0a9faaffaf/#files","title":"Files","text":"Name lib/oled/driver/device/device_interface.h Generic device descriptor used by OLED drivers. lib/oled/driver/device/oled_ssd132x_privates.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_b4d6f175b33edcf901b87ee260cccf25/","title":"lib/uart","text":""},{"location":"api/Files/dir_b4d6f175b33edcf901b87ee260cccf25/#directories","title":"Directories","text":"Name lib/uart/backend"},{"location":"api/Files/dir_b4d6f175b33edcf901b87ee260cccf25/#files","title":"Files","text":"Name lib/uart/uart.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_b8634a52f9b73d7c45618692cc54ea1b/","title":"lib/graphic/widget/base_support/common","text":"<p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/","title":"lib/graphic/device/oled","text":""},{"location":"api/Files/dir_d1d9f5e50a7225ba400e6c84d5375172/#files","title":"Files","text":"Name lib/graphic/device/oled/oled_graphic_device.c lib/graphic/device/oled/oled_graphic_device.h OLED device binding for the graphics subsystem. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/","title":"lib/oled/driver/backend","text":""},{"location":"api/Files/dir_da3f977f3122274fd4f48de3454415cc/#files","title":"Files","text":"Name lib/oled/driver/backend/oled_iic_130x.c lib/oled/driver/backend/oled_iic_130x.h lib/oled/driver/backend/oled_iic_132x.c lib/oled/driver/backend/oled_iic_132x.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/","title":"lib/graphic/widget/animation","text":""},{"location":"api/Files/dir_e03a75b10b8663ce65ed5ba47c19af3b/#files","title":"Files","text":"Name lib/graphic/widget/animation/animation.c <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/","title":"lib/iic","text":""},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#directories","title":"Directories","text":"Name lib/iic/backend"},{"location":"api/Files/dir_e99b67eb869d664170df7db87f2d95a3/#files","title":"Files","text":"Name lib/iic/iic.c lib/iic/iic.h I2C (IIC) abstraction layer for CFBD drivers. lib/iic/iic_error.h I2C/IIC error codes used by the CFBD I2C abstraction. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/","title":"lib/graphic/widget/base_support","text":""},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#directories","title":"Directories","text":"Name lib/graphic/widget/base_support/common"},{"location":"api/Files/dir_f31e53b6445a2d331769435801315ed2/#files","title":"Files","text":"Name lib/graphic/widget/base_support/image.c lib/graphic/widget/base_support/image.h Image widget for rendering bitmap graphics. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_f577579a120ec0357abd93f93d011028/","title":"lib/uart/backend","text":""},{"location":"api/Files/dir_f577579a120ec0357abd93f93d011028/#files","title":"Files","text":"Name lib/uart/backend/stm-impl-uart.c lib/uart/backend/stm-impl-uart.h <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/","title":"lib/iic/backend","text":""},{"location":"api/Files/dir_f8eec9e3a81638e6f7248fe614781262/#files","title":"Files","text":"Name lib/iic/backend/i2c_stm_impl.c lib/iic/backend/i2c_stm_impl.h STM32 HAL-based I2C backend private types and helpers. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ellipse_8c/","title":"ellipse.c","text":""},{"location":"api/Files/ellipse_8c/#functions","title":"Functions","text":"Name void clearBound(CFBD_GraphicDevice * handler, CFBD_GraphicEllipse * ellipse, const int16_t x_radius, const int16_t y_radius)"},{"location":"api/Files/ellipse_8c/#defines","title":"Defines","text":"Name PREANNOUNCE DRAW_OFFSET_POINT(offsetx, offsety) SQUARE(X)"},{"location":"api/Files/ellipse_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ellipse_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static inline void clearBound(\n    CFBD_GraphicDevice * handler,\n    CFBD_GraphicEllipse * ellipse,\n    const int16_t x_radius,\n    const int16_t y_radius\n)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ellipse_8c/#define-preannounce","title":"define PREANNOUNCE","text":"<pre><code>#define PREANNOUNCE PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-draw_offset_point","title":"define DRAW_OFFSET_POINT","text":"<pre><code>#define DRAW_OFFSET_POINT(\n    offsetx,\n    offsety\n)\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/ellipse_8c/#define-square","title":"define SQUARE","text":"<pre><code>#define SQUARE(\n    X\n)\n((X) * (X))\n</code></pre>"},{"location":"api/Files/ellipse_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ellipse.h\"\n\n#include \"base_helpers.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\n#define PREANNOUNCE                                                                                \\\n    PointBaseType __x = 0;                                                                         \\\n    PointBaseType __y = 0\n\n#define DRAW_OFFSET_POINT(offsetx, offsety)                                                        \\\n    do {                                                                                           \\\n        __x = ellipse-&gt;center.x + (offsetx);                                                       \\\n        __y = ellipse-&gt;center.y + (offsety);                                                       \\\n        setPixel(handler, __x, __y);                                                               \\\n    } while (0)\n\n#define SQUARE(X) ((X) * (X))\n\nstatic inline void clearBound(CFBD_GraphicDevice* handler,\n                              CFBD_GraphicEllipse* ellipse,\n                              const int16_t x_radius,\n                              const int16_t y_radius)\n{\n    int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n    int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n    int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n    int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n    handler-&gt;ops-&gt;update_area(handler,\n                              clamp_u16_from_i32(lx),\n                              clamp_u16_from_i32(ty),\n                              clamp_u16_from_i32(rx - lx + 1),\n                              clamp_u16_from_i32(by - ty + 1));\n}\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* handler, CFBD_GraphicEllipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* handler, CFBD_GraphicEllipse* ellipse)\n{\n    PREANNOUNCE;\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    const int16_t x_radius = ellipse-&gt;X_Radius;\n    const int16_t y_radius = ellipse-&gt;Y_Radius;\n    clearBound(handler, ellipse, x_radius, y_radius);\n    // Bresenham's Ellipse Algorithm to avoid costly floating point calculations\n    // Reference: https://blog.csdn.net/myf_666/article/details/128167392\n\n    int16_t x = 0;\n    int16_t y = y_radius;\n    const int16_t y_radius_square = SQUARE(y_radius);\n    const int16_t x_radius_square = SQUARE(x_radius);\n\n    // Initial decision variable for the first region of the ellipse\n    float d1 = y_radius_square + x_radius_square * (-y_radius + 0.5);\n    // Fill the ellipse by drawing vertical lines in the specified range (filled area)\n    for (int16_t j = -y; j &lt; y; j++) {\n        // Draw vertical lines to fill the area of the ellipse\n        DRAW_OFFSET_POINT(0, j);\n        DRAW_OFFSET_POINT(0, j);\n    }\n\n    // Draw initial points on the ellipse (4 points due to symmetry)\n    DRAW_OFFSET_POINT(x, y);\n    DRAW_OFFSET_POINT(-x, -y);\n    DRAW_OFFSET_POINT(-x, y);\n    DRAW_OFFSET_POINT(x, -y);\n\n    // Draw the middle part of the ellipse (first region)\n    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) {\n        if (d1 &lt;= 0) { // Next point is to the east of the current point\n            d1 += y_radius_square * (2 * x + 3);\n        }\n        else { // Next point is southeast of the current point\n            d1 += y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);\n            y--;\n        }\n        x++;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point in the current region\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    // Draw the two sides of the ellipse (second region)\n    float d2 = SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) -\n               x_radius_square * y_radius_square;\n\n    while (y &gt; 0) {\n        if (d2 &lt;= 0) { // Next point is to the east of the current point\n            d2 += y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);\n            x++;\n        }\n        else { // Next point is southeast of the current point\n            d2 += x_radius_square * (-2 * y + 3);\n        }\n        y--;\n\n        // Fill the ellipse by drawing vertical lines in the current range\n        for (int16_t j = -y; j &lt; y; j++) {\n            DRAW_OFFSET_POINT(x, j);\n            DRAW_OFFSET_POINT(-x, j);\n        }\n\n        // Draw ellipse arc for each point on the sides\n        DRAW_OFFSET_POINT(x, y);\n        DRAW_OFFSET_POINT(-x, -y);\n        DRAW_OFFSET_POINT(-x, y);\n        DRAW_OFFSET_POINT(x, -y);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(ellipse-&gt;center.x) - x_radius;\n        int32_t ty = asInt32_t(ellipse-&gt;center.y) - y_radius;\n        int32_t rx = asInt32_t(ellipse-&gt;center.x) + x_radius;\n        int32_t by = asInt32_t(ellipse-&gt;center.y) + y_radius;\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n\n#undef DRAW_OFFSET_POINT\n#undef SQUARE\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ellipse_8h/","title":"ellipse.h","text":"<p>Ellipse drawing utilities for 2D graphics rendering. </p>"},{"location":"api/Files/ellipse_8h/#classes","title":"Classes","text":"Name struct __CFBD_GraphicEllipse"},{"location":"api/Files/ellipse_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"point.h\"\n\ntypedef struct __CFBD_GraphicEllipse\n{\n    CFBDGraphic_Point center; \n    PointBaseType X_Radius;   \n    PointBaseType Y_Radius;   \n} CFBD_GraphicEllipse;\n\nvoid CFBDGraphic_DrawEllipse(CFBD_GraphicDevice* device, CFBD_GraphicEllipse* ellipse);\n\nvoid CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice* device, CFBD_GraphicEllipse* ellipse);\n\n // End of Ellipse_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/external__impl__driver_8h/","title":"lib/oled/configs/external_impl_driver.h","text":"<p>External (platform/application) implementation hooks for OLED driver.  More...</p>"},{"location":"api/Files/external__impl__driver_8h/#classes","title":"Classes","text":"Name struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C."},{"location":"api/Files/external__impl__driver_8h/#detailed-description","title":"Detailed Description","text":"<p>External (platform/application) implementation hooks for OLED driver. </p> <p>This header defines structures used to pass platform-specific initialization data to the OLED driver. It references the project's I2C/IIC abstraction and the device interface declarations. The structures here are intended to be filled by the board/application code and then passed to the OLED driver during initialization. </p>"},{"location":"api/Files/external__impl__driver_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"driver/device/device_interface.h\"\n\n/* I2C/IIC backend (points to the project I2C driver) */\n#include \"../iic/iic.h\"\n\ntypedef struct\n{\n    CFBD_I2CHandle* i2cHandle;\n\n    uint32_t accepted_time_delay;\n\n    uint16_t device_address;\n\n    CFBD_OLED_DeviceSpecific* device_specifics;\n\n    void (*iic_transition_callback)(int status);\n} CFBD_OLED_IICInitsParams;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8c/","title":"lib/gpio/gpio-stm-impl.c","text":""},{"location":"api/Files/gpio-stm-impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"gpio-stm-impl.h\"\n\n#include \"cfbd_define.h\"\n#include \"gpio.h\"\n#include \"lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n\nstatic inline void GPIO_CLK_Enable(GPIO_TypeDef* GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n    }\n    else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_ENABLE();\n    }\n    else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n    }\n    else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_ENABLE();\n    }\n    else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_ENABLE();\n    }\n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_ENABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_ENABLE();\n    }\n#endif\n    else {\n        /* \u975e\u6cd5 GPIO\uff0c\u5ffd\u7565\u6216\u65ad\u8a00 */\n    }\n}\n\nstatic inline void GPIO_CLK_Disable(GPIO_TypeDef* GPIOx)\n{\n    if (GPIOx == GPIOA) {\n        __HAL_RCC_GPIOA_CLK_DISABLE();\n    }\n    else if (GPIOx == GPIOB) {\n        __HAL_RCC_GPIOB_CLK_DISABLE();\n    }\n    else if (GPIOx == GPIOC) {\n        __HAL_RCC_GPIOC_CLK_DISABLE();\n    }\n    else if (GPIOx == GPIOD) {\n        __HAL_RCC_GPIOD_CLK_DISABLE();\n    }\n    else if (GPIOx == GPIOE) {\n        __HAL_RCC_GPIOE_CLK_DISABLE();\n    }\n#if defined(GPIOF)\n    else if (GPIOx == GPIOF) {\n        __HAL_RCC_GPIOF_CLK_DISABLE();\n    }\n#endif\n#if defined(GPIOG)\n    else if (GPIOx == GPIOG) {\n        __HAL_RCC_GPIOG_CLK_DISABLE();\n    }\n#endif\n    else {\n    }\n}\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params)\n{\n    CFBD_ST_GPIOInitParams* st_params = (CFBD_ST_GPIOInitParams*) params;\n    handle-&gt;handle_internals_ = st_params-&gt;handle;\n    handle-&gt;pin_internals_ = st_params-&gt;pin;\n    GPIO_CLK_Enable(st_params-&gt;handle);\n    HAL_GPIO_Init(st_params-&gt;handle, &amp;st_params-&gt;initer);\n}\n\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle)\n{\n    HAL_GPIO_WritePin(handle-&gt;handle_internals_, handle-&gt;pin_internals_, GPIO_PIN_SET);\n}\n\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle)\n{\n    HAL_GPIO_WritePin(handle-&gt;handle_internals_, handle-&gt;pin_internals_, GPIO_PIN_RESET);\n}\n\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle)\n{\n    HAL_GPIO_TogglePin(handle-&gt;handle_internals_, handle-&gt;pin_internals_);\n}\n\nCFBD_Bool CFBD_GPIOReadPin(CFBD_GPIOHandle* handle)\n{\n    return HAL_GPIO_ReadPin(handle-&gt;handle_internals_, handle-&gt;pin_internals_) == GPIO_PIN_SET\n                   ? CFBD_TRUE\n                   : CFBD_FALSE;\n}\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/gpio-stm-impl_8h/","title":"lib/gpio/gpio-stm-impl.h","text":"<p>STM32 specific GPIO implementation details for CFBD.  More...</p>"},{"location":"api/Files/gpio-stm-impl_8h/#detailed-description","title":"Detailed Description","text":"<p>STM32 specific GPIO implementation details for CFBD. </p> <p>This header provides STM32-specific types used by the public GPIO abstraction (<code>[lib/gpio/gpio.h](Files/gpio_8h.md#file-gpio.h)</code>). It is included only when the <code>CFBD_IS_ST</code> macro selects the ST platform implementation. The declarations here reference HAL types from <code>stm32f1xx_hal_gpio.h</code>.</p> <p>The STM32 GPIO backend encapsulates STM HAL initialization parameters and provides the low-level interface for pin configuration, setting, clearing and toggling operations on STM32 microcontrollers.</p>"},{"location":"api/Files/gpio-stm-impl_8h/#stm32-gpio-usage","title":"STM32 GPIO Usage","text":"<p>To use STM32 GPIO functionality:</p> <ol> <li>Include <code>[gpio.h](Files/gpio_8h.md#file-gpio.h)</code> (which conditionally includes this file when CFBD_IS_ST is set)</li> <li>Populate a <code>CFBD_ST_GPIOInitParams</code> structure with HAL types</li> <li>Cast to <code>CFBD_GPIOInitParams</code> and pass to <code>CFBD_GPIOInit</code></li> </ol>"},{"location":"api/Files/gpio-stm-impl_8h/#stm32-gpio-example","title":"STM32 GPIO Example","text":"<pre><code>#include \"lib/gpio/gpio.h\"\n#include &lt;stm32f1xx_hal.h&gt;\n\n// Example: Initialize GPIOA pin 5 as output\nCFBD_ST_GPIOInitParams stm_params;\nstm_params.handle = GPIOA;\nstm_params.pin = GPIO_PIN_5;\nstm_params.initer.Mode = GPIO_MODE_OUTPUT_PP;\nstm_params.initer.Pull = GPIO_NOPULL;\nstm_params.initer.Speed = GPIO_SPEED_FREQ_HIGH;\n\nCFBD_GPIOHandle gpio_handle;\nCFBD_GPIOInit(&amp;gpio_handle, (CFBD_GPIOInitParams)&amp;stm_params);\n\n// Set pin high\nCFBD_GPIOSet(&amp;gpio_handle);\n</code></pre>"},{"location":"api/Files/gpio-stm-impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../config/lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    GPIO_TypeDef* handle;\n\n    uint32_t pin;\n\n    GPIO_InitTypeDef initer;\n} CFBD_ST_GPIOInitParams; \n\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/gpio_8h/","title":"lib/gpio/gpio.h","text":"<p>GPIO abstraction and helpers used by platform and application code.  More...</p>"},{"location":"api/Files/gpio_8h/#classes","title":"Classes","text":"Name struct CFBD_GPIOHandle Public GPIO handle combining platform handle and pin id."},{"location":"api/Files/gpio_8h/#types","title":"Types","text":"Name typedef uint32_t GPIO_PinType Integral type used to identify a single GPIO pin. typedef void * GPIO_TypeHandle Opaque handle type referring to platform-specific GPIO state. typedef void * CFBD_GPIOInitParams Opaque pointer type for GPIO initialization parameters."},{"location":"api/Files/gpio_8h/#functions","title":"Functions","text":"Name void CFBD_GPIOInit(CFBD_GPIOHandle * handle, CFBD_GPIOInitParams params)Initialize a GPIO handle for subsequent operations. void CFBD_GPIOSet(CFBD_GPIOHandle * handle)Set (drive high) the GPIO represented by <code>handle</code>. void CFBD_GPIOUnset(CFBD_GPIOHandle * handle)Clear (drive low) the GPIO represented by <code>handle</code>. void CFBD_GPIOToggle(CFBD_GPIOHandle * handle)Toggle the GPIO represented by <code>handle</code>. void CFBD_GPIOSetPin(CFBD_GPIOHandle * handle, CFBD_Bool status)Inline helper to set or clear a GPIO based on <code>status</code>. CFBD_Bool CFBD_GPIOReadPin(CFBD_GPIOHandle * handle)"},{"location":"api/Files/gpio_8h/#detailed-description","title":"Detailed Description","text":"<p>GPIO abstraction and helpers used by platform and application code. </p> <p>Note: The header assumes a platform-specific implementation header (e.g. <code>[gpio-stm-impl.h](Files/gpio-stm-impl_8h.md#file-gpio-stm-impl.h)</code>) supplies the necessary low-level definitions used by the functions declared here. </p> <p>This header provides a minimal, portable GPIO interface used by the CFBD project. It defines lightweight handle types, an initialization parameter opaque type and basic operations for setting, clearing and toggling GPIO lines. The concrete backing implementation is selected by platform macros (for example <code>CFBD_IS_ST</code> includes the STM implementation).</p> <p>The API is intentionally small to keep portability across targets straightforward; callers should ensure the provided handle is valid and the underlying platform driver has been initialized.</p>"},{"location":"api/Files/gpio_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/gpio_8h/#typedef-gpio_pintype","title":"typedef GPIO_PinType","text":"<pre><code>GPIO_PinType;\n</code></pre> <p>Integral type used to identify a single GPIO pin. </p> <p>The concrete meaning (bit-mask, number, encoded port/pin) depends on the platform implementation header. Use <code>GPIO_PinType</code> when storing or passing pin identifiers to the API. </p>"},{"location":"api/Files/gpio_8h/#typedef-gpio_typehandle","title":"typedef GPIO_TypeHandle","text":"<pre><code>GPIO_TypeHandle;\n</code></pre> <p>Opaque handle type referring to platform-specific GPIO state. </p> <p>Implementations should cast this pointer to an internal structure defined by the platform backend. The type is intentionally opaque to keep the public API independent from implementation details. </p>"},{"location":"api/Files/gpio_8h/#typedef-cfbd_gpioinitparams","title":"typedef CFBD_GPIOInitParams","text":"<pre><code>CFBD_GPIOInitParams;\n</code></pre> <p>Opaque pointer type for GPIO initialization parameters. </p> <p>Allows platform or application-specific initialization data to be passed to <code>CFBD_GPIOInit</code>. Cast to the concrete type expected by the underlying implementation when processing. </p>"},{"location":"api/Files/gpio_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/gpio_8h/#function-cfbd_gpioinit","title":"function CFBD_GPIOInit","text":"<pre><code>void CFBD_GPIOInit(\n    CFBD_GPIOHandle * handle,\n    CFBD_GPIOInitParams params\n)\n</code></pre> <p>Initialize a GPIO handle for subsequent operations. </p> <p>Parameters: </p> <ul> <li>handle Pointer to a <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code> structure to initialize. </li> <li>params Opaque initialization parameters (may be NULL). </li> </ul> <p>Performs any required platform-specific setup of <code>handle</code> using the supplied <code>params</code>. After successful initialization the <code>handle</code> should be ready for <code>CFBD_GPIOSet</code>/<code>CFBD_GPIOUnset</code>/<code>CFBD_GPIOToggle</code>.</p>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpioset","title":"function CFBD_GPIOSet","text":"<pre><code>void CFBD_GPIOSet(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Set (drive high) the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiounset","title":"function CFBD_GPIOUnset","text":"<pre><code>void CFBD_GPIOUnset(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Clear (drive low) the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiotoggle","title":"function CFBD_GPIOToggle","text":"<pre><code>void CFBD_GPIOToggle(\n    CFBD_GPIOHandle * handle\n)\n</code></pre> <p>Toggle the GPIO represented by <code>handle</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> </ul>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpiosetpin","title":"function CFBD_GPIOSetPin","text":"<pre><code>static inline void CFBD_GPIOSetPin(\n    CFBD_GPIOHandle * handle,\n    CFBD_Bool status\n)\n</code></pre> <p>Inline helper to set or clear a GPIO based on <code>status</code>. </p> <p>Parameters: </p> <ul> <li>handle Pointer to an initialized <code>[CFBD_GPIOHandle](Classes/structCFBD__GPIOHandle.md)</code>. </li> <li>status If <code>CFBD_TRUE</code>, set the pin; if <code>CFBD_FALSE</code>, clear it. </li> </ul> <p>Convenience wrapper that calls <code>CFBD_GPIOSet</code> when <code>status</code> is true, otherwise calls <code>CFBD_GPIOUnset</code>.</p>"},{"location":"api/Files/gpio_8h/#function-cfbd_gpioreadpin","title":"function CFBD_GPIOReadPin","text":"<pre><code>CFBD_Bool CFBD_GPIOReadPin(\n    CFBD_GPIOHandle * handle\n)\n</code></pre>"},{"location":"api/Files/gpio_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include \"../gpio/gpio-stm-impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n\ntypedef uint32_t GPIO_PinType;\n\ntypedef void* GPIO_TypeHandle;\n\ntypedef struct\n{\n    GPIO_TypeHandle handle_internals_;\n\n    GPIO_PinType pin_internals_;\n} CFBD_GPIOHandle;\n\ntypedef void* CFBD_GPIOInitParams;\n\nvoid CFBD_GPIOInit(CFBD_GPIOHandle* handle, CFBD_GPIOInitParams params);\n\nvoid CFBD_GPIOSet(CFBD_GPIOHandle* handle);\n\nvoid CFBD_GPIOUnset(CFBD_GPIOHandle* handle);\n\nvoid CFBD_GPIOToggle(CFBD_GPIOHandle* handle);\n\nstatic void inline CFBD_GPIOSetPin(CFBD_GPIOHandle* handle, CFBD_Bool status)\n{\n    status ? CFBD_GPIOSet(handle) : CFBD_GPIOUnset(handle);\n}\n\nCFBD_Bool CFBD_GPIOReadPin(CFBD_GPIOHandle* handle);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/grapgic__device_8c/","title":"lib/graphic/device/grapgic_device.c","text":""},{"location":"api/Files/grapgic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"graphic_device.h\"\n#include \"oled/oled_graphic_device.h\"\n\nvoid CFBDGraphic_BindDevice(CFBD_GraphicDevice* device,\n                            CFBDGraphic_DeviceType device_type,\n                            /*\n                             * OLED -&gt; CFBD_OLED*\n                             */\n                            CFBDGraphicDeviceHandle internal_handle)\n{\n    device-&gt;internal_handle = internal_handle;\n    device-&gt;device_type = device_type;\n    switch(device_type){\n        case OLED:\n            CFBDGraphic_BindOLEDAsDevice(device, internal_handle);\n            return;\n        default:\n            return;\n        break;\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8c/","title":"lib/iic/backend/i2c_stm_impl.c","text":""},{"location":"api/Files/i2c__stm__impl_8c/#functions","title":"Functions","text":"Name void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin)Initialize an STM32 I2C private structure. void stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef * hi2c) void stm32_i2c_on_error(I2C_HandleTypeDef * hi2c) int stm32_init(CFBD_I2CHandle * bus) int stm32_deinit(CFBD_I2CHandle * bus) int stm32_transfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms) int stm32_is_device_ready(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms) int stm32_recover_bus(CFBD_I2CHandle * bus) int stm32_get_error(CFBD_I2CHandle * bus) void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>."},{"location":"api/Files/i2c__stm__impl_8c/#attributes","title":"Attributes","text":"Name const CFBD_I2COperations stm32_i2c_ops"},{"location":"api/Files/i2c__stm__impl_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre> <p>Initialize an STM32 I2C private structure. </p> <p>Parameters: </p> <ul> <li>priv Pointer to the <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code> instance to initialize. </li> <li>hi2c Pointer to a valid <code>I2C_HandleTypeDef</code> (HAL instance). </li> <li>scl_port GPIO port used for SCL (e.g. GPIOA). </li> <li>scl_pin Pin mask/number for SCL. </li> <li>sda_port GPIO port used for SDA (e.g. GPIOA). </li> <li>sda_pin Pin mask/number for SDA. </li> </ul> <p>Populates the <code>priv</code> structure with supplied HAL handles and GPIO pins. This helper does not modify hardware state; it only prepares the private context prior to registering it with the public bus handle via <code>[stm32_i2c_bus_register()](Files/i2c__stm__impl_8h.md#function-stm32-i2c-bus-register)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_tx_cplt","title":"function stm32_i2c_on_master_tx_cplt","text":"<pre><code>void stm32_i2c_on_master_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_master_rx_cplt","title":"function stm32_i2c_on_master_rx_cplt","text":"<pre><code>void stm32_i2c_on_master_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_tx_cplt","title":"function stm32_i2c_on_mem_tx_cplt","text":"<pre><code>void stm32_i2c_on_mem_tx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_mem_rx_cplt","title":"function stm32_i2c_on_mem_rx_cplt","text":"<pre><code>void stm32_i2c_on_mem_rx_cplt(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_on_error","title":"function stm32_i2c_on_error","text":"<pre><code>void stm32_i2c_on_error(\n    I2C_HandleTypeDef * hi2c\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_init","title":"function stm32_init","text":"<pre><code>static int stm32_init(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_deinit","title":"function stm32_deinit","text":"<pre><code>static int stm32_deinit(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_transfer","title":"function stm32_transfer","text":"<pre><code>static int stm32_transfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_is_device_ready","title":"function stm32_is_device_ready","text":"<pre><code>static int stm32_is_device_ready(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_recover_bus","title":"function stm32_recover_bus","text":"<pre><code>static int stm32_recover_bus(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_get_error","title":"function stm32_get_error","text":"<pre><code>static int stm32_get_error(\n    CFBD_I2CHandle * bus\n)\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p> <p>Parameters: </p> <ul> <li>bus Pointer to the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> to register. </li> <li>priv Pointer to the initialized <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Associates the backend-private data with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. After registration the I2C handle's <code>ops</code> table should be populated by the STM32 backend implementation to provide operational functions (init, transfer, etc.).</p>"},{"location":"api/Files/i2c__stm__impl_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8c/#variable-stm32_i2c_ops","title":"variable stm32_i2c_ops","text":"<pre><code>static const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n</code></pre>"},{"location":"api/Files/i2c__stm__impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"i2c_stm_impl.h\"\n\n#include &lt;memory.h&gt;\n\n#include \"../iic.h\"\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin)\n{\n    priv-&gt;hi2c = hi2c;\n    priv-&gt;scl_pin = scl_pin;\n    priv-&gt;scl_port = scl_port;\n    priv-&gt;sda_port = sda_port;\n    priv-&gt;sda_pin = sda_pin;\n}\n\n/* forward declear */\nvoid stm32_i2c_on_master_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_master_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_tx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_mem_rx_cplt(I2C_HandleTypeDef* hi2c);\nvoid stm32_i2c_on_error(I2C_HandleTypeDef* hi2c);\n\n/* forward ops */\nstatic int stm32_init(CFBD_I2CHandle* bus);\nstatic int stm32_deinit(CFBD_I2CHandle* bus);\nstatic int\nstm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms);\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus);\nstatic int stm32_get_error(CFBD_I2CHandle* bus);\n\nstatic const CFBD_I2COperations stm32_i2c_ops = {\n        .init = stm32_init,\n        .deinit = stm32_deinit,\n        .transfer = stm32_transfer,\n        .is_device_ready = stm32_is_device_ready,\n        .recover_bus = stm32_recover_bus,\n        .get_error = stm32_get_error,\n        .tx_dma_start = NULL,\n        .rx_dma_start = NULL,\n};\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv)\n{\n    bus-&gt;ops = &amp;stm32_i2c_ops;\n    bus-&gt;private_handle = priv;\n}\n\n/* ---------- lifecycle ---------- */\nstatic int stm32_init(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    if (HAL_I2C_GetState(p-&gt;hi2c) == HAL_I2C_STATE_RESET) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_deinit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    if (HAL_I2C_DeInit(p-&gt;hi2c) != HAL_OK) {\n        p-&gt;last_err = I2C_ERR_IO;\n        return I2C_ERR_IO;\n    }\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_transfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle || !msgs || num &lt;= 0)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n\n    for (int i = 0; i &lt; num; ++i) {\n        CFBD_I2C_Message* m = &amp;msgs[i];\n        uint16_t devAddr = ((m-&gt;addr &amp; 0x7F) &lt;&lt; 1);\n        HAL_StatusTypeDef status;\n\n        if ((m-&gt;flags &amp; I2C_M_RD) == 0) {\n            /* write */\n            if (i + 1 &lt; num) {\n                CFBD_I2C_Message* next = &amp;msgs[i + 1];\n\n                if (!(next-&gt;flags &amp; I2C_M_RD) &amp;&amp; next-&gt;addr == m-&gt;addr &amp;&amp; m-&gt;len == 1 &amp;&amp;\n                    next-&gt;len == 1) {\n                    uint16_t memAddr = m-&gt;buf[0];\n\n                    if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                        status = HAL_I2C_Mem_Write_DMA(p-&gt;hi2c,\n                                                       devAddr,\n                                                       memAddr,\n                                                       I2C_MEMADD_SIZE_8BIT,\n                                                       next-&gt;buf,\n                                                       next-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        status = HAL_I2C_Mem_Write(p-&gt;hi2c,\n                                                   devAddr,\n                                                   memAddr,\n                                                   I2C_MEMADD_SIZE_8BIT,\n                                                   next-&gt;buf,\n                                                   next-&gt;len,\n                                                   timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n\n                    i++; // \u8df3\u8fc7\u4e0b\u4e00\u4e2a\u6d88\u606f\n                    continue;\n                }\n            }\n\n            if (p-&gt;hi2c-&gt;hdmatx != NULL) {\n                status = HAL_I2C_Master_Transmit_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Transmit(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n        else {\n            /* read */\n            if (i &gt; 0) {\n                CFBD_I2C_Message* prev = &amp;msgs[i - 1];\n                if (!(prev-&gt;flags &amp; I2C_M_RD) &amp;&amp; prev-&gt;addr == m-&gt;addr &amp;&amp;\n                    (prev-&gt;len == 1 || prev-&gt;len == 2)) {\n                    uint16_t mem = 0;\n                    if (prev-&gt;len == 1)\n                        mem = prev-&gt;buf[0];\n                    else\n                        mem = ((uint16_t) prev-&gt;buf[0] &lt;&lt; 8) | prev-&gt;buf[1];\n                    uint16_t memadd =\n                            (prev-&gt;len == 1) ? I2C_MEMADD_SIZE_8BIT : I2C_MEMADD_SIZE_16BIT;\n\n                    if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                        status =\n                                HAL_I2C_Mem_Read_DMA(p-&gt;hi2c, devAddr, mem, memadd, m-&gt;buf, m-&gt;len);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n\n                        uint32_t tickstart = HAL_GetTick();\n                        while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                            if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                                p-&gt;last_err = I2C_ERR_TIMEOUT;\n                                return I2C_ERR_TIMEOUT;\n                            }\n                        }\n                    }\n                    else {\n                        status = HAL_I2C_Mem_Read(p-&gt;hi2c,\n                                                  devAddr,\n                                                  mem,\n                                                  memadd,\n                                                  m-&gt;buf,\n                                                  m-&gt;len,\n                                                  timeout_ms);\n                        if (status != HAL_OK) {\n                            p-&gt;last_err = I2C_ERR_IO;\n                            return I2C_ERR_IO;\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            // \u666e\u901a\u8bfb\n            if (p-&gt;hi2c-&gt;hdmarx != NULL) {\n                status = HAL_I2C_Master_Receive_DMA(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n\n                uint32_t tickstart = HAL_GetTick();\n                while (HAL_I2C_GetState(p-&gt;hi2c) != HAL_I2C_STATE_READY) {\n                    if ((HAL_GetTick() - tickstart) &gt; timeout_ms) {\n                        p-&gt;last_err = I2C_ERR_TIMEOUT;\n                        return I2C_ERR_TIMEOUT;\n                    }\n                }\n            }\n            else {\n                status = HAL_I2C_Master_Receive(p-&gt;hi2c, devAddr, m-&gt;buf, m-&gt;len, timeout_ms);\n                if (status != HAL_OK) {\n                    p-&gt;last_err = I2C_ERR_IO;\n                    return I2C_ERR_IO;\n                }\n            }\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int\nstm32_is_device_ready(CFBD_I2CHandle* bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;hi2c)\n        return I2C_ERR_INVAL;\n    uint16_t devAddr = (addr &amp; 0x7F) &lt;&lt; 1;\n    if (HAL_I2C_IsDeviceReady(p-&gt;hi2c, devAddr, trials, timeout_ms) == HAL_OK) {\n        p-&gt;last_err = I2C_OK;\n        return I2C_OK;\n    }\n    p-&gt;last_err = I2C_ERR_IO;\n    return I2C_ERR_IO;\n}\n\nstatic int stm32_recover_bus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    if (!p-&gt;scl_port || !p-&gt;sda_port)\n        return I2C_ERR_INVAL;\n\n    if (p-&gt;hi2c)\n        HAL_I2C_DeInit(p-&gt;hi2c);\n\n    GPIO_InitTypeDef gpio = {0};\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_OUTPUT_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    for (int i = 0; i &lt; 9; ++i) {\n        if (HAL_GPIO_ReadPin(p-&gt;sda_port, p-&gt;sda_pin) == GPIO_PIN_SET)\n            break;\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_RESET);\n        HAL_Delay(1);\n        HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n        HAL_Delay(1);\n    }\n\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_RESET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;scl_port, p-&gt;scl_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n    HAL_GPIO_WritePin(p-&gt;sda_port, p-&gt;sda_pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n\n    gpio.Pin = p-&gt;scl_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;scl_port, &amp;gpio);\n\n    gpio.Pin = p-&gt;sda_pin;\n    gpio.Mode = GPIO_MODE_AF_OD;\n    gpio.Pull = GPIO_NOPULL;\n    gpio.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(p-&gt;sda_port, &amp;gpio);\n\n    if (p-&gt;hi2c) {\n        if (HAL_I2C_Init(p-&gt;hi2c) != HAL_OK) {\n            p-&gt;last_err = I2C_ERR_IO;\n            return I2C_ERR_IO;\n        }\n    }\n\n    p-&gt;last_err = I2C_OK;\n    return I2C_OK;\n}\n\nstatic int stm32_get_error(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;private_handle)\n        return I2C_ERR_INVAL;\n    CFBD_ST_I2CPrivate* p = (CFBD_ST_I2CPrivate*) bus-&gt;private_handle;\n    return p-&gt;last_err;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/i2c__stm__impl_8h/","title":"lib/iic/backend/i2c_stm_impl.h","text":"<p>STM32 HAL-based I2C backend private types and helpers.  More...</p>"},{"location":"api/Files/i2c__stm__impl_8h/#classes","title":"Classes","text":"Name struct CFBD_ST_I2CPrivate Backend-private state for the STM32 I2C implementation."},{"location":"api/Files/i2c__stm__impl_8h/#functions","title":"Functions","text":"Name I2C_HandleTypeDef * native_handle(CFBD_ST_I2CPrivate * priv)Helper to obtain the native HAL I2C handle from the private struct. void init_stm32_i2c_privates(CFBD_ST_I2CPrivate * priv, I2C_HandleTypeDef * hi2c, GPIO_TypeDef * scl_port, uint16_t scl_pin, GPIO_TypeDef * sda_port, uint16_t sda_pin)Initialize an STM32 I2C private structure. void stm32_i2c_bus_register(CFBD_I2CHandle * bus, CFBD_ST_I2CPrivate * priv)Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>."},{"location":"api/Files/i2c__stm__impl_8h/#detailed-description","title":"Detailed Description","text":"<p>STM32 HAL-based I2C backend private types and helpers. </p> <p>Note: This header depends on STM32 HAL types such as <code>I2C_HandleTypeDef</code> and <code>GPIO_TypeDef</code> and is only relevant when building for ST platforms. </p> <p>Provides the STM32-specific private handle used by the project's CFBD I2C abstraction. The private handle contains HAL peripheral references and GPIO pin information used for optional bus recovery or low-level operations. Utility functions are provided to initialize the private structure and register it with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/i2c__stm__impl_8h/#function-native_handle","title":"function native_handle","text":"<pre><code>static inline I2C_HandleTypeDef * native_handle(\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Helper to obtain the native HAL I2C handle from the private struct. </p> <p>Parameters: </p> <ul> <li>priv Pointer to <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Return: I2C_HandleTypeDef* Native HAL handle or NULL if <code>priv</code> is NULL. </p>"},{"location":"api/Files/i2c__stm__impl_8h/#function-init_stm32_i2c_privates","title":"function init_stm32_i2c_privates","text":"<pre><code>void init_stm32_i2c_privates(\n    CFBD_ST_I2CPrivate * priv,\n    I2C_HandleTypeDef * hi2c,\n    GPIO_TypeDef * scl_port,\n    uint16_t scl_pin,\n    GPIO_TypeDef * sda_port,\n    uint16_t sda_pin\n)\n</code></pre> <p>Initialize an STM32 I2C private structure. </p> <p>Parameters: </p> <ul> <li>priv Pointer to the <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code> instance to initialize. </li> <li>hi2c Pointer to a valid <code>I2C_HandleTypeDef</code> (HAL instance). </li> <li>scl_port GPIO port used for SCL (e.g. GPIOA). </li> <li>scl_pin Pin mask/number for SCL. </li> <li>sda_port GPIO port used for SDA (e.g. GPIOA). </li> <li>sda_pin Pin mask/number for SDA. </li> </ul> <p>Populates the <code>priv</code> structure with supplied HAL handles and GPIO pins. This helper does not modify hardware state; it only prepares the private context prior to registering it with the public bus handle via <code>[stm32_i2c_bus_register()](Files/i2c__stm__impl_8h.md#function-stm32-i2c-bus-register)</code>.</p>"},{"location":"api/Files/i2c__stm__impl_8h/#function-stm32_i2c_bus_register","title":"function stm32_i2c_bus_register","text":"<pre><code>void stm32_i2c_bus_register(\n    CFBD_I2CHandle * bus,\n    CFBD_ST_I2CPrivate * priv\n)\n</code></pre> <p>Register the STM32 private context with a <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p> <p>Parameters: </p> <ul> <li>bus Pointer to the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code> to register. </li> <li>priv Pointer to the initialized <code>[CFBD_ST_I2CPrivate](Classes/structCFBD__ST__I2CPrivate.md)</code>. </li> </ul> <p>Associates the backend-private data with the public <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. After registration the I2C handle's <code>ops</code> table should be populated by the STM32 backend implementation to provide operational functions (init, transfer, etc.).</p>"},{"location":"api/Files/i2c__stm__impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"../iic.h\"\n\ntypedef struct\n{\n    I2C_HandleTypeDef* hi2c;\n\n    GPIO_TypeDef* scl_port;\n\n    uint16_t scl_pin;\n\n    GPIO_TypeDef* sda_port;\n\n    uint16_t sda_pin;\n\n    int last_err;\n} CFBD_ST_I2CPrivate;\n\nstatic inline I2C_HandleTypeDef* native_handle(CFBD_ST_I2CPrivate* priv)\n{\n    return priv ? priv-&gt;hi2c : NULL;\n}\n\nvoid init_stm32_i2c_privates(CFBD_ST_I2CPrivate* priv,\n                             I2C_HandleTypeDef* hi2c,\n                             GPIO_TypeDef* scl_port,\n                             uint16_t scl_pin,\n                             GPIO_TypeDef* sda_port,\n                             uint16_t sda_pin);\n\nvoid stm32_i2c_bus_register(CFBD_I2CHandle* bus, CFBD_ST_I2CPrivate* priv);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/icon__text__menu__demo_8c/","title":"lib/graphic/fast_test/demos/demo_icontext_menu/icon_text_menu_demo.c","text":"<p>Icon-text menu demonstration (OOP C \u98ce\u683c)  More...</p>"},{"location":"api/Files/icon__text__menu__demo_8c/#functions","title":"Functions","text":"Name void on_home_selected(void * user_data)Menu item callback - Home. void on_health_selected(void * user_data)Menu item callback - Health. void on_settings_selected(void * user_data)Menu item callback - Settings. void on_messages_selected(void * user_data)Menu item callback - Messages. void icontext_menu_demo(CFBD_GraphicDevice * dev)Icon-text menu demonstration (OOP C style)"},{"location":"api/Files/icon__text__menu__demo_8c/#attributes","title":"Attributes","text":"Name uint8_t[72] icontext_icon_home uint8_t[72] icontext_icon_health uint8_t[72] icontext_icon_settings uint8_t[72] icontext_icon_messages"},{"location":"api/Files/icon__text__menu__demo_8c/#detailed-description","title":"Detailed Description","text":"<p>Icon-text menu demonstration (OOP C \u98ce\u683c) </p> <p>\u5c55\u793a\u5982\u4f55\u521d\u59cb\u5316\u548c\u4f7f\u7528\u56fe\u6807\u6587\u5b57\u83dc\u5355\u7cfb\u7edf</p> <p>Icon Design Notes (OLED Page-Based Format):</p> <ul> <li>24x24 pixels icon for 128x64 OLED display</li> <li>OLED Memory Layout: Pages (vertical 8-pixel rows) \u00d7 Columns</li> <li>24 pixels high = 3 pages (0-7, 8-15, 16-23)</li> <li>24 pixels wide = 24 columns</li> <li>Total: 24 bytes/page \u00d7 3 pages = 72 bytes</li> <li>Each byte: 8 vertical pixels (MSB at top, LSB at bottom)</li> <li>Layout: Page0[0..23] + Page1[0..23] + Page2[0..23] </li> </ul>"},{"location":"api/Files/icon__text__menu__demo_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/icon__text__menu__demo_8c/#function-on_home_selected","title":"function on_home_selected","text":"<pre><code>void on_home_selected(\n    void * user_data\n)\n</code></pre> <p>Menu item callback - Home. </p>"},{"location":"api/Files/icon__text__menu__demo_8c/#function-on_health_selected","title":"function on_health_selected","text":"<pre><code>void on_health_selected(\n    void * user_data\n)\n</code></pre> <p>Menu item callback - Health. </p>"},{"location":"api/Files/icon__text__menu__demo_8c/#function-on_settings_selected","title":"function on_settings_selected","text":"<pre><code>void on_settings_selected(\n    void * user_data\n)\n</code></pre> <p>Menu item callback - Settings. </p>"},{"location":"api/Files/icon__text__menu__demo_8c/#function-on_messages_selected","title":"function on_messages_selected","text":"<pre><code>void on_messages_selected(\n    void * user_data\n)\n</code></pre> <p>Menu item callback - Messages. </p>"},{"location":"api/Files/icon__text__menu__demo_8c/#function-icontext_menu_demo","title":"function icontext_menu_demo","text":"<pre><code>void icontext_menu_demo(\n    CFBD_GraphicDevice * dev\n)\n</code></pre> <p>Icon-text menu demonstration (OOP C style) </p> <p>Demonstrates:</p> <ol> <li>Menu initialization</li> <li>Adding menu items via operations table</li> <li>Auto-demo of scrolling and selection with animated frame </li> </ol>"},{"location":"api/Files/icon__text__menu__demo_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/icon__text__menu__demo_8c/#variable-icontext_icon_home","title":"variable icontext_icon_home","text":"<pre><code>uint8_t[72] icontext_icon_home;\n</code></pre>"},{"location":"api/Files/icon__text__menu__demo_8c/#variable-icontext_icon_health","title":"variable icontext_icon_health","text":"<pre><code>uint8_t[72] icontext_icon_health;\n</code></pre>"},{"location":"api/Files/icon__text__menu__demo_8c/#variable-icontext_icon_settings","title":"variable icontext_icon_settings","text":"<pre><code>uint8_t[72] icontext_icon_settings;\n</code></pre>"},{"location":"api/Files/icon__text__menu__demo_8c/#variable-icontext_icon_messages","title":"variable icontext_icon_messages","text":"<pre><code>uint8_t[72] icontext_icon_messages;\n</code></pre>"},{"location":"api/Files/icon__text__menu__demo_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/menu/icontext_menu.h\"\n\nextern uint8_t icontext_icon_home[72];\nextern uint8_t icontext_icon_health[72];\nextern uint8_t icontext_icon_settings[72];\nextern uint8_t icontext_icon_messages[72];\n\nvoid on_home_selected(void* user_data)\n{\n    (void) user_data;\n    // Handle home selection\n}\n\nvoid on_health_selected(void* user_data)\n{\n    (void) user_data;\n    // Handle health selection\n}\n\nvoid on_settings_selected(void* user_data)\n{\n    (void) user_data;\n    // Handle settings selection\n}\n\nvoid on_messages_selected(void* user_data)\n{\n    (void) user_data;\n    // Handle messages selection\n}\n\nvoid icontext_menu_demo(CFBD_GraphicDevice* dev)\n{\n    CFBD_IconTextMenuItem items_buffer[6]; // Max 6 items on stack\n    CFBD_IconTextMenu menu;\n\n    CFBDGraphicRect viewport = {\n            .tl = {.x = 0, .y = 8},   // Top Y=8\n            .br = {.x = 128, .y = 56} // Bottom Y=56 (128x64 display)\n    };\n\n    CFBD_InitIconTextMenu(&amp;menu, dev, &amp;viewport, items_buffer, 6);\n\n    menu.operations-&gt;set_dimensions(&amp;menu,\n                                    40,  // Item width\n                                    36,  // Item height\n                                    10); // Spacing\n\n    menu.operations-&gt;set_circular(&amp;menu, CFBD_TRUE);\n\n    menu.operations-&gt;set_selection_border(&amp;menu, 1);\n\n    /* =======================\n     * Step 4: Configure icon size\n     * ======================= */\n    CFBDGraphicSize icon_size = {.width = 24, .height = 24}; // 24x24 icon\n\n    // Add \"Home\" item (via operations table)\n    CFBD_MenuItemCallbackPack home_cb = {.callback = on_home_selected, .user_data = NULL};\n    menu.operations-&gt;add_item(&amp;menu, \"Home\", icontext_icon_home, &amp;icon_size, &amp;home_cb);\n\n    // Add \"Health\" item\n    CFBD_MenuItemCallbackPack health_cb = {.callback = on_health_selected, .user_data = NULL};\n    menu.operations-&gt;add_item(&amp;menu, \"Health\", icontext_icon_health, &amp;icon_size, &amp;health_cb);\n\n    // Add \"Settings\" item\n    CFBD_MenuItemCallbackPack settings_cb = {.callback = on_settings_selected, .user_data = NULL};\n    menu.operations-&gt;add_item(&amp;menu, \"Settings\", icontext_icon_settings, &amp;icon_size, &amp;settings_cb);\n\n    // Add \"Messages\" item\n    CFBD_MenuItemCallbackPack messages_cb = {.callback = on_messages_selected, .user_data = NULL};\n    menu.operations-&gt;add_item(&amp;menu, \"Messages\", icontext_icon_messages, &amp;icon_size, &amp;messages_cb);\n\n    // Select first item initially (\u81ea\u52a8\u5c45\u4e2d)\n    menu.operations-&gt;select_index(&amp;menu, 0);\n    menu.operations-&gt;immediate_draw(&amp;menu);\n\n    /* =======================\n     * Step 5: Demo loop - \u5c55\u793a\u6240\u6709\u56fe\u6807\uff0c\u5e26\u52a8\u753b\u8fb9\u6846\n     * ======================= */\n    // \u521d\u59cb\u505c\u7559\u5728\u7b2c\u4e00\u4e2a\u56fe\u6807 (index 0)\n    system_delay_ms(500);\n\n    // \u5411\u53f3\u6eda\u52a8\uff1a0 -&gt; 1 -&gt; 2 -&gt; 3 (\u5c55\u793a\u6240\u67094\u4e2a\u56fe\u6807)\n    // animate_scroll\u4f1a\u81ea\u52a8\u7ed8\u5236\u52a8\u753b\uff0c\u5305\u62ec\u8fb9\u6846\n    for (size_t i = 0; i &lt; menu.item_count - 1; ++i) {\n        menu.operations-&gt;animate_scroll(&amp;menu, CFBD_ICONTEXT_SCROLL_RIGHT);\n        system_delay_ms(500); // \u6bcf\u4e2a\u56fe\u6807\u505c\u75592\u79d2\n    }\n\n    // \u5728\u6700\u540e\u4e00\u4e2a\u56fe\u6807\u505c\u7559\n    system_delay_ms(500);\n\n    // \u5411\u5de6\u6eda\u52a8\uff1a3 -&gt; 2 -&gt; 1 -&gt; 0 (\u8fd4\u56de\u7b2c\u4e00\u4e2a)\n    for (size_t i = 0; i &lt; menu.item_count - 1; ++i) {\n        menu.operations-&gt;animate_scroll(&amp;menu, CFBD_ICONTEXT_SCROLL_LEFT);\n        system_delay_ms(500);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/icons_8c/","title":"lib/graphic/fast_test/demos/demo_icontext_menu/icons.c","text":""},{"location":"api/Files/icons_8c/#attributes","title":"Attributes","text":"Name uint8_t[72] icontext_icon_home uint8_t[72] icontext_icon_health uint8_t[72] icontext_icon_settings uint8_t[72] icontext_icon_messages"},{"location":"api/Files/icons_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/icons_8c/#variable-icontext_icon_home","title":"variable icontext_icon_home","text":"<pre><code>uint8_t[72] icontext_icon_home = {\n0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0x70, 0xf0, 0xb8, 0xb8, 0xdc, 0xdc, 0xb8, 0xb8, 0x70, 0x70, 0xe0, 0xf0, 0xf0, 0xc0, 0x80, 0x80, 0x00, \n0x03, 0x03, 0x03, 0xfd, 0xfc, 0x7e, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0x7f, 0xfe, 0xfe, 0xfd, 0x01, 0x03, 0x03, 0x03, \n0x00, 0x00, 0x00, 0x1f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x38, 0x38, 0x3f, 0x38, 0x3b, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, \n};\n</code></pre>"},{"location":"api/Files/icons_8c/#variable-icontext_icon_health","title":"variable icontext_icon_health","text":"<pre><code>uint8_t[72] icontext_icon_health = {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x1f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\n};\n</code></pre>"},{"location":"api/Files/icons_8c/#variable-icontext_icon_settings","title":"variable icontext_icon_settings","text":"<pre><code>uint8_t[72] icontext_icon_settings = {\n0x00, 0x00, 0x00, 0x00, 0xe0, 0x30, 0x20, 0x60, 0x38, 0x3c, 0x0c, 0x0c, 0x18, 0x10, 0x10, 0x08, 0x08, 0xf0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x3c, 0x6c, 0xe7, 0x83, 0x00, 0x00, 0x3c, 0x46, 0x83, 0x81, 0x81, 0x83, 0x46, 0x3c, 0x00, 0x00, 0x01, 0x3d, 0xef, 0xe7, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x02, 0x07, 0x0c, 0x0c, 0x04, 0x1c, 0x38, 0x20, 0x20, 0x18, 0x08, 0x18, 0x30, 0x10, 0x1e, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, \n};\n</code></pre>"},{"location":"api/Files/icons_8c/#variable-icontext_icon_messages","title":"variable icontext_icon_messages","text":"<pre><code>uint8_t[72] icontext_icon_messages = {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0xf0, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n};\n</code></pre>"},{"location":"api/Files/icons_8c/#source-code","title":"Source code","text":"<pre><code>// clang-format off\n#include &lt;stdint.h&gt;\n\n/* 24x24 Home icon \u2014 bit-reversed to LSB-top (72 bytes) */\nuint8_t icontext_icon_home[72] = {\n0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0x70, 0xf0, 0xb8, 0xb8, 0xdc, 0xdc, 0xb8, 0xb8, 0x70, 0x70, 0xe0, 0xf0, 0xf0, 0xc0, 0x80, 0x80, 0x00, \n0x03, 0x03, 0x03, 0xfd, 0xfc, 0x7e, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0x7f, 0xfe, 0xfe, 0xfd, 0x01, 0x03, 0x03, 0x03, \n0x00, 0x00, 0x00, 0x1f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x38, 0x38, 0x3f, 0x38, 0x3b, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, \n};\n\n/* 24x24 Health (heart) icon - \u66f4\u5706\u6da6\u5bf9\u79f0 */\nuint8_t icontext_icon_health[72] = {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x1f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\n};\n\n/* 24x24 Settings (gear) icon - \u66f4\u6e05\u6670\u7684\u9f7f\u8f6e */\nuint8_t icontext_icon_settings[72] = {\n0x00, 0x00, 0x00, 0x00, 0xe0, 0x30, 0x20, 0x60, 0x38, 0x3c, 0x0c, 0x0c, 0x18, 0x10, 0x10, 0x08, 0x08, 0xf0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x3c, 0x6c, 0xe7, 0x83, 0x00, 0x00, 0x3c, 0x46, 0x83, 0x81, 0x81, 0x83, 0x46, 0x3c, 0x00, 0x00, 0x01, 0x3d, 0xef, 0xe7, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x02, 0x07, 0x0c, 0x0c, 0x04, 0x1c, 0x38, 0x20, 0x20, 0x18, 0x08, 0x18, 0x30, 0x10, 0x1e, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, \n};\n\n/* 24x24 Messages (envelope) icon - \u66f4\u7acb\u4f53\u7684\u4fe1\u5c01 */\nuint8_t icontext_icon_messages[72] = {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0xf0, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n};\n// clang-format on\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/icontext__menu_8c/","title":"lib/graphic/widget/menu/icontext_menu.c","text":"<p>Icon-text menu widget implementation.  More...</p>"},{"location":"api/Files/icontext__menu_8c/#functions","title":"Functions","text":"Name int16_t _calculate_item_x(CFBD_IconTextMenu * pMenu, size_t index)Calculate the X position for a menu item based on its index and scroll offset. uint16_t _calculate_item_y(CFBD_IconTextMenu * pMenu)Calculate the Y position for a menu item (center vertically in viewport) void _update_icon_widget(CFBD_IconTextMenu * pMenu, CFBD_IconTextMenuItem * item, int16_t item_x) uint16_t _calculate_text_width(const char * text, uint8_t font_size)Calculate text pixel width (\u9700\u8981\u6839\u636e\u5b9e\u9645\u5b57\u4f53\u7cfb\u7edf\u5b9e\u73b0) void _update_text_widget(CFBD_IconTextMenu * pMenu, CFBD_IconTextMenuItem * item, int16_t item_x) CFBD_Bool _is_item_visible(CFBD_IconTextMenu * pMenu, CFBD_IconTextMenuItem * item, int16_t item_x)Check if item's ICON is within visible viewport. void _draw_selection_frame(CFBD_IconTextMenu * pMenu, CFBD_IconTextMenuItem * item, int16_t item_x)Draw selection frame around the selected item's ICON only (not text) void _center_selected_item(CFBD_IconTextMenu * pMenu)Update scroll offset to center the selected item. CFBD_Bool CFBD_IconTextMenuAddItem(CFBD_IconTextMenu * pMenu, const char * label, uint8_t * icon_bitmap, CFBDGraphicSize * icon_size, CFBD_MenuItemCallbackPack * callback) void CFBD_IconTextMenuScroll(CFBD_IconTextMenu * pMenu, CFBD_IconTextScrollDirection direction) CFBD_Bool CFBD_IconTextMenuSelectIndex(CFBD_IconTextMenu * pMenu, int index) void CFBD_IconTextMenuActivateCurrent(CFBD_IconTextMenu * pMenu) void CFBD_IconTextMenuDraw(CFBD_IconTextMenu * pMenu) CFBD_Bool CFBD_IconTextMenuUpdate(CFBD_IconTextMenu * pMenu, uint32_t delta_ms) void CFBD_IconTextMenuSetDimensions(CFBD_IconTextMenu * pMenu, SizeBaseType width, SizeBaseType height, uint16_t spacing) CFBD_IconTextMenuItem * CFBD_IconTextMenuGetSelectedItem(CFBD_IconTextMenu * pMenu) CFBD_IconTextMenuItem * CFBD_IconTextMenuGetItem(CFBD_IconTextMenu * pMenu, int index) void CFBD_IconTextMenuSetCircular(CFBD_IconTextMenu * pMenu, CFBD_Bool is_circular) void CFBD_IconTextMenuSetSelectionBorder(CFBD_IconTextMenu * pMenu, uint16_t border_width) void CFBD_IconTextMenuAnimateScroll(CFBD_IconTextMenu * pMenu, CFBD_IconTextScrollDirection direction)"},{"location":"api/Files/icontext__menu_8c/#attributes","title":"Attributes","text":"Name CFBD_IconTextMenuOps _cfbd_icontext_menu_ops"},{"location":"api/Files/icontext__menu_8c/#detailed-description","title":"Detailed Description","text":"<p>Icon-text menu widget implementation. </p> <p>Implementation of horizontal scrollable menu with icon+text items, smooth animations, and touch-based navigation. </p>"},{"location":"api/Files/icontext__menu_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/icontext__menu_8c/#function-_calculate_item_x","title":"function _calculate_item_x","text":"<pre><code>static int16_t _calculate_item_x(\n    CFBD_IconTextMenu * pMenu,\n    size_t index\n)\n</code></pre> <p>Calculate the X position for a menu item based on its index and scroll offset. </p> <p>Parameters: </p> <ul> <li>pMenu - Menu structure </li> <li>index - Item index </li> </ul> <p>Return: int16_t - Calculated X position (\u53ef\u4ee5\u4e3a\u8d1f\u6570) </p>"},{"location":"api/Files/icontext__menu_8c/#function-_calculate_item_y","title":"function _calculate_item_y","text":"<pre><code>static uint16_t _calculate_item_y(\n    CFBD_IconTextMenu * pMenu\n)\n</code></pre> <p>Calculate the Y position for a menu item (center vertically in viewport) </p> <p>Parameters: </p> <ul> <li>pMenu - Menu structure </li> </ul> <p>Return: uint16_t - Calculated Y position </p>"},{"location":"api/Files/icontext__menu_8c/#function-_update_icon_widget","title":"function _update_icon_widget","text":"<pre><code>static void _update_icon_widget(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextMenuItem * item,\n    int16_t item_x\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-_calculate_text_width","title":"function _calculate_text_width","text":"<pre><code>static uint16_t _calculate_text_width(\n    const char * text,\n    uint8_t font_size\n)\n</code></pre> <p>Calculate text pixel width (\u9700\u8981\u6839\u636e\u5b9e\u9645\u5b57\u4f53\u7cfb\u7edf\u5b9e\u73b0) </p> <p>Parameters: </p> <ul> <li>text - Text string </li> <li>font_size - Font size </li> </ul> <p>Return: uint16_t - Text width in pixels </p>"},{"location":"api/Files/icontext__menu_8c/#function-_update_text_widget","title":"function _update_text_widget","text":"<pre><code>static void _update_text_widget(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextMenuItem * item,\n    int16_t item_x\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-_is_item_visible","title":"function _is_item_visible","text":"<pre><code>static CFBD_Bool _is_item_visible(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextMenuItem * item,\n    int16_t item_x\n)\n</code></pre> <p>Check if item's ICON is within visible viewport. </p> <p>Parameters: </p> <ul> <li>pMenu - Menu structure </li> <li>item - Menu item </li> <li>item_x - Item's calculated X position </li> </ul> <p>Return: CFBD_Bool - CFBD_TRUE if icon is visible </p>"},{"location":"api/Files/icontext__menu_8c/#function-_draw_selection_frame","title":"function _draw_selection_frame","text":"<pre><code>static void _draw_selection_frame(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextMenuItem * item,\n    int16_t item_x\n)\n</code></pre> <p>Draw selection frame around the selected item's ICON only (not text) </p> <p>Parameters: </p> <ul> <li>pMenu - Menu structure </li> <li>item - Current item </li> <li>item_x - Item's X position </li> </ul>"},{"location":"api/Files/icontext__menu_8c/#function-_center_selected_item","title":"function _center_selected_item","text":"<pre><code>static void _center_selected_item(\n    CFBD_IconTextMenu * pMenu\n)\n</code></pre> <p>Update scroll offset to center the selected item. </p> <p>Parameters: </p> <ul> <li>pMenu - Menu structure </li> </ul>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuadditem","title":"function CFBD_IconTextMenuAddItem","text":"<pre><code>static CFBD_Bool CFBD_IconTextMenuAddItem(\n    CFBD_IconTextMenu * pMenu,\n    const char * label,\n    uint8_t * icon_bitmap,\n    CFBDGraphicSize * icon_size,\n    CFBD_MenuItemCallbackPack * callback\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuscroll","title":"function CFBD_IconTextMenuScroll","text":"<pre><code>static void CFBD_IconTextMenuScroll(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextScrollDirection direction\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuselectindex","title":"function CFBD_IconTextMenuSelectIndex","text":"<pre><code>static CFBD_Bool CFBD_IconTextMenuSelectIndex(\n    CFBD_IconTextMenu * pMenu,\n    int index\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuactivatecurrent","title":"function CFBD_IconTextMenuActivateCurrent","text":"<pre><code>static void CFBD_IconTextMenuActivateCurrent(\n    CFBD_IconTextMenu * pMenu\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenudraw","title":"function CFBD_IconTextMenuDraw","text":"<pre><code>static void CFBD_IconTextMenuDraw(\n    CFBD_IconTextMenu * pMenu\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuupdate","title":"function CFBD_IconTextMenuUpdate","text":"<pre><code>static CFBD_Bool CFBD_IconTextMenuUpdate(\n    CFBD_IconTextMenu * pMenu,\n    uint32_t delta_ms\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenusetdimensions","title":"function CFBD_IconTextMenuSetDimensions","text":"<pre><code>static void CFBD_IconTextMenuSetDimensions(\n    CFBD_IconTextMenu * pMenu,\n    SizeBaseType width,\n    SizeBaseType height,\n    uint16_t spacing\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenugetselecteditem","title":"function CFBD_IconTextMenuGetSelectedItem","text":"<pre><code>static CFBD_IconTextMenuItem * CFBD_IconTextMenuGetSelectedItem(\n    CFBD_IconTextMenu * pMenu\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenugetitem","title":"function CFBD_IconTextMenuGetItem","text":"<pre><code>static CFBD_IconTextMenuItem * CFBD_IconTextMenuGetItem(\n    CFBD_IconTextMenu * pMenu,\n    int index\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenusetcircular","title":"function CFBD_IconTextMenuSetCircular","text":"<pre><code>static void CFBD_IconTextMenuSetCircular(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_Bool is_circular\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenusetselectionborder","title":"function CFBD_IconTextMenuSetSelectionBorder","text":"<pre><code>static void CFBD_IconTextMenuSetSelectionBorder(\n    CFBD_IconTextMenu * pMenu,\n    uint16_t border_width\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#function-cfbd_icontextmenuanimatescroll","title":"function CFBD_IconTextMenuAnimateScroll","text":"<pre><code>static void CFBD_IconTextMenuAnimateScroll(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_IconTextScrollDirection direction\n)\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/icontext__menu_8c/#variable-_cfbd_icontext_menu_ops","title":"variable _cfbd_icontext_menu_ops","text":"<pre><code>static CFBD_IconTextMenuOps _cfbd_icontext_menu_ops = {\n        .add_item = CFBD_IconTextMenuAddItem,\n        .scroll = CFBD_IconTextMenuScroll,\n        .select_index = CFBD_IconTextMenuSelectIndex,\n        .activate_current = CFBD_IconTextMenuActivateCurrent,\n        .immediate_draw = CFBD_IconTextMenuDraw,\n        .update = CFBD_IconTextMenuUpdate,\n        .set_dimensions = CFBD_IconTextMenuSetDimensions,\n        .get_selected_item = CFBD_IconTextMenuGetSelectedItem,\n        .get_item = CFBD_IconTextMenuGetItem,\n        .set_circular = CFBD_IconTextMenuSetCircular,\n        .set_selection_border = CFBD_IconTextMenuSetSelectionBorder,\n        .animate_scroll = CFBD_IconTextMenuAnimateScroll};\n</code></pre>"},{"location":"api/Files/icontext__menu_8c/#source-code","title":"Source code","text":"<pre><code>#include \"icontext_menu.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/rectangle.h\"\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/base_support/common/helpers.h\"\n#include \"widget/text_config.h\"\n\nstatic int16_t _calculate_item_x(CFBD_IconTextMenu* pMenu, size_t index)\n{\n    int32_t x =\n            pMenu-&gt;viewport.tl.x + (int32_t) (index * (pMenu-&gt;item_width + pMenu-&gt;item_spacing));\n    x += pMenu-&gt;scroll_offset;\n    return (int16_t) x;\n}\n\nstatic uint16_t _calculate_item_y(CFBD_IconTextMenu* pMenu)\n{\n    uint16_t viewport_height = pMenu-&gt;viewport.br.y - pMenu-&gt;viewport.tl.y;\n    int16_t y_offset = (viewport_height - pMenu-&gt;item_height) / 2;\n    return pMenu-&gt;viewport.tl.y + y_offset;\n}\n\nstatic void\n_update_icon_widget(CFBD_IconTextMenu* pMenu, CFBD_IconTextMenuItem* item, int16_t item_x)\n{\n    int16_t icon_x = item_x + (int16_t) ((pMenu-&gt;item_width - item-&gt;icon_size.width) / 2);\n    uint16_t icon_y = _calculate_item_y(pMenu) + CFBD_ICONTEXT_MENU_ICON_TEXT_GAP;\n\n    item-&gt;icon_widget.point.x = (uint16_t) icon_x;\n    item-&gt;icon_widget.point.y = icon_y;\n}\n\nstatic uint16_t _calculate_text_width(const char* text, uint8_t font_size)\n{\n    // \u7b80\u5355\u4f30\u7b97\uff1a\u6bcf\u4e2a\u5b57\u7b26\u5bbd\u5ea6 = font_size * 0.6 (\u9700\u8981\u6839\u636e\u5b9e\u9645\u5b57\u4f53\u8c03\u6574)\n    // \u6216\u8005\u8c03\u7528\u5b9e\u9645\u7684\u5b57\u4f53\u5bbd\u5ea6\u8ba1\u7b97\u51fd\u6570\n    if (!text)\n        return 0;\n\n    uint16_t char_count = strlen(text);\n    uint16_t fwidth = __fetch_font_size(font_size).width;\n    return char_count * fwidth;\n}\n\nstatic void\n_update_text_widget(CFBD_IconTextMenu* pMenu, CFBD_IconTextMenuItem* item, int16_t item_x)\n{\n    uint16_t text_y = _calculate_item_y(pMenu) + item-&gt;icon_size.height +\n                      CFBD_ICONTEXT_MENU_ICON_TEXT_GAP * 2;\n\n    // \u8ba1\u7b97\u6587\u5b57\u5b9e\u9645\u5bbd\u5ea6\n    uint16_t text_width = _calculate_text_width(item-&gt;label, CFBD_ICONTEXT_MENU_TEXT_SIZE);\n\n    uint16_t text_x;\n    if (text_width &lt; pMenu-&gt;item_width) {\n        // \u6587\u5b57\u5bbd\u5ea6\u5c0f\u4e8eitem\u5bbd\u5ea6\uff1a\u5c45\u4e2d\u5bf9\u9f50\n        text_x = item_x + (pMenu-&gt;item_width - text_width) / 2;\n    }\n    else {\n        // \u6587\u5b57\u5bbd\u5ea6\u5927\u4e8e\u7b49\u4e8eitem\u5bbd\u5ea6\uff1a\u5de6\u5bf9\u9f50\n        text_x = item_x;\n    }\n\n    item-&gt;text_widget.tl_point.x = text_x;\n    item-&gt;text_widget.tl_point.y = text_y;\n    item-&gt;text_widget.indexed_point = item-&gt;text_widget.tl_point;\n\n    item-&gt;text_widget.TexthandleSize.width = pMenu-&gt;item_width;\n    item-&gt;text_widget.TexthandleSize.height = 8;\n}\n\nstatic CFBD_Bool\n_is_item_visible(CFBD_IconTextMenu* pMenu, CFBD_IconTextMenuItem* item, int16_t item_x)\n{\n    // \u8ba1\u7b97\u56fe\u6807\u7684\u5b9e\u9645\u4f4d\u7f6e\uff08\u5c45\u4e2d\u5728item\u4e2d\uff09\n    int16_t icon_x = item_x + (int16_t) ((pMenu-&gt;item_width - item-&gt;icon_size.width) / 2);\n    int16_t icon_right = icon_x + (int16_t) item-&gt;icon_size.width;\n\n    int16_t viewport_left = pMenu-&gt;viewport.tl.x;\n    int16_t viewport_right = pMenu-&gt;viewport.br.x;\n\n    // \u68c0\u67e5\u56fe\u6807\uff08\u800c\u4e0d\u662fitem\uff09\u662f\u5426\u4e0e\u89c6\u53e3\u6709\u4ea4\u96c6\n    return (icon_right &gt; viewport_left) &amp;&amp; (icon_x &lt; viewport_right);\n}\n\nstatic void\n_draw_selection_frame(CFBD_IconTextMenu* pMenu, CFBD_IconTextMenuItem* item, int16_t item_x)\n{\n    if (!pMenu || !pMenu-&gt;device || !item) {\n        return;\n    }\n\n    // Calculate icon position (same as _update_icon_widget)\n    int16_t icon_x = item_x + (int16_t) ((pMenu-&gt;item_width - item-&gt;icon_size.width) / 2);\n    uint16_t icon_y = _calculate_item_y(pMenu) + CFBD_ICONTEXT_MENU_ICON_TEXT_GAP;\n\n    // Frame around icon only (not text)\n    int16_t frame_x = icon_x - pMenu-&gt;selection_border_width;\n    int16_t frame_y = icon_y - pMenu-&gt;selection_border_width;\n    uint16_t frame_width = item-&gt;icon_size.width + 2 * pMenu-&gt;selection_border_width;\n    uint16_t frame_height = item-&gt;icon_size.height + 2 * pMenu-&gt;selection_border_width;\n\n    uint16_t border = pMenu-&gt;selection_border_width;\n\n    // Draw four borders using draw_pixel\n    // Top border\n    for (uint16_t y = 0; y &lt; border; y++) {\n        for (uint16_t x = 0; x &lt; frame_width; x++) {\n            pMenu-&gt;device-&gt;ops-&gt;setPixel(pMenu-&gt;device, frame_x + x, frame_y + y);\n        }\n    }\n\n    // Bottom border\n    for (uint16_t y = 0; y &lt; border; y++) {\n        for (uint16_t x = 0; x &lt; frame_width; x++) {\n            pMenu-&gt;device-&gt;ops-&gt;setPixel(pMenu-&gt;device,\n                                         frame_x + x,\n                                         frame_y + frame_height - border + y);\n        }\n    }\n\n    // Left border\n    for (uint16_t y = border; y &lt; frame_height - border; y++) {\n        for (uint16_t x = 0; x &lt; border; x++) {\n            pMenu-&gt;device-&gt;ops-&gt;setPixel(pMenu-&gt;device, frame_x + x, frame_y + y);\n        }\n    }\n\n    // Right border\n    for (uint16_t y = border; y &lt; frame_height - border; y++) {\n        for (uint16_t x = 0; x &lt; border; x++) {\n            pMenu-&gt;device-&gt;ops-&gt;setPixel(pMenu-&gt;device,\n                                         frame_x + frame_width - border + x,\n                                         frame_y + y);\n        }\n    }\n}\n\nstatic void _center_selected_item(CFBD_IconTextMenu* pMenu)\n{\n    if (!pMenu) {\n        return;\n    }\n\n    int16_t viewport_width = pMenu-&gt;viewport.br.x - pMenu-&gt;viewport.tl.x;\n    int16_t center_offset = (viewport_width - pMenu-&gt;item_width) / 2;\n\n    pMenu-&gt;scroll_offset =\n            -pMenu-&gt;selected_index * (pMenu-&gt;item_width + pMenu-&gt;item_spacing) + center_offset;\n    pMenu-&gt;target_scroll_offset = pMenu-&gt;scroll_offset;\n    pMenu-&gt;prev_scroll_offset = pMenu-&gt;scroll_offset;\n}\n\n/* ========== Static Implementation Functions (prefixed with CFBD_) ========== */\n\nstatic CFBD_Bool CFBD_IconTextMenuAddItem(CFBD_IconTextMenu* pMenu,\n                                          const char* label,\n                                          uint8_t* icon_bitmap,\n                                          CFBDGraphicSize* icon_size,\n                                          CFBD_MenuItemCallbackPack* callback)\n{\n    if (!pMenu || pMenu-&gt;item_count &gt;= pMenu-&gt;capacity || !label || !icon_bitmap) {\n        return CFBD_FALSE;\n    }\n\n    CFBD_IconTextMenuItem* item = &amp;pMenu-&gt;items[pMenu-&gt;item_count];\n\n    item-&gt;label = label;\n    item-&gt;icon_bitmap = icon_bitmap;\n    item-&gt;icon_size = *icon_size;\n    item-&gt;state = CFBD_ICONTEXT_ITEM_NORMAL;\n    item-&gt;user_data = NULL;\n\n    if (callback) {\n        item-&gt;callback = *callback;\n    }\n    else {\n        item-&gt;callback.callback = NULL;\n        item-&gt;callback.user_data = NULL;\n    }\n\n    item-&gt;render_position.x = 0;\n    item-&gt;render_position.y = 0;\n\n    CFBDGraphic_InitImage(&amp;item-&gt;icon_widget, &amp;item-&gt;render_position, icon_size, icon_bitmap);\n\n    CFBDGraphicSize text_area = {.width = pMenu-&gt;item_width, .height = 8};\n    CFBDGraphic_InitText(&amp;item-&gt;text_widget,\n                         item-&gt;render_position,\n                         text_area,\n                         CFBD_ICONTEXT_MENU_TEXT_SIZE);\n    item-&gt;text_widget.no_wrap = CFBD_TRUE;\n    CFBDGraphic_SetText(&amp;item-&gt;text_widget, (char*) label);\n\n    pMenu-&gt;item_count++;\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_IconTextMenuScroll(CFBD_IconTextMenu* pMenu,\n                                    CFBD_IconTextScrollDirection direction)\n{\n    if (!pMenu || pMenu-&gt;item_count == 0 || pMenu-&gt;is_animating) {\n        return;\n    }\n\n    int new_index = pMenu-&gt;selected_index;\n\n    if (direction == CFBD_ICONTEXT_SCROLL_RIGHT) {\n        new_index++;\n        if (new_index &gt;= (int) pMenu-&gt;item_count) {\n            if (pMenu-&gt;is_circular) {\n                new_index = 0;\n            }\n            else {\n                return;\n            }\n        }\n    }\n    else if (direction == CFBD_ICONTEXT_SCROLL_LEFT) {\n        new_index--;\n        if (new_index &lt; 0) {\n            if (pMenu-&gt;is_circular) {\n                new_index = pMenu-&gt;item_count - 1;\n            }\n            else {\n                return;\n            }\n        }\n    }\n    else {\n        return;\n    }\n\n    pMenu-&gt;selected_index = new_index;\n    pMenu-&gt;scroll_direction = direction;\n\n    // Calculate target offset to center the new selected item\n    int16_t viewport_width = pMenu-&gt;viewport.br.x - pMenu-&gt;viewport.tl.x;\n    int16_t center_offset = (viewport_width - pMenu-&gt;item_width) / 2;\n    pMenu-&gt;target_scroll_offset =\n            -new_index * (pMenu-&gt;item_width + pMenu-&gt;item_spacing) + center_offset;\n\n    pMenu-&gt;animation_start_offset = pMenu-&gt;scroll_offset;\n    pMenu-&gt;animation_elapsed_ms = 0;\n    pMenu-&gt;anim_current_frame = 0;\n    pMenu-&gt;is_animating = CFBD_TRUE;\n}\n\nstatic CFBD_Bool CFBD_IconTextMenuSelectIndex(CFBD_IconTextMenu* pMenu, int index)\n{\n    if (!pMenu || index &lt; 0 || index &gt;= (int) pMenu-&gt;item_count) {\n        return CFBD_FALSE;\n    }\n\n    pMenu-&gt;selected_index = index;\n\n    // Center the selected item immediately\n    _center_selected_item(pMenu);\n\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_IconTextMenuActivateCurrent(CFBD_IconTextMenu* pMenu)\n{\n    if (!pMenu || pMenu-&gt;selected_index &lt; 0 || pMenu-&gt;selected_index &gt;= (int) pMenu-&gt;item_count) {\n        return;\n    }\n\n    CFBD_IconTextMenuItem* item = &amp;pMenu-&gt;items[pMenu-&gt;selected_index];\n\n    item-&gt;state = CFBD_ICONTEXT_ITEM_PRESSED;\n\n    if (item-&gt;callback.callback) {\n        item-&gt;callback.callback(item-&gt;callback.user_data);\n    }\n\n    item-&gt;state = CFBD_ICONTEXT_ITEM_FOCUSED;\n}\n\nstatic void CFBD_IconTextMenuDraw(CFBD_IconTextMenu* pMenu)\n{\n    if (!pMenu || !pMenu-&gt;device || pMenu-&gt;item_count == 0) {\n        return;\n    }\n\n    // \u3010\u4fee\u590d1\u3011\u6269\u5927\u6e05\u9664\u533a\u57df\uff0c\u786e\u4fdd\u8fb9\u6846\u4e5f\u88ab\u6e05\u9664\n    int16_t clear_x = pMenu-&gt;viewport.tl.x;\n    int16_t clear_y = pMenu-&gt;viewport.tl.y;\n    uint16_t clear_w = rect_width(&amp;pMenu-&gt;viewport);\n    uint16_t clear_h = rect_height(&amp;pMenu-&gt;viewport);\n\n    // \u5411\u5916\u6269\u5c55\u8fb9\u6846\u5bbd\u5ea6\u7684\u8ddd\u79bb\n    if (clear_x &gt;= pMenu-&gt;selection_border_width) {\n        clear_x -= pMenu-&gt;selection_border_width;\n        clear_w += pMenu-&gt;selection_border_width * 2;\n    }\n    if (clear_y &gt;= pMenu-&gt;selection_border_width) {\n        clear_y -= pMenu-&gt;selection_border_width;\n        clear_h += pMenu-&gt;selection_border_width * 2;\n    }\n\n    pMenu-&gt;device-&gt;ops-&gt;clear_area(pMenu-&gt;device, clear_x, clear_y, clear_w, clear_h);\n\n    for (size_t i = 0; i &lt; pMenu-&gt;item_count; i++) {\n        CFBD_IconTextMenuItem* item = &amp;pMenu-&gt;items[i];\n        int16_t item_x = _calculate_item_x(pMenu, i);\n\n        if (!_is_item_visible(pMenu, item, item_x)) {\n            continue;\n        }\n\n        _update_icon_widget(pMenu, item, item_x);\n        _update_text_widget(pMenu, item, item_x);\n\n        if ((int) i == pMenu-&gt;selected_index) {\n            _draw_selection_frame(pMenu, item, item_x);\n        }\n\n        if (item-&gt;icon_bitmap) {\n            CFBDGraphic_DrawImageClipped(pMenu-&gt;device, &amp;item-&gt;icon_widget, &amp;pMenu-&gt;viewport);\n        }\n\n        CFBDGraphic_DrawText(pMenu-&gt;device,\n                             &amp;item-&gt;text_widget,\n                             CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    pMenu-&gt;device-&gt;ops-&gt;update_area(pMenu-&gt;device,\n                                    pMenu-&gt;viewport.tl.x,\n                                    pMenu-&gt;viewport.tl.y,\n                                    rect_width(&amp;pMenu-&gt;viewport),\n                                    rect_height(&amp;pMenu-&gt;viewport));\n\n    pMenu-&gt;prev_scroll_offset = pMenu-&gt;scroll_offset;\n}\n\nstatic CFBD_Bool CFBD_IconTextMenuUpdate(CFBD_IconTextMenu* pMenu, uint32_t delta_ms)\n{\n    (void) delta_ms;\n\n    if (!pMenu || !pMenu-&gt;is_animating)\n        return CFBD_FALSE;\n\n    uint8_t max_frames = pMenu-&gt;scroll_animation.anim_frames;\n\n    if (pMenu-&gt;anim_current_frame &lt; max_frames)\n        pMenu-&gt;anim_current_frame++;\n\n    int32_t start = pMenu-&gt;animation_start_offset;\n    int32_t delta = (int32_t) pMenu-&gt;target_scroll_offset - start;\n\n    pMenu-&gt;scroll_offset = (int16_t) (start + (delta * pMenu-&gt;anim_current_frame) / max_frames);\n\n    if (pMenu-&gt;anim_current_frame &gt;= max_frames) {\n        pMenu-&gt;scroll_offset = pMenu-&gt;target_scroll_offset;\n        pMenu-&gt;is_animating = CFBD_FALSE;\n        pMenu-&gt;anim_current_frame = 0;\n        return CFBD_FALSE;\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_IconTextMenuSetDimensions(CFBD_IconTextMenu* pMenu,\n                                           SizeBaseType width,\n                                           SizeBaseType height,\n                                           uint16_t spacing)\n{\n    pMenu-&gt;item_width = width;\n    pMenu-&gt;item_height = height;\n    pMenu-&gt;item_spacing = spacing;\n}\n\nstatic CFBD_IconTextMenuItem* CFBD_IconTextMenuGetSelectedItem(CFBD_IconTextMenu* pMenu)\n{\n    if (!pMenu || pMenu-&gt;selected_index &lt; 0 || pMenu-&gt;selected_index &gt;= (int) pMenu-&gt;item_count) {\n        return NULL;\n    }\n    return &amp;pMenu-&gt;items[pMenu-&gt;selected_index];\n}\n\nstatic CFBD_IconTextMenuItem* CFBD_IconTextMenuGetItem(CFBD_IconTextMenu* pMenu, int index)\n{\n    if (!pMenu || index &lt; 0 || index &gt;= (int) pMenu-&gt;item_count) {\n        return NULL;\n    }\n    return &amp;pMenu-&gt;items[index];\n}\n\nstatic void CFBD_IconTextMenuSetCircular(CFBD_IconTextMenu* pMenu, CFBD_Bool is_circular)\n{\n    if (!pMenu) {\n        return;\n    }\n    pMenu-&gt;is_circular = is_circular;\n}\n\nstatic void CFBD_IconTextMenuSetSelectionBorder(CFBD_IconTextMenu* pMenu, uint16_t border_width)\n{\n    if (!pMenu) {\n        return;\n    }\n    pMenu-&gt;selection_border_width = border_width;\n}\n\nstatic void CFBD_IconTextMenuAnimateScroll(CFBD_IconTextMenu* pMenu,\n                                           CFBD_IconTextScrollDirection direction)\n{\n    if (!pMenu || pMenu-&gt;item_count == 0) {\n        return;\n    }\n\n    pMenu-&gt;operations-&gt;scroll(pMenu, direction);\n\n    if (!pMenu-&gt;is_animating) {\n        return;\n    }\n\n    uint32_t frame_delay = pMenu-&gt;scroll_animation.anim_frame_delay_ms;\n\n    while (pMenu-&gt;is_animating) {\n        pMenu-&gt;operations-&gt;update(pMenu, 0);\n        pMenu-&gt;operations-&gt;immediate_draw(pMenu);\n\n        if (frame_delay &gt; 0) {\n            system_delay_ms(frame_delay);\n        }\n    }\n}\n\n/* ========== Operation Table ========== */\n\nstatic CFBD_IconTextMenuOps _cfbd_icontext_menu_ops = {\n        .add_item = CFBD_IconTextMenuAddItem,\n        .scroll = CFBD_IconTextMenuScroll,\n        .select_index = CFBD_IconTextMenuSelectIndex,\n        .activate_current = CFBD_IconTextMenuActivateCurrent,\n        .immediate_draw = CFBD_IconTextMenuDraw,\n        .update = CFBD_IconTextMenuUpdate,\n        .set_dimensions = CFBD_IconTextMenuSetDimensions,\n        .get_selected_item = CFBD_IconTextMenuGetSelectedItem,\n        .get_item = CFBD_IconTextMenuGetItem,\n        .set_circular = CFBD_IconTextMenuSetCircular,\n        .set_selection_border = CFBD_IconTextMenuSetSelectionBorder,\n        .animate_scroll = CFBD_IconTextMenuAnimateScroll};\n\n/* ========== Public API ========== */\n\nvoid CFBD_InitIconTextMenu(CFBD_IconTextMenu* pMenu,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphicRect* viewport,\n                           CFBD_IconTextMenuItem* items_buffer,\n                           size_t capacity)\n{\n    pMenu-&gt;operations = &amp;_cfbd_icontext_menu_ops;\n    pMenu-&gt;items = items_buffer;\n    memset(pMenu-&gt;items, 0, capacity * sizeof(CFBD_IconTextMenuItem));\n\n    pMenu-&gt;device = device;\n    pMenu-&gt;viewport = *viewport;\n    pMenu-&gt;capacity = capacity;\n    pMenu-&gt;item_count = 0;\n\n    pMenu-&gt;selected_index = 0;\n    pMenu-&gt;first_visible_index = 0;\n    pMenu-&gt;scroll_offset = 0;\n    pMenu-&gt;prev_scroll_offset = 0;\n    pMenu-&gt;target_scroll_offset = 0;\n    pMenu-&gt;scroll_direction = CFBD_ICONTEXT_SCROLL_NONE;\n    pMenu-&gt;item_width = CFBD_ICONTEXT_MENU_DEFAULT_ITEM_WIDTH;\n    pMenu-&gt;item_height = CFBD_ICONTEXT_MENU_DEFAULT_ITEM_HEIGHT;\n    pMenu-&gt;item_spacing = 5;\n    pMenu-&gt;is_animating = CFBD_FALSE;\n    pMenu-&gt;is_circular = CFBD_FALSE;\n\n    pMenu-&gt;selection_border_width = 1;\n\n    pMenu-&gt;animation_start_offset = 0;\n    pMenu-&gt;animation_elapsed_ms = 0;\n    pMenu-&gt;anim_current_frame = 0;\n\n    CFBD_InitBaseAnimation(&amp;pMenu-&gt;scroll_animation);\n    pMenu-&gt;scroll_animation.anim_frames = 10;\n    pMenu-&gt;scroll_animation.anim_frame_delay_ms = 30;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/icontext__menu_8h/","title":"lib/graphic/widget/menu/icontext_menu.h","text":"<p>Icon-text menu widget for scrollable menu display.  More...</p>"},{"location":"api/Files/icontext__menu_8h/#classes","title":"Classes","text":"Name struct CFBD_IconTextMenuItem struct _CFBD_IconTextMenuOps Operation table for icon-text menu. struct _CFBD_IconTextMenu"},{"location":"api/Files/icontext__menu_8h/#detailed-description","title":"Detailed Description","text":"<p>Icon-text menu widget for scrollable menu display. </p> <p>Provides a horizontal scrollable menu widget optimized for small displays, featuring icon+text menu items with smooth scrolling animation and gesture-based navigation. </p>"},{"location":"api/Files/icontext__menu_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_item.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/base_support/image.h\"\n#include \"widget/text.h\"\n\ntypedef struct _CFBD_IconTextMenu CFBD_IconTextMenu;\n\n#define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_WIDTH (60)     \n#define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_HEIGHT (80)    \n#define CFBD_ICONTEXT_MENU_ICON_SIZE (48)              \n#define CFBD_ICONTEXT_MENU_ICON_TEXT_GAP (4)           \n#define CFBD_ICONTEXT_MENU_TEXT_SIZE ASCII_6x8         \n#define CFBD_ICONTEXT_MENU_ANIMATION_DURATION_MS (300) \n#define CFBD_ICONTEXT_MENU_VISIBLE_ITEMS (3)           \n\ntypedef enum\n{\n    CFBD_ICONTEXT_ITEM_NORMAL = 0,  \n    CFBD_ICONTEXT_ITEM_FOCUSED = 1, \n    CFBD_ICONTEXT_ITEM_PRESSED = 2, \n    CFBD_ICONTEXT_ITEM_DISABLED = 3 \n} CFBD_IconTextMenuItemState;\n\ntypedef enum\n{\n    CFBD_ICONTEXT_SCROLL_LEFT = -1, \n    CFBD_ICONTEXT_SCROLL_RIGHT = 1, \n    CFBD_ICONTEXT_SCROLL_NONE = 0   \n} CFBD_IconTextScrollDirection;\n\ntypedef struct\n{\n    const char* label;\n\n    uint8_t* icon_bitmap;\n\n    CFBDGraphicSize icon_size;\n\n    CFBD_IconTextMenuItemState state;\n\n    CFBD_MenuItemCallbackPack callback;\n\n    CFBDGraphic_Point render_position;\n\n    CCGraphic_Image icon_widget;\n\n    CFBDGraphic_Text text_widget;\n\n    void* user_data;\n} CFBD_IconTextMenuItem;\n\ntypedef struct _CFBD_IconTextMenuOps\n{\n    CFBD_Bool (*add_item)(CFBD_IconTextMenu* pMenu,\n                          const char* label,\n                          uint8_t* icon_bitmap,\n                          CFBDGraphicSize* icon_size,\n                          CFBD_MenuItemCallbackPack* callback);\n\n    void (*scroll)(CFBD_IconTextMenu* pMenu, CFBD_IconTextScrollDirection direction);\n\n    CFBD_Bool (*select_index)(CFBD_IconTextMenu* pMenu, int index);\n\n    void (*activate_current)(CFBD_IconTextMenu* pMenu);\n\n    void (*immediate_draw)(CFBD_IconTextMenu* pMenu);\n\n    CFBD_Bool (*update)(CFBD_IconTextMenu* pMenu, uint32_t delta_ms);\n\n    void (*set_appearance)(CFBD_IconTextMenu* pMenu,\n                           uint32_t bg_color,\n                           uint32_t highlight_color,\n                           uint32_t text_color);\n\n    void (*set_dimensions)(CFBD_IconTextMenu* pMenu,\n                           SizeBaseType width,\n                           SizeBaseType height,\n                           uint16_t spacing);\n\n    CFBD_IconTextMenuItem* (*get_selected_item)(CFBD_IconTextMenu* pMenu);\n\n    CFBD_IconTextMenuItem* (*get_item)(CFBD_IconTextMenu* pMenu, int index);\n\n    void (*set_circular)(CFBD_IconTextMenu* pMenu, CFBD_Bool is_circular);\n\n    void (*animate_scroll)(CFBD_IconTextMenu* pMenu, CFBD_IconTextScrollDirection direction);\n\n    void (*set_selection_border)(CFBD_IconTextMenu* pMenu, uint16_t width);\n} CFBD_IconTextMenuOps;\n\ntypedef struct _CFBD_IconTextMenu\n{\n    CFBD_IconTextMenuOps* operations;\n\n    CFBD_IconTextMenuItem* items;\n\n    size_t item_count;\n\n    size_t capacity;\n\n    CFBD_GraphicDevice* device;\n\n    CFBDGraphicRect viewport;\n\n    int selected_index;\n\n    int first_visible_index;\n\n    int16_t scroll_offset;\n\n    int16_t target_scroll_offset;\n\n    CFBD_IconTextScrollDirection scroll_direction;\n\n    CFBD_BaseAnimation scroll_animation;\n\n    SizeBaseType item_width;\n\n    SizeBaseType item_height;\n\n    uint16_t item_spacing;\n\n    CFBD_Bool is_circular;\n\n    CFBD_Bool is_animating;\n\n    int16_t animation_start_offset;\n\n    uint32_t animation_elapsed_ms;\n\n    int16_t prev_scroll_offset;\n\n    uint8_t anim_current_frame;\n\n    uint16_t selection_border_width;\n} CFBD_IconTextMenu;\n\nvoid CFBD_InitIconTextMenu(CFBD_IconTextMenu* pMenu,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphicRect* viewport,\n                           CFBD_IconTextMenuItem* items_buffer,\n                           size_t capacity);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/iic_8c/","title":"lib/iic/iic.c","text":""},{"location":"api/Files/iic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"iic.h\"\n#include &lt;stdint.h&gt;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r){\n    if (!handle || !r-&gt;data || \n        (r-&gt;mem_addr_size!=1 &amp;&amp; r-&gt;mem_addr_size!=2)){ \n        return I2C_ERR_INVAL;\n    }\n\n    uint8_t addr_buf[2];\n    CFBD_I2C_Message msgs[2];\n\n    if (r-&gt;mem_addr_size == 1) {\n        addr_buf[0] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 1;\n        msgs[0].buf = addr_buf;\n    } else {\n        addr_buf[0] = (uint8_t)((r-&gt;mem_addr &gt;&gt; 8) &amp; 0xFF);\n        addr_buf[1] = (uint8_t)(r-&gt;mem_addr &amp; 0xFF);\n        msgs[0].len = 2;\n        msgs[0].buf = addr_buf;\n    }\n    msgs[0].addr = r-&gt;addr7;\n    msgs[0].flags = 0;\n\n    msgs[1].addr = r-&gt;addr7;\n    msgs[1].flags = I2C_M_RD;\n    msgs[1].len = r-&gt;len;\n    msgs[1].buf = r-&gt;data;\n\n    return CFBD_I2CTransfer(handle, msgs, 2, r-&gt;timeout_ms);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/iic_8h/","title":"lib/iic/iic.h","text":"<p>I2C (IIC) abstraction layer for CFBD drivers.  More...</p>"},{"location":"api/Files/iic_8h/#classes","title":"Classes","text":"Name struct _CFBD_I2C_Message struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus. struct _CFBD_I2CHandle struct CFBD_I2C_IORequestParams Helper structure used by convenience read/write helpers."},{"location":"api/Files/iic_8h/#types","title":"Types","text":"Name typedef struct _CFBD_I2C_Message CFBD_I2C_Message typedef void(int status, void *arg) CFBD_I2C_AsyncCallback Signature for asynchronous I2C transfer completion callbacks. typedef struct _CFBD_I2CHandle CFBD_I2CHandle Opaque forward-declared type representing an I2C bus instance. typedef void * CFBD_I2CPrivateHandle Opaque pointer for backend-private state stored in the handle."},{"location":"api/Files/iic_8h/#defines","title":"Defines","text":"Name I2C_M_RD Flag indicating a read transfer (slave -&gt; master). I2C_M_NOSTART Flag to suppress START condition between messages."},{"location":"api/Files/iic_8h/#detailed-description","title":"Detailed Description","text":"<p>I2C (IIC) abstraction layer for CFBD drivers. </p> <p>This header defines a lightweight, backend-pluggable I2C interface used by drivers in the project (for example the OLED driver). The abstraction exposes message-based transfers, device readiness checks, error reporting and optional DMA hooks. Concrete backends implement the <code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code> table and populate <code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>. </p>"},{"location":"api/Files/iic_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_message","title":"typedef CFBD_I2C_Message","text":"<pre><code>typedef struct _CFBD_I2C_Message CFBD_I2C_Message;\n</code></pre>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2c_asynccallback","title":"typedef CFBD_I2C_AsyncCallback","text":"<pre><code>CFBD_I2C_AsyncCallback;\n</code></pre> <p>Signature for asynchronous I2C transfer completion callbacks. </p> <p>Parameters: </p> <ul> <li>status Result status code (I2C_OK or negative error code). </li> <li>arg User-provided argument passed through the async API.</li> </ul> <p>Par: Example - Async Transfer with Callback</p> <pre><code>struct TransferContext {\n    uint8_t *data;\n    size_t len;\n    int error_count;\n} ctx;\n\nvoid transfer_complete_callback(int status, void *arg) {\n    struct TransferContext *ctx = (struct TransferContext *)arg;\n\n    if (status != I2C_OK) {\n        ctx-&gt;error_count++;\n        if (status == I2C_ERR_TIMEOUT) {\n            // Timeout handling\n            schedule_retry();\n        }\n    } else {\n        // Transfer successful\n        process_received_data(ctx-&gt;data, ctx-&gt;len);\n    }\n}\n\n// Initiate async transfer\nctx.data = buffer;\nctx.len = sizeof(buffer);\nCFBD_I2CTransferAsync(bus, msgs, count, transfer_complete_callback, &amp;ctx);\n</code></pre> <p>Called when an asynchronous I2C operation completes. Enables interrupt-driven or DMA-based transfers without blocking the main application thread.</p>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2chandle","title":"typedef CFBD_I2CHandle","text":"<pre><code>typedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n</code></pre> <p>Opaque forward-declared type representing an I2C bus instance. </p> <p>Represents a single I2C bus in the system. The handle combines backend-agnostic operations with platform-specific state. </p>"},{"location":"api/Files/iic_8h/#typedef-cfbd_i2cprivatehandle","title":"typedef CFBD_I2CPrivateHandle","text":"<pre><code>CFBD_I2CPrivateHandle;\n</code></pre> <p>Opaque pointer for backend-private state stored in the handle. </p> <p>Backend implementations use this to store any hardware-specific data, such as peripheral base addresses, interrupt handlers, DMA channel info, etc. </p>"},{"location":"api/Files/iic_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/iic_8h/#define-i2c_m_rd","title":"define I2C_M_RD","text":"<pre><code>#define I2C_M_RD 0x0001 /* read data, from slave to master */\n</code></pre> <p>Flag indicating a read transfer (slave -&gt; master). </p> <p>Par: Example - Combined Write-Read Transfer</p> <pre><code>// Many I2C devices require: write address, then read data\nCFBD_I2C_Message msgs[2];\nuint8_t cmd = 0x01;  // Command/register\nuint8_t response[8];\n\n// Write command (no I2C_M_RD flag)\nmsgs[0].addr = 0x50;\nmsgs[0].flags = 0;\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;cmd;\n\n// Read response (with I2C_M_RD flag)\nmsgs[1].addr = 0x50;\nmsgs[1].flags = I2C_M_RD;  // Indicates read operation\nmsgs[1].len = sizeof(response);\nmsgs[1].buf = response;\n\nCFBD_I2CTransfer(bus, msgs, 2, 1000);\n</code></pre> <p>When set in a message's <code>flags</code> field, indicates that the message direction is a read operation (master receives from slave).</p>"},{"location":"api/Files/iic_8h/#define-i2c_m_nostart","title":"define I2C_M_NOSTART","text":"<pre><code>#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n</code></pre> <p>Flag to suppress START condition between messages. </p> <p>When set, prevents generation of a START condition before this message. Used in specialized scenarios (rare) where messages should be combined without intermediate START conditions. </p>"},{"location":"api/Files/iic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"iic_error.h\"\n\n#define I2C_M_RD 0x0001 /* read data, from slave to master */\n\n#define I2C_M_NOSTART 0x4000 /* no start between messages (rare) */\n\ntypedef struct _CFBD_I2C_Message\n{\n    uint16_t addr;  \n    uint16_t flags; \n    uint16_t len;   \n    uint8_t* buf;   \n} CFBD_I2C_Message;\n\n/* Async Callbacks */\ntypedef void CFBD_I2C_AsyncCallback(int status, void* arg);\n\ntypedef struct _CFBD_I2CHandle CFBD_I2CHandle;\n\ntypedef struct\n{\n    int (*init)(CFBD_I2CHandle* handle);\n\n    int (*deinit)(CFBD_I2CHandle* handle);\n\n    int (*transfer)(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms);\n\n    int (*is_device_ready)(CFBD_I2CHandle* bus,\n                           uint16_t addr,\n                           uint32_t trials,\n                           uint32_t timeout_ms);\n\n    int (*recover_bus)(CFBD_I2CHandle* bus);\n\n    int (*get_error)(CFBD_I2CHandle* bus);\n\n    /* optional DMA hooks */\n    int (*tx_dma_start)(CFBD_I2CHandle* bus, const uint8_t* buf, size_t len);\n\n    int (*rx_dma_start)(CFBD_I2CHandle* bus, uint8_t* buf, size_t len);\n} CFBD_I2COperations;\n\ntypedef void* CFBD_I2CPrivateHandle;\n\ntypedef struct _CFBD_I2CHandle\n{\n    const CFBD_I2COperations* ops;        \n    CFBD_I2CPrivateHandle private_handle; \n} CFBD_I2CHandle;\n\n/* --------- inline wrappers  ---------- */\nstatic inline int CFBD_I2CInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;init)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;init(bus);\n}\n\nstatic inline int CFBD_I2CDeInit(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;deinit)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;deinit(bus);\n}\n\nstatic inline int\nCFBD_I2CTransfer(CFBD_I2CHandle* bus, CFBD_I2C_Message* msgs, int num, uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;transfer)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;transfer(bus, msgs, num, timeout_ms);\n}\n\nstatic inline int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle* bus,\n                                                uint16_t addr,\n                                                uint32_t trials,\n                                                uint32_t timeout_ms)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;is_device_ready)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;is_device_ready(bus, addr, trials, timeout_ms);\n}\n\nstatic inline int CFBD_I2CRecoverBus(CFBD_I2CHandle* bus)\n{\n    if (!bus || !bus-&gt;ops || !bus-&gt;ops-&gt;recover_bus)\n        return I2C_ERR_INVAL;\n    return bus-&gt;ops-&gt;recover_bus(bus);\n}\n\ntypedef struct\n{\n    uint16_t addr7;        \n    uint32_t mem_addr;     \n    uint8_t mem_addr_size; \n    uint8_t* data;         \n    uint16_t len;          \n    uint32_t timeout_ms;   \n} CFBD_I2C_IORequestParams;\n\nint CFBD_I2CRead(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\n\nint CFBD_I2CWrite(CFBD_I2CHandle* handle, CFBD_I2C_IORequestParams* r);\n\n#include \"lib_settings.h\"\n#if defined(CFBD_IS_ST)\n#include \"backend/i2c_stm_impl.h\"\n#else\n#error \"No supports chips\"\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/iic__error_8h/","title":"lib/iic/iic_error.h","text":"<p>I2C/IIC error codes used by the CFBD I2C abstraction.  More...</p>"},{"location":"api/Files/iic__error_8h/#detailed-description","title":"Detailed Description","text":"<p>I2C/IIC error codes used by the CFBD I2C abstraction. </p> <p>Small set of error code macros used across the I2C driver infrastructure. Error codes mirror common POSIX/Linux errno-style values to ease mapping to platform-level errors. </p>"},{"location":"api/Files/iic__error_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define I2C_OK 0\n\n#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n\n#define I2C_ERR_NACK -121 /* -EPROTO (nack) */\n\n#define I2C_ERR_BUSY -16 /* -EBUSY */\n\n#define I2C_ERR_IO -5 /* -EIO */\n\n#define I2C_ERR_INVAL -22 /* -EINVAL */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/iic__pack__type_8h/","title":"lib/oled/configs/iic_pack_type.h","text":""},{"location":"api/Files/iic__pack__type_8h/#defines","title":"Defines","text":"Name SSD130X_REQUEST_IIC_PACK SSD132X_REQUEST_IIC_PACK"},{"location":"api/Files/iic__pack__type_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/iic__pack__type_8h/#define-ssd130x_request_iic_pack","title":"define SSD130X_REQUEST_IIC_PACK","text":"<pre><code>#define SSD130X_REQUEST_IIC_PACK (\"ssd130x\")\n</code></pre>"},{"location":"api/Files/iic__pack__type_8h/#define-ssd132x_request_iic_pack","title":"define SSD132X_REQUEST_IIC_PACK","text":"<pre><code>#define SSD132X_REQUEST_IIC_PACK (\"ssd132x\")\n</code></pre>"},{"location":"api/Files/iic__pack__type_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define SSD130X_REQUEST_IIC_PACK (\"ssd130x\")\n#define SSD132X_REQUEST_IIC_PACK (\"ssd132x\")\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/image_8c/","title":"lib/graphic/widget/base_support/image.c","text":""},{"location":"api/Files/image_8c/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImageClipped(CFBD_GraphicDevice * device, CCGraphic_Image * image, CFBDGraphicRect * clip_rect)Draw image with clipping using small fixed buffer (batch processing) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image)"},{"location":"api/Files/image_8c/#defines","title":"Defines","text":"Name CLIP_BUFFER_SIZE"},{"location":"api/Files/image_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8c/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8c/#function-cfbdgraphic_drawimageclipped","title":"function CFBDGraphic_DrawImageClipped","text":"<pre><code>void CFBDGraphic_DrawImageClipped(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Image * image,\n    CFBDGraphicRect * clip_rect\n)\n</code></pre> <p>Draw image with clipping using small fixed buffer (batch processing) </p> <p>Parameters: </p> <ul> <li>device - Graphic device </li> <li>image - Image to draw </li> <li>clip_rect - Clipping rectangle (viewport bounds) </li> </ul> <p>Note: Uses 64-byte fixed buffer, processes image in columns batches </p>"},{"location":"api/Files/image_8c/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/image_8c/#define-clip_buffer_size","title":"define CLIP_BUFFER_SIZE","text":"<pre><code>#define CLIP_BUFFER_SIZE 64\n</code></pre>"},{"location":"api/Files/image_8c/#source-code","title":"Source code","text":"<pre><code>#include \"image.h\"\n\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"device/graphic_device.h\"\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register)\n{\n    image-&gt;image_size = *image_size;\n    image-&gt;point = *tl_point;\n    image-&gt;sources_register = sources_register;\n}\n\nvoid CFBDGraphic_DrawImageClipped(CFBD_GraphicDevice* device,\n                                  CCGraphic_Image* image,\n                                  CFBDGraphicRect* clip_rect)\n{\n    if (!image-&gt;sources_register || !device || !clip_rect) {\n        return;\n    }\n\n    // \u8ba1\u7b97\u56fe\u50cf\u7684\u8fb9\u754c\n    int16_t img_left = (int16_t) image-&gt;point.x;\n    int16_t img_top = (int16_t) image-&gt;point.y;\n    int16_t img_right = img_left + (int16_t) image-&gt;image_size.width;\n    int16_t img_bottom = img_top + (int16_t) image-&gt;image_size.height;\n\n    // \u8ba1\u7b97\u88c1\u526a\u533a\u57df\u7684\u8fb9\u754c\n    int16_t clip_left = clip_rect-&gt;tl.x;\n    int16_t clip_top = clip_rect-&gt;tl.y;\n    int16_t clip_right = clip_rect-&gt;br.x;\n    int16_t clip_bottom = clip_rect-&gt;br.y;\n\n    // \u68c0\u67e5\u662f\u5426\u5b8c\u5168\u5728\u88c1\u526a\u533a\u57df\u5916\n    if (img_right &lt;= clip_left || img_left &gt;= clip_right || img_bottom &lt;= clip_top ||\n        img_top &gt;= clip_bottom) {\n        return; // \u5b8c\u5168\u4e0d\u53ef\u89c1\n    }\n\n    // \u8ba1\u7b97\u53ef\u89c1\u533a\u57df\u7684\u4ea4\u96c6\n    int16_t visible_left = (img_left &lt; clip_left) ? clip_left : img_left;\n    int16_t visible_top = (img_top &lt; clip_top) ? clip_top : img_top;\n    int16_t visible_right = (img_right &gt; clip_right) ? clip_right : img_right;\n    int16_t visible_bottom = (img_bottom &gt; clip_bottom) ? clip_bottom : img_bottom;\n\n    // \u8ba1\u7b97\u88c1\u526a\u540e\u7684\u5c3a\u5bf8\n    uint16_t visible_width = (uint16_t) (visible_right - visible_left);\n    uint16_t visible_height = (uint16_t) (visible_bottom - visible_top);\n\n    if (visible_width == 0 || visible_height == 0) {\n        return;\n    }\n\n    // \u5982\u679c\u56fe\u50cf\u5b8c\u5168\u5728\u88c1\u526a\u533a\u57df\u5185\uff0c\u76f4\u63a5\u7ed8\u5236\n    if (visible_left == img_left &amp;&amp; visible_top == img_top &amp;&amp; visible_right == img_right &amp;&amp;\n        visible_bottom == img_bottom) {\n        CFBDGraphic_DrawImage(device, image);\n        return;\n    }\n\n    // \u8ba1\u7b97\u5728\u539f\u56fe\u50cf\u4e2d\u7684\u504f\u79fb\u91cf\n    uint16_t offset_x = (uint16_t) (visible_left - img_left);\n    uint16_t offset_y = (uint16_t) (visible_top - img_top);\n\n// \u56fa\u5b9a64\u5b57\u8282\u7f13\u51b2\u533a\n#define CLIP_BUFFER_SIZE 64\n    uint8_t clipped_buffer[CLIP_BUFFER_SIZE];\n\n    // \u8ba1\u7b97\u6bcf\u5217\u9700\u8981\u7684\u5b57\u8282\u6570\uff08OLED\u5782\u76f4\u5b57\u8282\u683c\u5f0f\uff09\n    uint16_t bytes_per_column = (visible_height + 7) / 8;\n\n    // \u8ba1\u7b97\u6bcf\u6279\u6b21\u80fd\u5904\u7406\u591a\u5c11\u5217\n    uint16_t columns_per_batch = CLIP_BUFFER_SIZE / bytes_per_column;\n    if (columns_per_batch == 0) {\n        columns_per_batch = 1; // \u81f3\u5c11\u5904\u74061\u5217\n    }\n\n    // \u6e90\u56fe\u50cf\u7684\u6bcf\u5217\u5b57\u8282\u6570\n    uint16_t src_bytes_per_column = (image-&gt;image_size.height + 7) / 8;\n    uint8_t bit_offset = offset_y % 8;\n\n    // \u5206\u6279\u6b21\u5904\u7406\n    for (uint16_t batch_start = 0; batch_start &lt; visible_width; batch_start += columns_per_batch) {\n        // \u8ba1\u7b97\u672c\u6279\u6b21\u5b9e\u9645\u5904\u7406\u7684\u5217\u6570\n        uint16_t batch_cols = columns_per_batch;\n        if (batch_start + batch_cols &gt; visible_width) {\n            batch_cols = visible_width - batch_start;\n        }\n\n        // \u63d0\u53d6\u672c\u6279\u6b21\u7684bitmap\u6570\u636e\n        for (uint16_t x = 0; x &lt; batch_cols; x++) {\n            uint16_t src_x = offset_x + batch_start + x;\n\n            for (uint16_t byte_y = 0; byte_y &lt; bytes_per_column; byte_y++) {\n                uint16_t src_byte_y = (offset_y / 8) + byte_y;\n\n                if (src_byte_y &lt; src_bytes_per_column &amp;&amp; src_x &lt; image-&gt;image_size.width) {\n                    uint8_t src_data =\n                            image-&gt;sources_register[src_byte_y * image-&gt;image_size.width + src_x];\n\n                    // \u5904\u7406\u5782\u76f4\u504f\u79fb\n                    if (bit_offset == 0) {\n                        clipped_buffer[byte_y * batch_cols + x] = src_data;\n                    }\n                    else {\n                        // \u9700\u8981\u79fb\u4f4d\u62fc\u63a5\n                        uint8_t current_byte = src_data &gt;&gt; bit_offset;\n\n                        if (src_byte_y + 1 &lt; src_bytes_per_column) {\n                            uint8_t next_byte =\n                                    image-&gt;sources_register[(src_byte_y + 1) *\n                                                                    image-&gt;image_size.width +\n                                                            src_x];\n                            current_byte |= (next_byte &lt;&lt; (8 - bit_offset));\n                        }\n\n                        clipped_buffer[byte_y * batch_cols + x] = current_byte;\n                    }\n                }\n                else {\n                    clipped_buffer[byte_y * batch_cols + x] = 0;\n                }\n            }\n        }\n\n        // \u7ed8\u5236\u672c\u6279\u6b21\n        uint16_t batch_x = (uint16_t) (visible_left + batch_start);\n        device-&gt;ops-&gt;setArea(device,\n                             batch_x,\n                             (uint16_t) visible_top,\n                             batch_cols,\n                             visible_height,\n                             clipped_buffer);\n\n        // \u7acb\u5373\u66f4\u65b0\u8fd9\u4e00\u6279\u6b21\n        if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n            device-&gt;ops-&gt;update_area(device,\n                                     batch_x,\n                                     (uint16_t) visible_top,\n                                     batch_cols,\n                                     visible_height);\n        }\n    }\n\n#undef CLIP_BUFFER_SIZE\n}\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image)\n{\n    if (!image-&gt;sources_register)\n        return;\n    handler-&gt;ops-&gt;setArea(handler,\n                          image-&gt;point.x,\n                          image-&gt;point.y,\n                          image-&gt;image_size.width,\n                          image-&gt;image_size.height,\n                          image-&gt;sources_register);\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        handler-&gt;ops-&gt;update_area(handler,\n                                  image-&gt;point.x,\n                                  image-&gt;point.y,\n                                  image-&gt;image_size.width,\n                                  image-&gt;image_size.height);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/image_8h/","title":"lib/graphic/widget/base_support/image.h","text":"<p>Image widget for rendering bitmap graphics.  More...</p>"},{"location":"api/Files/image_8h/#classes","title":"Classes","text":"Name struct CCGraphic_Image"},{"location":"api/Files/image_8h/#functions","title":"Functions","text":"Name void CFBDGraphic_InitImage(CCGraphic_Image * image, CFBDGraphic_Point * tl_point, CFBDGraphicSize * image_size, uint8_t * sources_register) void CFBDGraphic_DrawImage(CFBD_GraphicDevice * handler, CCGraphic_Image * image) void CFBDGraphic_DrawImageClipped(CFBD_GraphicDevice * device, CCGraphic_Image * image, CFBDGraphicRect * clip_rect)Draw image with clipping using small fixed buffer (batch processing)"},{"location":"api/Files/image_8h/#detailed-description","title":"Detailed Description","text":"<p>Image widget for rendering bitmap graphics. </p> <p>Provides image structures and functions for drawing bitmap data at specified positions on graphics devices. Supports arbitrary bitmap data with configurable size and position. </p>"},{"location":"api/Files/image_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/image_8h/#function-cfbdgraphic_initimage","title":"function CFBDGraphic_InitImage","text":"<pre><code>void CFBDGraphic_InitImage(\n    CCGraphic_Image * image,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize * image_size,\n    uint8_t * sources_register\n)\n</code></pre>"},{"location":"api/Files/image_8h/#function-cfbdgraphic_drawimage","title":"function CFBDGraphic_DrawImage","text":"<pre><code>void CFBDGraphic_DrawImage(\n    CFBD_GraphicDevice * handler,\n    CCGraphic_Image * image\n)\n</code></pre>"},{"location":"api/Files/image_8h/#function-cfbdgraphic_drawimageclipped","title":"function CFBDGraphic_DrawImageClipped","text":"<pre><code>void CFBDGraphic_DrawImageClipped(\n    CFBD_GraphicDevice * device,\n    CCGraphic_Image * image,\n    CFBDGraphicRect * clip_rect\n)\n</code></pre> <p>Draw image with clipping using small fixed buffer (batch processing) </p> <p>Parameters: </p> <ul> <li>device - Graphic device </li> <li>image - Image to draw </li> <li>clip_rect - Clipping rectangle (viewport bounds) </li> </ul> <p>Note: Uses 64-byte fixed buffer, processes image in columns batches </p>"},{"location":"api/Files/image_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point point;\n\n    CFBDGraphicSize image_size;\n\n    uint8_t* sources_register;\n} CCGraphic_Image;\n\nvoid CFBDGraphic_InitImage(CCGraphic_Image* image,\n                           CFBDGraphic_Point* tl_point,\n                           CFBDGraphicSize* image_size,\n                           uint8_t* sources_register);\n\nvoid CFBDGraphic_DrawImage(CFBD_GraphicDevice* handler, CCGraphic_Image* image);\n\nvoid CFBDGraphic_DrawImageClipped(CFBD_GraphicDevice* device,\n                                  CCGraphic_Image* image,\n                                  CFBDGraphicRect* clip_rect);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input_8c/","title":"lib/input/input.c","text":""},{"location":"api/Files/input_8c/#functions","title":"Functions","text":"Name CFBD_Bool enqueue_event(CFBDInputEventContext * context_init, CFBDInputEvent * event) CFBD_Bool sync_poll(CFBDInputEventContext * context_init) CFBD_Bool input_register_handler(CFBDInputEventContext * context_init, CFBDEventInputHandler handler) void input_unregister_handler(CFBDInputEventContext * context_init, CFBDEventInputHandler handler) void CFBD_CreateInputContext(CFBDInputEventContext * context_init) void CFBD_SetGlobalInputEventContext(CFBDInputEventContext * context) const CFBDInputEventContext * CFBD_GetGlobalInputEventContext()"},{"location":"api/Files/input_8c/#attributes","title":"Attributes","text":"Name CFBDInputEventContextOperations ops CFBDInputEventContext * global_context"},{"location":"api/Files/input_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input_8c/#function-enqueue_event","title":"function enqueue_event","text":"<pre><code>static CFBD_Bool enqueue_event(\n    CFBDInputEventContext * context_init,\n    CFBDInputEvent * event\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-sync_poll","title":"function sync_poll","text":"<pre><code>static CFBD_Bool sync_poll(\n    CFBDInputEventContext * context_init\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-input_register_handler","title":"function input_register_handler","text":"<pre><code>CFBD_Bool input_register_handler(\n    CFBDInputEventContext * context_init,\n    CFBDEventInputHandler handler\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-input_unregister_handler","title":"function input_unregister_handler","text":"<pre><code>void input_unregister_handler(\n    CFBDInputEventContext * context_init,\n    CFBDEventInputHandler handler\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-cfbd_createinputcontext","title":"function CFBD_CreateInputContext","text":"<pre><code>void CFBD_CreateInputContext(\n    CFBDInputEventContext * context_init\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-cfbd_setglobalinputeventcontext","title":"function CFBD_SetGlobalInputEventContext","text":"<pre><code>void CFBD_SetGlobalInputEventContext(\n    CFBDInputEventContext * context\n)\n</code></pre>"},{"location":"api/Files/input_8c/#function-cfbd_getglobalinputeventcontext","title":"function CFBD_GetGlobalInputEventContext","text":"<pre><code>const CFBDInputEventContext * CFBD_GetGlobalInputEventContext()\n</code></pre>"},{"location":"api/Files/input_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/input_8c/#variable-ops","title":"variable ops","text":"<pre><code>static CFBDInputEventContextOperations ops = {.enqueue_event = enqueue_event,\n                                              .sync_poll = sync_poll,\n                                              .register_handle = input_register_handler,\n                                              .unregister_handler = input_unregister_handler};\n</code></pre>"},{"location":"api/Files/input_8c/#variable-global_context","title":"variable global_context","text":"<pre><code>static CFBDInputEventContext * global_context = NULL;\n</code></pre>"},{"location":"api/Files/input_8c/#source-code","title":"Source code","text":"<pre><code>#include \"input.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"input_config.h\"\n#include \"input_device_base.h\"\n\nstatic CFBD_Bool enqueue_event(CFBDInputEventContext* context_init, CFBDInputEvent* event)\n{\n    uint8_t next = (context_init-&gt;tail + 1) % INPUT_EVENT_QUEUE_SIZE;\n    if (next != context_init-&gt;head) {\n        context_init-&gt;queue[context_init-&gt;tail] = *event;\n        context_init-&gt;tail = next;\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic CFBD_Bool sync_poll(CFBDInputEventContext* context_init)\n{\n    while (context_init-&gt;head != context_init-&gt;tail) {\n        CFBDInputEvent* event = &amp;context_init-&gt;queue[context_init-&gt;head];\n\n        for (uint8_t i = 0; i &lt; context_init-&gt;handler_count; i++) {\n            CFBD_Bool result = context_init-&gt;handlers[i](event);\n            if (!result &amp;&amp; context_init-&gt;stop_propergate_if_failed) {\n                // stop as event processed failed as when\n                // stop_propergate_if_failed == true\n                break;\n            }\n\n            if (event-&gt;stop_propergate) {\n                break; // OK, event shutdown, stop propergate\n            }\n        }\n\n        context_init-&gt;head = (context_init-&gt;head + 1) % INPUT_EVENT_QUEUE_SIZE;\n    }\n\n    return CFBD_TRUE;\n}\n\nCFBD_Bool input_register_handler(CFBDInputEventContext* context_init, CFBDEventInputHandler handler)\n{\n    if (context_init-&gt;handler_count &gt;= INPUT_MAX_HANDLER_CNT || handler == NULL) {\n        return CFBD_FALSE;\n    }\n\n    for (uint8_t i = 0; i &lt; context_init-&gt;handler_count; i++) {\n        if (context_init-&gt;handlers[i] == handler) {\n            return CFBD_TRUE;\n        }\n    }\n\n    context_init-&gt;handlers[context_init-&gt;handler_count++] = handler;\n    return CFBD_TRUE;\n}\n\nvoid input_unregister_handler(CFBDInputEventContext* context_init, CFBDEventInputHandler handler)\n{\n    for (uint8_t i = 0; i &lt; context_init-&gt;handler_count; i++) {\n        if (context_init-&gt;handlers[i] == handler) {\n            for (uint8_t j = i; j &lt; context_init-&gt;handler_count - 1; j++) {\n                context_init-&gt;handlers[j] = context_init-&gt;handlers[j + 1];\n            }\n            context_init-&gt;handler_count--;\n            break;\n        }\n    }\n}\n\nstatic CFBDInputEventContextOperations ops = {.enqueue_event = enqueue_event,\n                                              .sync_poll = sync_poll,\n                                              .register_handle = input_register_handler,\n                                              .unregister_handler = input_unregister_handler};\n\nvoid CFBD_CreateInputContext(CFBDInputEventContext* context_init)\n{\n    context_init-&gt;ops = &amp;ops;\n    context_init-&gt;handler_count = 0;\n    context_init-&gt;head = 0;\n    context_init-&gt;tail = 0;\n    context_init-&gt;stop_propergate_if_failed = CFBD_FALSE;\n}\n\nstatic CFBDInputEventContext* global_context = NULL;\n\nvoid CFBD_SetGlobalInputEventContext(CFBDInputEventContext* context)\n{\n    global_context = context;\n}\n\nconst CFBDInputEventContext* CFBD_GetGlobalInputEventContext()\n{\n    return global_context;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input_8h/","title":"lib/input/input.h","text":""},{"location":"api/Files/input_8h/#classes","title":"Classes","text":"Name struct __CFBDInputEventContextOperations struct __CFBDInputEventContext"},{"location":"api/Files/input_8h/#types","title":"Types","text":"Name typedef CFBD_Bool(*)(CFBDInputEvent *event) CFBDEventInputHandler typedef struct __CFBDInputEventContext CFBDInputEventContext typedef struct __CFBDInputEventContextOperations CFBDInputEventContextOperations"},{"location":"api/Files/input_8h/#functions","title":"Functions","text":"Name void CFBD_CreateInputContext(CFBDInputEventContext * context_init) void CFBD_SetGlobalInputEventContext(CFBDInputEventContext * context) const CFBDInputEventContext * CFBD_GetGlobalInputEventContext() void CFBD_CreateGlobalContext(CFBDInputEventContext * context_init)"},{"location":"api/Files/input_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/input_8h/#typedef-cfbdeventinputhandler","title":"typedef CFBDEventInputHandler","text":"<pre><code>typedef CFBD_Bool(* CFBDEventInputHandler) (CFBDInputEvent *event);\n</code></pre>"},{"location":"api/Files/input_8h/#typedef-cfbdinputeventcontext","title":"typedef CFBDInputEventContext","text":"<pre><code>typedef struct __CFBDInputEventContext CFBDInputEventContext;\n</code></pre>"},{"location":"api/Files/input_8h/#typedef-cfbdinputeventcontextoperations","title":"typedef CFBDInputEventContextOperations","text":"<pre><code>typedef struct __CFBDInputEventContextOperations CFBDInputEventContextOperations;\n</code></pre>"},{"location":"api/Files/input_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input_8h/#function-cfbd_createinputcontext","title":"function CFBD_CreateInputContext","text":"<pre><code>void CFBD_CreateInputContext(\n    CFBDInputEventContext * context_init\n)\n</code></pre>"},{"location":"api/Files/input_8h/#function-cfbd_setglobalinputeventcontext","title":"function CFBD_SetGlobalInputEventContext","text":"<pre><code>void CFBD_SetGlobalInputEventContext(\n    CFBDInputEventContext * context\n)\n</code></pre>"},{"location":"api/Files/input_8h/#function-cfbd_getglobalinputeventcontext","title":"function CFBD_GetGlobalInputEventContext","text":"<pre><code>const CFBDInputEventContext * CFBD_GetGlobalInputEventContext()\n</code></pre>"},{"location":"api/Files/input_8h/#function-cfbd_createglobalcontext","title":"function CFBD_CreateGlobalContext","text":"<pre><code>static inline void CFBD_CreateGlobalContext(\n    CFBDInputEventContext * context_init\n)\n</code></pre>"},{"location":"api/Files/input_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"input_config.h\"\n#include \"input_device_base.h\"\n#include \"input_event.h\"\n\ntypedef CFBD_Bool (*CFBDEventInputHandler)(CFBDInputEvent* event);\ntypedef struct __CFBDInputEventContext CFBDInputEventContext;\ntypedef struct __CFBDInputEventContextOperations\n{\n    CFBD_Bool (*enqueue_event)(CFBDInputEventContext* context, CFBDInputEvent* event);\n    CFBD_Bool (*sync_poll)(CFBDInputEventContext* context);\n    CFBD_Bool (*register_handle)(CFBDInputEventContext* context, CFBDEventInputHandler handler);\n    void (*unregister_handler)(CFBDInputEventContext* context, CFBDEventInputHandler handler);\n} CFBDInputEventContextOperations;\n\ntypedef struct __CFBDInputEventContext\n{\n    CFBDInputEventContextOperations* ops;\n    CFBDEventInputHandler handlers[INPUT_MAX_HANDLER_CNT];\n    uint8_t handler_count;\n    CFBDInputEvent queue[INPUT_EVENT_QUEUE_SIZE];\n    volatile uint8_t head;\n    volatile uint8_t tail;\n\n    CFBD_Bool stop_propergate_if_failed;\n} CFBDInputEventContext;\n\nvoid CFBD_CreateInputContext(CFBDInputEventContext* context_init);\nvoid CFBD_SetGlobalInputEventContext(CFBDInputEventContext* context);\nconst CFBDInputEventContext* CFBD_GetGlobalInputEventContext();\n\nstatic inline void CFBD_CreateGlobalContext(CFBDInputEventContext* context_init)\n{\n    CFBD_CreateInputContext(context_init);\n    CFBD_SetGlobalInputEventContext(context_init);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__config_8h/","title":"lib/input/input_config.h","text":""},{"location":"api/Files/input__config_8h/#defines","title":"Defines","text":"Name INPUT_MAX_HANDLER_CNT INPUT_EVENT_QUEUE_SIZE"},{"location":"api/Files/input__config_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/input__config_8h/#define-input_max_handler_cnt","title":"define INPUT_MAX_HANDLER_CNT","text":"<pre><code>#define INPUT_MAX_HANDLER_CNT (8)\n</code></pre>"},{"location":"api/Files/input__config_8h/#define-input_event_queue_size","title":"define INPUT_EVENT_QUEUE_SIZE","text":"<pre><code>#define INPUT_EVENT_QUEUE_SIZE (16)\n</code></pre>"},{"location":"api/Files/input__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define INPUT_MAX_HANDLER_CNT (8)\n\n#define INPUT_EVENT_QUEUE_SIZE (16)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__device__base_8c/","title":"lib/input/input_device_base.c","text":""},{"location":"api/Files/input__device__base_8c/#functions","title":"Functions","text":"Name CFBD_Bool bind_context(CFBDInputDeviceBase * device, CFBDInputEventContext * new_context) CFBD_Bool unbind_context(CFBDInputDeviceBase * device) CFBD_Bool report_once(CFBDInputDeviceBase * device, CFBDInputEvent * event) void setDeviceIDGenerator(CFBD_DeviceIDGenerator * id) void CFBD_CreateInputDeviceBase(CFBDInputDeviceBase * base, CFBDInputEventContext * context, void * assigned_privates)"},{"location":"api/Files/input__device__base_8c/#attributes","title":"Attributes","text":"Name CFBDInputDeviceBaseOperation ops CFBD_DeviceIDGenerator * allocator"},{"location":"api/Files/input__device__base_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__device__base_8c/#function-bind_context","title":"function bind_context","text":"<pre><code>static CFBD_Bool bind_context(\n    CFBDInputDeviceBase * device,\n    CFBDInputEventContext * new_context\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#function-unbind_context","title":"function unbind_context","text":"<pre><code>static CFBD_Bool unbind_context(\n    CFBDInputDeviceBase * device\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#function-report_once","title":"function report_once","text":"<pre><code>static CFBD_Bool report_once(\n    CFBDInputDeviceBase * device,\n    CFBDInputEvent * event\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#function-setdeviceidgenerator","title":"function setDeviceIDGenerator","text":"<pre><code>void setDeviceIDGenerator(\n    CFBD_DeviceIDGenerator * id\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#function-cfbd_createinputdevicebase","title":"function CFBD_CreateInputDeviceBase","text":"<pre><code>void CFBD_CreateInputDeviceBase(\n    CFBDInputDeviceBase * base,\n    CFBDInputEventContext * context,\n    void * assigned_privates\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/input__device__base_8c/#variable-ops","title":"variable ops","text":"<pre><code>static CFBDInputDeviceBaseOperation ops = {.bind_context = bind_context,\n                                           .unbind_context = unbind_context,\n                                           .report_once = report_once};\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#variable-allocator","title":"variable allocator","text":"<pre><code>static CFBD_DeviceIDGenerator * allocator = NULL;\n</code></pre>"},{"location":"api/Files/input__device__base_8c/#source-code","title":"Source code","text":"<pre><code>#include \"input_device_base.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"input.h\"\n#include \"input_id_allocator.h\"\n\nstatic CFBD_Bool bind_context(CFBDInputDeviceBase* device, CFBDInputEventContext* new_context)\n{\n    device-&gt;context = new_context;\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool unbind_context(CFBDInputDeviceBase* device)\n{\n    device-&gt;context = NULL;\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool report_once(CFBDInputDeviceBase* device, CFBDInputEvent* event)\n{\n    if (!device-&gt;context) {\n        return CFBD_FALSE;\n    }\n\n    return device-&gt;context-&gt;ops-&gt;enqueue_event(device-&gt;context, event);\n}\n\nstatic CFBDInputDeviceBaseOperation ops = {.bind_context = bind_context,\n                                           .unbind_context = unbind_context,\n                                           .report_once = report_once};\n\nstatic CFBD_DeviceIDGenerator* allocator = NULL;\n\nvoid setDeviceIDGenerator(CFBD_DeviceIDGenerator* id)\n{\n    allocator = id;\n}\n\nvoid CFBD_CreateInputDeviceBase(CFBDInputDeviceBase* base,\n                                CFBDInputEventContext* context,\n                                void* assigned_privates)\n{\n    base-&gt;device_internals = assigned_privates;\n    base-&gt;ops = &amp;ops;\n    base-&gt;context = context;\n\n    // allocate id\n    if (!allocator) {\n        allocator = CFBD_CreateDeviceIDDefaultGenerator();\n    }\n\n    base-&gt;device_id = allocator-&gt;get_next();\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__device__base_8h/","title":"lib/input/input_device_base.h","text":""},{"location":"api/Files/input__device__base_8h/#classes","title":"Classes","text":"Name struct __CFBDInputDeviceBaseOps struct __CFBDInputDeviceBase"},{"location":"api/Files/input__device__base_8h/#types","title":"Types","text":"Name typedef struct __CFBDInputEventContext CFBDInputEventContext typedef struct __CFBDInputDeviceBase CFBDInputDeviceBase typedef struct __CFBDInputEvent CFBDInputEvent typedef struct __CFBD_DeviceIDGenerator CFBD_DeviceIDGenerator typedef uint32_t CFBDInputDeviceID_t typedef struct __CFBDInputDeviceBaseOps CFBDInputDeviceBaseOperation"},{"location":"api/Files/input__device__base_8h/#functions","title":"Functions","text":"Name void setDeviceIDGenerator(CFBD_DeviceIDGenerator * id) void CFBD_CreateInputDeviceBase(CFBDInputDeviceBase * base, CFBDInputEventContext * context, void * assigned_privates)"},{"location":"api/Files/input__device__base_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/input__device__base_8h/#typedef-cfbdinputeventcontext","title":"typedef CFBDInputEventContext","text":"<pre><code>typedef struct __CFBDInputEventContext CFBDInputEventContext;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#typedef-cfbdinputdevicebase","title":"typedef CFBDInputDeviceBase","text":"<pre><code>typedef struct __CFBDInputDeviceBase CFBDInputDeviceBase;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#typedef-cfbdinputevent","title":"typedef CFBDInputEvent","text":"<pre><code>typedef struct __CFBDInputEvent CFBDInputEvent;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#typedef-cfbd_deviceidgenerator","title":"typedef CFBD_DeviceIDGenerator","text":"<pre><code>typedef struct __CFBD_DeviceIDGenerator CFBD_DeviceIDGenerator;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#typedef-cfbdinputdeviceid_t","title":"typedef CFBDInputDeviceID_t","text":"<pre><code>typedef uint32_t CFBDInputDeviceID_t;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#typedef-cfbdinputdevicebaseoperation","title":"typedef CFBDInputDeviceBaseOperation","text":"<pre><code>typedef struct __CFBDInputDeviceBaseOps CFBDInputDeviceBaseOperation;\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__device__base_8h/#function-setdeviceidgenerator","title":"function setDeviceIDGenerator","text":"<pre><code>void setDeviceIDGenerator(\n    CFBD_DeviceIDGenerator * id\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#function-cfbd_createinputdevicebase","title":"function CFBD_CreateInputDeviceBase","text":"<pre><code>void CFBD_CreateInputDeviceBase(\n    CFBDInputDeviceBase * base,\n    CFBDInputEventContext * context,\n    void * assigned_privates\n)\n</code></pre>"},{"location":"api/Files/input__device__base_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef struct __CFBDInputEventContext CFBDInputEventContext;\ntypedef struct __CFBDInputDeviceBase CFBDInputDeviceBase;\ntypedef struct __CFBDInputEvent CFBDInputEvent;\ntypedef struct __CFBD_DeviceIDGenerator CFBD_DeviceIDGenerator;\ntypedef uint32_t CFBDInputDeviceID_t;\n\ntypedef struct __CFBDInputDeviceBaseOps\n{\n    CFBD_Bool (*bind_context)(CFBDInputDeviceBase* device, CFBDInputEventContext* new_context);\n    CFBD_Bool (*unbind_context)(CFBDInputDeviceBase* device);\n    CFBD_Bool (*report_once)(CFBDInputDeviceBase* device, CFBDInputEvent* event);\n} CFBDInputDeviceBaseOperation;\n\ntypedef struct __CFBDInputDeviceBase\n{\n    CFBDInputDeviceID_t device_id;\n    CFBDInputEventContext* context;\n    CFBDInputDeviceBaseOperation* ops;\n    void* device_internals; // private datas\n} CFBDInputDeviceBase;      // Each devices should register this as base class\n\nvoid setDeviceIDGenerator(CFBD_DeviceIDGenerator* id); // use if wanna specified\n\nvoid CFBD_CreateInputDeviceBase(CFBDInputDeviceBase* base,\n                                CFBDInputEventContext* context,\n                                void* assigned_privates);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__event_8c/","title":"lib/input/input_event.c","text":""},{"location":"api/Files/input__event_8c/#functions","title":"Functions","text":"Name void CFBD_CreateEvent(CFBDInputEvent * event, CFBDInputDeviceBase * baseDevice, CFBDInputDeviceEventType_t eventType)"},{"location":"api/Files/input__event_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__event_8c/#function-cfbd_createevent","title":"function CFBD_CreateEvent","text":"<pre><code>void CFBD_CreateEvent(\n    CFBDInputEvent * event,\n    CFBDInputDeviceBase * baseDevice,\n    CFBDInputDeviceEventType_t eventType\n)\n</code></pre>"},{"location":"api/Files/input__event_8c/#source-code","title":"Source code","text":"<pre><code>#include \"input_event.h\"\n\nvoid CFBD_CreateEvent(CFBDInputEvent* event,\n                      CFBDInputDeviceBase* baseDevice,\n                      CFBDInputDeviceEventType_t eventType)\n{\n    event-&gt;device_id = baseDevice-&gt;device_id;\n    event-&gt;event_private_data = baseDevice-&gt;device_internals;\n    event-&gt;event_indicates = eventType;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__event_8h/","title":"lib/input/input_event.h","text":""},{"location":"api/Files/input__event_8h/#classes","title":"Classes","text":"Name struct __CFBDInputEvent"},{"location":"api/Files/input__event_8h/#types","title":"Types","text":"Name typedef uint32_t CFBDInputDeviceEventType_t typedef struct __CFBDInputEventContext CFBDInputEventContext typedef struct __CFBDInputEvent CFBDInputEvent"},{"location":"api/Files/input__event_8h/#functions","title":"Functions","text":"Name void CFBD_CreateEvent(CFBDInputEvent * event, CFBDInputDeviceBase * baseDevic, CFBDInputDeviceEventType_t eventType) void CFBD_SetEventStopHandled(CFBDInputEvent * event)"},{"location":"api/Files/input__event_8h/#defines","title":"Defines","text":"Name CFBDInputDeviceEventType_INVALID_ID CFBDInputDeviceEventType_SYSDEF_START CFBDInputDeviceEventType_USER_START"},{"location":"api/Files/input__event_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/input__event_8h/#typedef-cfbdinputdeviceeventtype_t","title":"typedef CFBDInputDeviceEventType_t","text":"<pre><code>typedef uint32_t CFBDInputDeviceEventType_t;\n</code></pre>"},{"location":"api/Files/input__event_8h/#typedef-cfbdinputeventcontext","title":"typedef CFBDInputEventContext","text":"<pre><code>typedef struct __CFBDInputEventContext CFBDInputEventContext;\n</code></pre>"},{"location":"api/Files/input__event_8h/#typedef-cfbdinputevent","title":"typedef CFBDInputEvent","text":"<pre><code>typedef struct __CFBDInputEvent CFBDInputEvent;\n</code></pre>"},{"location":"api/Files/input__event_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__event_8h/#function-cfbd_createevent","title":"function CFBD_CreateEvent","text":"<pre><code>void CFBD_CreateEvent(\n    CFBDInputEvent * event,\n    CFBDInputDeviceBase * baseDevic,\n    CFBDInputDeviceEventType_t eventType\n)\n</code></pre>"},{"location":"api/Files/input__event_8h/#function-cfbd_seteventstophandled","title":"function CFBD_SetEventStopHandled","text":"<pre><code>static inline void CFBD_SetEventStopHandled(\n    CFBDInputEvent * event\n)\n</code></pre>"},{"location":"api/Files/input__event_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/input__event_8h/#define-cfbdinputdeviceeventtype_invalid_id","title":"define CFBDInputDeviceEventType_INVALID_ID","text":"<pre><code>#define CFBDInputDeviceEventType_INVALID_ID (0)\n</code></pre>"},{"location":"api/Files/input__event_8h/#define-cfbdinputdeviceeventtype_sysdef_start","title":"define CFBDInputDeviceEventType_SYSDEF_START","text":"<pre><code>#define CFBDInputDeviceEventType_SYSDEF_START (CFBDInputDeviceEventType_INVALID_ID + 1)\n</code></pre>"},{"location":"api/Files/input__event_8h/#define-cfbdinputdeviceeventtype_user_start","title":"define CFBDInputDeviceEventType_USER_START","text":"<pre><code>#define CFBDInputDeviceEventType_USER_START (0x100)\n</code></pre>"},{"location":"api/Files/input__event_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"input_device_base.h\"\n\ntypedef uint32_t CFBDInputDeviceEventType_t;\ntypedef struct __CFBDInputEventContext CFBDInputEventContext;\n\n#define CFBDInputDeviceEventType_INVALID_ID (0)\n#define CFBDInputDeviceEventType_SYSDEF_START (CFBDInputDeviceEventType_INVALID_ID + 1)\n#define CFBDInputDeviceEventType_USER_START (0x100)\n\ntypedef struct __CFBDInputEvent\n{\n    CFBDInputDeviceEventType_t event_indicates; // what events?\n    CFBDInputDeviceID_t device_id;              // what device?\n    void* event_private_data;                   // event_datas\n    CFBD_Bool stop_propergate;                  // should stop propergate?\n} CFBDInputEvent; // OK, Events here contains what where are the session from\n\nvoid CFBD_CreateEvent(CFBDInputEvent* event,\n                      CFBDInputDeviceBase* baseDevic,\n                      CFBDInputDeviceEventType_t eventType);\n\nstatic inline void CFBD_SetEventStopHandled(CFBDInputEvent* event)\n{\n    event-&gt;stop_propergate = CFBD_TRUE;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__id__allocator_8c/","title":"lib/input/input_id_allocator.c","text":""},{"location":"api/Files/input__id__allocator_8c/#functions","title":"Functions","text":"Name CFBDInputDeviceID_t default_gen() CFBD_DeviceIDGenerator * CFBD_CreateDeviceIDDefaultGenerator() void CFBD_CreateDeviceIDCustomGenerator(CFBD_DeviceIDGenerator * gen, CFBDInputDeviceID_t(*)() get_next)"},{"location":"api/Files/input__id__allocator_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__id__allocator_8c/#function-default_gen","title":"function default_gen","text":"<pre><code>static CFBDInputDeviceID_t default_gen()\n</code></pre>"},{"location":"api/Files/input__id__allocator_8c/#function-cfbd_createdeviceiddefaultgenerator","title":"function CFBD_CreateDeviceIDDefaultGenerator","text":"<pre><code>CFBD_DeviceIDGenerator * CFBD_CreateDeviceIDDefaultGenerator()\n</code></pre>"},{"location":"api/Files/input__id__allocator_8c/#function-cfbd_createdeviceidcustomgenerator","title":"function CFBD_CreateDeviceIDCustomGenerator","text":"<pre><code>void CFBD_CreateDeviceIDCustomGenerator(\n    CFBD_DeviceIDGenerator * gen,\n    CFBDInputDeviceID_t(*)() get_next\n)\n</code></pre>"},{"location":"api/Files/input__id__allocator_8c/#source-code","title":"Source code","text":"<pre><code>#include \"input_id_allocator.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"input_device_base.h\"\n\nstatic CFBDInputDeviceID_t default_gen()\n{\n    static uint32_t GlobalAllocateID = 0;\n    return GlobalAllocateID++;\n}\n\nCFBD_DeviceIDGenerator* CFBD_CreateDeviceIDDefaultGenerator()\n{\n    static CFBD_DeviceIDGenerator gen;\n    CFBD_CreateDeviceIDCustomGenerator(&amp;gen, default_gen);\n    return &amp;gen;\n}\n\nvoid CFBD_CreateDeviceIDCustomGenerator(CFBD_DeviceIDGenerator* gen,\n                                        CFBDInputDeviceID_t (*get_next)())\n{\n    gen-&gt;get_next = get_next;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/input__id__allocator_8h/","title":"lib/input/input_id_allocator.h","text":""},{"location":"api/Files/input__id__allocator_8h/#classes","title":"Classes","text":"Name struct __CFBD_DeviceIDGenerator"},{"location":"api/Files/input__id__allocator_8h/#types","title":"Types","text":"Name typedef struct __CFBD_DeviceIDGenerator CFBD_DeviceIDGenerator"},{"location":"api/Files/input__id__allocator_8h/#functions","title":"Functions","text":"Name CFBD_DeviceIDGenerator * CFBD_CreateDeviceIDDefaultGenerator() void CFBD_CreateDeviceIDCustomGenerator(CFBD_DeviceIDGenerator * gen, CFBDInputDeviceID_t(*)() get_next)"},{"location":"api/Files/input__id__allocator_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/input__id__allocator_8h/#typedef-cfbd_deviceidgenerator","title":"typedef CFBD_DeviceIDGenerator","text":"<pre><code>typedef struct __CFBD_DeviceIDGenerator CFBD_DeviceIDGenerator;\n</code></pre>"},{"location":"api/Files/input__id__allocator_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/input__id__allocator_8h/#function-cfbd_createdeviceiddefaultgenerator","title":"function CFBD_CreateDeviceIDDefaultGenerator","text":"<pre><code>CFBD_DeviceIDGenerator * CFBD_CreateDeviceIDDefaultGenerator()\n</code></pre>"},{"location":"api/Files/input__id__allocator_8h/#function-cfbd_createdeviceidcustomgenerator","title":"function CFBD_CreateDeviceIDCustomGenerator","text":"<pre><code>void CFBD_CreateDeviceIDCustomGenerator(\n    CFBD_DeviceIDGenerator * gen,\n    CFBDInputDeviceID_t(*)() get_next\n)\n</code></pre>"},{"location":"api/Files/input__id__allocator_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"input_device_base.h\"\ntypedef struct __CFBD_DeviceIDGenerator\n{\n    CFBDInputDeviceID_t (*get_next)();\n} CFBD_DeviceIDGenerator;\n\nCFBD_DeviceIDGenerator* CFBD_CreateDeviceIDDefaultGenerator();\nvoid CFBD_CreateDeviceIDCustomGenerator(CFBD_DeviceIDGenerator* gen,\n                                        CFBDInputDeviceID_t (*get_next)());\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/lib__settings_8h/","title":"lib/config/lib_settings.h","text":""},{"location":"api/Files/lib__settings_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"config/system_settings.h\"\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/line_8c/","title":"line.c","text":""},{"location":"api/Files/line_8c/#functions","title":"Functions","text":"Name void swap_int16(int16_t * val1, int16_t * val2) uint16_t max_uint16(uint16_t val1, uint16_t val2) uint16_t min_uint16(uint16_t val1, uint16_t val2) void clearBounds(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_vertical_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __on_handle_horizental_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line) void __pvt_BresenhamMethod_line(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Files/line_8c/#defines","title":"Defines","text":"Name __pvt_fast_draw_point(X, Y)"},{"location":"api/Files/line_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/line_8c/#function-swap_int16","title":"function swap_int16","text":"<pre><code>static inline void swap_int16(\n    int16_t * val1,\n    int16_t * val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-max_uint16","title":"function max_uint16","text":"<pre><code>static inline uint16_t max_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-min_uint16","title":"function min_uint16","text":"<pre><code>static inline uint16_t min_uint16(\n    uint16_t val1,\n    uint16_t val2\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-clearbounds","title":"function clearBounds","text":"<pre><code>static inline void clearBounds(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_vertical_line","title":"function __on_handle_vertical_line","text":"<pre><code>static void __on_handle_vertical_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__on_handle_horizental_line","title":"function __on_handle_horizental_line","text":"<pre><code>static void __on_handle_horizental_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#function-__pvt_bresenhammethod_line","title":"function __pvt_BresenhamMethod_line","text":"<pre><code>void __pvt_BresenhamMethod_line(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre>"},{"location":"api/Files/line_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/line_8c/#define-__pvt_fast_draw_point","title":"define __pvt_fast_draw_point","text":"<pre><code>#define __pvt_fast_draw_point(\n    X,\n    Y\n)\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n</code></pre>"},{"location":"api/Files/line_8c/#source-code","title":"Source code","text":"<pre><code>#include \"line.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"point.h\"\n\nstatic inline void swap_int16(int16_t* val1, int16_t* val2)\n{\n    if (*val1 == *val2)\n        return;\n    *val1 ^= *val2;\n    *val2 ^= *val1;\n    *val1 ^= *val2;\n}\n\nstatic inline uint16_t max_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &gt; val2 ? val1 : val2;\n}\n\nstatic inline uint16_t min_uint16(uint16_t val1, uint16_t val2)\n{\n    return val1 &lt; val2 ? val1 : val2;\n}\n\nstatic inline void clearBounds(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    int32_t lx = asInt32_t(line-&gt;p_left.x);\n    int32_t rx = asInt32_t(line-&gt;p_right.x);\n    int32_t ty = asInt32_t(line-&gt;p_left.y);\n    int32_t by = asInt32_t(line-&gt;p_right.y);\n\n    if (lx &gt; rx) {\n        int32_t t = lx;\n        lx = rx;\n        rx = t;\n    }\n    if (ty &gt; by) {\n        int32_t t = ty;\n        ty = by;\n        by = t;\n    }\n}\n\n/*\n    draw the lines that matches the equal x\n*/\nstatic void __on_handle_vertical_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    PointBaseType max_y = max_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType min_y = min_uint16(line-&gt;p_left.y, line-&gt;p_right.y);\n    PointBaseType x = line-&gt;p_left.x;\n    PointBaseType y;\n    CFBD_Bool (*setpixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    for (PointBaseType i = min_y; i &lt;= max_y; i++) {\n        y = i;\n        setpixel(handler, x, y);\n    }\n}\n\nstatic void __on_handle_horizental_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n    PointBaseType max_x = max_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType min_x = min_uint16(line-&gt;p_left.x, line-&gt;p_right.x);\n    PointBaseType x;\n    PointBaseType y = line-&gt;p_left.y;\n    for (PointBaseType i = min_x; i &lt;= max_x; i++) {\n        x = i;\n        setPixel(handler, x, y);\n    }\n}\n\n// Bresenham's Line Algorithm, designed to avoid floating point calculations\n// References: https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf\n// https://www.bilibili.com/video/BV1364y1d7Lo\nvoid __pvt_BresenhamMethod_line(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handler-&gt;ops-&gt;setPixel;\n\n#define __pvt_fast_draw_point(X, Y)                                                                \\\n    do {                                                                                           \\\n        setPixel(handler, X, Y);                                                                   \\\n    } while (0)\n\n    // Define initial points for the line: p_left and p_right represent the endpoints\n    int16_t startX = line-&gt;p_left.x;\n    int16_t startY = line-&gt;p_left.y;\n    int16_t endX = line-&gt;p_right.x;\n    int16_t endY = line-&gt;p_right.y;\n\n    // Flags to indicate transformations of coordinates\n    uint8_t isYInverted = 0, isXYInverted = 0;\n    {\n        // If the start point's X coordinate is greater than the end point's X, swap the points\n        if (startX &gt; endX) {\n            // Swap the X and Y coordinates for the start and end points\n            swap_int16(&amp;startX, &amp;endX);\n            swap_int16(&amp;startY, &amp;endY);\n        }\n\n        // If the start point's Y coordinate is greater than the end point's Y, invert the Y\n        // coordinates\n        if (startY &gt; endY) {\n            // Invert Y coordinates to make the line direction consistent in the first quadrant\n            startY = -startY;\n            endY = -endY;\n            // Set the flag indicating Y coordinates were inverted\n            isYInverted = 1;\n        }\n\n        // If the line's slope (dy/dx) is greater than 1, swap X and Y coordinates for a shallower\n        // slope\n        if (endY - startY &gt; endX - startX) {\n            // Swap X and Y coordinates for both points\n            swap_int16(&amp;startX, &amp;startY);\n            swap_int16(&amp;endX, &amp;endY);\n            // Set the flag indicating both X and Y coordinates were swapped\n            isXYInverted = 1;\n        }\n\n        // Calculate differences (dx, dy) and the decision variables for Bresenham's algorithm\n        const int16_t dx = endX - startX;\n        const int16_t dy = endY - startY;\n        const int16_t incrE = 2 * dy;         // Increment for eastward movement\n        const int16_t incrNE = 2 * (dy - dx); // Increment for northeastward movement\n\n        int16_t decision = 2 * dy - dx; // Initial decision variable\n        int16_t x = startX;             // Starting X coordinate\n        int16_t y = startY;             // Starting Y coordinate\n\n        // Draw the starting point and handle coordinate transformations based on flags\n        if (isYInverted &amp;&amp; isXYInverted) {\n            __pvt_fast_draw_point(y, -x);\n        }\n        else if (isYInverted) {\n            __pvt_fast_draw_point(x, -y);\n        }\n        else if (isXYInverted) {\n            __pvt_fast_draw_point(y, x);\n        }\n        else {\n            __pvt_fast_draw_point(x, y);\n        }\n\n        // Iterate through the X-axis to draw the rest of the line\n        while (x &lt; endX) {\n            x++; // Increment X coordinate\n            if (decision &lt; 0) {\n                decision += incrE; // Move eastward if decision variable is negative\n            }\n            else {\n                y++; // Move northeastward if decision variable is positive or zero\n                decision += incrNE;\n            }\n\n            // Draw each point along the line with coordinate transformation as needed\n            if (isYInverted &amp;&amp; isXYInverted) {\n                __pvt_fast_draw_point(y, -x);\n            }\n            else if (isYInverted) {\n                __pvt_fast_draw_point(x, -y);\n            }\n            else if (isXYInverted) {\n                __pvt_fast_draw_point(y, x);\n            }\n            else {\n                __pvt_fast_draw_point(x, y);\n            }\n        }\n    }\n}\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line)\n{\n    clearBounds(handler, line);\n    // test if the vertical\n    if (line-&gt;p_left.x == line-&gt;p_right.x)\n        __on_handle_vertical_line(handler, line);\n    if (line-&gt;p_left.y == line-&gt;p_right.y)\n        __on_handle_horizental_line(handler, line);\n    __pvt_BresenhamMethod_line(handler, line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handler)) {\n        int32_t lx = asInt32_t(line-&gt;p_left.x);\n        int32_t rx = asInt32_t(line-&gt;p_right.x);\n        int32_t ty = asInt32_t(line-&gt;p_left.y);\n        int32_t by = asInt32_t(line-&gt;p_right.y);\n\n        if (lx &gt; rx) {\n            int32_t t = lx;\n            lx = rx;\n            rx = t;\n        }\n        if (ty &gt; by) {\n            int32_t t = ty;\n            ty = by;\n            by = t;\n        }\n\n        handler-&gt;ops-&gt;update_area(handler,\n                                  clamp_u16_from_i32(lx),\n                                  clamp_u16_from_i32(ty),\n                                  clamp_u16_from_i32(rx - lx + 1),\n                                  clamp_u16_from_i32(by - ty + 1));\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/line_8h/","title":"line.h","text":"<p>Line drawing utilities for 2D graphics rendering. </p>"},{"location":"api/Files/line_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Line Represents a line segment defined by two endpoints."},{"location":"api/Files/line_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"point.h\"\n\ntypedef struct\n{\n    CFBDGraphic_Point p_left;  \n    CFBDGraphic_Point p_right; \n} CFBDGraphic_Line;\n\nvoid CFBDGraphic_DrawLine(CFBD_GraphicDevice* handler, CFBDGraphic_Line* line);\n\n // End of Line_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu_8c/","title":"lib/graphic/widget/menu/menu.c","text":""},{"location":"api/Files/menu_8c/#functions","title":"Functions","text":"Name const uint16_t get_menu_new_item_x(CFBD_Menu * pMenu) const uint16_t get_menu_new_item_height(CFBD_MenuItem * item) const uint16_t get_menu_new_item_y(CFBD_Menu * pMenu) void CFBD_BindMenuItems(CFBD_Menu * pMenu, CFBD_MenuItemGroup * assigned_menu_items) void CFBD_AnimationSet(CFBD_Menu * pMenu, CFBD_BaseAnimation * pBaseAnimation) CFBD_Bool CFBD_MenuAddItems(CFBD_Menu * pMenu, const char * label, Ascii_Font_Size font_size, CFBD_MenuItemCallbackPack * callbacks) void CFBD_DrawMenu(CFBD_Menu * m) void redraw_item(CFBD_Menu * m, int idx) int32_t smoothstep_q8(int32_t f, int32_t frames) void OLED_Menu_Select(CFBD_Menu * m, int new_index) void reset_tl_points(CFBD_Menu * m, CFBDGraphic_Point * p, CFBD_Bool request_updates) void OLED_Menu_Activate(CFBD_Menu * m) void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width)"},{"location":"api/Files/menu_8c/#attributes","title":"Attributes","text":"Name CFBD_MenuOps _ops"},{"location":"api/Files/menu_8c/#defines","title":"Defines","text":"Name MAKE_RECT(rx, ry, rw, rh) LERP_Q8(a, b, s)"},{"location":"api/Files/menu_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8c/#function-get_menu_new_item_x","title":"function get_menu_new_item_x","text":"<pre><code>static inline const uint16_t get_menu_new_item_x(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_height","title":"function get_menu_new_item_height","text":"<pre><code>static const uint16_t get_menu_new_item_height(\n    CFBD_MenuItem * item\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-get_menu_new_item_y","title":"function get_menu_new_item_y","text":"<pre><code>static const uint16_t get_menu_new_item_y(\n    CFBD_Menu * pMenu\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_bindmenuitems","title":"function CFBD_BindMenuItems","text":"<pre><code>static void CFBD_BindMenuItems(\n    CFBD_Menu * pMenu,\n    CFBD_MenuItemGroup * assigned_menu_items\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_animationset","title":"function CFBD_AnimationSet","text":"<pre><code>static void CFBD_AnimationSet(\n    CFBD_Menu * pMenu,\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_menuadditems","title":"function CFBD_MenuAddItems","text":"<pre><code>static CFBD_Bool CFBD_MenuAddItems(\n    CFBD_Menu * pMenu,\n    const char * label,\n    Ascii_Font_Size font_size,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_drawmenu","title":"function CFBD_DrawMenu","text":"<pre><code>static void CFBD_DrawMenu(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-redraw_item","title":"function redraw_item","text":"<pre><code>static void redraw_item(\n    CFBD_Menu * m,\n    int idx\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-smoothstep_q8","title":"function smoothstep_q8","text":"<pre><code>static inline int32_t smoothstep_q8(\n    int32_t f,\n    int32_t frames\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_select","title":"function OLED_Menu_Select","text":"<pre><code>void OLED_Menu_Select(\n    CFBD_Menu * m,\n    int new_index\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-reset_tl_points","title":"function reset_tl_points","text":"<pre><code>static void reset_tl_points(\n    CFBD_Menu * m,\n    CFBDGraphic_Point * p,\n    CFBD_Bool request_updates\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-oled_menu_activate","title":"function OLED_Menu_Activate","text":"<pre><code>static void OLED_Menu_Activate(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu_8c/#variable-_ops","title":"variable _ops","text":"<pre><code>static CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n</code></pre>"},{"location":"api/Files/menu_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/menu_8c/#define-make_rect","title":"define MAKE_RECT","text":"<pre><code>#define MAKE_RECT(\n    rx,\n    ry,\n    rw,\n    rh\n)\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n</code></pre>"},{"location":"api/Files/menu_8c/#define-lerp_q8","title":"define LERP_Q8","text":"<pre><code>#define LERP_Q8(\n    a,\n    b,\n    s\n)\n((a) + (((b) - (a)) * (s) &gt;&gt; 8))\n</code></pre>"},{"location":"api/Files/menu_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_config.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"sys_clock/system_clock.h\"\n#include \"widget/base_support/common/helpers.h\"\n#include \"widget/menu/menu.h\"\n#include \"widget/text.h\"\n#include \"widget/text_config.h\"\n\nstatic inline const uint16_t get_menu_new_item_x(CFBD_Menu* pMenu)\n{\n    return pMenu-&gt;tl_point.x + pMenu-&gt;indicator.width + pMenu-&gt;indicator.x +\n           CFBD_MENU_INDICATOR_GAP;\n}\n\nstatic const uint16_t get_menu_new_item_height(CFBD_MenuItem* item)\n{\n    CFBDGraphicSize sz = __fetch_font_size(item-&gt;text_obj.font_size);\n    return (sz.height + 2 * CFBD_MENU_ITEM_Y_GAP);\n}\n\nstatic const uint16_t get_menu_new_item_y(CFBD_Menu* pMenu)\n{\n    uint16_t result = pMenu-&gt;tl_point.y;\n    if (!pMenu || !pMenu-&gt;menu_items) {\n        return result;\n    }\n\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    for (uint8_t i = 0; i &lt; group-&gt;count; i++) {\n        result += get_menu_new_item_height(&amp;group-&gt;pItems[i]);\n    }\n    return result + CFBD_MENU_ITEM_Y_GAP;\n}\n\nstatic void CFBD_BindMenuItems(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items)\n{\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n\nstatic void CFBD_AnimationSet(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation)\n{\n    pMenu-&gt;animation = *pBaseAnimation;\n}\n\nstatic CFBD_Bool CFBD_MenuAddItems(CFBD_Menu* pMenu,\n                                   const char* label,\n                                   Ascii_Font_Size font_size,\n                                   CFBD_MenuItemCallbackPack* callbacks)\n{\n    CFBD_MenuItemGroup* group = pMenu-&gt;menu_items;\n    if (group-&gt;count &gt;= group-&gt;capacity) {\n        return CFBD_FALSE;\n    }\n\n    CFBD_MenuItem* it = &amp;group-&gt;pItems[group-&gt;count];\n    it-&gt;label = (char*) label;\n    CFBDGraphic_Point p = {.x = get_menu_new_item_x(pMenu), .y = get_menu_new_item_y(pMenu)};\n    CFBD_MenuItemInit(it, &amp;p, callbacks);\n    CFBDGraphicSize sz = {.width = pMenu-&gt;max_width,\n                          .height = __fetch_font_size(font_size).height + 2 * CFBD_MENU_ITEM_Y_GAP};\n    /* init text object */\n    CFBDGraphic_InitText(&amp;it-&gt;text_obj, it-&gt;tl, sz, font_size);\n    CFBDGraphic_SetText(&amp;it-&gt;text_obj, it-&gt;label);\n    group-&gt;count++;\n\n    return CFBD_TRUE;\n}\n\nstatic void CFBD_DrawMenu(CFBD_Menu* m)\n{\n    CFBD_GraphicDevice* dev = m-&gt;device;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    for (size_t i = 0; i &lt; group-&gt;count; ++i) {\n        CFBD_MenuItem* it = &amp;group-&gt;pItems[i];\n        CFBDGraphic_DrawText(dev, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n    }\n\n    /* draw indicator at selected */\n    if (m-&gt;selected &gt;= 0 &amp;&amp; (size_t) m-&gt;selected &lt; group-&gt;count) {\n        CFBD_MenuItem* sel = &amp;group-&gt;pItems[m-&gt;selected];\n        uint16_t ix = m-&gt;tl_point.x + m-&gt;indicator.x;\n        uint16_t iy = sel-&gt;tl.y;\n        uint16_t ih = rect_height(&amp;sel-&gt;text_obj.text_bounding_rect);\n        CFBD_DrawMenuIndicator(m, ix, iy, m-&gt;indicator.width, ih);\n\n        /* reversed the target */\n        CFBDGraphic_Text* text = &amp;sel-&gt;text_obj;\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    text-&gt;tl_point.x,\n                                    text-&gt;tl_point.y,\n                                    rect_width(&amp;text-&gt;text_bounding_rect),\n                                    ih);\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(m-&gt;device)) {\n        m-&gt;device-&gt;ops-&gt;update(m-&gt;device);\n    }\n}\n\nstatic void redraw_item(CFBD_Menu* m, int idx)\n{\n    if (idx &lt; 0 || (size_t) idx &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[idx];\n\n    /* \u4f7f\u7528\u9a71\u52a8\u63d0\u4f9b\u7684 clear_area\uff08clear_rect_area \u5df2\u7ecf\u4f1a\u4ee3\u7406\uff09 */\n    CFBDGraphicSize* size = &amp;it-&gt;text_obj.TexthandleSize;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, it-&gt;tl.x, it-&gt;tl.y, size-&gt;width, size-&gt;height);\n    CFBDGraphic_DrawText(m-&gt;device, &amp;it-&gt;text_obj, CCGraphic_AsciiTextItem_RequestOldPoint);\n}\n\nstatic inline int32_t smoothstep_q8(int32_t f, int32_t frames)\n{\n    int32_t t = (f &lt;&lt; 8) / frames; // Q8\n    int32_t t2 = (t * t) &gt;&gt; 8;\n    return (t2 * (3 * 256 - 2 * t)) &gt;&gt; 8;\n}\n\nvoid OLED_Menu_Select(CFBD_Menu* m, int new_index)\n{\n    if (new_index &lt; 0)\n        new_index = 0;\n    CFBD_MenuItemGroup* group = m-&gt;menu_items;\n    if (new_index &gt;= (int) group-&gt;count)\n        new_index = (int) group-&gt;count - 1;\n    int old = m-&gt;selected;\n    if (old == new_index)\n        return;\n\n    uint16_t start_y = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? group-&gt;pItems[old].tl.y\n                                                                 : group-&gt;pItems[0].tl.y;\n\n    uint16_t end_y = group-&gt;pItems[new_index].tl.y;\n    int frames = (m-&gt;animation.anim_frames &gt; 1) ? m-&gt;animation.anim_frames : 1;\n\n#define MAKE_RECT(rx, ry, rw, rh)                                                                  \\\n    (CFBDGraphicRect)                                                                              \\\n    {                                                                                              \\\n        {(uint16_t) (rx), (uint16_t) (ry)},                                                        \\\n        {                                                                                          \\\n            (uint16_t) ((rx) + (rw)), (uint16_t) ((ry) + (rh))                                     \\\n        }                                                                                          \\\n    }\n\n    CFBDGraphicRect global_upd;\n    CFBD_Bool have_global = CFBD_FALSE;\n\n    /* restore old text highlight */\n    uint16_t old_text_x = 0, old_text_w = 0, old_text_h = 0;\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        old_text_x = ot-&gt;tl_point.x;\n        old_text_w = rect_width(&amp;ot-&gt;text_bounding_rect);\n        old_text_h = rect_height(&amp;ot-&gt;text_bounding_rect);\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        CFBDGraphicRect r = MAKE_RECT(old_text_x, ot-&gt;tl_point.y, old_text_w, old_text_h);\n        global_upd = r;\n        have_global = CFBD_TRUE;\n    }\n\n    /* clear indicator column */\n    uint16_t old_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count)\n                             ? group-&gt;pItems[old].text_obj.TexthandleSize.height\n                             : group-&gt;pItems[0].text_obj.TexthandleSize.height;\n    uint16_t new_h = group-&gt;pItems[new_index].text_obj.TexthandleSize.height;\n    uint16_t miny = MIN(start_y, end_y);\n    uint16_t maxy = MAX(start_y, end_y) + MAX(old_h, new_h);\n    uint16_t colx = m-&gt;tl_point.x + m-&gt;indicator.x, colw = m-&gt;indicator.width;\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, miny, colw, maxy - miny);\n    {\n        CFBDGraphicRect r = MAKE_RECT(colx, miny, colw, maxy - miny);\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n        }\n    }\n\n    /* new text parameters */\n    CFBDGraphic_Text* nt = &amp;group-&gt;pItems[new_index].text_obj;\n    uint16_t new_text_x = nt-&gt;tl_point.x;\n    uint16_t new_text_w = rect_width(&amp;nt-&gt;text_bounding_rect);\n    volatile CFBDGraphicRect n = rect_normalize(nt-&gt;text_bounding_rect);\n    uint16_t new_text_h = (uint32_t) asInt32_t(n.br.y) - (uint32_t) asInt32_t(n.tl.y);\n\n    /* prepare interpolation bases (if old missing, base on new) */\n    int base_x = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_x : (int) new_text_x;\n    int base_w = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_w : (int) new_text_w;\n    int base_h = (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) ? (int) old_text_h : (int) new_text_h;\n\n    int last_rev_x = -1, last_rev_y = -1, last_rev_w = 0, last_rev_h = 0;\n\n    for (int f = 0; f &lt;= frames; ++f) {\n        int32_t st = smoothstep_q8(f, frames);\n#define LERP_Q8(a, b, s) ((a) + (((b) - (a)) * (s) &gt;&gt; 8))\n        int cur_y = LERP_Q8(start_y, end_y, st);\n        int cur_x = LERP_Q8(base_x, new_text_x, st);\n        int cur_w = LERP_Q8(base_w, new_text_w, st);\n        int cur_h = LERP_Q8(base_h, new_text_h, st);\n#undef LERP_Q8\n\n        if (cur_w &lt; 1)\n            cur_w = 1;\n        if (cur_h &lt; 1)\n            cur_h = 1;\n\n        CFBDGraphicRect frame_upd;\n        CFBD_Bool have_frame = CFBD_FALSE;\n\n        /* restore previous frame's revert (before drawing indicator) */\n        if (last_rev_y &gt;= 0) {\n            m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                        (uint16_t) last_rev_x,\n                                        (uint16_t) last_rev_y,\n                                        (uint16_t) last_rev_w,\n                                        (uint16_t) last_rev_h);\n            CFBDGraphicRect r = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n            frame_upd = r;\n            have_frame = CFBD_TRUE;\n        }\n\n        /* draw indicator */\n        uint16_t ih = MAX(old_h, new_h);\n\n        CFBD_DrawMenuIndicator(m, colx, cur_y, colw, ih);\n        {\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        /* apply current-frame text revert (this produces the highlight) */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) cur_x,\n                                    (uint16_t) cur_y,\n                                    (uint16_t) cur_w,\n                                    (uint16_t) cur_h);\n        {\n            CFBDGraphicRect r = MAKE_RECT(cur_x, cur_y, cur_w, cur_h);\n            if (!have_frame) {\n                frame_upd = r;\n                have_frame = CFBD_TRUE;\n            }\n            else {\n                frame_upd = rect_union(&amp;frame_upd, &amp;r);\n            }\n        }\n\n        last_rev_x = cur_x;\n        last_rev_y = cur_y;\n        last_rev_w = cur_w;\n        last_rev_h = cur_h;\n\n        if (have_frame) {\n            uint16_t ux = frame_upd.tl.x;\n            uint16_t uy = frame_upd.tl.y;\n            uint16_t uw = (uint16_t) (frame_upd.br.x - frame_upd.tl.x);\n            uint16_t uh = (uint16_t) (frame_upd.br.y - frame_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n            if (!have_global) {\n                global_upd = frame_upd;\n                have_global = CFBD_TRUE;\n            }\n            else\n                global_upd = rect_union(&amp;global_upd, &amp;frame_upd);\n        }\n\n        system_delay_ms(m-&gt;animation.anim_frame_delay_ms);\n\n        /* clear indicator (non-final frame) */\n        if (f != frames) {\n            m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device, colx, cur_y, colw, ih);\n            CFBDGraphicRect r = MAKE_RECT(colx, cur_y, colw, ih);\n            if (!have_global) {\n                global_upd = r;\n                have_global = CFBD_TRUE;\n            }\n            else {\n                global_upd = rect_union(&amp;global_upd, &amp;r);\n            }\n        }\n    }\n\n    /* redraw old item and include into global update */\n    if (old &gt;= 0 &amp;&amp; (size_t) old &lt; group-&gt;count) {\n        redraw_item(m, old);\n        CFBDGraphic_Text* ot = &amp;group-&gt;pItems[old].text_obj;\n        CFBDGraphicRect r = MAKE_RECT(ot-&gt;tl_point.x,\n                                      ot-&gt;tl_point.y,\n                                      rect_width(&amp;ot-&gt;text_bounding_rect),\n                                      rect_height(&amp;ot-&gt;text_bounding_rect));\n        if (!have_global) {\n            global_upd = r;\n            have_global = CFBD_TRUE;\n        }\n        else\n            global_upd = rect_union(&amp;global_upd, &amp;r);\n    }\n\n    /* final correction: if last_rev differs from exact end, restore and set exact final */\n    if (last_rev_y &gt;= 0 &amp;&amp; (last_rev_y != (int) end_y || last_rev_w != (int) new_text_w ||\n                            last_rev_x != (int) new_text_x || last_rev_h != (int) new_text_h)) {\n        /* restore last */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device,\n                                    (uint16_t) last_rev_x,\n                                    (uint16_t) last_rev_y,\n                                    (uint16_t) last_rev_w,\n                                    (uint16_t) last_rev_h);\n        CFBDGraphicRect r1 = MAKE_RECT(last_rev_x, last_rev_y, last_rev_w, last_rev_h);\n        if (!have_global) {\n            global_upd = r1;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r1);\n        }\n\n        /* final exact revert at end_y with new size */\n        m-&gt;device-&gt;ops-&gt;revert_area(m-&gt;device, new_text_x, end_y, new_text_w, new_text_h);\n        CFBDGraphicRect r2 = MAKE_RECT(new_text_x, end_y, new_text_w, new_text_h);\n        if (!have_global) {\n            global_upd = r2;\n            have_global = CFBD_TRUE;\n        }\n        else {\n            global_upd = rect_union(&amp;global_upd, &amp;r2);\n        }\n\n        /* flush final small region */\n        uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n        uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n        uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n    }\n    else {\n        if (have_global) {\n            uint16_t ux = global_upd.tl.x, uy = global_upd.tl.y;\n            uint16_t uw = (uint16_t) (global_upd.br.x - global_upd.tl.x);\n            uint16_t uh = (uint16_t) (global_upd.br.y - global_upd.tl.y);\n            m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device, ux, uy, uw, uh);\n        }\n    }\n\n#undef MAKE_RECT\n    m-&gt;selected = new_index;\n}\n\nstatic void reset_tl_points(CFBD_Menu* m, CFBDGraphic_Point* p, CFBD_Bool request_updates)\n{\n    m-&gt;device-&gt;ops-&gt;clear_area(m-&gt;device,\n                               m-&gt;tl_point.x,\n                               m-&gt;tl_point.y,\n                               m-&gt;max_width,\n                               get_menu_new_item_y(m) - m-&gt;tl_point.y);\n    m-&gt;tl_point = *p;\n    PointBaseType y_height = CFBD_MENU_ITEM_Y_GAP + m-&gt;tl_point.y;\n    for (int i = 0; i &lt; m-&gt;menu_items-&gt;count; i++) {\n        CFBD_MenuItem* item = &amp;m-&gt;menu_items-&gt;pItems[i];\n        item-&gt;tl.x = get_menu_new_item_x(m);\n        item-&gt;tl.y = y_height;\n        CFBDGraphic_SetTextTLPointPoint(&amp;item-&gt;text_obj, &amp;item-&gt;tl);\n        y_height += get_menu_new_item_height(item) - CFBD_MENU_ITEM_Y_GAP;\n    }\n    if (request_updates) {\n        m-&gt;device-&gt;ops-&gt;update_area(m-&gt;device,\n                                    m-&gt;tl_point.x,\n                                    m-&gt;tl_point.y,\n                                    m-&gt;max_width,\n                                    get_menu_new_item_y(m) - m-&gt;tl_point.y);\n        CFBD_DrawMenu(m);\n    }\n}\n\nstatic void OLED_Menu_Activate(CFBD_Menu* m)\n{\n    if (m-&gt;selected &lt; 0 || (size_t) m-&gt;selected &gt;= m-&gt;menu_items-&gt;count)\n        return;\n    CFBD_MenuItem* it = &amp;m-&gt;menu_items-&gt;pItems[m-&gt;selected];\n    CFBD_MenuItemCallbackPack* pack = &amp;it-&gt;on_select;\n    if (pack-&gt;callback) {\n        pack-&gt;callback(pack-&gt;user_data);\n    }\n}\n\nstatic CFBD_MenuOps _ops = {.bind_item_groups_contains = CFBD_BindMenuItems,\n                            .set_animation = CFBD_AnimationSet,\n                            .add_item = CFBD_MenuAddItems,\n                            .immediate_draw = CFBD_DrawMenu,\n                            .activate_current = OLED_Menu_Activate,\n                            .select_index = OLED_Menu_Select,\n                            .reset_tl_points = reset_tl_points};\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width)\n{\n    pMenu-&gt;operations = &amp;_ops;\n    pMenu-&gt;max_width = max_width;\n    pMenu-&gt;device = devices;\n    pMenu-&gt;tl_point.x = 0;\n    pMenu-&gt;tl_point.y = 0;\n    CFBD_InitBaseAnimation(&amp;pMenu-&gt;animation);\n    CFBD_InitDefaultMenuIndicator(&amp;pMenu-&gt;indicator);\n    pMenu-&gt;menu_items = assigned_menu_items;\n    pMenu-&gt;selected = 0;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu_8h/","title":"lib/graphic/widget/menu/menu.h","text":"<p>Menu widget for hierarchical item selection.  More...</p>"},{"location":"api/Files/menu_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuOps struct _CFBD_Menu"},{"location":"api/Files/menu_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu Forward declaration of menu structure."},{"location":"api/Files/menu_8h/#functions","title":"Functions","text":"Name void CFBD_InitMenu(CFBD_Menu * pMenu, CFBD_GraphicDevice * devices, CFBD_MenuItemGroup * assigned_menu_items, SizeBaseType max_width) void OLED_Menu_SelectNext(CFBD_Menu * m) void OLED_Menu_SelectPrev(CFBD_Menu * m)"},{"location":"api/Files/menu_8h/#detailed-description","title":"Detailed Description","text":"<p>Menu widget for hierarchical item selection. </p> <p>Provides comprehensive menu system with items, indicator, animation, and callbacks. Supports keyboard navigation and item selection. </p>"},{"location":"api/Files/menu_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre> <p>Forward declaration of menu structure. </p> <p>See: </p> <ul> <li>CFBD_InitMenu</li> <li>CFBD_MenuOps</li> </ul> <p>Main menu widget structure.</p> <p>Encompasses all menu state including items, rendering surface, indicator, animation, and selection state. </p>"},{"location":"api/Files/menu_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu_8h/#function-cfbd_initmenu","title":"function CFBD_InitMenu","text":"<pre><code>void CFBD_InitMenu(\n    CFBD_Menu * pMenu,\n    CFBD_GraphicDevice * devices,\n    CFBD_MenuItemGroup * assigned_menu_items,\n    SizeBaseType max_width\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectnext","title":"function OLED_Menu_SelectNext","text":"<pre><code>static inline void OLED_Menu_SelectNext(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#function-oled_menu_selectprev","title":"function OLED_Menu_SelectPrev","text":"<pre><code>static inline void OLED_Menu_SelectPrev(\n    CFBD_Menu * m\n)\n</code></pre>"},{"location":"api/Files/menu_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n\n#include \"base/point.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"menu_indicator.h\"\n#include \"menu_item.h\"\n#include \"widget/animation/animation.h\"\n#include \"widget/text_config.h\"\n\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct\n{\n    void (*bind_item_groups_contains)(CFBD_Menu* pMenu, CFBD_MenuItemGroup* assigned_menu_items);\n\n    CFBD_Bool (*add_item)(CFBD_Menu* pMenu,\n                          const char* label,\n                          Ascii_Font_Size size,\n                          CFBD_MenuItemCallbackPack* callbacks);\n\n    void (*set_indicator_property)(CFBD_Menu* pMenu, CFBD_MenuIndicator* pIndicator);\n    void (*set_animation)(CFBD_Menu* pMenu, CFBD_BaseAnimation* pBaseAnimation);\n    void (*immediate_draw)(CFBD_Menu* pMenu);\n    void (*select_index)(CFBD_Menu* pMenu, int index);\n    void (*activate_current)(CFBD_Menu* pMenu);\n    void (*reset_tl_points)(CFBD_Menu* pMenu, CFBDGraphic_Point* p, CFBD_Bool request_updates);\n} CFBD_MenuOps;\n\ntypedef struct _CFBD_Menu\n{\n    CFBD_MenuOps* operations;\n\n    CFBD_GraphicDevice* device;\n\n    CFBD_MenuItemGroup* menu_items;\n\n    CFBDGraphic_Point tl_point;\n\n    SizeBaseType max_width;\n\n    int selected;\n\n    CFBD_MenuIndicator indicator;\n\n    CFBD_BaseAnimation animation;\n} CFBD_Menu;\n\nvoid CFBD_InitMenu(CFBD_Menu* pMenu,\n                   CFBD_GraphicDevice* devices,\n                   CFBD_MenuItemGroup* assigned_menu_items,\n                   SizeBaseType max_width);\n\nstatic inline void OLED_Menu_SelectNext(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected + 1) % (int) m-&gt;menu_items-&gt;count;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n\nstatic inline void OLED_Menu_SelectPrev(CFBD_Menu* m)\n{\n    int ni = (m-&gt;selected - 1);\n    if (ni &lt; 0)\n        ni = (int) m-&gt;menu_items-&gt;count - 1;\n    m-&gt;operations-&gt;select_index(m, ni);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu__config_8h/","title":"lib/graphic/widget/menu/menu_config.h","text":"<p>Menu widget compile-time configuration.  More...</p>"},{"location":"api/Files/menu__config_8h/#detailed-description","title":"Detailed Description","text":"<p>Menu widget compile-time configuration. </p> <p>Provides configuration macros for menu appearance, including indicator dimensions, positioning, and item spacing. </p>"},{"location":"api/Files/menu__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define CFBD_MENU_INDICATOR_WIDTH (4)\n\n#define CFBD_MENU_INDICATOR_POSX (0)\n\n#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n\n#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n\n#define CFBD_MENU_INDICATOR_GAP (4)\n\n#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu__indicator_8c/","title":"lib/graphic/widget/menu/menu_indicator.c","text":""},{"location":"api/Files/menu__indicator_8c/#functions","title":"Functions","text":"Name size_t bytes_per_row_px(uint16_t px_width) void blit_fill_rect_bytes(uint8_t * buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte) void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8c/#attributes","title":"Attributes","text":"Name uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf"},{"location":"api/Files/menu__indicator_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#function-bytes_per_row_px","title":"function bytes_per_row_px","text":"<pre><code>static inline size_t bytes_per_row_px(\n    uint16_t px_width\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-blit_fill_rect_bytes","title":"function blit_fill_rect_bytes","text":"<pre><code>static void blit_fill_rect_bytes(\n    uint8_t * buf,\n    uint16_t w_px,\n    uint16_t h_px,\n    uint8_t fill_byte\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/menu__indicator_8c/#variable-s_indicator_buf","title":"variable s_indicator_buf","text":"<pre><code>static uint8_t[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX+7)/8) *CFBD_MENU_INDICATOR_MAX_HEIGHT_PX] s_indicator_buf;\n</code></pre>"},{"location":"api/Files/menu__indicator_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_indicator.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"menu.h\"\n#include \"menu_config.h\"\n\n\nstatic uint8_t s_indicator_buf[((CFBD_MENU_INDICATOR_MAX_WIDTH_PX + 7) / 8) *\n                               CFBD_MENU_INDICATOR_MAX_HEIGHT_PX];\n\n/* compute bytes per row for given pixel width (1bpp) */\nstatic inline size_t bytes_per_row_px(uint16_t px_width)\n{\n    return (px_width + 7) / 8;\n}\n\n/* fill a byte buffer with 0xFF (set pixels) or 0x00 (clear) */\nstatic void blit_fill_rect_bytes(uint8_t* buf, uint16_t w_px, uint16_t h_px, uint8_t fill_byte)\n{\n    size_t rowb = bytes_per_row_px(w_px);\n    for (uint16_t r = 0; r &lt; h_px; ++r) {\n        uint8_t* rowp = buf + r * rowb;\n        for (size_t i = 0; i &lt; rowb; ++i) {\n            rowp[i] = fill_byte;\n        }\n    }\n}\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault)\n{\n    menuIndicatorDefault-&gt;width = CFBD_MENU_INDICATOR_WIDTH;\n    menuIndicatorDefault-&gt;x = CFBD_MENU_INDICATOR_POSX;\n}\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_GraphicDevice* dev = menu-&gt;device;\n\n    /* safety clamp (\u9632\u6b62\u8d8a\u754c) */\n    if (w &gt; CFBD_MENU_INDICATOR_MAX_WIDTH_PX || h &gt; CFBD_MENU_INDICATOR_MAX_HEIGHT_PX) {\n        return CFBD_FALSE;\n    }\n\n    blit_fill_rect_bytes(s_indicator_buf, w, h, 0xFF);\n\n    return dev-&gt;ops-&gt;setArea(dev, x, y, w, h, s_indicator_buf);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu__indicator_8h/","title":"lib/graphic/widget/menu/menu_indicator.h","text":"<p>Menu indicator widget for visual selection feedback.  More...</p>"},{"location":"api/Files/menu__indicator_8h/#classes","title":"Classes","text":"Name struct __CFBD_MenuIndicator"},{"location":"api/Files/menu__indicator_8h/#types","title":"Types","text":"Name typedef struct _CFBD_Menu CFBD_Menu Forward declaration of menu structure. typedef struct __CFBD_MenuIndicator CFBD_MenuIndicator Menu indicator configuration structure."},{"location":"api/Files/menu__indicator_8h/#functions","title":"Functions","text":"Name void CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator * menuIndicatorDefault) CFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu * menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"},{"location":"api/Files/menu__indicator_8h/#detailed-description","title":"Detailed Description","text":"<p>Menu indicator widget for visual selection feedback. </p> <p>Provides menu indicator structure and functions for rendering a sliding indicator bar showing current menu selection. </p>"},{"location":"api/Files/menu__indicator_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menu","title":"typedef CFBD_Menu","text":"<pre><code>typedef struct _CFBD_Menu CFBD_Menu;\n</code></pre> <p>Forward declaration of menu structure. </p>"},{"location":"api/Files/menu__indicator_8h/#typedef-cfbd_menuindicator","title":"typedef CFBD_MenuIndicator","text":"<pre><code>CFBD_MenuIndicator;\n</code></pre> <p>Menu indicator configuration structure. </p> <p>See: </p> <ul> <li>CFBD_InitDefaultMenuIndicator</li> <li>CFBD_DrawMenuIndicator</li> </ul> <p>Defines visual properties of the menu indicator bar that slides between menu items to show current selection. </p>"},{"location":"api/Files/menu__indicator_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__indicator_8h/#function-cfbd_initdefaultmenuindicator","title":"function CFBD_InitDefaultMenuIndicator","text":"<pre><code>void CFBD_InitDefaultMenuIndicator(\n    CFBD_MenuIndicator * menuIndicatorDefault\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#function-cfbd_drawmenuindicator","title":"function CFBD_DrawMenuIndicator","text":"<pre><code>CFBD_Bool CFBD_DrawMenuIndicator(\n    CFBD_Menu * menu,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/menu__indicator_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct _CFBD_Menu CFBD_Menu;\n\ntypedef struct __CFBD_MenuIndicator\n{\n    uint8_t width;\n\n    uint8_t x;\n} CFBD_MenuIndicator;\n\nvoid CFBD_InitDefaultMenuIndicator(CFBD_MenuIndicator* menuIndicatorDefault);\n\nCFBD_Bool CFBD_DrawMenuIndicator(CFBD_Menu* menu, uint16_t x, uint16_t y, uint16_t w, uint16_t h);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu__item_8c/","title":"lib/graphic/widget/menu/menu_item.c","text":""},{"location":"api/Files/menu__item_8c/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8c/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8c/#source-code","title":"Source code","text":"<pre><code>#include \"menu_item.h\"\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks)\n{\n    menuItem-&gt;tl = *tl;\n    menuItem-&gt;on_select = *callbacks;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/menu__item_8h/","title":"lib/graphic/widget/menu/menu_item.h","text":"<p>Menu item widget for menu selection options.  More...</p>"},{"location":"api/Files/menu__item_8h/#classes","title":"Classes","text":"Name struct CFBD_MenuItemCallbackPack struct __CFBD_MenuItem struct __CFBD_MenuItemArray"},{"location":"api/Files/menu__item_8h/#types","title":"Types","text":"Name typedef void(*)(void *user_data) CFBD_MenuItemCallback Callback function type for menu item activation. typedef struct __CFBD_MenuItem CFBD_MenuItem Single menu item structure. typedef struct __CFBD_MenuItemArray CFBD_MenuItemGroup Array container for menu items."},{"location":"api/Files/menu__item_8h/#functions","title":"Functions","text":"Name void CFBD_MenuItemInit(CFBD_MenuItem * menuItem, CFBDGraphic_Point * tl, CFBD_MenuItemCallbackPack * callbacks)"},{"location":"api/Files/menu__item_8h/#detailed-description","title":"Detailed Description","text":"<p>Menu item widget for menu selection options. </p> <p>Provides menu item structures and initialization for creating clickable menu options with optional callbacks. </p>"},{"location":"api/Files/menu__item_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemcallback","title":"typedef CFBD_MenuItemCallback","text":"<pre><code>CFBD_MenuItemCallback;\n</code></pre> <p>Callback function type for menu item activation. </p> <p>Parameters: </p> <ul> <li>user_data - User-supplied callback context data </li> </ul> <p>Return: void </p> <p>Called when user selects/activates a menu item. </p>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitem","title":"typedef CFBD_MenuItem","text":"<pre><code>CFBD_MenuItem;\n</code></pre> <p>Single menu item structure. </p> <p>See: </p> <ul> <li>CFBD_MenuItemInit</li> <li>CFBD_MenuItemCallbackPack</li> </ul> <p>Represents one menu item with label, position, and optional callback. </p>"},{"location":"api/Files/menu__item_8h/#typedef-cfbd_menuitemgroup","title":"typedef CFBD_MenuItemGroup","text":"<pre><code>CFBD_MenuItemGroup;\n</code></pre> <p>Array container for menu items. </p> <p>See: CFBD_MenuItem</p> <p>Manages dynamic array of menu items with capacity and count tracking. </p>"},{"location":"api/Files/menu__item_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/menu__item_8h/#function-cfbd_menuiteminit","title":"function CFBD_MenuItemInit","text":"<pre><code>void CFBD_MenuItemInit(\n    CFBD_MenuItem * menuItem,\n    CFBDGraphic_Point * tl,\n    CFBD_MenuItemCallbackPack * callbacks\n)\n</code></pre>"},{"location":"api/Files/menu__item_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/point.h\"\n#include \"widget/text.h\"\n\ntypedef void (*CFBD_MenuItemCallback)(void* user_data);\n\ntypedef struct\n{\n    CFBD_MenuItemCallback callback;\n\n    void* user_data;\n} CFBD_MenuItemCallbackPack;\n\ntypedef struct __CFBD_MenuItem\n{\n    char* label;\n\n    CFBDGraphic_Point tl;\n\n    CFBD_MenuItemCallbackPack on_select;\n\n    CFBDGraphic_Text text_obj;\n} CFBD_MenuItem;\n\ntypedef struct __CFBD_MenuItemArray\n{\n    CFBD_MenuItem* pItems;\n\n    size_t capacity;\n\n    size_t count;\n} CFBD_MenuItemGroup;\n\nvoid CFBD_MenuItemInit(CFBD_MenuItem* menuItem,\n                       CFBDGraphic_Point* tl,\n                       CFBD_MenuItemCallbackPack* callbacks);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled_8c/","title":"lib/oled/oled.c","text":""},{"location":"api/Files/oled_8c/#functions","title":"Functions","text":"Name void CFBD_OLED_ImmediateInit(CFBD_OLED * oled) void CFBD_OLED_IICInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle) CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8c/#function-cfbd_oled_immediateinit","title":"function CFBD_OLED_ImmediateInit","text":"<pre><code>static inline void CFBD_OLED_ImmediateInit(\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#function-cfbd_oled_iicinit","title":"function CFBD_OLED_IICInit","text":"<pre><code>void CFBD_OLED_IICInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"configs/external_impl_driver.h\"\n\n\nstatic inline void CFBD_OLED_ImmediateInit(CFBD_OLED* oled)\n{\n    const CFBD_OLEDOperations* ops = oled-&gt;ops;\n    ops-&gt;init(oled, NULL);\n    ops-&gt;clear(oled);\n    ops-&gt;update(oled);\n}\n\nextern void CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle);\n\nCFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,\n                             const CFBD_OLEDDriverType driver_type,\n                             CFBDOLED_Params_Inits args,\n                             CFBD_Bool request_immediate_init)\n{\n    switch (driver_type) {\n        case CFBD_OLEDDriverType_IIC:\n            CFBD_OLED_IICInit(oled, args);\n            break;\n        default:\n            return CFBD_FALSE;\n            break;\n    }\n\n    if (request_immediate_init) {\n        CFBD_OLED_ImmediateInit(oled);\n    }\n\n    return CFBD_TRUE;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled_8h/","title":"lib/oled/oled.h","text":"<p>Generic OLED object and operations exposed to application code. </p>"},{"location":"api/Files/oled_8h/#classes","title":"Classes","text":"Name struct _CFBD_OLED_OPS struct _CFBD_OLED"},{"location":"api/Files/oled_8h/#types","title":"Types","text":"Name enum CFBD_OLEDDriverType { CFBD_OLEDDriverType_IIC, CFBD_OLEDDriverType_SPI}Transport/driver type used to communicate with the OLED device. typedef void * CFBD_OLEDHandle Opaque handle type referencing driver-specific state. typedef struct _CFBD_OLED CFBD_OLED Forward declaration for the OLED object. typedef CFBD_Bool(*)(CFBD_OLED *oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height) AreaOperations Function pointer type for area-based display operations. typedef CFBD_Bool(*)(CFBD_OLED *oled) FrameOperation Function pointer type for full-frame display operations. typedef CFBD_Bool(*)(CFBD_OLED *oled) OLEDSelfOperation Function pointer type for device lifecycle operations. typedef CFBD_Bool(*)(CFBD_OLED *oled, const char *property, void *args, void *request_data) OLED_QueryOperation Function pointer type for querying device-specific properties. typedef CFBD_Bool(*)(CFBD_OLED *oled, const char *property, void *args, void *request_data) OLED_SetPropertyOperation typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations typedef void * CFBDOLED_Params_Inits Opaque pointer type for transport-specific initialization parameters."},{"location":"api/Files/oled_8h/#functions","title":"Functions","text":"Name CFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED * oled, const CFBD_OLEDDriverType driver_type, CFBDOLED_Params_Inits args, CFBD_Bool request_immediate_init)"},{"location":"api/Files/oled_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/oled_8h/#enum-cfbd_oleddrivertype","title":"enum CFBD_OLEDDriverType","text":"Enumerator Value Description CFBD_OLEDDriverType_IIC I2C (IIC) transport - suitable for displays with I2C interface CFBD_OLEDDriverType_SPI SPI transport - suitable for displays with SPI interface <p>Transport/driver type used to communicate with the OLED device. </p> <p>See: CFBD_GetOLEDHandle()for usage when creating device handles </p> <p>Specifies the underlying communication protocol used to interface with the OLED controller. Different transport types may have different initialization parameters and performance characteristics.</p>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledhandle","title":"typedef CFBD_OLEDHandle","text":"<pre><code>CFBD_OLEDHandle;\n</code></pre> <p>Opaque handle type referencing driver-specific state. </p>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oled","title":"typedef CFBD_OLED","text":"<pre><code>typedef struct _CFBD_OLED CFBD_OLED;\n</code></pre> <p>Forward declaration for the OLED object. </p>"},{"location":"api/Files/oled_8h/#typedef-areaoperations","title":"typedef AreaOperations","text":"<pre><code>AreaOperations;\n</code></pre> <p>Function pointer type for area-based display operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> <li>x X coordinate of the area's top-left corner (origin 0,0 at top-left). </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. Combined with x must not exceed display width. </li> <li>height Height of the area in pixels. Combined with y must not exceed display height.</li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. Failures may include invalid coordinates or driver errors.</p> <p>This function pointer signature is used for operations that target a rectangular area of the display (e.g., update_area, clear_area, revert_area). Implementations should use clipping to handle areas that extend beyond display boundaries.</p>"},{"location":"api/Files/oled_8h/#typedef-frameoperation","title":"typedef FrameOperation","text":"<pre><code>FrameOperation;\n</code></pre> <p>Function pointer type for full-frame display operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>B</p> <p>This function pointer signature handles operations that affect the entire display frame (update, clear, revert operations). Typically used to push local buffer changes to the display, clear all pixels, or restore the previous frame content if supported by the device.</p>"},{"location":"api/Files/oled_8h/#typedef-oledselfoperation","title":"typedef OLEDSelfOperation","text":"<pre><code>OLEDSelfOperation;\n</code></pre> <p>Function pointer type for device lifecycle operations. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being operated on. </li> </ul> <p>See: CFBD_OLEDOperationsfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature is used for operations that manage the device lifecycle (open/close/enable/disable). These operations typically handle resource allocation, hardware initialization, and cleanup.</p>"},{"location":"api/Files/oled_8h/#typedef-oled_queryoperation","title":"typedef OLED_QueryOperation","text":"<pre><code>OLED_QueryOperation;\n</code></pre> <p>Function pointer type for querying device-specific properties. </p> <p>Parameters: </p> <ul> <li>oled Pointer to the CFBD_OLED instance being queried. </li> <li>property Null-terminated string naming the queried property. </li> <li>args Optional input arguments for the query (implementation-defined). Pass NULL if the query doesn't require additional arguments. </li> <li>request_data Output pointer where query results are written. Caller must allocate appropriate buffer based on property type.</li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success (property found and returned), CFBD_FALSE on failure (unknown property or error). </p> <p>This function pointer signature handles runtime queries for device capabilities and properties. Implementations must support standard properties (\"width\", \"height\", \"rgb\") and may support additional device-specific properties.</p> <p>Supported standard properties:</p> <ul> <li>\"width\": returns uint16_t display width in pixels</li> <li>\"height\": returns uint16_t display height in pixels</li> <li>\"rgb\": returns CFBD_Bool indicating RGB vs monochrome support</li> </ul>"},{"location":"api/Files/oled_8h/#typedef-oled_setpropertyoperation","title":"typedef OLED_SetPropertyOperation","text":"<pre><code>typedef CFBD_Bool(* OLED_SetPropertyOperation) (CFBD_OLED *oled, const char *property, void *args, void *request_data);\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbd_oledoperations","title":"typedef CFBD_OLEDOperations","text":"<pre><code>typedef struct _CFBD_OLED_OPS CFBD_OLEDOperations;\n</code></pre>"},{"location":"api/Files/oled_8h/#typedef-cfbdoled_params_inits","title":"typedef CFBDOLED_Params_Inits","text":"<pre><code>CFBDOLED_Params_Inits;\n</code></pre> <p>Opaque pointer type for transport-specific initialization parameters. </p> <p>See: CFBD_GetOLEDHandle()for usage </p> <p>This typedef abstracts transport-specific parameter structures. For I2C transport: point to CFBD_OLED_IICInitsParams For SPI transport: point to device-specific SPI parameter structure For other transports: point to relevant parameter structure</p>"},{"location":"api/Files/oled_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled_8h/#function-cfbd_getoledhandle","title":"function CFBD_GetOLEDHandle","text":"<pre><code>CFBD_Bool CFBD_GetOLEDHandle(\n    CFBD_OLED * oled,\n    const CFBD_OLEDDriverType driver_type,\n    CFBDOLED_Params_Inits args,\n    CFBD_Bool request_immediate_init\n)\n</code></pre>"},{"location":"api/Files/oled_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n\ntypedef enum\n{\n    CFBD_OLEDDriverType_IIC, \n    CFBD_OLEDDriverType_SPI  \n} CFBD_OLEDDriverType;\n\ntypedef void* CFBD_OLEDHandle;\n\ntypedef struct _CFBD_OLED CFBD_OLED;\n\ntypedef CFBD_Bool (\n        *AreaOperations)(CFBD_OLED* oled, uint16_t x, uint16_t y, uint16_t width, uint16_t height);\n\ntypedef CFBD_Bool (*FrameOperation)(CFBD_OLED* oled);\n\ntypedef CFBD_Bool (*OLEDSelfOperation)(CFBD_OLED* oled);\n\ntypedef CFBD_Bool (*OLED_QueryOperation)(CFBD_OLED* oled,\n                                         const char* property,\n                                         void* args,\n                                         void* request_data);\n\ntypedef CFBD_Bool (*OLED_SetPropertyOperation)(CFBD_OLED* oled,\n                                               const char* property,\n                                               void* args,\n                                               void* request_data); // What to write?\n\ntypedef struct _CFBD_OLED_OPS\n{\n    int (*init)(CFBD_OLED* oled, void* init_args);\n\n    CFBD_Bool (*setPixel)(CFBD_OLED* oled, uint16_t x, uint16_t y);\n\n    CFBD_Bool (*setArea)(CFBD_OLED* device,\n                         uint16_t x,\n                         uint16_t y,\n                         uint16_t width,\n                         uint16_t height,\n                         uint8_t* source);\n\n    FrameOperation update;\n\n    FrameOperation clear;\n\n    FrameOperation revert;\n\n    AreaOperations update_area;\n\n    AreaOperations clear_area;\n\n    AreaOperations revert_area;\n\n    OLEDSelfOperation open;\n\n    OLEDSelfOperation close;\n\n    OLED_QueryOperation self_consult;\n\n    OLED_SetPropertyOperation self_property_setter;\n} CFBD_OLEDOperations;\n\ntypedef struct _CFBD_OLED\n{\n    const CFBD_OLEDOperations* ops;\n\n    CFBD_OLEDDriverType driver_type;\n\n    CFBD_OLEDHandle oled_internal_handle;\n} CFBD_OLED;\n\ntypedef void* CFBDOLED_Params_Inits;\n\nCFBD_Bool CFBD_GetOLEDHandle(CFBD_OLED* oled,\n                             const CFBD_OLEDDriverType driver_type,\n                             CFBDOLED_Params_Inits args,\n                             CFBD_Bool request_immediate_init);\n\n // end of OLED group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__concreate__iic_8c/","title":"lib/oled/oled_concreate_iic.c","text":""},{"location":"api/Files/oled__concreate__iic_8c/#functions","title":"Functions","text":"Name void CFBD_OLED_IICInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle)"},{"location":"api/Files/oled__concreate__iic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__concreate__iic_8c/#function-cfbd_oled_iicinit","title":"function CFBD_OLED_IICInit","text":"<pre><code>void CFBD_OLED_IICInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre>"},{"location":"api/Files/oled__concreate__iic_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;string.h&gt;\n\n#include \"configs/external_impl_driver.h\"\n#include \"configs/iic_pack_type.h\"\n#include \"driver/backend/oled_iic_130x.h\"\n#include \"driver/backend/oled_iic_132x.h\"\n#include \"oled.h\"\n\nvoid CFBD_OLED_IICInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle)\n{\n    if (strcmp(pvt_handle-&gt;device_specifics-&gt;iic_pack_type, SSD130X_REQUEST_IIC_PACK) == 0) {\n        CFBD_OLED_IIC130XInit(handle, pvt_handle);\n    }\n    else if (strcmp(pvt_handle-&gt;device_specifics-&gt;iic_pack_type, SSD132X_REQUEST_IIC_PACK) == 0) {\n        CFBD_OLED_IIC132XInit(handle, pvt_handle);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__graphic__device_8c/","title":"lib/graphic/device/oled/oled_graphic_device.c","text":""},{"location":"api/Files/oled__graphic__device_8c/#functions","title":"Functions","text":"Name CFBD_OLED * _get_oled(CFBD_GraphicDevice * device) int graphic_oled_init(CFBD_GraphicDevice * device, void * init_args) CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice * device, uint16_t x, uint16_t y) CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * source) CFBD_Bool graphic_oled_update(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_update_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_clear_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_revert_area(CFBD_GraphicDevice * device, uint16_t x, uint16_t y, uint16_t w, uint16_t h) CFBD_Bool graphic_oled_open(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_close(CFBD_GraphicDevice * device) CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice * device, const char * property, void * args, void * request_data) CFBD_Bool graphic_oled_self_sets(CFBD_GraphicDevice * device, const char * property, void * args, void * request_data)"},{"location":"api/Files/oled__graphic__device_8c/#attributes","title":"Attributes","text":"Name CFBD_GraphicDeviceOperation graphic_oled_ops"},{"location":"api/Files/oled__graphic__device_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#function-_get_oled","title":"function _get_oled","text":"<pre><code>static inline CFBD_OLED * _get_oled(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_init","title":"function graphic_oled_init","text":"<pre><code>static int graphic_oled_init(\n    CFBD_GraphicDevice * device,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_setpixel","title":"function graphic_oled_setPixel","text":"<pre><code>static CFBD_Bool graphic_oled_setPixel(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_drawarea","title":"function graphic_oled_drawArea","text":"<pre><code>static CFBD_Bool graphic_oled_drawArea(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * source\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update","title":"function graphic_oled_update","text":"<pre><code>static CFBD_Bool graphic_oled_update(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear","title":"function graphic_oled_clear","text":"<pre><code>static CFBD_Bool graphic_oled_clear(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert","title":"function graphic_oled_revert","text":"<pre><code>static CFBD_Bool graphic_oled_revert(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_update_area","title":"function graphic_oled_update_area","text":"<pre><code>static CFBD_Bool graphic_oled_update_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_clear_area","title":"function graphic_oled_clear_area","text":"<pre><code>static CFBD_Bool graphic_oled_clear_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_revert_area","title":"function graphic_oled_revert_area","text":"<pre><code>static CFBD_Bool graphic_oled_revert_area(\n    CFBD_GraphicDevice * device,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_open","title":"function graphic_oled_open","text":"<pre><code>static CFBD_Bool graphic_oled_open(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_close","title":"function graphic_oled_close","text":"<pre><code>static CFBD_Bool graphic_oled_close(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_self_consult","title":"function graphic_oled_self_consult","text":"<pre><code>static CFBD_Bool graphic_oled_self_consult(\n    CFBD_GraphicDevice * device,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#function-graphic_oled_self_sets","title":"function graphic_oled_self_sets","text":"<pre><code>static CFBD_Bool graphic_oled_self_sets(\n    CFBD_GraphicDevice * device,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__graphic__device_8c/#variable-graphic_oled_ops","title":"variable graphic_oled_ops","text":"<pre><code>static CFBD_GraphicDeviceOperation graphic_oled_ops = {.init = graphic_oled_init,\n                                                       .setPixel = graphic_oled_setPixel,\n                                                       .setArea = graphic_oled_drawArea,\n\n                                                       .update = graphic_oled_update,\n                                                       .clear = graphic_oled_clear,\n                                                       .revert = graphic_oled_revert,\n\n                                                       .update_area = graphic_oled_update_area,\n                                                       .clear_area = graphic_oled_clear_area,\n                                                       .revert_area = graphic_oled_revert_area,\n\n                                                       .open = graphic_oled_open,\n                                                       .close = graphic_oled_close,\n\n                                                       .self_consult = graphic_oled_self_consult,\n                                                       .self_sets = graphic_oled_self_sets};\n</code></pre>"},{"location":"api/Files/oled__graphic__device_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_graphic_device.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n\nstatic inline CFBD_OLED* _get_oled(CFBD_GraphicDevice* device)\n{\n    return (CFBD_OLED*) device-&gt;internal_handle;\n}\n\n/* ---------- init ---------- */\n\nstatic int graphic_oled_init(CFBD_GraphicDevice* device, void* init_args)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;init(oled, init_args);\n}\n\n/* ---------- pixel ---------- */\n\nstatic CFBD_Bool graphic_oled_setPixel(CFBD_GraphicDevice* device, uint16_t x, uint16_t y)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setPixel(oled, x, y);\n}\n\nstatic CFBD_Bool graphic_oled_drawArea(CFBD_GraphicDevice* device,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* source)\n{\n    CFBD_OLED* oled = _get_oled(device);\n    return oled-&gt;ops-&gt;setArea(oled, x, y, width, height, source);\n}\n/* ---------- frame ---------- */\n\nstatic CFBD_Bool graphic_oled_update(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;update(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_clear(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_revert(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert(_get_oled(device));\n}\n\n/* ---------- area ---------- */\n\nstatic CFBD_Bool\ngraphic_oled_update_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;update_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_clear_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;clear_area(_get_oled(device), x, y, w, h);\n}\n\nstatic CFBD_Bool\ngraphic_oled_revert_area(CFBD_GraphicDevice* device, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    return _get_oled(device)-&gt;ops-&gt;revert_area(_get_oled(device), x, y, w, h);\n}\n\n/* ---------- lifecycle ---------- */\n\nstatic CFBD_Bool graphic_oled_open(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;open(_get_oled(device));\n}\n\nstatic CFBD_Bool graphic_oled_close(CFBD_GraphicDevice* device)\n{\n    return _get_oled(device)-&gt;ops-&gt;close(_get_oled(device));\n}\n\n/* ---------- query ---------- */\n\nstatic CFBD_Bool graphic_oled_self_consult(CFBD_GraphicDevice* device,\n                                           const char* property,\n                                           void* args,\n                                           void* request_data)\n{\n    return _get_oled(device)-&gt;ops-&gt;self_consult(_get_oled(device), property, args, request_data);\n}\n\nstatic CFBD_Bool graphic_oled_self_sets(CFBD_GraphicDevice* device,\n                                        const char* property,\n                                        void* args,\n                                        void* request_data)\n{\n    return _get_oled(device)-&gt;ops-&gt;self_property_setter(_get_oled(device),\n                                                        property,\n                                                        args,\n                                                        request_data);\n}\n\nstatic CFBD_GraphicDeviceOperation graphic_oled_ops = {.init = graphic_oled_init,\n                                                       .setPixel = graphic_oled_setPixel,\n                                                       .setArea = graphic_oled_drawArea,\n\n                                                       .update = graphic_oled_update,\n                                                       .clear = graphic_oled_clear,\n                                                       .revert = graphic_oled_revert,\n\n                                                       .update_area = graphic_oled_update_area,\n                                                       .clear_area = graphic_oled_clear_area,\n                                                       .revert_area = graphic_oled_revert_area,\n\n                                                       .open = graphic_oled_open,\n                                                       .close = graphic_oled_close,\n\n                                                       .self_consult = graphic_oled_self_consult,\n                                                       .self_sets = graphic_oled_self_sets};\n\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled)\n{\n    if (device == NULL || oled == NULL || oled-&gt;ops == NULL)\n        return;\n\n    device-&gt;ops = &amp;graphic_oled_ops;\n    device-&gt;device_type = OLED;\n    device-&gt;internal_handle = (CFBDGraphicDeviceHandle) oled;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__graphic__device_8h/","title":"lib/graphic/device/oled/oled_graphic_device.h","text":"<p>OLED device binding for the graphics subsystem.  More...</p>"},{"location":"api/Files/oled__graphic__device_8h/#detailed-description","title":"Detailed Description","text":"<p>OLED device binding for the graphics subsystem. </p> <p>See: </p> <ul> <li>[graphic_device.h]for the generic graphics interface </li> <li>oled.hfor the OLED driver </li> </ul> <p>This module provides the integration layer between the generic OLED driver and the graphics device abstraction. It allows OLED displays to be used as rendering targets within the graphics framework.</p> <p>The OLED graphics device adapter translates graphics operations (pixel drawing, area updates, etc.) into OLED-specific commands and memory layouts.</p>"},{"location":"api/Files/oled__graphic__device_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"device/graphic_device.h\"\n#include \"oled.h\"\n\n\nvoid CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice* device, CFBD_OLED* oled);\n\n // end of Graphics_OLED group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__iic__130x_8c/","title":"lib/oled/driver/backend/oled_iic_130x.c","text":""},{"location":"api/Files/oled__iic__130x_8c/#functions","title":"Functions","text":"Name CFBD_OLED_IICInitsParams * asIICInitsParams(void * internal) void send_data(CFBD_OLED_IICInitsParams * internal, uint8_t * data, uint16_t len) void send_cmd(CFBD_OLED_IICInitsParams * internal, uint8_t cmd) void __pvt_oled_set_cursor(CFBD_OLED_IICInitsParams * handle, const uint8_t y, const uint8_t x) int init(CFBD_OLED * oled, void * init_args) CFBD_Bool setPixel(CFBD_OLED * handle, uint16_t x, uint16_t y) CFBD_Bool clear(CFBD_OLED * handle) CFBD_Bool update(CFBD_OLED * handle) CFBD_Bool oled_helper_clear_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_draw_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * sources) CFBD_Bool oled_helper_update_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool oled_helper_reverse(CFBD_OLED * handle) CFBD_Bool oled_helper_reversearea(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height) CFBD_Bool open_oled(CFBD_OLED * handle) CFBD_Bool close_oled(CFBD_OLED * handle) CFBD_Bool iic_query(CFBD_OLED * oled, const char * property, void * args, void * request_data) CFBD_Bool iic_sets(CFBD_OLED * oled, const char * property, void * args, void * request_data)"},{"location":"api/Files/oled__iic__130x_8c/#attributes","title":"Attributes","text":"Name uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM const CFBD_OLEDOperations iic_ops"},{"location":"api/Files/oled__iic__130x_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__iic__130x_8c/#function-asiicinitsparams","title":"function asIICInitsParams","text":"<pre><code>static inline CFBD_OLED_IICInitsParams * asIICInitsParams(\n    void * internal\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-send_data","title":"function send_data","text":"<pre><code>static void send_data(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t * data,\n    uint16_t len\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-send_cmd","title":"function send_cmd","text":"<pre><code>static void send_cmd(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t cmd\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-__pvt_oled_set_cursor","title":"function __pvt_oled_set_cursor","text":"<pre><code>static void __pvt_oled_set_cursor(\n    CFBD_OLED_IICInitsParams * handle,\n    const uint8_t y,\n    const uint8_t x\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-init","title":"function init","text":"<pre><code>static int init(\n    CFBD_OLED * oled,\n    void * init_args\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-setpixel","title":"function setPixel","text":"<pre><code>static CFBD_Bool setPixel(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-clear","title":"function clear","text":"<pre><code>static CFBD_Bool clear(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-update","title":"function update","text":"<pre><code>static CFBD_Bool update(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-oled_helper_clear_area","title":"function oled_helper_clear_area","text":"<pre><code>static CFBD_Bool oled_helper_clear_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-oled_helper_draw_area","title":"function oled_helper_draw_area","text":"<pre><code>static CFBD_Bool oled_helper_draw_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * sources\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-oled_helper_update_area","title":"function oled_helper_update_area","text":"<pre><code>static CFBD_Bool oled_helper_update_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-oled_helper_reverse","title":"function oled_helper_reverse","text":"<pre><code>static CFBD_Bool oled_helper_reverse(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-oled_helper_reversearea","title":"function oled_helper_reversearea","text":"<pre><code>static CFBD_Bool oled_helper_reversearea(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-open_oled","title":"function open_oled","text":"<pre><code>static CFBD_Bool open_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-close_oled","title":"function close_oled","text":"<pre><code>static CFBD_Bool close_oled(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-iic_query","title":"function iic_query","text":"<pre><code>static CFBD_Bool iic_query(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#function-iic_sets","title":"function iic_sets","text":"<pre><code>static CFBD_Bool iic_sets(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__iic__130x_8c/#variable-oled_gram","title":"variable OLED_GRAM","text":"<pre><code>static uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM;\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#variable-iic_ops","title":"variable iic_ops","text":"<pre><code>static const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query,\n                                            .self_property_setter = iic_sets};\n</code></pre>"},{"location":"api/Files/oled__iic__130x_8c/#source-code","title":"Source code","text":"<pre><code>#include \"oled_iic_130x.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"configs/cache_config-ssd130x.h\"\n#include \"iic.h\"\n#include \"oled.h\"\n\nstatic uint8_t OLED_GRAM[CACHED_HEIGHT][CACHED_WIDTH];\n\nstatic inline CFBD_OLED_IICInitsParams* asIICInitsParams(void* internal)\n{\n    return internal;\n}\n\nstatic void send_data(CFBD_OLED_IICInitsParams* internal, uint8_t* data, uint16_t len)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;data_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = NULL,\n                                        .len = 1,\n                                }};\n    for (uint16_t i = 0; i &lt; len; i++) {\n        cmds[1].buf = &amp;data[i];\n        CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n    }\n}\n\nstatic void send_cmd(CFBD_OLED_IICInitsParams* internal, uint8_t cmd)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;cmd_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;cmd,\n                                        .len = 1,\n                                }};\n    CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n}\n\nstatic void\n__pvt_oled_set_cursor(CFBD_OLED_IICInitsParams* handle, const uint8_t y, const uint8_t x)\n{\n    send_cmd(handle, 0xB0 | y);\n    send_cmd(handle, 0x10 | ((x &amp; 0xF0) &gt;&gt; 4));\n    send_cmd(handle, 0x00 | (x &amp; 0x0F));\n}\n\n// Impls\nstatic int init(CFBD_OLED* oled, void* init_args)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    uint8_t* init_cmds = internal-&gt;device_specifics-&gt;init_session_tables();\n    uint16_t init_cmds_sz = internal-&gt;device_specifics-&gt;init_session_tables_sz;\n    for (int i = 0; i &lt; init_cmds_sz; i++) {\n        send_cmd(internal, init_cmds[i]);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool setPixel(CFBD_OLED* handle, uint16_t x, uint16_t y)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    if (x &lt; internal-&gt;device_specifics-&gt;logic_width &amp;&amp;\n        y &lt; internal-&gt;device_specifics-&gt;logic_height) {\n        OLED_GRAM[y / 8][x] |= 0x01 &lt;&lt; (y % 8);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool clear(CFBD_OLED* handle)\n{\n    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool update(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    for (uint8_t j = 0; j &lt; CACHED_HEIGHT; j++) {\n        __pvt_oled_set_cursor(handle-&gt;oled_internal_handle, j, 0);\n        send_data(handle-&gt;oled_internal_handle,\n                  OLED_GRAM[j],\n                  internal-&gt;device_specifics-&gt;logic_width);\n    }\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_clear_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y; i &lt; y + height; i++) {\n        for (uint8_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] &amp;= ~(0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* sources)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    // clear the area before being set\n    oled_helper_clear_area(handle, x, y, width, height);\n\n    for (uint16_t j = 0; j &lt; (height - 1) / 8 + 1; j++) {\n        for (uint16_t i = 0; i &lt; width; i++) {\n            if (x + i &gt; CACHED_WIDTH) {\n                break;\n            }\n            if (y / 8 + j &gt; CACHED_HEIGHT - 1) {\n                return CFBD_TRUE;\n            }\n\n            OLED_GRAM[y / 8 + j][x + i] |= sources[j * width + i] &lt;&lt; (y % 8);\n\n            if (y / 8 + j + 1 &gt; CACHED_HEIGHT - 1) {\n                continue;\n            }\n\n            OLED_GRAM[y / 8 + j + 1][x + i] |= sources[j * width + i] &gt;&gt; (8 - y % 8);\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_update_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt;= POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt;= POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint8_t i = y / 8; i &lt; (y + height - 1) / 8 + 1; i++) {\n        /*\u8bbe\u7f6e\u5149\u6807\u4f4d\u7f6e\u4e3a\u76f8\u5173\u9875\u7684\u6307\u5b9a\u5217*/\n        __pvt_oled_set_cursor(internal, i, x);\n        /*\u8fde\u7eed\u5199\u5165Width\u4e2a\u6570\u636e\uff0c\u5c06\u663e\u5b58\u6570\u7ec4\u7684\u6570\u636e\u5199\u5165\u5230OLED\u786c\u4ef6*/\n        send_data(internal, &amp;OLED_GRAM[i][x], width);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_reverse(CFBD_OLED* handle)\n{\n    for (uint16_t i = 0; i &lt; CACHED_HEIGHT; i++) {\n        for (uint16_t j = 0; j &lt; CACHED_WIDTH; j++) {\n            OLED_GRAM[i][j] ^= 0xFF;\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_reversearea(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    const uint16_t POINT_X_MAX = internal-&gt;device_specifics-&gt;logic_width;\n    const uint16_t POINT_Y_MAX = internal-&gt;device_specifics-&gt;logic_height;\n    if (x &gt; POINT_X_MAX)\n        return CFBD_FALSE;\n    if (y &gt; POINT_Y_MAX)\n        return CFBD_FALSE;\n\n    if (x + width &gt; POINT_X_MAX)\n        width = POINT_X_MAX - x;\n    if (y + height &gt; POINT_Y_MAX)\n        height = POINT_Y_MAX - y;\n\n    for (uint16_t i = y; i &lt; y + height; i++) {\n        for (uint16_t j = x; j &lt; x + width; j++) {\n            OLED_GRAM[i / 8][j] ^= (0x01 &lt;&lt; (i % 8));\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool open_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x14);\n    send_cmd(internal, 0xAF);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool close_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0x8D);\n    send_cmd(internal, 0x10);\n    send_cmd(internal, 0xAE);\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool iic_query(CFBD_OLED* oled,\n                           const char* property, // property for query\n                           void* args,           // if property request args\n                           void* request_data)   // contains results\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    if (strcmp(\"rgb\", property) == 0) {\n        CFBD_Bool* support_rgb = (CFBD_Bool*) request_data;\n        *support_rgb = CFBD_FALSE;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"width\", property) == 0) {\n        uint16_t* width = (uint16_t*) request_data;\n        *width = internal-&gt;device_specifics-&gt;logic_width;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"height\", property) == 0) {\n        uint16_t* height = (uint16_t*) request_data;\n        *height = internal-&gt;device_specifics-&gt;logic_height;\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic CFBD_Bool iic_sets(CFBD_OLED* oled, const char* property, void* args, void* request_data)\n{\n    // Oh no\n    return CFBD_FALSE;\n}\n\nstatic const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query,\n                                            .self_property_setter = iic_sets};\n\nvoid CFBD_OLED_IIC130XInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle)\n{\n    handle-&gt;oled_internal_handle = pvt_handle;\n    handle-&gt;driver_type = CFBD_OLEDDriverType_IIC;\n    handle-&gt;ops = &amp;iic_ops;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__iic__130x_8h/","title":"lib/oled/driver/backend/oled_iic_130x.h","text":""},{"location":"api/Files/oled__iic__130x_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"configs/external_impl_driver.h\"\n#include \"oled.h\"\n\nvoid CFBD_OLED_IIC130XInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle);\n\n // end of OLED_Backend group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__iic__132x_8c/","title":"lib/oled/driver/backend/oled_iic_132x.c","text":""},{"location":"api/Files/oled__iic__132x_8c/#functions","title":"Functions","text":"Name CFBD_OLED_IICInitsParams * asIICInitsParams(void * internal) void send_cmd(CFBD_OLED_IICInitsParams * internal, uint8_t cmd) void send_data(CFBD_OLED_IICInitsParams * internal, uint8_t * data, uint16_t len) void set_window(CFBD_OLED_IICInitsParams * internal, uint8_t col_start, uint8_t col_end, uint8_t row_start, uint8_t row_end) uint8_t get_grey_scale(CFBD_OLED * oled) int init(CFBD_OLED * oled, void * args) CFBD_Bool setPixel(CFBD_OLED * handle, uint16_t x, uint16_t y)\u8bbe\u7f6e\u5355\u4e2a\u50cf\u7d20 CFBD_Bool clear(CFBD_OLED * handle)\u6e05\u7a7a\u663e\u793a\u7f13\u51b2\u533a CFBD_Bool update(CFBD_OLED * handle)\u66f4\u65b0\u6574\u4e2a\u663e\u793a\u5c4f CFBD_Bool oled_helper_clear_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\u6e05\u7a7a\u6307\u5b9a\u533a\u57df CFBD_Bool oled_helper_draw_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t * sources)\u7ed8\u5236\u533a\u57df\uff08\u4ece\u6e90\u6570\u636e\uff09 CFBD_Bool oled_helper_update_area(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\u66f4\u65b0\u6307\u5b9a\u533a\u57df\u5230\u663e\u793a\u5c4f CFBD_Bool oled_helper_reverse(CFBD_OLED * handle) CFBD_Bool oled_helper_reversearea(CFBD_OLED * handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\u53cd\u8f6c\u6307\u5b9a\u533a\u57df CFBD_Bool open_oled(CFBD_OLED * handle)\u6253\u5f00\u663e\u793a CFBD_Bool close_oled(CFBD_OLED * handle)\u5173\u95ed\u663e\u793a CFBD_Bool iic_query(CFBD_OLED * oled, const char * property, void * args, void * request_data) CFBD_Bool iic_sets(CFBD_OLED * oled, const char * property, void * args, void * request_data)"},{"location":"api/Files/oled__iic__132x_8c/#attributes","title":"Attributes","text":"Name uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM I2C_HandleTypeDef hi2c1 const CFBD_OLEDOperations iic_ops"},{"location":"api/Files/oled__iic__132x_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/oled__iic__132x_8c/#function-asiicinitsparams","title":"function asIICInitsParams","text":"<pre><code>static inline CFBD_OLED_IICInitsParams * asIICInitsParams(\n    void * internal\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-send_cmd","title":"function send_cmd","text":"<pre><code>static void send_cmd(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t cmd\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-send_data","title":"function send_data","text":"<pre><code>static void send_data(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t * data,\n    uint16_t len\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-set_window","title":"function set_window","text":"<pre><code>static void set_window(\n    CFBD_OLED_IICInitsParams * internal,\n    uint8_t col_start,\n    uint8_t col_end,\n    uint8_t row_start,\n    uint8_t row_end\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-get_grey_scale","title":"function get_grey_scale","text":"<pre><code>static uint8_t get_grey_scale(\n    CFBD_OLED * oled\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-init","title":"function init","text":"<pre><code>static int init(\n    CFBD_OLED * oled,\n    void * args\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-setpixel","title":"function setPixel","text":"<pre><code>static CFBD_Bool setPixel(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y\n)\n</code></pre> <p>\u8bbe\u7f6e\u5355\u4e2a\u50cf\u7d20 </p> <p>Parameters: </p> <ul> <li>handle OLED\u53e5\u67c4 </li> <li>x X\u5750\u6807\uff080-127\uff09 </li> <li>y Y\u5750\u6807\uff080-95\uff09 </li> </ul>"},{"location":"api/Files/oled__iic__132x_8c/#function-clear","title":"function clear","text":"<pre><code>static CFBD_Bool clear(\n    CFBD_OLED * handle\n)\n</code></pre> <p>\u6e05\u7a7a\u663e\u793a\u7f13\u51b2\u533a </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-update","title":"function update","text":"<pre><code>static CFBD_Bool update(\n    CFBD_OLED * handle\n)\n</code></pre> <p>\u66f4\u65b0\u6574\u4e2a\u663e\u793a\u5c4f </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-oled_helper_clear_area","title":"function oled_helper_clear_area","text":"<pre><code>static CFBD_Bool oled_helper_clear_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre> <p>\u6e05\u7a7a\u6307\u5b9a\u533a\u57df </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-oled_helper_draw_area","title":"function oled_helper_draw_area","text":"<pre><code>static CFBD_Bool oled_helper_draw_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height,\n    uint8_t * sources\n)\n</code></pre> <p>\u7ed8\u5236\u533a\u57df\uff08\u4ece\u6e90\u6570\u636e\uff09 </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-oled_helper_update_area","title":"function oled_helper_update_area","text":"<pre><code>static CFBD_Bool oled_helper_update_area(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre> <p>\u66f4\u65b0\u6307\u5b9a\u533a\u57df\u5230\u663e\u793a\u5c4f </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-oled_helper_reverse","title":"function oled_helper_reverse","text":"<pre><code>static CFBD_Bool oled_helper_reverse(\n    CFBD_OLED * handle\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-oled_helper_reversearea","title":"function oled_helper_reversearea","text":"<pre><code>static CFBD_Bool oled_helper_reversearea(\n    CFBD_OLED * handle,\n    uint16_t x,\n    uint16_t y,\n    uint16_t width,\n    uint16_t height\n)\n</code></pre> <p>\u53cd\u8f6c\u6307\u5b9a\u533a\u57df </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-open_oled","title":"function open_oled","text":"<pre><code>static CFBD_Bool open_oled(\n    CFBD_OLED * handle\n)\n</code></pre> <p>\u6253\u5f00\u663e\u793a </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-close_oled","title":"function close_oled","text":"<pre><code>static CFBD_Bool close_oled(\n    CFBD_OLED * handle\n)\n</code></pre> <p>\u5173\u95ed\u663e\u793a </p>"},{"location":"api/Files/oled__iic__132x_8c/#function-iic_query","title":"function iic_query","text":"<pre><code>static CFBD_Bool iic_query(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#function-iic_sets","title":"function iic_sets","text":"<pre><code>static CFBD_Bool iic_sets(\n    CFBD_OLED * oled,\n    const char * property,\n    void * args,\n    void * request_data\n)\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/oled__iic__132x_8c/#variable-oled_gram","title":"variable OLED_GRAM","text":"<pre><code>static uint8_t[CACHED_HEIGHT][CACHED_WIDTH] OLED_GRAM;\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#variable-hi2c1","title":"variable hi2c1","text":"<pre><code>I2C_HandleTypeDef hi2c1;\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#variable-iic_ops","title":"variable iic_ops","text":"<pre><code>static const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query,\n                                            .self_property_setter = iic_sets};\n</code></pre>"},{"location":"api/Files/oled__iic__132x_8c/#source-code","title":"Source code","text":"<pre><code>#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"configs/cache_config-ssd132x.h\"\n#include \"configs/external_impl_driver.h\"\n#include \"driver/device/oled_ssd132x_privates.h\"\n#include \"oled.h\"\n\nstatic uint8_t OLED_GRAM[CACHED_HEIGHT][CACHED_WIDTH];\n\nextern I2C_HandleTypeDef hi2c1;\n\nstatic inline CFBD_OLED_IICInitsParams* asIICInitsParams(void* internal)\n{\n    return (CFBD_OLED_IICInitsParams*) internal;\n}\n\nstatic void send_cmd(CFBD_OLED_IICInitsParams* internal, uint8_t cmd)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;cmd_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;cmd,\n                                        .len = 1,\n                                }};\n    CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n}\n\nstatic void send_data(CFBD_OLED_IICInitsParams* internal, uint8_t* data, uint16_t len)\n{\n    CFBD_I2CHandle* handle = internal-&gt;i2cHandle;\n    uint8_t prefix = internal-&gt;device_specifics-&gt;data_prefix;\n    CFBD_I2C_Message cmds[2] = {{\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = &amp;prefix,\n                                        .len = 1,\n                                },\n                                {\n                                        .addr = internal-&gt;device_address &gt;&gt; 1,\n                                        .flags = 0,\n                                        .buf = data,\n                                        .len = len,\n                                }};\n    CFBD_I2CTransfer(handle, cmds, 2, internal-&gt;accepted_time_delay);\n}\n\nstatic void set_window(CFBD_OLED_IICInitsParams* internal,\n                       uint8_t col_start,\n                       uint8_t col_end,\n                       uint8_t row_start,\n                       uint8_t row_end)\n{\n    // \u8bbe\u7f6e\u5217\u5730\u5740\u8303\u56f4\n    send_cmd(internal, 0x15);\n    send_cmd(internal, col_start);\n    send_cmd(internal, col_end);\n\n    // \u8bbe\u7f6e\u884c\u5730\u5740\u8303\u56f4\n    send_cmd(internal, 0x75);\n    send_cmd(internal, row_start);\n    send_cmd(internal, row_end);\n}\n\nstatic uint8_t get_grey_scale(CFBD_OLED* oled)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    SSD132XPrivateDatas* privates = internal-&gt;device_specifics-&gt;private_data;\n    return privates-&gt;grey_scale;\n}\n\nstatic int init(CFBD_OLED* oled, void* args)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n    uint8_t* init_cmds = internal-&gt;device_specifics-&gt;init_session_tables();\n    uint16_t init_cmds_sz = internal-&gt;device_specifics-&gt;init_session_tables_sz;\n\n    // \u53d1\u9001\u521d\u59cb\u5316\u547d\u4ee4\u5e8f\u5217\n    for (int i = 0; i &lt; init_cmds_sz; i++) {\n        send_cmd(internal, init_cmds[i]);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool setPixel(CFBD_OLED* handle, uint16_t x, uint16_t y)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    if (x &gt;= internal-&gt;device_specifics-&gt;logic_width ||\n        y &gt;= internal-&gt;device_specifics-&gt;logic_height) {\n        return CFBD_FALSE;\n    }\n\n    // \u8ba1\u7b97\u7f13\u51b2\u533a\u4f4d\u7f6e\n    uint8_t col = x / 2;       // \u5217\u5730\u5740\uff08\u6bcf\u5217\u5b582\u4e2a\u50cf\u7d20\uff09\n    uint8_t pixel_pos = x % 2; // \u50cf\u7d20\u4f4d\u7f6e\uff080=\u9ad84\u4f4d\uff0c1=\u4f4e4\u4f4d\uff09\n\n    uint8_t color = get_grey_scale(handle); // \u9650\u5236\u4e3a4\u4f4d\n\n    if (pixel_pos == 0) {\n        // \u9ad84\u4f4d\n        OLED_GRAM[y][col] = (OLED_GRAM[y][col] &amp; 0x0F) | (color &lt;&lt; 4);\n    }\n    else {\n        // \u4f4e4\u4f4d\n        OLED_GRAM[y][col] = (OLED_GRAM[y][col] &amp; 0xF0) | color;\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool clear(CFBD_OLED* handle)\n{\n    memset(OLED_GRAM, 0x00, sizeof(OLED_GRAM));\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool update(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    // \u8bbe\u7f6e\u5168\u5c4f\u7a97\u53e3\n    set_window(internal, 0, CACHED_WIDTH - 1, 0, CACHED_HEIGHT - 1);\n\n    // \u53d1\u9001\u6574\u4e2a\u7f13\u51b2\u533a\u6570\u636e\n    for (uint8_t row = 0; row &lt; CACHED_HEIGHT; row++) {\n        send_data(internal, OLED_GRAM[row], CACHED_WIDTH);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_clear_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    if (x &gt;= internal-&gt;device_specifics-&gt;logic_width ||\n        y &gt;= internal-&gt;device_specifics-&gt;logic_height)\n        return CFBD_FALSE;\n\n    if (x + width &gt; internal-&gt;device_specifics-&gt;logic_width)\n        width = internal-&gt;device_specifics-&gt;logic_width - x;\n    if (y + height &gt; internal-&gt;device_specifics-&gt;logic_height)\n        height = internal-&gt;device_specifics-&gt;logic_height - y;\n\n    for (uint16_t j = 0; j &lt; height; j++) {\n        for (uint16_t i = 0; i &lt; width; i++) {\n            uint16_t dst_col = (x + i) / 2;\n            uint8_t dst_pixel = (x + i) % 2;\n\n            if (dst_pixel == 0) {\n                OLED_GRAM[y + j][dst_col] &amp;= 0x0F;\n            }\n            else {\n                OLED_GRAM[y + j][dst_col] &amp;= 0xF0;\n            }\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_draw_area(CFBD_OLED* handle,\n                                       uint16_t x,\n                                       uint16_t y,\n                                       uint16_t width,\n                                       uint16_t height,\n                                       uint8_t* sources)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    if (x &gt;= internal-&gt;device_specifics-&gt;logic_width ||\n        y &gt;= internal-&gt;device_specifics-&gt;logic_height)\n        return CFBD_FALSE;\n\n    // \u8fb9\u754c\u68c0\u67e5\n    uint16_t draw_w = (x + width &gt; internal-&gt;device_specifics-&gt;logic_width)\n                              ? (internal-&gt;device_specifics-&gt;logic_width - x)\n                              : width;\n    uint16_t draw_h = (y + height &gt; internal-&gt;device_specifics-&gt;logic_height)\n                              ? (internal-&gt;device_specifics-&gt;logic_height - y)\n                              : height;\n\n    for (uint16_t i = 0; i &lt; draw_w; i++) {     // \u904d\u5386\u5217\n        for (uint16_t j = 0; j &lt; draw_h; j++) { // \u904d\u5386\u884c\n            uint16_t src_byte_idx = (j / 8) * width + i;\n            uint8_t src_bit_idx = j % 8; // LSB-top: \u4f4d 0 \u5728\u6700\u4e0a\u65b9\n\n            uint8_t bit = (sources[src_byte_idx] &gt;&gt; src_bit_idx) &amp; 0x01;\n            uint8_t pixel_value = (bit == 0) ? 0x00 : get_grey_scale(handle);\n\n            // --- \u5199\u5165 SSD1327 \u7684 4bpp GRAM ---\n            uint16_t curr_x = x + i;\n            uint16_t curr_y = y + j;\n            uint16_t dst_col = curr_x / 2;\n\n            if (curr_x % 2 == 0) {\n                // \u5076\u6570\u5217\u5199\u9ad8 4 \u4f4d (D7-D4)\n                OLED_GRAM[curr_y][dst_col] =\n                        (OLED_GRAM[curr_y][dst_col] &amp; 0x0F) | (pixel_value &lt;&lt; 4);\n            }\n            else {\n                // \u5947\u6570\u5217\u5199\u4f4e 4 \u4f4d (D3-D0)\n                OLED_GRAM[curr_y][dst_col] = (OLED_GRAM[curr_y][dst_col] &amp; 0xF0) | pixel_value;\n            }\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_update_area(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    // \u8fb9\u754c\u68c0\u67e5\u4e0e\u4fee\u6b63\n    if (x &gt;= internal-&gt;device_specifics-&gt;logic_width)\n        return CFBD_FALSE;\n    if (y &gt;= internal-&gt;device_specifics-&gt;logic_height)\n        return CFBD_FALSE;\n\n    if (x + width &gt; internal-&gt;device_specifics-&gt;logic_width)\n        width = internal-&gt;device_specifics-&gt;logic_width - x;\n    if (y + height &gt; internal-&gt;device_specifics-&gt;logic_height)\n        height = internal-&gt;device_specifics-&gt;logic_height - y;\n\n    // \u8ba1\u7b97\u5217\u8303\u56f4\n    uint8_t col_start = x / 2;\n    uint8_t col_end = (x + width - 1) / 2;\n\n    // \u8bbe\u7f6e\u7a97\u53e3\u5e76\u53d1\u9001\u6570\u636e\n    set_window(internal, col_start, col_end, y, y + height - 1);\n\n    for (uint16_t row = y; row &lt; y + height; row++) {\n        send_data(internal, &amp;OLED_GRAM[row][col_start], col_end - col_start + 1);\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool oled_helper_reverse(CFBD_OLED* handle)\n{\n    for (uint16_t i = 0; i &lt; CACHED_HEIGHT; i++) {\n        for (uint16_t j = 0; j &lt; CACHED_WIDTH; j++) {\n            uint8_t high = (~OLED_GRAM[i][j]) &amp; 0xF0;\n            uint8_t low = (~OLED_GRAM[i][j]) &amp; 0x0F;\n            OLED_GRAM[i][j] = high | low;\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool\noled_helper_reversearea(CFBD_OLED* handle, uint16_t x, uint16_t y, uint16_t width, uint16_t height)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n\n    if (x &gt;= internal-&gt;device_specifics-&gt;logic_width)\n        return CFBD_FALSE;\n    if (y &gt;= internal-&gt;device_specifics-&gt;logic_height)\n        return CFBD_FALSE;\n\n    if (x + width &gt; internal-&gt;device_specifics-&gt;logic_width)\n        width = internal-&gt;device_specifics-&gt;logic_width - x;\n    if (y + height &gt; internal-&gt;device_specifics-&gt;logic_height)\n        height = internal-&gt;device_specifics-&gt;logic_height - y;\n\n    // \u53cd\u8f6c\u6307\u5b9a\u533a\u57df\n    for (uint16_t j = y; j &lt; y + height; j++) {\n        for (uint16_t i = x; i &lt; x + width; i++) {\n            uint8_t col = i / 2;\n            uint8_t pixel_pos = i % 2;\n\n            if (pixel_pos == 0) {\n                // \u53cd\u8f6c\u9ad84\u4f4d\n                OLED_GRAM[j][col] ^= 0xF0;\n            }\n            else {\n                // \u53cd\u8f6c\u4f4e4\u4f4d\n                OLED_GRAM[j][col] ^= 0x0F;\n            }\n        }\n    }\n\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool open_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0xAF); // Display ON\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool close_oled(CFBD_OLED* handle)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(handle-&gt;oled_internal_handle);\n    send_cmd(internal, 0xAE); // Display OFF\n    return CFBD_TRUE;\n}\n\nstatic CFBD_Bool iic_query(CFBD_OLED* oled, const char* property, void* args, void* request_data)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n\n    if (strcmp(\"rgb\", property) == 0) {\n        CFBD_Bool* support_rgb = (CFBD_Bool*) request_data;\n        *support_rgb = CFBD_FALSE;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"width\", property) == 0) {\n        uint16_t* width = (uint16_t*) request_data;\n        *width = internal-&gt;device_specifics-&gt;logic_width;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"height\", property) == 0) {\n        uint16_t* height = (uint16_t*) request_data;\n        *height = internal-&gt;device_specifics-&gt;logic_height;\n        return CFBD_TRUE;\n    }\n\n    if (strcmp(\"color\", property) == 0) {\n        uint8_t* grey_scale = (uint8_t*) request_data;\n        SSD132XPrivateDatas* privates =\n                (SSD132XPrivateDatas*) internal-&gt;device_specifics-&gt;private_data;\n        *grey_scale = privates-&gt;grey_scale;\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic CFBD_Bool iic_sets(CFBD_OLED* oled, const char* property, void* args, void* request_data)\n{\n    CFBD_OLED_IICInitsParams* internal = asIICInitsParams(oled-&gt;oled_internal_handle);\n\n    if (strcmp(\"color\", property) == 0) {\n        uint8_t* grey_scale = (uint8_t*) request_data;\n        SSD132XPrivateDatas* privates =\n                (SSD132XPrivateDatas*) internal-&gt;device_specifics-&gt;private_data;\n        privates-&gt;grey_scale = *grey_scale &amp; 0x0F; // Ok get the least fourth\n        return CFBD_TRUE;\n    }\n\n    return CFBD_FALSE;\n}\n\nstatic const CFBD_OLEDOperations iic_ops = {.init = init,\n                                            .setPixel = setPixel,\n                                            .setArea = oled_helper_draw_area,\n\n                                            .clear = clear,\n                                            .update = update,\n                                            .revert = oled_helper_reverse,\n\n                                            .clear_area = oled_helper_clear_area,\n                                            .update_area = oled_helper_update_area,\n                                            .revert_area = oled_helper_reversearea,\n\n                                            .close = close_oled,\n                                            .open = open_oled,\n\n                                            .self_consult = iic_query,\n                                            .self_property_setter = iic_sets};\n\nvoid CFBD_OLED_IIC132XInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle)\n{\n    handle-&gt;oled_internal_handle = pvt_handle;\n    handle-&gt;driver_type = CFBD_OLEDDriverType_IIC;\n    handle-&gt;ops = &amp;iic_ops;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__iic__132x_8h/","title":"lib/oled/driver/backend/oled_iic_132x.h","text":""},{"location":"api/Files/oled__iic__132x_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"configs/external_impl_driver.h\"\n#include \"oled.h\"\n\nvoid CFBD_OLED_IIC132XInit(CFBD_OLED* handle, CFBD_OLED_IICInitsParams* pvt_handle);\n\n // end of OLED_Backend group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/oled__ssd132x__privates_8h/","title":"lib/oled/driver/device/oled_ssd132x_privates.h","text":""},{"location":"api/Files/oled__ssd132x__privates_8h/#classes","title":"Classes","text":"Name struct __SSD132XPrivateDatas"},{"location":"api/Files/oled__ssd132x__privates_8h/#types","title":"Types","text":"Name typedef struct __SSD132XPrivateDatas SSD132XPrivateDatas"},{"location":"api/Files/oled__ssd132x__privates_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/oled__ssd132x__privates_8h/#typedef-ssd132xprivatedatas","title":"typedef SSD132XPrivateDatas","text":"<pre><code>typedef struct __SSD132XPrivateDatas SSD132XPrivateDatas;\n</code></pre>"},{"location":"api/Files/oled__ssd132x__privates_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\ntypedef struct __SSD132XPrivateDatas\n{\n    uint8_t grey_scale;\n} SSD132XPrivateDatas;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/plain__button_8c/","title":"lib/input/button_like/plain_button.c","text":""},{"location":"api/Files/plain__button_8c/#functions","title":"Functions","text":"Name void CFBD_CreatePlainButton(CFBD_PlainButton * button, CFBD_ButtonCreationPack * pack) void ButtonOfLongSession(CFBD_PlainButton * handle) void CFBD_PlainButtonSyncScan(CFBD_PlainButton * button) void CFBD_PlainButtonEventMaker(CFBD_PlainButton * button, CFBDInputEvent * blank_event) void CFBD_SetMonitoringButtons(IntrButtonArrayInfo * buttons) CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks()"},{"location":"api/Files/plain__button_8c/#attributes","title":"Attributes","text":"Name IntrButtonArrayInfo * g_buttons"},{"location":"api/Files/plain__button_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/plain__button_8c/#function-cfbd_createplainbutton","title":"function CFBD_CreatePlainButton","text":"<pre><code>void CFBD_CreatePlainButton(\n    CFBD_PlainButton * button,\n    CFBD_ButtonCreationPack * pack\n)\n</code></pre>"},{"location":"api/Files/plain__button_8c/#function-buttonoflongsession","title":"function ButtonOfLongSession","text":"<pre><code>static void ButtonOfLongSession(\n    CFBD_PlainButton * handle\n)\n</code></pre>"},{"location":"api/Files/plain__button_8c/#function-cfbd_plainbuttonsyncscan","title":"function CFBD_PlainButtonSyncScan","text":"<pre><code>void CFBD_PlainButtonSyncScan(\n    CFBD_PlainButton * button\n)\n</code></pre>"},{"location":"api/Files/plain__button_8c/#function-cfbd_plainbuttoneventmaker","title":"function CFBD_PlainButtonEventMaker","text":"<pre><code>void CFBD_PlainButtonEventMaker(\n    CFBD_PlainButton * button,\n    CFBDInputEvent * blank_event\n)\n</code></pre>"},{"location":"api/Files/plain__button_8c/#function-cfbd_setmonitoringbuttons","title":"function CFBD_SetMonitoringButtons","text":"<pre><code>void CFBD_SetMonitoringButtons(\n    IntrButtonArrayInfo * buttons\n)\n</code></pre>"},{"location":"api/Files/plain__button_8c/#function-cfbd_plainbuttongetintrcallbacks","title":"function CFBD_PlainButtonGetIntrCallbacks","text":"<pre><code>CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks()\n</code></pre>"},{"location":"api/Files/plain__button_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/plain__button_8c/#variable-g_buttons","title":"variable g_buttons","text":"<pre><code>static IntrButtonArrayInfo * g_buttons;\n</code></pre>"},{"location":"api/Files/plain__button_8c/#source-code","title":"Source code","text":"<pre><code>#include \"plain_button.h\"\n\n#include \"app.h\"\n#include \"cfbd_define.h\"\n#include \"input_device_base.h\"\n#include \"plain_button_impl.h\"\n\nvoid CFBD_CreatePlainButton(CFBD_PlainButton* button, CFBD_ButtonCreationPack* pack)\n{\n    CFBDInputEventContext* context = pack-&gt;input_context;\n    button-&gt;handle = pack-&gt;gpio;\n    button-&gt;long_press_triggered = CFBD_FALSE;\n    button-&gt;press_time = 0;\n    button-&gt;release_time = 0;\n    button-&gt;last_click_time = 0;\n    button-&gt;is_pressed = CFBD_FALSE;\n    button-&gt;current_state_id = BUTTON_EVENT_IDLE;\n    button-&gt;is_double_click_pending = CFBD_FALSE;\n    button-&gt;click_pending_time = 0;\n    CFBD_CreateInputDeviceBase(&amp;button-&gt;base_inputs, context, button-&gt;handle);\n    context-&gt;ops-&gt;register_handle(context, pack-&gt;callbacks);\n\n    if (pack-&gt;isInterruptMode) {\n        button-&gt;mode = BUTTON_MODE_INTERRUPT;\n        pack-&gt;enable_intr(button);\n    }\n    else {\n        button-&gt;mode = BUTTON_MODE_POLLING;\n    }\n}\n\nstatic void ButtonOfLongSession(CFBD_PlainButton* handle)\n{\n    uint32_t current_time = HAL_GetTick();\n\n    // \u957f\u6309\u68c0\u6d4b\n    if (handle-&gt;is_pressed &amp;&amp; !handle-&gt;long_press_triggered) {\n        uint32_t press_duration = current_time - handle-&gt;press_time;\n\n        if (press_duration &gt;= BUTTON_LONG_PRESS_TIME) {\n            handle-&gt;long_press_triggered = CFBD_TRUE;\n            handle-&gt;current_state_id = BUTTON_EVENT_LONG_PRESS;\n\n            if (handle-&gt;mode == BUTTON_MODE_INTERRUPT) {\n                CFBDInputEvent event;\n                CFBD_PlainButtonEventMaker(handle, &amp;event);\n                handle-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(handle-&gt;base_inputs.context,\n                                                                &amp;event);\n            }\n        }\n    }\n\n    if (handle-&gt;current_state_id == BUTTON_EVENT_LONG_PRESS &amp;&amp; handle-&gt;is_pressed) {\n        handle-&gt;current_state_id = BUTTON_EVENT_LONG_PRESS_HOLD;\n\n        if (handle-&gt;mode == BUTTON_MODE_INTERRUPT) {\n            CFBDInputEvent event;\n            CFBD_PlainButtonEventMaker(handle, &amp;event);\n            handle-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(handle-&gt;base_inputs.context, &amp;event);\n        }\n    }\n}\n\nvoid CFBD_PlainButtonSyncScan(CFBD_PlainButton* button)\n{\n    if (button-&gt;mode != BUTTON_MODE_POLLING) {\n        return;\n    }\n\n    CFBD_Bool current_state = CFBD_GPIOReadPin(button-&gt;handle);\n    uint32_t current_time = getApp(CFBD_FALSE)-&gt;tick_provider();\n    CFBD_Bool is_pressed = (current_state == button-&gt;button_press_state);\n\n    // \u6309\u4e0b\u68c0\u6d4b\n    if (is_pressed &amp;&amp; !button-&gt;is_pressed) {\n        button-&gt;is_pressed = CFBD_TRUE;\n        button-&gt;press_time = current_time;\n        button-&gt;long_press_triggered = CFBD_FALSE;\n\n        // \u53d1\u9001\u6309\u4e0b\u4e8b\u4ef6\n        button-&gt;current_state_id = BUTTON_EVENT_PRESS;\n        CFBDInputEvent event;\n        CFBD_PlainButtonEventMaker(button, &amp;event);\n        button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context, &amp;event);\n    }\n\n    // \u91ca\u653e\u68c0\u6d4b\n    if (!is_pressed &amp;&amp; button-&gt;is_pressed) {\n        button-&gt;is_pressed = CFBD_FALSE;\n        button-&gt;release_time = current_time;\n        uint32_t press_duration = button-&gt;release_time - button-&gt;press_time;\n\n        // \u53d1\u9001\u91ca\u653e\u4e8b\u4ef6\n        button-&gt;current_state_id = BUTTON_EVENT_RELEASE;\n        CFBDInputEvent event;\n        CFBD_PlainButtonEventMaker(button, &amp;event);\n        button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context, &amp;event);\n\n        // \u53ea\u5728\u975e\u957f\u6309\u7684\u60c5\u51b5\u4e0b\u5904\u7406\u70b9\u51fb/\u53cc\u51fb\n        if (!button-&gt;long_press_triggered &amp;&amp; press_duration &lt; BUTTON_LONG_PRESS_TIME) {\n            if (button-&gt;last_click_time != 0 &amp;&amp;\n                (current_time - button-&gt;last_click_time) &lt; BUTTON_DOUBLE_CLICK_TIME) {\n                button-&gt;current_state_id = BUTTON_EVENT_DOUBLE_CLICK;\n                button-&gt;last_click_time = 0; // \u6e05\u96f6\uff0c\u907f\u514d\u4e09\u51fb\u88ab\u8bef\u5224\u4e3a\u53cc\u51fb\n\n                CFBD_PlainButtonEventMaker(button, &amp;event);\n                button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context,\n                                                                &amp;event);\n                return;\n            }\n            else {\n                button-&gt;last_click_time = current_time;\n            }\n        }\n        else {\n            button-&gt;last_click_time = 0;\n        }\n    }\n\n    // \u957f\u6309\u68c0\u6d4b\uff08\u4ec5\u5728\u6309\u4e0b\u72b6\u6001\uff09\n    if (button-&gt;is_pressed) {\n        ButtonOfLongSession(button);\n    }\n    else if (button-&gt;last_click_time != 0 &amp;&amp;\n             (current_time - button-&gt;last_click_time) &gt;= BUTTON_DOUBLE_CLICK_TIME) {\n        button-&gt;current_state_id = BUTTON_EVENT_CLICK;\n        button-&gt;last_click_time = 0;\n\n        CFBDInputEvent event;\n        CFBD_PlainButtonEventMaker(button, &amp;event);\n        button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context, &amp;event);\n    }\n    else if (!button-&gt;is_pressed &amp;&amp; button-&gt;last_click_time == 0) {\n        button-&gt;current_state_id = BUTTON_EVENT_IDLE;\n    }\n}\n\nvoid CFBD_PlainButtonEventMaker(CFBD_PlainButton* button, CFBDInputEvent* blank_event)\n{\n    blank_event-&gt;event_indicates = button-&gt;current_state_id;\n    blank_event-&gt;device_id = button-&gt;base_inputs.device_id;\n    blank_event-&gt;event_private_data = NULL;\n    return;\n}\n\nstatic IntrButtonArrayInfo* g_buttons;\nvoid CFBD_SetMonitoringButtons(IntrButtonArrayInfo* buttons)\n{\n    g_buttons = buttons;\n}\n\n// in impl.h as requests\n\nCFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks()\n{\n    if (!g_buttons) {\n        return NULL;\n    }\n\n    return CFBD_PlainButtonGetIntrCallbacksImpl(g_buttons);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/plain__button_8h/","title":"lib/input/button_like/plain_button.h","text":""},{"location":"api/Files/plain__button_8h/#classes","title":"Classes","text":"Name struct _CFBD_PlainButton struct CFBD_ButtonCreationPack struct IntrButtonArrayInfo"},{"location":"api/Files/plain__button_8h/#types","title":"Types","text":"Name enum CFBD_PlainButtonEventID enum CFBD_PlainButtonMode typedef struct _CFBD_PlainButton CFBD_PlainButton typedef void(*)(void *intr_datas) CFBD_ButtonIntrCallbacks typedef CFBD_PlainButton ** CFBDPlainButtonArray"},{"location":"api/Files/plain__button_8h/#functions","title":"Functions","text":"Name void CFBD_CreatePlainButton(CFBD_PlainButton * button, CFBD_ButtonCreationPack * pack) void CFBD_PlainButtonEventMaker(CFBD_PlainButton * button, CFBDInputEvent * blank_event) void CFBD_PlainButtonSyncScan(CFBD_PlainButton * button) void CFBD_SetMonitoringButtons(IntrButtonArrayInfo * buttons) CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks()"},{"location":"api/Files/plain__button_8h/#defines","title":"Defines","text":"Name BUTTON_DEBOUNCE_TIME BUTTON_LONG_PRESS_TIME BUTTON_DOUBLE_CLICK_TIME MAX_HOLDABLE_BUTTON"},{"location":"api/Files/plain__button_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/plain__button_8h/#enum-cfbd_plainbuttoneventid","title":"enum CFBD_PlainButtonEventID","text":"Enumerator Value Description BUTTON_EVENT_IDLE CFBDInputDeviceEventType_INVALID_ID BUTTON_EVENT_PRESS CFBDInputDeviceEventType_SYSDEF_START BUTTON_EVENT_RELEASE BUTTON_EVENT_CLICK BUTTON_EVENT_DOUBLE_CLICK BUTTON_EVENT_LONG_PRESS BUTTON_EVENT_LONG_PRESS_HOLD"},{"location":"api/Files/plain__button_8h/#enum-cfbd_plainbuttonmode","title":"enum CFBD_PlainButtonMode","text":"Enumerator Value Description BUTTON_MODE_POLLING 0 BUTTON_MODE_INTERRUPT"},{"location":"api/Files/plain__button_8h/#typedef-cfbd_plainbutton","title":"typedef CFBD_PlainButton","text":"<pre><code>typedef struct _CFBD_PlainButton CFBD_PlainButton;\n</code></pre>"},{"location":"api/Files/plain__button_8h/#typedef-cfbd_buttonintrcallbacks","title":"typedef CFBD_ButtonIntrCallbacks","text":"<pre><code>typedef void(* CFBD_ButtonIntrCallbacks) (void *intr_datas);\n</code></pre>"},{"location":"api/Files/plain__button_8h/#typedef-cfbdplainbuttonarray","title":"typedef CFBDPlainButtonArray","text":"<pre><code>typedef CFBD_PlainButton** CFBDPlainButtonArray;\n</code></pre>"},{"location":"api/Files/plain__button_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/plain__button_8h/#function-cfbd_createplainbutton","title":"function CFBD_CreatePlainButton","text":"<pre><code>void CFBD_CreatePlainButton(\n    CFBD_PlainButton * button,\n    CFBD_ButtonCreationPack * pack\n)\n</code></pre>"},{"location":"api/Files/plain__button_8h/#function-cfbd_plainbuttoneventmaker","title":"function CFBD_PlainButtonEventMaker","text":"<pre><code>void CFBD_PlainButtonEventMaker(\n    CFBD_PlainButton * button,\n    CFBDInputEvent * blank_event\n)\n</code></pre>"},{"location":"api/Files/plain__button_8h/#function-cfbd_plainbuttonsyncscan","title":"function CFBD_PlainButtonSyncScan","text":"<pre><code>void CFBD_PlainButtonSyncScan(\n    CFBD_PlainButton * button\n)\n</code></pre>"},{"location":"api/Files/plain__button_8h/#function-cfbd_setmonitoringbuttons","title":"function CFBD_SetMonitoringButtons","text":"<pre><code>void CFBD_SetMonitoringButtons(\n    IntrButtonArrayInfo * buttons\n)\n</code></pre>"},{"location":"api/Files/plain__button_8h/#function-cfbd_plainbuttongetintrcallbacks","title":"function CFBD_PlainButtonGetIntrCallbacks","text":"<pre><code>CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks()\n</code></pre>"},{"location":"api/Files/plain__button_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/plain__button_8h/#define-button_debounce_time","title":"define BUTTON_DEBOUNCE_TIME","text":"<pre><code>#define BUTTON_DEBOUNCE_TIME 20\n</code></pre>"},{"location":"api/Files/plain__button_8h/#define-button_long_press_time","title":"define BUTTON_LONG_PRESS_TIME","text":"<pre><code>#define BUTTON_LONG_PRESS_TIME 1000\n</code></pre>"},{"location":"api/Files/plain__button_8h/#define-button_double_click_time","title":"define BUTTON_DOUBLE_CLICK_TIME","text":"<pre><code>#define BUTTON_DOUBLE_CLICK_TIME 300\n</code></pre>"},{"location":"api/Files/plain__button_8h/#define-max_holdable_button","title":"define MAX_HOLDABLE_BUTTON","text":"<pre><code>#define MAX_HOLDABLE_BUTTON (3)\n</code></pre>"},{"location":"api/Files/plain__button_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"gpio.h\"\n#include \"input.h\"\n#include \"input_device_base.h\"\n#include \"input_event.h\"\n\n#define BUTTON_DEBOUNCE_TIME 20\n#define BUTTON_LONG_PRESS_TIME 1000\n#define BUTTON_DOUBLE_CLICK_TIME 300\n\n#define MAX_HOLDABLE_BUTTON (3)\n\ntypedef enum\n{\n    BUTTON_EVENT_IDLE = CFBDInputDeviceEventType_INVALID_ID,\n    BUTTON_EVENT_PRESS = CFBDInputDeviceEventType_SYSDEF_START, // \u6309\u4e0b\u4e8b\u4ef6\n    BUTTON_EVENT_RELEASE,                                       // \u91ca\u653e\u4e8b\u4ef6\n    BUTTON_EVENT_CLICK,                                         // \u5355\u51fb\u4e8b\u4ef6\n    BUTTON_EVENT_DOUBLE_CLICK,                                  // \u53cc\u51fb\u4e8b\u4ef6\n    BUTTON_EVENT_LONG_PRESS,                                    // \u957f\u6309\u4e8b\u4ef6\n    BUTTON_EVENT_LONG_PRESS_HOLD                                // \u957f\u6309\u4fdd\u6301\n} CFBD_PlainButtonEventID;\n\ntypedef enum\n{\n    BUTTON_MODE_POLLING = 0, // \u8f6e\u8be2\u6a21\u5f0f\n    BUTTON_MODE_INTERRUPT    // \u4e2d\u65ad\u6a21\u5f0f\n} CFBD_PlainButtonMode;\n\ntypedef struct _CFBD_PlainButton\n{\n    CFBDInputDeviceBase base_inputs;\n    CFBD_GPIOHandle* handle;\n    CFBD_PlainButtonMode mode;\n    CFBDEventInputHandler stateChangedCb;\n    CFBD_PlainButtonEventID current_state_id;\n\n    uint32_t press_time;      // \u6309\u4e0b\u65f6\u523b\n    uint32_t release_time;    // \u91ca\u653e\u65f6\u523b\n    uint32_t last_click_time; // \u4e0a\u6b21\u5355\u51fb\u65f6\u523b\n\n    CFBD_Bool is_double_click_pending;\n    uint32_t click_pending_time;\n\n    CFBD_Bool is_pressed;           // \u5f53\u524d\u662f\u5426\u6309\u4e0b\n    CFBD_Bool long_press_triggered; // \u957f\u6309\u5df2\u89e6\u53d1\u6807\u5fd7\n    CFBD_Bool button_press_state;   // when button presssed, at what status should be for gpio\n} CFBD_PlainButton;\n\ntypedef struct\n{\n    CFBD_GPIOHandle* gpio;\n    CFBDEventInputHandler callbacks;\n    CFBDInputEventContext* input_context;\n    CFBD_Bool button_press_state;\n    CFBD_Bool isInterruptMode;\n    void (*enable_intr)(CFBD_PlainButton* button);\n} CFBD_ButtonCreationPack;\n\nvoid CFBD_CreatePlainButton(CFBD_PlainButton* button, CFBD_ButtonCreationPack* pack);\nvoid CFBD_PlainButtonEventMaker(CFBD_PlainButton* button, CFBDInputEvent* blank_event);\nvoid CFBD_PlainButtonSyncScan(CFBD_PlainButton* button);\n\ntypedef void (*CFBD_ButtonIntrCallbacks)(void* intr_datas);\ntypedef CFBD_PlainButton** CFBDPlainButtonArray;\ntypedef struct\n{\n    CFBDPlainButtonArray array;\n    int cnt;\n} IntrButtonArrayInfo;\n\nvoid CFBD_SetMonitoringButtons(IntrButtonArrayInfo* buttons);\nCFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacks();\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/plain__button__impl_8c/","title":"lib/input/button_like/stm_hal_series/plain_button_impl.c","text":""},{"location":"api/Files/plain__button__impl_8c/#source-code","title":"Source code","text":"<pre><code>#include \"../config/lib_settings.h\"\n\n#if defined(CFBD_IS_ST)\n#include \"button_like/plain_button.h\"\n#include \"button_like/plain_button_impl.h\"\n#include \"cfbd_define.h\"\n#include \"gpio-stm-impl.h\"\n\nstatic IntrButtonArrayInfo* g_info;\n\nstatic void each_button_process(CFBD_PlainButton* button)\n{\n    GPIO_PinState pin_state = CFBD_GPIOReadPin(button-&gt;handle);\n    uint32_t current_time = HAL_GetTick();\n\n    if (button-&gt;click_pending_time &gt; 0 &amp;&amp;\n        (current_time - button-&gt;click_pending_time) &gt;= BUTTON_DOUBLE_CLICK_TIME) {\n        // \u5355\u51fb\u8d85\u65f6,\u786e\u8ba4\u4e3a\u5355\u51fb\n        button-&gt;current_state_id = BUTTON_EVENT_CLICK;\n        button-&gt;click_pending_time = 0;\n\n        CFBDInputEvent event;\n        CFBD_PlainButtonEventMaker(button, &amp;event);\n        button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context, &amp;event);\n    }\n\n    // ========================================\n    // \ud83d\udd27 \u6b65\u9aa43: \u6309\u94ae\u72b6\u6001\u5904\u7406\n    // ========================================\n    CFBD_Bool is_pressed = (pin_state == button-&gt;button_press_state);\n    CFBDInputEvent event;\n    CFBD_Bool should_send_event = CFBD_FALSE;\n\n    // --- \u6309\u4e0b\u4e8b\u4ef6 ---\n    if (is_pressed &amp;&amp; !button-&gt;is_pressed) {\n        button-&gt;is_pressed = CFBD_TRUE;\n        button-&gt;press_time = current_time;\n        button-&gt;current_state_id = BUTTON_EVENT_PRESS;\n        button-&gt;long_press_triggered = CFBD_FALSE;\n\n        // \u68c0\u67e5\u662f\u5426\u662f\u53cc\u51fb\u7684\u7b2c\u4e8c\u6b21\u6309\u4e0b\n        if (button-&gt;click_pending_time &gt; 0 &amp;&amp;\n            (current_time - button-&gt;click_pending_time) &lt; BUTTON_DOUBLE_CLICK_TIME) {\n            // \u8fd9\u662f\u53cc\u51fb!\u53d6\u6d88\u5f85\u5b9a\u7684\u5355\u51fb\n            button-&gt;is_double_click_pending = CFBD_TRUE;\n            button-&gt;click_pending_time = 0; // \u6e05\u9664\u5355\u51fb\u5f85\u5b9a\n        }\n\n        should_send_event = CFBD_TRUE;\n    }\n    else if (!is_pressed &amp;&amp; button-&gt;is_pressed) {\n        button-&gt;is_pressed = CFBD_FALSE;\n        button-&gt;release_time = current_time;\n        uint32_t press_duration = current_time - button-&gt;press_time;\n\n        // \u975e\u957f\u6309\u7684\u77ed\u6309\n        if (!button-&gt;long_press_triggered &amp;&amp; press_duration &lt; BUTTON_LONG_PRESS_TIME) {\n            // \u68c0\u67e5\u662f\u5426\u662f\u53cc\u51fb\u7684\u7b2c\u4e8c\u6b21\u91ca\u653e\n            if (button-&gt;is_double_click_pending) {\n                button-&gt;current_state_id = BUTTON_EVENT_DOUBLE_CLICK;\n                button-&gt;is_double_click_pending = CFBD_FALSE;\n                button-&gt;click_pending_time = 0;\n                should_send_event = CFBD_TRUE;\n            }\n            else {\n                button-&gt;current_state_id = BUTTON_EVENT_CLICK;\n                button-&gt;click_pending_time = current_time;\n                should_send_event = CFBD_FALSE;\n            }\n        }\n        else {\n            // \u957f\u6309\u91ca\u653e\n            button-&gt;current_state_id = BUTTON_EVENT_RELEASE;\n            button-&gt;click_pending_time = 0;\n            button-&gt;is_double_click_pending = CFBD_FALSE;\n            should_send_event = CFBD_TRUE;\n        }\n    }\n    // --- \u6301\u7eed\u6309\u4e0b:\u957f\u6309\u68c0\u6d4b ---\n    else if (button-&gt;is_pressed &amp;&amp; !button-&gt;long_press_triggered) {\n        uint32_t press_duration = current_time - button-&gt;press_time;\n\n        if (press_duration &gt;= BUTTON_LONG_PRESS_TIME) {\n            // \u89e6\u53d1\u957f\u6309\n            button-&gt;long_press_triggered = CFBD_TRUE;\n            button-&gt;current_state_id = BUTTON_EVENT_LONG_PRESS;\n            button-&gt;click_pending_time = 0;\n            should_send_event = CFBD_TRUE;\n        }\n    }\n\n    // ========================================\n    // \ud83d\udd27 \u6b65\u9aa44: \u53d1\u9001\u4e8b\u4ef6\n    // ========================================\n    if (should_send_event) {\n        CFBD_PlainButtonEventMaker(button, &amp;event);\n        if (button-&gt;base_inputs.context &amp;&amp; button-&gt;base_inputs.context-&gt;ops) {\n            button-&gt;base_inputs.context-&gt;ops-&gt;enqueue_event(button-&gt;base_inputs.context, &amp;event);\n        }\n    }\n}\n\nstatic void CFBD_STButtonIntrCallbacks(void* intr_datas)\n{\n    uint16_t GPIO_Pin = *(uint16_t*) intr_datas;\n    for (int i = 0; i &lt; g_info-&gt;cnt; i++) {\n        CFBD_PlainButton* btn = g_info-&gt;array[i];\n        if (btn-&gt;handle-&gt;pin_internals_ == GPIO_Pin) {\n            each_button_process(btn);\n        }\n    }\n}\n\nCFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacksImpl(IntrButtonArrayInfo* info)\n{\n    g_info = info;\n    return CFBD_STButtonIntrCallbacks;\n}\n\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/plain__button__impl_8h/","title":"lib/input/button_like/plain_button_impl.h","text":""},{"location":"api/Files/plain__button__impl_8h/#functions","title":"Functions","text":"Name CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacksImpl(IntrButtonArrayInfo * info)"},{"location":"api/Files/plain__button__impl_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/plain__button__impl_8h/#function-cfbd_plainbuttongetintrcallbacksimpl","title":"function CFBD_PlainButtonGetIntrCallbacksImpl","text":"<pre><code>CFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacksImpl(\n    IntrButtonArrayInfo * info\n)\n</code></pre>"},{"location":"api/Files/plain__button__impl_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"plain_button.h\"\n\nCFBD_ButtonIntrCallbacks CFBD_PlainButtonGetIntrCallbacksImpl(IntrButtonArrayInfo* info);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/point_8h/","title":"point.h","text":"<p>Point and Vector data structures and utility functions for 2D graphics. </p>"},{"location":"api/Files/point_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components."},{"location":"api/Files/point_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct\n{\n    PointBaseType x; \n    PointBaseType y; \n} CFBDGraphic_Point;\n\ntypedef struct\n{\n    int32_t x; \n    int32_t y; \n} CFBDGraphic_Vec2i;\n\nstatic inline CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    uint32_t x = (uint32_t) a.x + b.x;\n    uint32_t y = (uint32_t) a.y + b.y;\n\n    if (x &gt; UINT16_MAX)\n        x = UINT16_MAX;\n    if (y &gt; UINT16_MAX)\n        y = UINT16_MAX;\n\n    return (CFBDGraphic_Point) {(uint16_t) x, (uint16_t) y};\n}\n\nstatic inline CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)\n{\n    return (CFBDGraphic_Vec2i) {(int32_t) a.x - (int32_t) b.x, (int32_t) a.y - (int32_t) b.y};\n}\n\n // End of Point_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/progressbar_8c/","title":"lib/graphic/widget/progressbar/progressbar.c","text":""},{"location":"api/Files/progressbar_8c/#functions","title":"Functions","text":"Name void draw_rect_border(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void fill_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void clear_rect(CFBD_GraphicDevice * dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h) void compute_inner_box(CFBD_ProgressBar * pb, uint16_t * out_x, uint16_t * out_y, uint16_t * out_w, uint16_t * out_h) float smoothstep(float t) uint16_t compute_fill_width(CFBD_ProgressBar * pb, int32_t value) void CFBD_ProgressBar_Draw(CFBD_ProgressBar * pb) void CFBD_ProgressBar_SetValue(CFBD_ProgressBar * pb, int32_t new_value) CFBD_Bool CFBD_ProgressBar_SetProperty(CFBD_ProgressBar * pb, const char * property, const void * value) void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8c/#attributes","title":"Attributes","text":"Name CFBD_ProgressBarOps ops"},{"location":"api/Files/progressbar_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8c/#function-draw_rect_border","title":"function draw_rect_border","text":"<pre><code>static void draw_rect_border(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-fill_rect","title":"function fill_rect","text":"<pre><code>static void fill_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-clear_rect","title":"function clear_rect","text":"<pre><code>static void clear_rect(\n    CFBD_GraphicDevice * dev,\n    uint16_t x,\n    uint16_t y,\n    uint16_t w,\n    uint16_t h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_inner_box","title":"function compute_inner_box","text":"<pre><code>static void compute_inner_box(\n    CFBD_ProgressBar * pb,\n    uint16_t * out_x,\n    uint16_t * out_y,\n    uint16_t * out_w,\n    uint16_t * out_h\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-smoothstep","title":"function smoothstep","text":"<pre><code>static float smoothstep(\n    float t\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-compute_fill_width","title":"function compute_fill_width","text":"<pre><code>static uint16_t compute_fill_width(\n    CFBD_ProgressBar * pb,\n    int32_t value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_draw","title":"function CFBD_ProgressBar_Draw","text":"<pre><code>void CFBD_ProgressBar_Draw(\n    CFBD_ProgressBar * pb\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setvalue","title":"function CFBD_ProgressBar_SetValue","text":"<pre><code>void CFBD_ProgressBar_SetValue(\n    CFBD_ProgressBar * pb,\n    int32_t new_value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_setproperty","title":"function CFBD_ProgressBar_SetProperty","text":"<pre><code>CFBD_Bool CFBD_ProgressBar_SetProperty(\n    CFBD_ProgressBar * pb,\n    const char * property,\n    const void * value\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/progressbar_8c/#variable-ops","title":"variable ops","text":"<pre><code>CFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n</code></pre>"},{"location":"api/Files/progressbar_8c/#source-code","title":"Source code","text":"<pre><code>#include \"progressbar.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"cfbd_define.h\"\n#include \"device/graphic_device.h\"\n#include \"sys_clock/system_clock.h\" /* for system_delay_ms */\n#include \"widget/animation/animation.h\"\n#include \"widget/base_support/common/helpers.h\"\n\n/* Draw rectangle border using setPixel (1px thick) */\nstatic void\ndraw_rect_border(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    /* top/bottom */\n    for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n        SetPixelAction(dev, ix, y);\n        SetPixelAction(dev, ix, y + h - 1);\n    }\n    /* left/right */\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        SetPixelAction(dev, x, iy);\n        SetPixelAction(dev, x + w - 1, iy);\n    }\n}\n\n/* Fill rectangular area with pixels (setPixel) */\nstatic void fill_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    CFBD_Bool (*SetPixelAction)(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y) =\n            dev-&gt;ops-&gt;setPixel;\n    for (uint16_t iy = y; iy &lt; y + h; ++iy) {\n        for (uint16_t ix = x; ix &lt; x + w; ++ix) {\n            SetPixelAction(dev, ix, iy);\n        }\n    }\n}\n\n/* Clear area using device-provided clear_area (faster than per-pixel clear) */\nstatic void clear_rect(CFBD_GraphicDevice* dev, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    dev-&gt;ops-&gt;clear_area(dev, x, y, w, h);\n}\n\n/* internal: compute inner box (where fill is drawn) */\nstatic void compute_inner_box(CFBD_ProgressBar* pb,\n                              uint16_t* out_x,\n                              uint16_t* out_y,\n                              uint16_t* out_w,\n                              uint16_t* out_h)\n{\n    uint16_t x = pb-&gt;tl.x;\n    uint16_t y = pb-&gt;tl.y;\n    uint16_t w = pb-&gt;size.width;\n    uint16_t h = pb-&gt;size.height;\n\n    uint8_t pad = pb-&gt;padding;\n    if (pb-&gt;border) {\n        /* 1 px border assumed */\n        if (w &lt;= 2)\n            w = 0;\n        else {\n            x += 1;\n            w -= 2;\n        }\n        if (h &lt;= 2)\n            h = 0;\n        else {\n            y += 1;\n            h -= 2;\n        }\n    }\n    /* apply padding inside */\n    if (w &gt; 2 * pad) {\n        x += pad;\n        w -= (uint16_t) (2 * pad);\n    }\n    else\n        w = 0;\n    if (h &gt; 2 * pad) {\n        y += pad;\n        h -= (uint16_t) (2 * pad);\n    }\n    else\n        h = 0;\n\n    *out_x = x;\n    *out_y = y;\n    *out_w = w;\n    *out_h = h;\n}\n\nstatic float smoothstep(float t)\n{\n    /* classic smoothstep: 3t^2 - 2t^3 */\n    return t * t * (3.0f - 2.0f * t);\n}\n\nstatic uint16_t compute_fill_width(CFBD_ProgressBar* pb, int32_t value)\n{\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    if (iw == 0 || pb-&gt;max &lt;= pb-&gt;min)\n        return 0;\n\n    value = clamp_i32(value, pb-&gt;min, pb-&gt;max);\n    float frac = (float) (value - pb-&gt;min) / (float) (pb-&gt;max - pb-&gt;min);\n\n    if (frac &lt; 0.0f)\n        frac = 0.0f;\n    if (frac &gt; 1.0f)\n        frac = 1.0f;\n\n    return (uint16_t) (frac * (float) iw + 0.5f);\n}\n\nvoid CFBD_ProgressBar_Draw(CFBD_ProgressBar* pb)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    CFBD_GraphicDevice* dev = pb-&gt;device;\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n\n    /* clear inner area */\n    clear_rect(dev, ix, iy, iw, ih);\n\n    /* draw filled area */\n    uint16_t fill_w = compute_fill_width(pb, pb-&gt;value);\n    if (fill_w &gt; 0)\n        fill_rect(dev, ix, iy, fill_w, ih);\n\n    /* border */\n    if (pb-&gt;border)\n        draw_rect_border(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n    dev-&gt;ops-&gt;update_area(dev, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n}\n\nvoid CFBD_ProgressBar_SetValue(CFBD_ProgressBar* pb, int32_t new_value)\n{\n    if (!pb || !pb-&gt;device)\n        return;\n\n    new_value = clamp_i32(new_value, pb-&gt;min, pb-&gt;max);\n\n    int32_t old_value = pb-&gt;value;\n    if (pb-&gt;animation.anim_frames &lt;= 1) {\n        pb-&gt;value = new_value;\n        CFBD_ProgressBar_Draw(pb);\n        return;\n    }\n\n    uint16_t ix, iy, iw, ih;\n    compute_inner_box(pb, &amp;ix, &amp;iy, &amp;iw, &amp;ih);\n    if (iw == 0 || ih == 0) {\n        pb-&gt;value = new_value;\n        return;\n    }\n\n    int frames = pb-&gt;animation.anim_frames;\n    int delay = (pb-&gt;animation.anim_frame_delay_ms &gt; 0) ? pb-&gt;animation.anim_frame_delay_ms : 16;\n\n    uint16_t last_fill = compute_fill_width(pb, old_value);\n\n    for (int f = 1; f &lt;= frames; ++f) {\n        float t = (float) f / (float) frames;\n        float st = smoothstep(t);\n\n        int32_t cur_value = old_value + (int32_t) ((float) (new_value - old_value) * st);\n\n        uint16_t cur_fill = compute_fill_width(pb, cur_value);\n\n        /* incremental update only */\n        if (cur_fill &gt; last_fill) {\n            /* grow */\n            fill_rect(pb-&gt;device, ix + last_fill, iy, cur_fill - last_fill, ih);\n        }\n        else if (cur_fill &lt; last_fill) {\n            /* shrink */\n            clear_rect(pb-&gt;device, ix + cur_fill, iy, last_fill - cur_fill, ih);\n        }\n\n        if (pb-&gt;border)\n            draw_rect_border(pb-&gt;device, pb-&gt;tl.x, pb-&gt;tl.y, pb-&gt;size.width, pb-&gt;size.height);\n\n        pb-&gt;device-&gt;ops-&gt;update_area(pb-&gt;device,\n                                     pb-&gt;tl.x,\n                                     pb-&gt;tl.y,\n                                     pb-&gt;size.width,\n                                     pb-&gt;size.height);\n\n        last_fill = cur_fill;\n        pb-&gt;value = cur_value;\n\n        system_delay_ms(delay);\n    }\n\n    pb-&gt;value = new_value;\n}\n\n/*\n *          -&gt; border, uint8_t as boarders\n *          -&gt; padding, uint8_t as padding\n *          -&gt; animation, CFBD_BaseAnimation* passed\n */\nCFBD_Bool\nCFBD_ProgressBar_SetProperty(CFBD_ProgressBar* pb, const char* property, const void* value)\n{\n    if (strcmp(property, \"border\") == 0) {\n        uint8_t border = *(uint8_t*) (value);\n        pb-&gt;border = border;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"padding\") == 0) {\n        uint8_t padding = *(uint8_t*) (value);\n        pb-&gt;padding = padding;\n        return CFBD_TRUE;\n    }\n    else if (strcmp(property, \"animation\") == 0) {\n        CFBD_BaseAnimation* animation = (CFBD_BaseAnimation*) (value);\n        pb-&gt;animation = *animation;\n        return CFBD_TRUE;\n    }\n    return CFBD_FALSE;\n}\n\nCFBD_ProgressBarOps ops = {.immediate_draw = CFBD_ProgressBar_Draw,\n                           .set_property = CFBD_ProgressBar_SetProperty,\n                           .set_value = CFBD_ProgressBar_SetValue};\n\n/* simple setters */\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max)\n{\n    if (!pb)\n        return;\n    memset(pb, 0, sizeof(*pb));\n    pb-&gt;tl = *tl;\n    pb-&gt;size = *sz;\n    pb-&gt;min = min;\n    pb-&gt;max = max;\n    pb-&gt;value = min;\n    pb-&gt;device = device;\n    pb-&gt;border = 1;\n    pb-&gt;padding = 1;\n    pb-&gt;ops = &amp;ops;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/progressbar_8h/","title":"lib/graphic/widget/progressbar/progressbar.h","text":"<p>Progress bar widget for progress visualization.  More...</p>"},{"location":"api/Files/progressbar_8h/#classes","title":"Classes","text":"Name struct CFBD_ProgressBarOps struct __CFBD_ProgressBar"},{"location":"api/Files/progressbar_8h/#types","title":"Types","text":"Name typedef struct __CFBD_ProgressBar CFBD_ProgressBar Forward declaration of progress bar structure."},{"location":"api/Files/progressbar_8h/#functions","title":"Functions","text":"Name void CFBD_ProgressBar_Init(CFBD_ProgressBar * pb, CFBD_GraphicDevice * device, CFBDGraphic_Point * tl, CFBDGraphicSize * sz, int32_t min, int32_t max)"},{"location":"api/Files/progressbar_8h/#detailed-description","title":"Detailed Description","text":"<p>Progress bar widget for progress visualization. </p> <p>Provides progress bar structure and operations for displaying progress with optional borders, padding, and animations. </p>"},{"location":"api/Files/progressbar_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/progressbar_8h/#typedef-cfbd_progressbar","title":"typedef CFBD_ProgressBar","text":"<pre><code>typedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n</code></pre> <p>Forward declaration of progress bar structure. </p> <p>See: </p> <ul> <li>CFBD_ProgressBar_Init</li> <li>CFBD_ProgressBarOps</li> </ul> <p>Progress bar widget structure.</p> <p>Encapsulates all progress bar state including value range, visual properties, animation, and rendering surface. </p>"},{"location":"api/Files/progressbar_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/progressbar_8h/#function-cfbd_progressbar_init","title":"function CFBD_ProgressBar_Init","text":"<pre><code>void CFBD_ProgressBar_Init(\n    CFBD_ProgressBar * pb,\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_Point * tl,\n    CFBDGraphicSize * sz,\n    int32_t min,\n    int32_t max\n)\n</code></pre>"},{"location":"api/Files/progressbar_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/animation/animation.h\"\n\ntypedef struct __CFBD_ProgressBar CFBD_ProgressBar;\n\ntypedef struct\n{\n    void (*immediate_draw)(CFBD_ProgressBar*);\n\n    void (*set_value)(CFBD_ProgressBar*, int32_t new_value);\n\n    CFBD_Bool (*set_property)(CFBD_ProgressBar*, const char* property, const void* args);\n} CFBD_ProgressBarOps;\n\ntypedef struct __CFBD_ProgressBar\n{\n    CFBD_ProgressBarOps* ops;\n\n    CFBDGraphic_Point tl;\n\n    CFBDGraphicSize size;\n\n    int32_t min;\n\n    int32_t max;\n\n    int32_t value;\n\n    CFBD_GraphicDevice* device;\n\n    uint8_t border;\n\n    uint8_t padding;\n\n    CFBD_BaseAnimation animation;\n} CFBD_ProgressBar;\n\nvoid CFBD_ProgressBar_Init(CFBD_ProgressBar* pb,\n                           CFBD_GraphicDevice* device,\n                           CFBDGraphic_Point* tl,\n                           CFBDGraphicSize* sz,\n                           int32_t min,\n                           int32_t max);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/rectangle_8c/","title":"rectangle.c","text":""},{"location":"api/Files/rectangle_8c/#types","title":"Types","text":"Name enum ____CSCode"},{"location":"api/Files/rectangle_8c/#functions","title":"Functions","text":"Name int cs_compute_code(const CFBDGraphicRect * r, int32_t x, int32_t y)"},{"location":"api/Files/rectangle_8c/#defines","title":"Defines","text":"Name MAX(a, b) MIN(a, b)"},{"location":"api/Files/rectangle_8c/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/rectangle_8c/#enum-____cscode","title":"enum ____CSCode","text":"Enumerator Value Description CS_LEFT 1 &lt;&lt; 0 CS_RIGHT 1 &lt;&lt; 1 CS_BOTTOM 1 &lt;&lt; 2 CS_TOP 1 &lt;&lt; 3"},{"location":"api/Files/rectangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/rectangle_8c/#function-cs_compute_code","title":"function cs_compute_code","text":"<pre><code>static int cs_compute_code(\n    const CFBDGraphicRect * r,\n    int32_t x,\n    int32_t y\n)\n</code></pre>"},{"location":"api/Files/rectangle_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/rectangle_8c/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre>"},{"location":"api/Files/rectangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"rectangle.h\"\n\n#include &lt;math.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"device/graphic_device.h\"\n\ntypedef enum\n{\n    CS_LEFT = 1 &lt;&lt; 0,\n    CS_RIGHT = 1 &lt;&lt; 1,\n    CS_BOTTOM = 1 &lt;&lt; 2,\n    CS_TOP = 1 &lt;&lt; 3\n} ____CSCode;\n\nvoid CFBDGraphic_DrawRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    if (device == NULL || rect == NULL)\n        return;\n    if (device-&gt;ops == NULL)\n        return;\n\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    if (lx == rx &amp;&amp; ty == by) {\n        device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty));\n    }\n    else {\n        /* \u9876\u8fb9\u4e0e\u5e95\u8fb9\uff08\u6c34\u5e73\uff09: x = lx..rx */\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(ty));\n            if (by != ty) /* \u5982\u679c\u9ad8\u5ea6&gt;1 \u518d\u753b\u5e95\u8fb9\uff0c\u9632\u6b62\u91cd\u590d\u753b\u540c\u4e00\u884c */\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(by));\n        }\n        if (by - ty &gt;= 2) {\n            for (int32_t y = ty + 1; y &lt;= by - 1; ++y) {\n                device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(y));\n                if (rx != lx)\n                    device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(rx), clamp_u16_from_i32(y));\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nvoid CFBDGraphic_FillRect(CFBD_GraphicDevice* device, CFBDGraphicRect* rect)\n{\n    CFBDGraphicRect n = rect_normalize(*rect);\n    int32_t lx = asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y);\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    device-&gt;ops-&gt;clear_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n\n    for (int32_t y = ty; y &lt;= by; ++y) {\n        for (int32_t x = lx; x &lt;= rx; ++x) {\n            device-&gt;ops-&gt;setPixel(device, clamp_u16_from_i32(x), clamp_u16_from_i32(y));\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device)) {\n        device-&gt;ops-&gt;update_area(device, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n    }\n}\n\nstatic int cs_compute_code(const CFBDGraphicRect* r, int32_t x, int32_t y)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t code = 0;\n\n    if (x &lt; asInt32_t(n.tl.x))\n        code |= CS_LEFT;\n    else if (x &gt; asInt32_t(n.br.x))\n        code |= CS_RIGHT;\n\n    if (y &lt; asInt32_t(n.tl.y))\n        code |= CS_TOP;\n    else if (y &gt; asInt32_t(n.br.y))\n        code |= CS_BOTTOM;\n\n    return code;\n}\n\nCFBDGraphicRect rect_intersection(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n#ifndef MAX\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n    int32_t lx = MAX(asInt32_t(A.tl.x), asInt32_t(B.tl.x));\n    int32_t ty = MAX(asInt32_t(A.tl.y), asInt32_t(B.tl.y));\n    int32_t rx = MIN(asInt32_t(A.br.x), asInt32_t(B.br.x));\n    int32_t by = MIN(asInt32_t(A.br.y), asInt32_t(B.br.y));\n#undef MAX\n#undef MIN\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_union(const CFBDGraphicRect* a, const CFBDGraphicRect* b)\n{\n    CFBDGraphicRect A = rect_normalize(*a);\n    CFBDGraphicRect B = rect_normalize(*b);\n\n    int32_t lx = asInt32_t(A.tl.x) &lt; asInt32_t(B.tl.x) ? asInt32_t(A.tl.x) : asInt32_t(B.tl.x);\n    int32_t ty = asInt32_t(A.tl.y) &lt; asInt32_t(B.tl.y) ? asInt32_t(A.tl.y) : asInt32_t(B.tl.y);\n    int32_t rx = asInt32_t(A.br.x) &gt; asInt32_t(B.br.x) ? asInt32_t(A.br.x) : asInt32_t(B.br.x);\n    int32_t by = asInt32_t(A.br.y) &gt; asInt32_t(B.br.y) ? asInt32_t(A.br.y) : asInt32_t(B.br.y);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_offset(const CFBDGraphicRect* r, int32_t dx, int32_t dy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(asInt32_t(n.tl.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.tl.y) + dy)},\n                              {clamp_u16_from_i32(asInt32_t(n.br.x) + dx),\n                               clamp_u16_from_i32(asInt32_t(n.br.y) + dy)}};\n}\n\nCFBDGraphicRect\nrect_inset(const CFBDGraphicRect* r, int32_t left, int32_t top, int32_t right, int32_t bottom)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t lx = asInt32_t(n.tl.x) + left;\n    int32_t ty = asInt32_t(n.tl.y) + top;\n    int32_t rx = asInt32_t(n.br.x) - right;\n    int32_t by = asInt32_t(n.br.y) - bottom;\n\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                              {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n}\n\nCFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect* r, float sx, float sy)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n\n    int32_t cx = (asInt32_t(n.tl.x) + asInt32_t(n.br.x)) / 2;\n    int32_t cy = (asInt32_t(n.tl.y) + asInt32_t(n.br.y)) / 2;\n\n    int32_t hw = asInt32_t(n.br.x) - asInt32_t(n.tl.x);\n    int32_t hh = asInt32_t(n.br.y) - asInt32_t(n.tl.y);\n\n    int32_t new_hw = (int32_t) floorf(hw * sx / 2.0f + 0.5f);\n    int32_t new_hh = (int32_t) floorf(hh * sy / 2.0f + 0.5f);\n\n    return (CFBDGraphicRect) {{clamp_u16_from_i32(cx - new_hw), clamp_u16_from_i32(cy - new_hh)},\n                              {clamp_u16_from_i32(cx + new_hw), clamp_u16_from_i32(cy + new_hh)}};\n}\n\nCFBDGraphicRect\nrect_align_in_parent(const CFBDGraphicRect* parent, const CFBDGraphicRect* child, uint8_t anchor)\n{\n    CFBDGraphicRect P = rect_normalize(*parent);\n    CFBDGraphicRect C = rect_normalize(*child);\n    int32_t pw = asInt32_t(P.br.x) - asInt32_t(P.tl.x);\n    int32_t ph = asInt32_t(P.br.y) - asInt32_t(P.tl.y);\n    int32_t cw = asInt32_t(C.br.x) - asInt32_t(C.tl.x);\n    int32_t ch = asInt32_t(C.br.y) - asInt32_t(C.tl.y);\n    int32_t nx = asInt32_t(P.tl.x);\n    int32_t ny = asInt32_t(P.tl.y); /* \u6c34\u5e73 */\n    if (anchor &amp; RECT_ANCHOR_LEFT) {\n        nx = asInt32_t(P.tl.x);\n    }\n    else if (anchor &amp; RECT_ANCHOR_RIGHT) {\n        nx = asInt32_t(P.br.x) - cw;\n    }\n    else { /* center by default */\n        nx = asInt32_t(P.tl.x) + (pw - cw) / 2;\n    } /* \u5782\u76f4 */\n    if (anchor &amp; RECT_ANCHOR_TOP) {\n        ny = asInt32_t(P.tl.y);\n    }\n    else if (anchor &amp; RECT_ANCHOR_BOTTOM) {\n        ny = asInt32_t(P.br.y) - ch;\n    }\n    else {\n        ny = asInt32_t(P.tl.y) + (ph - ch) / 2;\n    }\n    return rect_from_xywh(nx, ny, cw, ch);\n}\n\n/* ---------- \u6700\u8fd1\u70b9 / \u70b9\u5230\u77e9\u5f62\u8ddd\u79bb ---------- */\n\n/* \u8fd4\u56de\u77e9\u5f62\u5185\u5230\u70b9\u6700\u8fd1\u7684\u70b9\uff08\u5982\u679c\u70b9\u5728\u77e9\u5f62\u5185\uff0c\u5219\u8fd4\u56de\u70b9\u672c\u8eab\uff0c\u7ed3\u679c\u4e3a uint16_t\uff09 */\nCFBDGraphic_Point rect_closest_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t px = asInt32_t(p.x), py = asInt32_t(p.y);\n    int32_t lx = asInt32_t(n.tl.x), ty = asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x), by = asInt32_t(n.br.y);\n    int32_t cx = px &lt; lx ? lx : (px &gt; rx ? rx : px);\n    int32_t cy = py &lt; ty ? ty : (py &gt; by ? by : py);\n    CFBDGraphic_Point out = {clamp_u16_from_i32(cx), clamp_u16_from_i32(cy)};\n    return out;\n}\n\n/* \u70b9\u5230\u77e9\u5f62\u6700\u77ed\u8ddd\u79bb\uff08\u50cf\u7d20\u8ddd\u79bb\uff0c\u82e5\u5728\u77e9\u5f62\u5185\u5219\u4e3a0\uff09*/\nuint32_t rect_distance_to_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphic_Point cp = rect_closest_point(r, p);\n    int32_t dx = asInt32_t(cp.x) - asInt32_t(p.x);\n    int32_t dy = asInt32_t(cp.y) - asInt32_t(p.y);\n    return (uint32_t) (sqrt((double) (dx * dx + dy * dy)));\n}\n\n/* ---------- \u6269\u5c55 / \u5305\u542b\u70b9 ---------- */\nCFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect* r, CFBDGraphic_Point p)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; asInt32_t(p.x) ? asInt32_t(n.tl.x) : asInt32_t(p.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; asInt32_t(p.y) ? asInt32_t(n.tl.y) : asInt32_t(p.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; asInt32_t(p.x) ? asInt32_t(n.br.x) : asInt32_t(p.x);\n    int32_t by = asInt32_t(n.br.y) &gt; asInt32_t(p.y) ? asInt32_t(n.br.y) : asInt32_t(p.y);\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n\nCFBD_Bool rect_clip_line(CFBDGraphicRect* r, CFBDGraphic_Point* p0, CFBDGraphic_Point* p1)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t x0 = asInt32_t(p0-&gt;x), y0 = asInt32_t(p0-&gt;y);\n    int32_t x1 = asInt32_t(p1-&gt;x), y1 = asInt32_t(p1-&gt;y);\n    int code0 = cs_compute_code(&amp;n, x0, y0);\n    int code1 = cs_compute_code(&amp;n, x1, y1);\n    CFBD_Bool accept = CFBD_FALSE;\n    while (1) {\n        if ((code0 | code1) == 0) {\n            accept = CFBD_TRUE;\n            break;\n        }\n        else if (code0 &amp; code1) {\n            accept = CFBD_FALSE;\n            break;\n        }\n        else {\n            int outcode = code0 ? code0 : code1;\n            int32_t nx = 0, ny = 0;\n            if (outcode &amp; CS_TOP) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.tl.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.tl.y);\n            }\n            else if (outcode &amp; CS_BOTTOM) {\n                nx = x0 +\n                     (int32_t) ((double) (x1 - x0) * (asInt32_t(n.br.y) - y0) / (double) (y1 - y0));\n                ny = asInt32_t(n.br.y);\n            }\n            else if (outcode &amp; CS_RIGHT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.br.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.br.x);\n            }\n            else if (outcode &amp; CS_LEFT) {\n                ny = y0 +\n                     (int32_t) ((double) (y1 - y0) * (asInt32_t(n.tl.x) - x0) / (double) (x1 - x0));\n                nx = asInt32_t(n.tl.x);\n            }\n            if (outcode == code0) {\n                x0 = nx;\n                y0 = ny;\n                code0 = cs_compute_code(&amp;n, x0, y0);\n            }\n            else {\n                x1 = nx;\n                y1 = ny;\n                code1 = cs_compute_code(&amp;n, x1, y1);\n            }\n        }\n    }\n    if (accept) {\n        p0-&gt;x = clamp_u16_from_i32(x0);\n        p0-&gt;y = clamp_u16_from_i32(y0);\n        p1-&gt;x = clamp_u16_from_i32(x1);\n        p1-&gt;y = clamp_u16_from_i32(y1);\n    }\n    return accept;\n}\n\n/* ---------- \u591a\u7528\u9014\uff1a\u88c1\u526a\u5230\u5c4f\u5e55\u8fb9\u754c ---------- */\nCFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect* r, uint16_t screen_w, uint16_t screen_h)\n{\n    CFBDGraphicRect n = rect_normalize(*r);\n    int32_t lx = asInt32_t(n.tl.x) &lt; 0 ? 0 : asInt32_t(n.tl.x);\n    int32_t ty = asInt32_t(n.tl.y) &lt; 0 ? 0 : asInt32_t(n.tl.y);\n    int32_t rx = asInt32_t(n.br.x) &gt; screen_w ? screen_w : asInt32_t(n.br.x);\n    int32_t by = asInt32_t(n.br.y) &gt; screen_h ? screen_h : asInt32_t(n.br.y);\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n    CFBDGraphicRect out = {{clamp_u16_from_i32(lx), clamp_u16_from_i32(ty)},\n                           {clamp_u16_from_i32(rx), clamp_u16_from_i32(by)}};\n    return out;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/size_8c/","title":"size.c","text":""},{"location":"api/Files/size_8c/#source-code","title":"Source code","text":"<pre><code>#include \"size.h\"\n#include \"cfbd_graphic_define.h\"\n#include &lt;stddef.h&gt;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize){\n    PointBaseType width, height;\n    device-&gt;ops-&gt;self_consult(device, \"width\", NULL, &amp;width);\n    device-&gt;ops-&gt;self_consult(device, \"height\", NULL, &amp;height);\n    pSize-&gt;height = height;\n    pSize-&gt;width = width;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/size_8h/","title":"size.h","text":"<p>Size data structure and utilities for 2D graphics. </p>"},{"location":"api/Files/size_8h/#classes","title":"Classes","text":"Name struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area."},{"location":"api/Files/size_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n\ntypedef struct\n{\n    SizeBaseType width;  \n    SizeBaseType height; \n} CFBDGraphicSize;\n\nvoid CFBDGraphic_GetScreenSize(CFBD_GraphicDevice* device, CFBDGraphicSize* pSize);\n\n // End of Size_Module group\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1306_8c/","title":"lib/oled/driver/device/ssd1306/ssd1306.c","text":""},{"location":"api/Files/ssd1306_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1306_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1306_inits_commands CFBD_OLED_DeviceSpecific ssd1306_specific"},{"location":"api/Files/ssd1306_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8c/#function-ssd1306_init_sessions","title":"function ssd1306_init_sessions","text":"<pre><code>static uint8_t * ssd1306_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_inits_commands","title":"variable ssd1306_inits_commands","text":"<pre><code>static uint8_t[] ssd1306_inits_commands = {\n\n};\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#variable-ssd1306_specific","title":"variable ssd1306_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1306_specific;\n</code></pre>"},{"location":"api/Files/ssd1306_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1306.h\"\n#include &lt;stdint.h&gt;\n\nstatic uint8_t ssd1306_inits_commands[] = {\n\n};\n\n\nstatic uint8_t* ssd1306_init_sessions(void){\n    return ssd1306_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1306_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific(){\n    ssd1306_specific.init_session_tables = ssd1306_init_sessions;\n    return &amp;ssd1306_specific;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1306_8h/","title":"lib/oled/driver/device/ssd1306/ssd1306.h","text":"<p>SSD1306 device-specific descriptor and factory.  More...</p>"},{"location":"api/Files/ssd1306_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1306Specific()"},{"location":"api/Files/ssd1306_8h/#detailed-description","title":"Detailed Description","text":"<p>SSD1306 device-specific descriptor and factory. </p> <p>See: </p> <ul> <li>CFBD_OLED_DeviceSpecificfor the generic interface </li> <li>device_interface.hfor base types </li> </ul> <p>This module provides the SSD1306-specific implementation of the device descriptor interface. It delivers initialization sequences, GRAM buffers, and communication parameters tailored for SSD1306-based displays.</p> <p>The SSD1306 is a common monochrome OLED controller featuring:</p> <ul> <li>128x64 pixel resolution (typical)</li> <li>I2C or SPI communication interface</li> <li>256-byte graphics RAM</li> <li>Multiplex and COM output configurations</li> </ul>"},{"location":"api/Files/ssd1306_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1306_8h/#function-getssd1306specific","title":"function getSSD1306Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1306Specific()\n</code></pre>"},{"location":"api/Files/ssd1306_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"driver/device/device_interface.h\"\n\nCFBD_OLED_DeviceSpecific* getSSD1306Specific();\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1309_8c/","title":"lib/oled/driver/device/ssd1309/ssd1309.c","text":""},{"location":"api/Files/ssd1309_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1309_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1309_inits_commands CFBD_OLED_DeviceSpecific ssd1309_specific"},{"location":"api/Files/ssd1309_8c/#defines","title":"Defines","text":"Name CMD_TABLE_SZ"},{"location":"api/Files/ssd1309_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8c/#function-ssd1309_init_sessions","title":"function ssd1309_init_sessions","text":"<pre><code>static uint8_t * ssd1309_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_inits_commands","title":"variable ssd1309_inits_commands","text":"<pre><code>static uint8_t[] ssd1309_inits_commands = {\n        0xAE,       \n        0xFD, 0x12, \n        0xD5,       \n        0xA0,       \n        0xA8,       \n        0x3F,       \n        0xD3,       \n        0x00,       \n        0x40,       \n        0xA1,       \n        0xC8,       \n        0xDA,       \n        0x12,       \n        0x81,       \n        0xBF,       \n        0xD9,       \n        0x25,       \n        0xDB,       \n        0x34,       \n        0xA4,       \n        0xA6,       \n        0xAF        \n};\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#variable-ssd1309_specific","title":"variable ssd1309_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1309_specific;\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1309_8c/#define-cmd_table_sz","title":"define CMD_TABLE_SZ","text":"<pre><code>#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n</code></pre>"},{"location":"api/Files/ssd1309_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1309.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\nstatic uint8_t ssd1309_inits_commands[] = {\n        0xAE,       // Turn off OLED panel\n        0xFD, 0x12, // Set display clock divide ratio/oscillator frequency\n        0xD5,       // Set display clock divide ratio\n        0xA0,       // Set multiplex ratio\n        0xA8,       // Set multiplex ratio (1 to 64)\n        0x3F,       // 1/64 duty\n        0xD3,       // Set display offset\n        0x00,       // No offset\n        0x40,       // Set start line address\n        0xA1,       // Set SEG/Column mapping (0xA0 for reverse, 0xA1 for normal)\n        0xC8,       // Set COM/Row scan direction (0xC0 for reverse, 0xC8 for normal)\n        0xDA,       // Set COM pins hardware configuration\n        0x12,       // COM pins configuration\n        0x81,       // Set contrast control register\n        0xBF,       // Set SEG output current brightness\n        0xD9,       // Set pre-charge period\n        0x25,       // Set pre-charge as 15 clocks &amp; discharge as 1 clock\n        0xDB,       // Set VCOMH\n        0x34,       // Set VCOM deselect level\n        0xA4,       // Disable entire display on\n        0xA6,       // Disable inverse display on\n        0xAF        // Turn on the display\n};\n\n#define CMD_TABLE_SZ ((sizeof(ssd1309_inits_commands)) / sizeof(ssd1309_inits_commands[0]))\n\nstatic uint8_t* ssd1309_init_sessions(void)\n{\n    return ssd1309_inits_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1309_specific;\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific()\n{\n    ssd1309_specific.init_session_tables = ssd1309_init_sessions;\n    ssd1309_specific.init_session_tables_sz = CMD_TABLE_SZ;\n    ssd1309_specific.cmd_prefix = 0x00;\n    ssd1309_specific.data_prefix = 0x40;\n    ssd1309_specific.logic_height = 64;\n    ssd1309_specific.logic_width = 128;\n    ssd1309_specific.iic_pack_type = SSD1309_IIC_PACK;\n    ssd1309_specific.private_data = NULL; // no, nothing here\n    return &amp;ssd1309_specific;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1309_8h/","title":"lib/oled/driver/device/ssd1309/ssd1309.h","text":"<p>SSD1309 device-specific descriptor and factory.  More...</p>"},{"location":"api/Files/ssd1309_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1309Specific()"},{"location":"api/Files/ssd1309_8h/#defines","title":"Defines","text":"Name SSD1309_IIC_PACK"},{"location":"api/Files/ssd1309_8h/#detailed-description","title":"Detailed Description","text":"<p>SSD1309 device-specific descriptor and factory. </p> <p>See: </p> <ul> <li>CFBD_OLED_DeviceSpecificfor the generic interface </li> <li>device_interface.hfor base types </li> </ul> <p>This module provides the SSD1309-specific implementation of the device descriptor interface. It delivers initialization sequences, GRAM buffers, and communication parameters optimized for SSD1309-based displays.</p> <p>The SSD1309 is an enhanced monochrome OLED controller featuring:</p> <ul> <li>Extended resolution support (typically 128x64 or larger)</li> <li>Improved contrast and brightness control</li> <li>I2C and SPI communication interfaces</li> <li>Advanced timing parameters for various OLED panel types</li> <li>Fixed default I2C address: 0x78</li> </ul>"},{"location":"api/Files/ssd1309_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1309_8h/#function-getssd1309specific","title":"function getSSD1309Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1309Specific()\n</code></pre>"},{"location":"api/Files/ssd1309_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1309_8h/#define-ssd1309_iic_pack","title":"define SSD1309_IIC_PACK","text":"<pre><code>#define SSD1309_IIC_PACK (SSD130X_REQUEST_IIC_PACK)\n</code></pre>"},{"location":"api/Files/ssd1309_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"driver/device/device_interface.h\"\n\n#define SSD1309_DRIVER_ADDRESS (0x78)\n#define SSD1309_IIC_PACK (SSD130X_REQUEST_IIC_PACK)\n\nCFBD_OLED_DeviceSpecific* getSSD1309Specific();\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1327_8c/","title":"lib/oled/driver/device/ssd1327/ssd1327.c","text":""},{"location":"api/Files/ssd1327_8c/#functions","title":"Functions","text":"Name uint8_t * ssd1327_init_sessions(void ) CFBD_OLED_DeviceSpecific * getSSD1327Specific()"},{"location":"api/Files/ssd1327_8c/#attributes","title":"Attributes","text":"Name uint8_t[] ssd1327_init_commands CFBD_OLED_DeviceSpecific ssd1327_specific SSD132XPrivateDatas ssd1327_private_data"},{"location":"api/Files/ssd1327_8c/#defines","title":"Defines","text":"Name CMD_TABLE_SZ"},{"location":"api/Files/ssd1327_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1327_8c/#function-ssd1327_init_sessions","title":"function ssd1327_init_sessions","text":"<pre><code>static uint8_t * ssd1327_init_sessions(\n    void \n)\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#function-getssd1327specific","title":"function getSSD1327Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1327Specific()\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/ssd1327_8c/#variable-ssd1327_init_commands","title":"variable ssd1327_init_commands","text":"<pre><code>static uint8_t[] ssd1327_init_commands = {\n        0xAE, \n\n        0xA0, 0x51, \n        0xA1, 0x00, \n        0xA2, 0x20, \n\n        0xA4,       \n        0xA8, 0x5F, \n        0xAB, 0x01, \n        0x81, 0x77, \n        0xB1, 0x31, 0xB3, 0xB1, 0xB5, 0x03, 0xB6, 0x0D, 0xBC, 0x07, 0xBE, 0x07, 0xD5, 0x02,\n        0xAF \n};\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#variable-ssd1327_specific","title":"variable ssd1327_specific","text":"<pre><code>static CFBD_OLED_DeviceSpecific ssd1327_specific;\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#variable-ssd1327_private_data","title":"variable ssd1327_private_data","text":"<pre><code>static SSD132XPrivateDatas ssd1327_private_data = {.grey_scale = 0x05};\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1327_8c/#define-cmd_table_sz","title":"define CMD_TABLE_SZ","text":"<pre><code>#define CMD_TABLE_SZ ((sizeof(ssd1327_init_commands)) / sizeof(ssd1327_init_commands[0]))\n</code></pre>"},{"location":"api/Files/ssd1327_8c/#source-code","title":"Source code","text":"<pre><code>#include \"ssd1327.h\"\n\n#include &lt;stdint.h&gt;\n\n#include \"../oled_ssd132x_privates.h\"\n#include \"configs/iic_pack_type.h\"\n\nstatic uint8_t ssd1327_init_commands[] = {\n        0xAE, // Display OFF\n\n        0xA0, 0x51, // Remap (keep 0x51 for your module initial test)\n        0xA1, 0x00, // Display Start Line = 0\n        0xA2, 0x20, // Display Offset = 32 (128 - 96)\n\n        0xA4,       // Normal display\n        0xA8, 0x5F, // MUX = 96 - 1\n        0xAB, 0x01, // Enable internal VDD\n        0x81, 0x77, // Contrast\n        0xB1, 0x31, 0xB3, 0xB1, 0xB5, 0x03, 0xB6, 0x0D, 0xBC, 0x07, 0xBE, 0x07, 0xD5, 0x02,\n        0xAF // Display ON\n};\n\n#define CMD_TABLE_SZ ((sizeof(ssd1327_init_commands)) / sizeof(ssd1327_init_commands[0]))\n\nstatic uint8_t* ssd1327_init_sessions(void)\n{\n    return ssd1327_init_commands;\n}\n\nstatic CFBD_OLED_DeviceSpecific ssd1327_specific;\nstatic SSD132XPrivateDatas ssd1327_private_data = {.grey_scale = 0x05};\n\nCFBD_OLED_DeviceSpecific* getSSD1327Specific()\n{\n    ssd1327_specific.init_session_tables = ssd1327_init_sessions;\n    ssd1327_specific.init_session_tables_sz = CMD_TABLE_SZ;\n    ssd1327_specific.cmd_prefix = 0x00;\n    ssd1327_specific.data_prefix = 0x40;\n    ssd1327_specific.logic_height = 96;\n    ssd1327_specific.logic_width = 128;\n    ssd1327_specific.iic_pack_type = SSD132X_REQUEST_IIC_PACK;\n    ssd1327_specific.private_data = &amp;ssd1327_private_data;\n    return &amp;ssd1327_specific;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/ssd1327_8h/","title":"lib/oled/driver/device/ssd1327/ssd1327.h","text":""},{"location":"api/Files/ssd1327_8h/#functions","title":"Functions","text":"Name CFBD_OLED_DeviceSpecific * getSSD1327Specific()"},{"location":"api/Files/ssd1327_8h/#defines","title":"Defines","text":"Name SSD1327_DRIVER_ADDRESS SSD1327_IIC_PACK"},{"location":"api/Files/ssd1327_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ssd1327_8h/#function-getssd1327specific","title":"function getSSD1327Specific","text":"<pre><code>CFBD_OLED_DeviceSpecific * getSSD1327Specific()\n</code></pre>"},{"location":"api/Files/ssd1327_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ssd1327_8h/#define-ssd1327_driver_address","title":"define SSD1327_DRIVER_ADDRESS","text":"<pre><code>#define SSD1327_DRIVER_ADDRESS (0x78)\n</code></pre>"},{"location":"api/Files/ssd1327_8h/#define-ssd1327_iic_pack","title":"define SSD1327_IIC_PACK","text":"<pre><code>#define SSD1327_IIC_PACK (SSD132X_REQUEST_IIC_PACK)\n</code></pre>"},{"location":"api/Files/ssd1327_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"driver/device/device_interface.h\"\n\n#define SSD1327_DRIVER_ADDRESS (0x78)\n#define SSD1327_IIC_PACK (SSD132X_REQUEST_IIC_PACK)\n\nCFBD_OLED_DeviceSpecific* getSSD1327Specific();\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/stm-impl-uart_8c/","title":"lib/uart/backend/stm-impl-uart.c","text":""},{"location":"api/Files/stm-impl-uart_8c/#functions","title":"Functions","text":"Name UART_HandleTypeDef * native_uart_handle(CFBD_UARTHandle * handle) void uart_sync_send(CFBD_UARTHandle * handle, const uint8_t * buffer, const uint16_t buffer_size) void uart_sync_receive(CFBD_UARTHandle * handle, uint8_t * available_buffer, const uint16_t available_buffer_size) void uart_async_send(CFBD_UARTHandle * handle, const uint8_t * buffer, const uint16_t buffer_size) void uart_async_receive(CFBD_UARTHandle * handle, uint8_t * available_buffer, const uint16_t available_buffer_size) void CFBD_Init_STUARTBackend(CFBD_UARTHandle * handle, uint32_t timeouts, CFBD_ST_UARTPrivate * st_packs, void(*)(CFBD_ST_UARTPrivate *init_callbacks) inits_callback) void async_send_helper(void * native_data) void async_receive_helper(void * native_data) uint32_t CFBD_UART_GetDMARxRemaining(CFBD_UARTHandle * handle) uint32_t CFBD_UART_GetDMARxReceivedCount(CFBD_UARTHandle * handle) void async_idle_line_helper(void * native_data) CFBD_ST_UART_AsyncHelper * CFBD_GainUARTAsyncHelpers()Gain the AsyncHelpers that can be used in callbacks at native frameworks."},{"location":"api/Files/stm-impl-uart_8c/#attributes","title":"Attributes","text":"Name CFBD_UARTOperations ops CFBD_ST_UART_AsyncHelper g_async_helper"},{"location":"api/Files/stm-impl-uart_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/stm-impl-uart_8c/#function-native_uart_handle","title":"function native_uart_handle","text":"<pre><code>static inline UART_HandleTypeDef * native_uart_handle(\n    CFBD_UARTHandle * handle\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-uart_sync_send","title":"function uart_sync_send","text":"<pre><code>static void uart_sync_send(\n    CFBD_UARTHandle * handle,\n    const uint8_t * buffer,\n    const uint16_t buffer_size\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-uart_sync_receive","title":"function uart_sync_receive","text":"<pre><code>static void uart_sync_receive(\n    CFBD_UARTHandle * handle,\n    uint8_t * available_buffer,\n    const uint16_t available_buffer_size\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-uart_async_send","title":"function uart_async_send","text":"<pre><code>static void uart_async_send(\n    CFBD_UARTHandle * handle,\n    const uint8_t * buffer,\n    const uint16_t buffer_size\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-uart_async_receive","title":"function uart_async_receive","text":"<pre><code>static void uart_async_receive(\n    CFBD_UARTHandle * handle,\n    uint8_t * available_buffer,\n    const uint16_t available_buffer_size\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-cfbd_init_stuartbackend","title":"function CFBD_Init_STUARTBackend","text":"<pre><code>void CFBD_Init_STUARTBackend(\n    CFBD_UARTHandle * handle,\n    uint32_t timeouts,\n    CFBD_ST_UARTPrivate * st_packs,\n    void(*)(CFBD_ST_UARTPrivate *init_callbacks) inits_callback\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-async_send_helper","title":"function async_send_helper","text":"<pre><code>static void async_send_helper(\n    void * native_data\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-async_receive_helper","title":"function async_receive_helper","text":"<pre><code>static void async_receive_helper(\n    void * native_data\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-cfbd_uart_getdmarxremaining","title":"function CFBD_UART_GetDMARxRemaining","text":"<pre><code>static uint32_t CFBD_UART_GetDMARxRemaining(\n    CFBD_UARTHandle * handle\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-cfbd_uart_getdmarxreceivedcount","title":"function CFBD_UART_GetDMARxReceivedCount","text":"<pre><code>static uint32_t CFBD_UART_GetDMARxReceivedCount(\n    CFBD_UARTHandle * handle\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-async_idle_line_helper","title":"function async_idle_line_helper","text":"<pre><code>static void async_idle_line_helper(\n    void * native_data\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#function-cfbd_gainuartasynchelpers","title":"function CFBD_GainUARTAsyncHelpers","text":"<pre><code>CFBD_ST_UART_AsyncHelper * CFBD_GainUARTAsyncHelpers()\n</code></pre> <p>Gain the AsyncHelpers that can be used in callbacks at native frameworks. </p> <p>Return: CFBD_ST_UART_AsyncHelper* </p>"},{"location":"api/Files/stm-impl-uart_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/stm-impl-uart_8c/#variable-ops","title":"variable ops","text":"<pre><code>static CFBD_UARTOperations ops = {\n        .sync_send = uart_sync_send,\n        .sync_receive = uart_sync_receive,\n        .async_send = uart_async_send,\n        .async_receive = uart_async_receive,\n};\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#variable-g_async_helper","title":"variable g_async_helper","text":"<pre><code>static CFBD_ST_UART_AsyncHelper g_async_helper = {.async_send_complete = async_send_helper,\n                                                  .async_receive_complete = async_receive_helper,\n                                                  .async_idle_line = async_idle_line_helper};\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8c/#source-code","title":"Source code","text":"<pre><code>#include \"stm-impl-uart.h\"\n\nstatic inline UART_HandleTypeDef* native_uart_handle(CFBD_UARTHandle* handle)\n{\n    return (UART_HandleTypeDef*) handle-&gt;backends;\n}\n\nstatic void\nuart_sync_send(CFBD_UARTHandle* handle, const uint8_t* buffer, const uint16_t buffer_size)\n{\n    HAL_UART_Transmit(native_uart_handle(handle), buffer, buffer_size, handle-&gt;accept_timeout);\n}\n\nstatic void uart_sync_receive(CFBD_UARTHandle* handle,\n                              uint8_t* available_buffer,\n                              const uint16_t available_buffer_size)\n{\n    HAL_UART_Receive(native_uart_handle(handle),\n                     available_buffer,\n                     available_buffer_size,\n                     handle-&gt;accept_timeout);\n}\n\nstatic void\nuart_async_send(CFBD_UARTHandle* handle, const uint8_t* buffer, const uint16_t buffer_size)\n{\n    UART_HandleTypeDef* huart = native_uart_handle(handle);\n\n    if (HAL_UART_Transmit_DMA(huart, (uint8_t*) buffer, buffer_size) != HAL_OK) {\n        HAL_UART_Transmit_IT(huart, (uint8_t*) buffer, buffer_size);\n    }\n}\n\nstatic void uart_async_receive(CFBD_UARTHandle* handle,\n                               uint8_t* available_buffer,\n                               const uint16_t available_buffer_size)\n{\n    UART_HandleTypeDef* huart = native_uart_handle(handle);\n    handle-&gt;rx_buffer_size = available_buffer_size;\n    handle-&gt;rx_buffer = available_buffer;\n\n    if (HAL_UART_Receive_DMA(huart, available_buffer, available_buffer_size) != HAL_OK) {\n        HAL_UART_Receive_IT(huart, available_buffer, available_buffer_size);\n    }\n}\nstatic CFBD_UARTOperations ops = {\n        .sync_send = uart_sync_send,\n        .sync_receive = uart_sync_receive,\n        .async_send = uart_async_send,\n        .async_receive = uart_async_receive,\n};\n\nvoid CFBD_Init_STUARTBackend(CFBD_UARTHandle* handle,\n                             uint32_t timeouts,\n                             CFBD_ST_UARTPrivate* st_packs,\n                             void (*inits_callback)(CFBD_ST_UARTPrivate* init_callbacks))\n{\n    handle-&gt;ops = &amp;ops;\n    handle-&gt;backends = st_packs;\n\n    handle-&gt;accept_timeout = timeouts;\n    handle-&gt;rx_buffer = NULL;\n    handle-&gt;rx_buffer_size = 0;\n\n    st_packs-&gt;parent_handles = handle;\n    /* Call backs for the inits */\n    inits_callback(st_packs);\n}\n\nstatic void async_send_helper(void* native_data)\n{\n    UART_HandleTypeDef* huart = (UART_HandleTypeDef*) native_data;\n\n    CFBD_ST_UARTPrivate* private_data =\n            (CFBD_ST_UARTPrivate*) ((uint8_t*) huart - offsetof(CFBD_ST_UARTPrivate, hal_uart));\n    CFBD_UARTHandle* handle = private_data-&gt;parent_handles;\n\n    if (handle &amp;&amp; handle-&gt;async_callbacks &amp;&amp; handle-&gt;async_callbacks-&gt;on_send_complete) {\n        handle-&gt;async_callbacks-&gt;on_send_complete(handle);\n    }\n}\n\nstatic void async_receive_helper(void* native_data)\n{\n    UART_HandleTypeDef* huart = (UART_HandleTypeDef*) native_data;\n    CFBD_ST_UARTPrivate* private_data =\n            (CFBD_ST_UARTPrivate*) ((uint8_t*) huart - offsetof(CFBD_ST_UARTPrivate, hal_uart));\n\n    CFBD_UARTHandle* handle = private_data-&gt;parent_handles;\n    if (handle &amp;&amp; handle-&gt;async_callbacks &amp;&amp; handle-&gt;async_callbacks-&gt;on_receive_complete) {\n        handle-&gt;async_callbacks-&gt;on_receive_complete(handle);\n    }\n}\n\nstatic uint32_t CFBD_UART_GetDMARxRemaining(CFBD_UARTHandle* handle)\n{\n    UART_HandleTypeDef* huart = native_uart_handle(handle);\n\n    if (huart-&gt;hdmarx != NULL) {\n        return __HAL_DMA_GET_COUNTER(huart-&gt;hdmarx);\n    }\n\n    return 0;\n}\n\nstatic uint32_t CFBD_UART_GetDMARxReceivedCount(CFBD_UARTHandle* handle)\n{\n    uint32_t remaining = CFBD_UART_GetDMARxRemaining(handle);\n    if (remaining == 0) {\n        return handle-&gt;rx_buffer_size;\n    }\n\n    return handle-&gt;rx_buffer_size - remaining;\n}\n\nstatic void async_idle_line_helper(void* native_data)\n{\n    UART_HandleTypeDef* huart = (UART_HandleTypeDef*) native_data;\n\n    CFBD_ST_UARTPrivate* private_data =\n            (CFBD_ST_UARTPrivate*) ((uint8_t*) huart - offsetof(CFBD_ST_UARTPrivate, hal_uart));\n\n    CFBD_UARTHandle* handle = private_data-&gt;parent_handles;\n\n    if (handle &amp;&amp; handle-&gt;async_callbacks &amp;&amp; handle-&gt;async_callbacks-&gt;on_idle_line) {\n        uint32_t remaining = CFBD_UART_GetDMARxRemaining(handle);\n        uint32_t received_len = handle-&gt;rx_buffer_size - remaining;\n\n        HAL_UART_DMAStop(huart);\n\n        handle-&gt;async_callbacks-&gt;on_idle_line(handle, received_len);\n    }\n}\n\nstatic CFBD_ST_UART_AsyncHelper g_async_helper = {.async_send_complete = async_send_helper,\n                                                  .async_receive_complete = async_receive_helper,\n                                                  .async_idle_line = async_idle_line_helper};\n\nCFBD_ST_UART_AsyncHelper* CFBD_GainUARTAsyncHelpers()\n{\n    return &amp;g_async_helper;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/stm-impl-uart_8h/","title":"lib/uart/backend/stm-impl-uart.h","text":""},{"location":"api/Files/stm-impl-uart_8h/#classes","title":"Classes","text":"Name struct CFBD_ST_UARTPrivate"},{"location":"api/Files/stm-impl-uart_8h/#functions","title":"Functions","text":"Name void CFBD_Init_STUARTBackend(CFBD_UARTHandle * handle, uint32_t timeouts, CFBD_ST_UARTPrivate * st_packs, void(*)(CFBD_ST_UARTPrivate *init_callbacks) inits_callback)"},{"location":"api/Files/stm-impl-uart_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/stm-impl-uart_8h/#function-cfbd_init_stuartbackend","title":"function CFBD_Init_STUARTBackend","text":"<pre><code>void CFBD_Init_STUARTBackend(\n    CFBD_UARTHandle * handle,\n    uint32_t timeouts,\n    CFBD_ST_UARTPrivate * st_packs,\n    void(*)(CFBD_ST_UARTPrivate *init_callbacks) inits_callback\n)\n</code></pre>"},{"location":"api/Files/stm-impl-uart_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"../uart.h\"\n#include \"cfbd_define.h\"\n\ntypedef struct\n{\n    UART_HandleTypeDef hal_uart;\n    CFBD_UARTHandle* parent_handles;\n} CFBD_ST_UARTPrivate;\n\nvoid CFBD_Init_STUARTBackend(CFBD_UARTHandle* handle,\n                             uint32_t timeouts,\n                             CFBD_ST_UARTPrivate* st_packs,\n                             void (*inits_callback)(CFBD_ST_UARTPrivate* init_callbacks));\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/system__clock_8c/","title":"lib/application/sys_clock/system_clock.c","text":"<p>More...</p>"},{"location":"api/Files/system__clock_8c/#detailed-description","title":"Detailed Description","text":"<p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30</p> <p>Copyright: Copyright \u00a9 2025 </p>"},{"location":"api/Files/system__clock_8c/#source-code","title":"Source code","text":"<pre><code>#include \"system_clock.h\"\n\n#include \"app.h\"\n#include \"cfbd_define.h\"\n#include \"config/system_settings.h\"\n\nvoid system_delay_us(uint32_t us)\n{\n    CFBDApplication* app = getApp(CFBD_FALSE);\n\n    uint64_t ticks; // Total number of ticks required for the delay\n    uint32_t prevValue, currentValue,\n            elapsedTicks = 0;             // Variables for SysTick counter values and elapsed ticks\n    uint32_t reloadValue = SysTick-&gt;LOAD; // Value of the SysTick reload register\n    uint32_t sysclk_freq = app-&gt;freq_provider() / 1000000L;\n    ticks = us * sysclk_freq; // Calculate the number of ticks needed for the desired delay in\n                              // microseconds\n\n    prevValue = SysTick-&gt;VAL; // Store the initial SysTick counter value\n\n    while (1) {\n        currentValue = SysTick-&gt;VAL; // Get the current SysTick counter value\n        if (currentValue != prevValue) {\n            if (currentValue &lt; prevValue) {\n                elapsedTicks +=\n                        prevValue -\n                        currentValue; // Count the elapsed ticks (SysTick is a decrementing counter)\n            }\n            else {\n                elapsedTicks += reloadValue - currentValue + prevValue; // Handle the rollover case\n            }\n            prevValue = currentValue; // Update the previous value to the current value\n\n            if (elapsedTicks &gt;=\n                ticks) // If the elapsed time is greater than or equal to the requested delay\n            {\n                break; // Exit the loop to complete the delay\n            }\n        }\n    }\n}\n\nvoid system_delay_ms(uint32_t delay_ms)\n{\n    for (uint32_t i = 0; i &lt; delay_ms; i++) {\n        system_delay_us(1000);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/system__clock_8h/","title":"lib/application/sys_clock/system_clock.h","text":"<p>System timing primitives and delay helpers.  More...</p>"},{"location":"api/Files/system__clock_8h/#detailed-description","title":"Detailed Description","text":"<p>System timing primitives and delay helpers. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2025-03-30 </p> <p>Note: Units are explicitly milliseconds (<code>ms</code>) and microseconds (<code>us</code>).</p> <p>Copyright: Copyright \u00a9 2025 </p> <p>This header exposes minimal timing helpers used throughout the application code for short, platform-dependent delays. The concrete behavior (blocking, sleep, busy-wait, tick resolution) depends on the platform-specific implementation behind these APIs.</p> <p>Implementations should document any real-time or concurrency restrictions (for example, whether the functions may be called from interrupt context). Consumers of these APIs should avoid long blocking delays in time-critical or interrupt contexts.</p>"},{"location":"api/Files/system__clock_8h/#source-code","title":"Source code","text":"<pre><code>#ifndef SYSCLK_H\n#define SYSCLK_H\n\n#include &lt;stdint.h&gt;\n\nvoid system_delay_ms(uint32_t delay_ms);\n\nvoid system_delay_us(uint32_t us);\n\n#endif /* SYSCLK_H */\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/test__base__graphic_8c/","title":"lib/graphic/fast_test/test_base_graphic.c","text":""},{"location":"api/Files/test__base__graphic_8c/#functions","title":"Functions","text":"Name void test_draw_line(CFBD_GraphicDevice * handler) void test_draw_rectangle(CFBD_GraphicDevice * handler) void test_draw_circle(CFBD_GraphicDevice * handler) void test_draw_ellipse(CFBD_GraphicDevice * handler) void test_draw_triangle(CFBD_GraphicDevice * handler) void test_draw_arc(CFBD_GraphicDevice * handler) void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_line","title":"function test_draw_line","text":"<pre><code>static void test_draw_line(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_rectangle","title":"function test_draw_rectangle","text":"<pre><code>static void test_draw_rectangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_circle","title":"function test_draw_circle","text":"<pre><code>static void test_draw_circle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_ellipse","title":"function test_draw_ellipse","text":"<pre><code>static void test_draw_ellipse(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_triangle","title":"function test_draw_triangle","text":"<pre><code>static void test_draw_triangle(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_arc","title":"function test_draw_arc","text":"<pre><code>static void test_draw_arc(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8c/#source-code","title":"Source code","text":"<pre><code>#include \"base/arc.h\"\n#include \"base/circle.h\"\n#include \"base/ellipse.h\"\n#include \"base/line.h\"\n#include \"base/rectangle.h\"\n#include \"base/triangle.h\"\n\n// \u6d4b\u8bd5\u76f4\u7ebf\u7ed8\u5236\nstatic void test_draw_line(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u6c34\u5e73\u7ebf\n    CFBDGraphic_Line line1 = {.p_left = {10, 10}, .p_right = {50, 10}};\n    CFBDGraphic_DrawLine(handler, &amp;line1);\n\n    // \u6d4b\u8bd52: \u5782\u76f4\u7ebf\n    CFBDGraphic_Line line2 = {.p_left = {60, 5}, .p_right = {60, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line2);\n\n    // \u6d4b\u8bd53: \u659c\u7ebf\n    CFBDGraphic_Line line3 = {.p_left = {70, 5}, .p_right = {90, 25}};\n    CFBDGraphic_DrawLine(handler, &amp;line3);\n}\n\n// \u6d4b\u8bd5\u77e9\u5f62\u7ed8\u5236\nstatic void test_draw_rectangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect1 = {.tl = {5, 30}, .br = {35, 50}};\n    CFBDGraphic_DrawRect(handler, &amp;rect1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u77e9\u5f62\n    CFBDGraphicRect rect2 = {.tl = {40, 32}, .br = {60, 48}};\n    CFBDGraphic_FillRect(handler, &amp;rect2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f62\u7ed8\u5236\nstatic void test_draw_circle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\n    CFBDGraphicCircle circle1 = {.center = {80, 15}, .radius = 10};\n    CFBDGraphic_DrawCircle(handler, &amp;circle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u5706\n    CFBDGraphicCircle circle2 = {.center = {105, 15}, .radius = 8};\n    CFBDGraphic_DrawFilledCircle(handler, &amp;circle2);\n}\n\n// \u6d4b\u8bd5\u692d\u5706\u7ed8\u5236\nstatic void test_draw_ellipse(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u692d\u5706\n    CFBD_GraphicEllipse ellipse1 = {.center = {85, 40}, .X_Radius = 15, .Y_Radius = 10};\n    CFBDGraphic_DrawEllipse(handler, &amp;ellipse1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u692d\u5706\n    CFBD_GraphicEllipse ellipse2 = {.center = {110, 55}, .X_Radius = 10, .Y_Radius = 6};\n    CFBDGraphic_DrawFilledEllipse(handler, &amp;ellipse2);\n}\n\n// \u6d4b\u8bd5\u4e09\u89d2\u5f62\u7ed8\u5236\nstatic void test_draw_triangle(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle1 = {.p1 = {15, 55}, .p2 = {5, 62}, .p3 = {25, 62}};\n    CCGraphic_DrawTriangle(handler, &amp;triangle1);\n\n    // \u6d4b\u8bd52: \u5b9e\u5fc3\u4e09\u89d2\u5f62\n    CFBDGraphic_Triangle triangle2 = {.p1 = {45, 55}, .p2 = {35, 62}, .p3 = {55, 62}};\n    CCGraphic_DrawFilledTriangle(handler, &amp;triangle2);\n}\n\n// \u6d4b\u8bd5\u5706\u5f27\u7ed8\u5236\nstatic void test_draw_arc(CFBD_GraphicDevice* handler)\n{\n    // \u6d4b\u8bd51: \u7a7a\u5fc3\u5706\u5f27 (0-90\u5ea6)\n    CFBD_GraphicArc arc1 = {.center = {20, 15}, .radius = 12, .start_degree = 0, .end_degree = 90};\n    CFBDGraphic_DrawArc(handler, &amp;arc1);\n\n    // \u6d4b\u8bd52: \u7a7a\u5fc3\u5706\u5f27 (180-270\u5ea6)\n    CFBD_GraphicArc arc2 = {.center = {45, 15},\n                            .radius = 12,\n                            .start_degree = 180,\n                            .end_degree = 270};\n    CFBDGraphic_DrawArc(handler, &amp;arc2);\n\n    // \u6d4b\u8bd53: \u5b9e\u5fc3\u5706\u5f27 (45-135\u5ea6)\n    CFBD_GraphicArc arc3 = {.center = {70, 55}, .radius = 8, .start_degree = 45, .end_degree = 135};\n    CFBDGraphic_DrawFilledArc(handler, &amp;arc3);\n}\n\n// \u4e3b\u6d4b\u8bd5\u51fd\u6570 - \u6309\u987a\u5e8f\u6d4b\u8bd5\u6240\u6709\u56fe\u5f62\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler)\n{\n    // 1. \u6d4b\u8bd5\u76f4\u7ebf\n    test_draw_line(handler);\n\n    // 2. \u6d4b\u8bd5\u77e9\u5f62\n    test_draw_rectangle(handler);\n\n    // 3. \u6d4b\u8bd5\u5706\u5f62\n    test_draw_circle(handler);\n\n    // 4. \u6d4b\u8bd5\u692d\u5706\n    test_draw_ellipse(handler);\n\n    // 5. \u6d4b\u8bd5\u4e09\u89d2\u5f62\n    test_draw_triangle(handler);\n\n    // 6. \u6d4b\u8bd5\u5706\u5f27\n    test_draw_arc(handler);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/test__base__graphic_8h/","title":"lib/graphic/fast_test/test_base_graphic.h","text":""},{"location":"api/Files/test__base__graphic_8h/#functions","title":"Functions","text":"Name void test_draw_base_graphic(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__base__graphic_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__base__graphic_8h/#function-test_draw_base_graphic","title":"function test_draw_base_graphic","text":"<pre><code>void test_draw_base_graphic(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__base__graphic_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_graphic_define.h\"\n\nvoid test_draw_base_graphic(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/test__widget_8c/","title":"lib/graphic/fast_test/test_widget.c","text":""},{"location":"api/Files/test__widget_8c/#functions","title":"Functions","text":"Name void icontext_menu_demo(CFBD_GraphicDevice * dev)Icon-text menu demonstration (OOP C style) void demo_progressbar(CFBD_GraphicDevice * dev) void test_text(CFBD_GraphicDevice * dev) void demo_end_screen(CFBD_GraphicDevice * dev) void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8c/#attributes","title":"Attributes","text":"Name const CFBD_DemoDescriptor[] g_demos"},{"location":"api/Files/test__widget_8c/#defines","title":"Defines","text":"Name g_demo_count"},{"location":"api/Files/test__widget_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8c/#function-icontext_menu_demo","title":"function icontext_menu_demo","text":"<pre><code>void icontext_menu_demo(\n    CFBD_GraphicDevice * dev\n)\n</code></pre> <p>Icon-text menu demonstration (OOP C style) </p> <p>Demonstrates:</p> <ol> <li>Menu initialization</li> <li>Adding menu items via operations table</li> <li>Auto-demo of scrolling and selection with animated frame </li> </ol>"},{"location":"api/Files/test__widget_8c/#function-demo_progressbar","title":"function demo_progressbar","text":"<pre><code>void demo_progressbar(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-test_text","title":"function test_text","text":"<pre><code>void test_text(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-demo_end_screen","title":"function demo_end_screen","text":"<pre><code>void demo_end_screen(\n    CFBD_GraphicDevice * dev\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/test__widget_8c/#variable-g_demos","title":"variable g_demos","text":"<pre><code>const CFBD_DemoDescriptor[] g_demos = {{\"IconText Menu\", icontext_menu_demo, 3000},\n                                       {\"Progress Bar\", demo_progressbar, 2500},\n                                       {\"Text Alignment\", test_text, 2000},\n                                       {\"Demo End\", demo_end_screen, 3000}};\n</code></pre>"},{"location":"api/Files/test__widget_8c/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/test__widget_8c/#define-g_demo_count","title":"define g_demo_count","text":"<pre><code>#define g_demo_count sizeof(g_demos) / sizeof(g_demos[0])\n</code></pre>"},{"location":"api/Files/test__widget_8c/#source-code","title":"Source code","text":"<pre><code>#include \"test_widget.h\"\n\n#include \"cfbd_graphic_define.h\"\n#include \"demo_support/demo_manager.h\"\n\n/* Demo entry declarations */\nvoid icontext_menu_demo(CFBD_GraphicDevice* dev);\nvoid demo_progressbar(CFBD_GraphicDevice* dev);\nvoid test_text(CFBD_GraphicDevice* dev);\nvoid demo_end_screen(CFBD_GraphicDevice* dev);\n\nconst CFBD_DemoDescriptor g_demos[] = {{\"IconText Menu\", icontext_menu_demo, 3000},\n                                       {\"Progress Bar\", demo_progressbar, 2500},\n                                       {\"Text Alignment\", test_text, 2000},\n                                       {\"Demo End\", demo_end_screen, 3000}};\n\n#define g_demo_count sizeof(g_demos) / sizeof(g_demos[0])\n\nvoid test_widget(CFBD_GraphicDevice* handler)\n{\n    CFBD_DemoManager_Run(handler, g_demos, g_demo_count, CFBD_DEMO_RUN_LOOP, 0);\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/test__widget_8h/","title":"lib/graphic/fast_test/test_widget.h","text":""},{"location":"api/Files/test__widget_8h/#functions","title":"Functions","text":"Name void test_widget(CFBD_GraphicDevice * handler)"},{"location":"api/Files/test__widget_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/test__widget_8h/#function-test_widget","title":"function test_widget","text":"<pre><code>void test_widget(\n    CFBD_GraphicDevice * handler\n)\n</code></pre>"},{"location":"api/Files/test__widget_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cfbd_graphic_define.h\"\n\nvoid test_widget(CFBD_GraphicDevice* handler);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/text_8c/","title":"lib/graphic/widget/text.c","text":""},{"location":"api/Files/text_8c/#functions","title":"Functions","text":"Name void __pvt_draw_char_each(CFBD_GraphicDevice * device_handle, CCGraphic_Image * borrowing_image, const char ch, Ascii_Font_Size size) uint8_t __pvt_should_be_next_line(CFBD_GraphicDevice * device_handle, CFBDGraphic_Point * brpoint, CFBDGraphic_Point * cur_draw_p, Ascii_Font_Size s) CFBDGraphic_Point __pvt_fetch_valid_final_point(CFBD_GraphicDevice * device_handle, CFBDGraphicSize * size, CFBDGraphic_Point * tl)"},{"location":"api/Files/text_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/text_8c/#function-__pvt_draw_char_each","title":"function __pvt_draw_char_each","text":"<pre><code>static void __pvt_draw_char_each(\n    CFBD_GraphicDevice * device_handle,\n    CCGraphic_Image * borrowing_image,\n    const char ch,\n    Ascii_Font_Size size\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_should_be_next_line","title":"function __pvt_should_be_next_line","text":"<pre><code>static inline uint8_t __pvt_should_be_next_line(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Point * brpoint,\n    CFBDGraphic_Point * cur_draw_p,\n    Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Files/text_8c/#function-__pvt_fetch_valid_final_point","title":"function __pvt_fetch_valid_final_point","text":"<pre><code>static inline CFBDGraphic_Point __pvt_fetch_valid_final_point(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphicSize * size,\n    CFBDGraphic_Point * tl\n)\n</code></pre>"},{"location":"api/Files/text_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text.h\"\n\n#include &lt;limits.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"base/base_helpers.h\"\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"base_support/image.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"widget/text.h\"\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size)\n{\n    item-&gt;font_size = text_size;\n    item-&gt;sources_borrowed = \"\";\n    item-&gt;tl_point = tl_point;\n    item-&gt;indexed_point = tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n    item-&gt;no_wrap = CFBD_FALSE;\n}\n\nstatic void __pvt_draw_char_each(CFBD_GraphicDevice* device_handle,\n                                 CCGraphic_Image* borrowing_image,\n                                 const char ch,\n                                 Ascii_Font_Size size)\n{\n    borrowing_image-&gt;image_size = __fetch_font_size(size);\n    uint8_t* ascii = __select_from_ascii_font_size(size, ch);\n    borrowing_image-&gt;sources_register = ascii;\n    CFBDGraphic_DrawImage(device_handle, borrowing_image);\n}\n\nstatic uint8_t inline __pvt_should_be_next_line(CFBD_GraphicDevice* device_handle,\n                                                CFBDGraphic_Point* brpoint,\n                                                CFBDGraphic_Point* cur_draw_p,\n                                                Ascii_Font_Size s)\n{\n    return cur_draw_p-&gt;x + (int16_t) (1.5 * __fetch_font_size(s).width) &gt;= brpoint-&gt;x;\n}\n\nstatic CFBDGraphic_Point inline __pvt_fetch_valid_final_point(CFBD_GraphicDevice* device_handle,\n                                                              CFBDGraphicSize* size,\n                                                              CFBDGraphic_Point* tl)\n{\n    CFBDGraphic_Point br;\n    CFBDGraphicSize device_size;\n    CFBDGraphic_GetScreenSize(device_handle, &amp;device_size);\n\n    br.x = tl-&gt;x + size-&gt;width;\n    br.y = tl-&gt;y + size-&gt;height;\n    if (device_size.width &lt; br.x) {\n        br.x = device_size.width;\n    }\n    if (device_size.height &lt; br.y) {\n        br.y = device_size.height;\n    }\n    return br;\n}\n\nCFBDGraphic_Point\nCFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle, CFBDGraphic_Text* item, AppendMethod method)\n{\n    if (!device_handle || !item || !device_handle-&gt;ops)\n        return item-&gt;tl_point;\n\n    if (strcmp(item-&gt;sources_borrowed, \"\") == 0)\n        return item-&gt;tl_point;\n    CFBDGraphic_Point old = item-&gt;tl_point;\n    CCGraphic_Image handle_draw_image;\n    CFBDGraphic_Point draw_tl_point = item-&gt;indexed_point;\n\n    const Ascii_Font_Size font_size = item-&gt;font_size;\n    const CFBDGraphicSize size = __fetch_font_size(font_size);\n    const SizeBaseType font_width = size.width;\n    const SizeBaseType font_height = size.height;\n\n    CFBDGraphic_Point br = __pvt_fetch_valid_final_point(device_handle,\n                                                         &amp;(item-&gt;TexthandleSize),\n                                                         &amp;(item-&gt;tl_point));\n\n    uint8_t offseterx = 0;\n    uint8_t offsetery = 0;\n\n    int32_t lx = INT32_MAX;\n    int32_t ty = INT32_MAX;\n    int32_t rx = INT32_MIN;\n    int32_t by = INT32_MIN;\n\n    for (uint8_t i = 0; item-&gt;sources_borrowed[i] != '\\0'; i++) {\n        draw_tl_point.x = item-&gt;indexed_point.x + offseterx * font_width;\n        draw_tl_point.y = item-&gt;indexed_point.y + offsetery * font_height;\n\n        handle_draw_image.point = draw_tl_point;\n\n        __pvt_draw_char_each(device_handle,\n                             &amp;handle_draw_image,\n                             item-&gt;sources_borrowed[i],\n                             item-&gt;font_size);\n\n        int32_t cx1 = asInt32_t(draw_tl_point.x);\n        int32_t cy1 = asInt32_t(draw_tl_point.y);\n        int32_t cx2 = cx1 + font_width;\n        int32_t cy2 = cy1 + font_height;\n\n        if (cx1 &lt; lx)\n            lx = cx1;\n        if (cy1 &lt; ty)\n            ty = cy1;\n        if (cx2 &gt; rx)\n            rx = cx2;\n        if (cy2 &gt; by)\n            by = cy2;\n\n        if (!item-&gt;no_wrap &amp;&amp;\n            __pvt_should_be_next_line(device_handle, &amp;br, &amp;draw_tl_point, font_size)) {\n            offseterx = 0;\n            offsetery++;\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n        }\n        else {\n            offseterx++;\n        }\n    }\n\n    /* \u7f13\u5b58 TextBoundingRect */\n    if (lx &lt;= rx &amp;&amp; ty &lt;= by) {\n        item-&gt;text_bounding_rect.tl.x = clamp_u16_from_i32(lx - CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.tl.y = clamp_u16_from_i32(ty - CFBDGraphic_TEXT_PADDING_HEIGHT);\n        item-&gt;text_bounding_rect.br.x = clamp_u16_from_i32(rx + CFBDGraphic_TEXT_PADDING_WIDTH);\n        item-&gt;text_bounding_rect.br.y = clamp_u16_from_i32(by + CFBDGraphic_TEXT_PADDING_HEIGHT);\n    }\n    else {\n        item-&gt;text_bounding_rect.tl = item-&gt;indexed_point;\n        item-&gt;text_bounding_rect.br = item-&gt;indexed_point;\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(device_handle)) {\n        device_handle-&gt;ops-&gt;update_area(device_handle,\n                                        clamp_u16_from_i32(lx),\n                                        clamp_u16_from_i32(ty),\n                                        clamp_u16_from_i32(rx - lx + 1),\n                                        clamp_u16_from_i32(by - ty + 1));\n    }\n\n    switch (method) {\n        case CCGraphic_AsciiTextItem_AppendNextLine:\n            item-&gt;indexed_point.x = item-&gt;tl_point.x;\n            item-&gt;indexed_point.y += font_height;\n            break;\n        case CCGraphic_AsciiTextItem_AppendContinously:\n            item-&gt;indexed_point.x += font_width;\n            break;\n        case CCGraphic_AsciiTextItem_RequestOldPoint:\n            item-&gt;indexed_point = old;\n            break;\n        default:\n            break;\n    }\n\n    return item-&gt;indexed_point;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/text_8h/","title":"lib/graphic/widget/text.h","text":"<p>Text widget for rendering ASCII text strings.  More...</p>"},{"location":"api/Files/text_8h/#classes","title":"Classes","text":"Name struct CFBDGraphic_Text"},{"location":"api/Files/text_8h/#detailed-description","title":"Detailed Description","text":"<p>Text widget for rendering ASCII text strings. </p> <p>Provides comprehensive text rendering with support for multiple font sizes, multiline text, and configurable layout. Text renders monospace characters with optional padding for visual separation. </p>"},{"location":"api/Files/text_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"base/point.h\"\n#include \"base/rectangle.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"text_config.h\"\n\n#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n\n#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n\ntypedef struct\n{\n    char* sources_borrowed;\n\n    CFBDGraphic_Point tl_point;\n\n    CFBDGraphic_Point indexed_point;\n\n    CFBDGraphicSize TexthandleSize;\n\n    Ascii_Font_Size font_size;\n\n    CFBDGraphicRect text_bounding_rect;\n\n    CFBD_Bool no_wrap;\n} CFBDGraphic_Text;\n\ntypedef enum\n{\n    CCGraphic_AsciiTextItem_AppendContinously,\n\n    CCGraphic_AsciiTextItem_AppendNextLine,\n\n    CCGraphic_AsciiTextItem_RequestOldPoint\n} AppendMethod;\n\nvoid CFBDGraphic_InitText(CFBDGraphic_Text* item,\n                          CFBDGraphic_Point tl_point,\n                          CFBDGraphicSize textHandleSize,\n                          Ascii_Font_Size text_size);\n\nstatic inline void CFBDGraphic_SetText(CFBDGraphic_Text* item, char* text)\n{\n    item-&gt;sources_borrowed = text;\n}\n\nstatic inline void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;tl_point = *p;\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text* item, CFBDGraphic_Point* p)\n{\n    item-&gt;indexed_point = *p;\n}\n\nstatic inline void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text* item,\n                                                          CFBDGraphic_Point* tl_point,\n                                                          CFBDGraphicSize textHandleSize)\n{\n    item-&gt;tl_point = *tl_point;\n    item-&gt;TexthandleSize = textHandleSize;\n}\n\nCFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice* device_handle,\n                                       CFBDGraphic_Text* item,\n                                       AppendMethod method);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/text__config_8c/","title":"lib/graphic/widget/text_config.c","text":""},{"location":"api/Files/text__config_8c/#attributes","title":"Attributes","text":"Name const uint8_t[][16] ascii8x16_sources const uint8_t[][6] ascii6x8_sources"},{"location":"api/Files/text__config_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/text__config_8c/#variable-ascii8x16_sources","title":"variable ascii8x16_sources","text":"<pre><code>const uint8_t[][16] ascii8x16_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#variable-ascii6x8_sources","title":"variable ascii6x8_sources","text":"<pre><code>const uint8_t[][6] ascii6x8_sources;\n</code></pre>"},{"location":"api/Files/text__config_8c/#source-code","title":"Source code","text":"<pre><code>#include \"text_config.h\"\n\n\nextern const uint8_t ascii8x16_sources[][16];\nextern const uint8_t ascii6x8_sources[][6];\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch)\n{\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            return (uint8_t*) (ascii6x8_sources[ch - ' ']);\n#endif\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            return (uint8_t*) (ascii8x16_sources[ch - ' ']);\n#endif\n        /*\n            To programmers, if new ascii like sources is\n            registered, please implement follows\n        */\n        default:\n            return UNSUPPORTIVE_FONT_SOURCE;\n    }\n}\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)\n{\n    CFBDGraphicSize size = {0, 0};\n    switch (s) {\n#if ENABLE_ASCII_6x8_SOURCES\n        case ASCII_6x8:\n            size.height = 8;\n            size.width = 6;\n            break;\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n        case ASCII_8x16:\n            size.height = 16;\n            size.width = 8;\n            break;\n#endif\n        default:\n            break;\n    }\n    return size;\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/text__config_8h/","title":"lib/graphic/widget/text_config.h","text":"<p>Text widget font configuration and selection.  More...</p>"},{"location":"api/Files/text__config_8h/#detailed-description","title":"Detailed Description","text":"<p>Text widget font configuration and selection. </p> <p>Provides font size enumeration, selection functions, and configuration for text rendering. Supports multiple font sizes (6x8, 8x16) with compile-time selection via resource configuration. </p>"},{"location":"api/Files/text__config_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"base/size.h\"\n#include \"resource/config.h\"\n\ntypedef enum\n{\n#if ENABLE_ASCII_6x8_SOURCES\n    ASCII_6x8,\n#endif\n\n#if ENABLE_ASCII_8x16_SOURCES\n    ASCII_8x16,\n#endif\n\n    NO_ASCII_SIZE\n} Ascii_Font_Size;\n\ntypedef enum\n{\n    Unicode_16x16\n} Unicode_Font_Size;\n\n#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n\nuint8_t* __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch);\n\nCFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/triangle_8c/","title":"triangle.c","text":""},{"location":"api/Files/triangle_8c/#functions","title":"Functions","text":"Name int16_t find_int16min(int16_t * vals, int16_t size) int16_t find_int16max(int16_t * vals, int16_t size) void clearBound(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void update_requests(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) uint8_t __pvt_is_in_triangle(int16_t * triangles_x, int16_t * triangles_y, PointBaseType x, PointBaseType y)"},{"location":"api/Files/triangle_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/triangle_8c/#function-find_int16min","title":"function find_int16min","text":"<pre><code>static inline int16_t find_int16min(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-find_int16max","title":"function find_int16max","text":"<pre><code>static inline int16_t find_int16max(\n    int16_t * vals,\n    int16_t size\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-clearbound","title":"function clearBound","text":"<pre><code>static void clearBound(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-update_requests","title":"function update_requests","text":"<pre><code>static void update_requests(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#function-__pvt_is_in_triangle","title":"function __pvt_is_in_triangle","text":"<pre><code>static uint8_t __pvt_is_in_triangle(\n    int16_t * triangles_x,\n    int16_t * triangles_y,\n    PointBaseType x,\n    PointBaseType y\n)\n</code></pre>"},{"location":"api/Files/triangle_8c/#source-code","title":"Source code","text":"<pre><code>#include \"triangle.h\"\n\n#include \"base_helpers.h\"\n#include \"cfbd_graphic_define.h\"\n#include \"device/graphic_device.h\"\n#include \"line.h\"\n#include \"point.h\"\n\nstatic inline int16_t find_int16min(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &lt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic inline int16_t find_int16max(int16_t* vals, int16_t size)\n{\n    int16_t result = vals[0];\n    for (int16_t i = 0; i &lt; size; i++) {\n        if (vals[i] &gt; result)\n            result = vals[i];\n    }\n    return result;\n}\n\nstatic void clearBound(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;clear_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nstatic void update_requests(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    int32_t lx = asInt32_t(triangle-&gt;p1.x);\n    int32_t ty = asInt32_t(triangle-&gt;p1.y);\n    int32_t rx = lx;\n    int32_t by = ty;\n\n    /* p2 */\n    if (asInt32_t(triangle-&gt;p2.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p2.y);\n    if (asInt32_t(triangle-&gt;p2.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p2.x);\n    if (asInt32_t(triangle-&gt;p2.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p2.y);\n\n    /* p3 */\n    if (asInt32_t(triangle-&gt;p3.x) &lt; lx)\n        lx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &lt; ty)\n        ty = asInt32_t(triangle-&gt;p3.y);\n    if (asInt32_t(triangle-&gt;p3.x) &gt; rx)\n        rx = asInt32_t(triangle-&gt;p3.x);\n    if (asInt32_t(triangle-&gt;p3.y) &gt; by)\n        by = asInt32_t(triangle-&gt;p3.y);\n\n    /* \u9632\u5fa1\u5f0f\u5904\u7406 */\n    if (rx &lt; lx)\n        rx = lx;\n    if (by &lt; ty)\n        by = ty;\n\n    uint16_t w = (uint16_t) (rx - lx + 1);\n    uint16_t h = (uint16_t) (by - ty + 1);\n    handle-&gt;ops-&gt;update_area(handle, clamp_u16_from_i32(lx), clamp_u16_from_i32(ty), w, h);\n}\n\nvoid CCGraphic_DrawTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBDGraphic_Line line;\n    line.p_left = triangle-&gt;p1;\n    line.p_right = triangle-&gt;p2;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p2;\n    line.p_right = triangle-&gt;p3;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n    line.p_left = triangle-&gt;p1;\n    CFBDGraphic_DrawLine(handle, &amp;line);\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n\nstatic uint8_t\n__pvt_is_in_triangle(int16_t* triangles_x, int16_t* triangles_y, PointBaseType x, PointBaseType y)\n{\n    uint8_t is_in = 0;\n    /* https://wrfranklin.org/Research/Short_Notes/pnpoly.html */\n    for (uint8_t i = 0, j = 2; i &lt; 3; j = i++) {\n        if (((triangles_y[i] &gt; y) != (triangles_y[j] &gt; y)) &amp;&amp;\n            (x &lt; (triangles_x[j] - triangles_x[i]) * (y - triangles_y[i]) /\n                                 (triangles_y[j] - triangles_y[i]) +\n                         triangles_x[i])) {\n            is_in = !is_in;\n        }\n    }\n    return is_in;\n}\n\nvoid CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice* handle, CFBDGraphic_Triangle* triangle)\n{\n    clearBound(handle, triangle);\n    CFBD_Bool (*setPixel)(CFBD_GraphicDevice* device, uint16_t x, uint16_t y) =\n            handle-&gt;ops-&gt;setPixel;\n\n    int16_t triangles_x[] = {triangle-&gt;p1.x, triangle-&gt;p2.x, triangle-&gt;p3.x};\n\n    int16_t triangles_y[] = {triangle-&gt;p1.y, triangle-&gt;p2.y, triangle-&gt;p3.y};\n\n    int16_t minX = find_int16min(triangles_x, 3);\n    int16_t minY = find_int16min(triangles_y, 3);\n\n    int16_t maxX = find_int16max(triangles_x, 3);\n    int16_t maxY = find_int16max(triangles_y, 3);\n\n    for (int16_t i = minX; i &lt; maxX; i++) {\n        for (int16_t j = minY; j &lt; maxY; j++) {\n            if (__pvt_is_in_triangle(triangles_x, triangles_y, i, j)) {\n                setPixel(handle, i, j);\n            }\n        }\n    }\n\n    if (CFBDGraphic_DeviceRequestUpdateAtOnce(handle)) {\n        update_requests(handle, triangle);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/uart_8h/","title":"lib/uart/uart.h","text":""},{"location":"api/Files/uart_8h/#classes","title":"Classes","text":"Name struct _CFBD_UARTOperations struct CFBD_UART_AsyncCallbacks As C owns no virtual, we need to filled the function processor by users. struct _CFBD_UARTHandle struct CFBD_ST_UART_AsyncHelper"},{"location":"api/Files/uart_8h/#types","title":"Types","text":"Name enum CFBD_UARTAsyncOp typedef struct _CFBD_UARTHandle CFBD_UARTHandle typedef void(*)(CFBD_UARTHandle *handle, uint8_t *buffer, const uint16_t buffer_size, CFBD_UARTAsyncOp what_async_done) CFBD_UARTAsyncCallback typedef struct _CFBD_UARTOperations CFBD_UARTOperations"},{"location":"api/Files/uart_8h/#functions","title":"Functions","text":"Name CFBD_ST_UART_AsyncHelper * CFBD_GainUARTAsyncHelpers()Gain the AsyncHelpers that can be used in callbacks at native frameworks. void CFBD_UARTBindRXProcessBuffer(CFBD_UARTHandle * handle, uint8_t * rx_buffer, const uint16_t rx_buffer_size)"},{"location":"api/Files/uart_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/uart_8h/#enum-cfbd_uartasyncop","title":"enum CFBD_UARTAsyncOp","text":"Enumerator Value Description SEND RECEIVE"},{"location":"api/Files/uart_8h/#typedef-cfbd_uarthandle","title":"typedef CFBD_UARTHandle","text":"<pre><code>typedef struct _CFBD_UARTHandle CFBD_UARTHandle;\n</code></pre>"},{"location":"api/Files/uart_8h/#typedef-cfbd_uartasynccallback","title":"typedef CFBD_UARTAsyncCallback","text":"<pre><code>typedef void(* CFBD_UARTAsyncCallback) (CFBD_UARTHandle *handle, uint8_t *buffer, const uint16_t buffer_size, CFBD_UARTAsyncOp what_async_done);\n</code></pre>"},{"location":"api/Files/uart_8h/#typedef-cfbd_uartoperations","title":"typedef CFBD_UARTOperations","text":"<pre><code>typedef struct _CFBD_UARTOperations CFBD_UARTOperations;\n</code></pre>"},{"location":"api/Files/uart_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/uart_8h/#function-cfbd_gainuartasynchelpers","title":"function CFBD_GainUARTAsyncHelpers","text":"<pre><code>CFBD_ST_UART_AsyncHelper * CFBD_GainUARTAsyncHelpers()\n</code></pre> <p>Gain the AsyncHelpers that can be used in callbacks at native frameworks. </p> <p>Return: CFBD_ST_UART_AsyncHelper* </p>"},{"location":"api/Files/uart_8h/#function-cfbd_uartbindrxprocessbuffer","title":"function CFBD_UARTBindRXProcessBuffer","text":"<pre><code>static inline void CFBD_UARTBindRXProcessBuffer(\n    CFBD_UARTHandle * handle,\n    uint8_t * rx_buffer,\n    const uint16_t rx_buffer_size\n)\n</code></pre>"},{"location":"api/Files/uart_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"cfbd_define.h\"\n\ntypedef struct _CFBD_UARTHandle CFBD_UARTHandle;\n\ntypedef enum\n{\n    SEND,\n    RECEIVE\n} CFBD_UARTAsyncOp;\n\ntypedef void (*CFBD_UARTAsyncCallback)(CFBD_UARTHandle* handle,\n                                       uint8_t* buffer,\n                                       const uint16_t buffer_size,\n                                       CFBD_UARTAsyncOp what_async_done);\n\ntypedef struct _CFBD_UARTOperations\n{\n    void (*sync_send)(CFBD_UARTHandle* handle, const uint8_t* buffer, const uint16_t buffer_size);\n    void (*sync_receive)(CFBD_UARTHandle* handle,\n                         uint8_t* available_buffer,\n                         const uint16_t available_buffer_size);\n    void (*async_send)(CFBD_UARTHandle* handle, const uint8_t* buffer, const uint16_t buffer_size);\n    void (*async_receive)(CFBD_UARTHandle* handle,\n                          uint8_t* available_buffer,\n                          const uint16_t available_buffer_size);\n} CFBD_UARTOperations;\n\ntypedef struct\n{\n    void (*on_send_complete)(CFBD_UARTHandle* handle);\n    void (*on_receive_complete)(CFBD_UARTHandle* handle);\n    void (*on_error)(CFBD_UARTHandle* handle, uint32_t error_code);\n    void (*on_idle_line)(CFBD_UARTHandle* handle, uint32_t received_len);\n} CFBD_UART_AsyncCallbacks;\n\ntypedef struct _CFBD_UARTHandle\n{\n    CFBD_UARTOperations* ops;\n    CFBD_UARTAsyncCallback handle_async_callback;\n    uint32_t accept_timeout;\n\n    void* backends; // backends here\n    CFBD_UART_AsyncCallbacks* async_callbacks;\n\n    uint8_t* rx_buffer;\n    uint16_t rx_buffer_size;\n} CFBD_UARTHandle;\n\n// OK, then we need to provide the async helpers\n// to enable user level to control the details of everything\n\ntypedef struct\n{\n    void (*async_send_complete)(void* native_data);\n    void (*async_receive_complete)(void* native_data);\n    void (*async_idle_line)(void* native_data);\n} CFBD_ST_UART_AsyncHelper;\n\nCFBD_ST_UART_AsyncHelper* CFBD_GainUARTAsyncHelpers();\n\nstatic inline void CFBD_UARTBindRXProcessBuffer(CFBD_UARTHandle* handle,\n                                                uint8_t* rx_buffer,\n                                                const uint16_t rx_buffer_size)\n{\n    handle-&gt;rx_buffer_size = rx_buffer_size;\n    handle-&gt;rx_buffer = rx_buffer;\n}\n\n#include \"lib_settings.h\"\n#if defined(CFBD_IS_ST)\n#include \"backend/stm-impl-uart.h\"\n#else\n#error \"No supports chips\"\n#endif\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/uart__inits_8c/","title":"lib/logger/uart_adapts/uart_inits.c","text":""},{"location":"api/Files/uart__inits_8c/#functions","title":"Functions","text":"Name CFBD_UARTHandle * asUARTNative(void * native_handle) void log_native_sync(void * native_handle, const char * buffer, const uint16_t buffer_size) void log_native_async(void * native_handle, const char * buffer, const uint16_t buffer_size) uint32_t log_timestamp(void * _) void CFBD_InitLoggerWithUART(CFBD_Logger * logger, CFBD_UARTHandle * uart_handle, cfbd_log_level_t filter_level, CFBD_Bool async_ok)"},{"location":"api/Files/uart__inits_8c/#attributes","title":"Attributes","text":"Name uint8_t[CFBD_LOG_BUFFER_SZ] logger_buffer CFBD_NativeLoggerOperations sync_ops CFBD_NativeLoggerOperations async_ops"},{"location":"api/Files/uart__inits_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/uart__inits_8c/#function-asuartnative","title":"function asUARTNative","text":"<pre><code>static inline CFBD_UARTHandle * asUARTNative(\n    void * native_handle\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#function-log_native_sync","title":"function log_native_sync","text":"<pre><code>static void log_native_sync(\n    void * native_handle,\n    const char * buffer,\n    const uint16_t buffer_size\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#function-log_native_async","title":"function log_native_async","text":"<pre><code>static void log_native_async(\n    void * native_handle,\n    const char * buffer,\n    const uint16_t buffer_size\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#function-log_timestamp","title":"function log_timestamp","text":"<pre><code>static uint32_t log_timestamp(\n    void * _\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#function-cfbd_initloggerwithuart","title":"function CFBD_InitLoggerWithUART","text":"<pre><code>void CFBD_InitLoggerWithUART(\n    CFBD_Logger * logger,\n    CFBD_UARTHandle * uart_handle,\n    cfbd_log_level_t filter_level,\n    CFBD_Bool async_ok\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/uart__inits_8c/#variable-logger_buffer","title":"variable logger_buffer","text":"<pre><code>static uint8_t[CFBD_LOG_BUFFER_SZ] logger_buffer;\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#variable-sync_ops","title":"variable sync_ops","text":"<pre><code>static CFBD_NativeLoggerOperations sync_ops = {.log_native = log_native_sync,\n                                               .timestamp = log_timestamp};\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#variable-async_ops","title":"variable async_ops","text":"<pre><code>static CFBD_NativeLoggerOperations async_ops = {.log_native = log_native_async,\n                                                .timestamp = log_timestamp};\n</code></pre>"},{"location":"api/Files/uart__inits_8c/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdint.h&gt;\n\n#include \"app.h\"\n#include \"cfbd_define.h\"\n#include \"cfbd_log.h\"\n#include \"cfbd_log_configs.h\"\n#include \"uart.h\"\n\nstatic uint8_t logger_buffer[CFBD_LOG_BUFFER_SZ];\n\nstatic inline CFBD_UARTHandle* asUARTNative(void* native_handle)\n{\n    return (CFBD_UARTHandle*) native_handle;\n}\n\nstatic void log_native_sync(void* native_handle, const char* buffer, const uint16_t buffer_size)\n{\n    CFBD_UARTHandle* uart = asUARTNative(native_handle);\n    uart-&gt;ops-&gt;sync_send(uart, (uint8_t*) buffer, buffer_size);\n}\n\nstatic void log_native_async(void* native_handle, const char* buffer, const uint16_t buffer_size)\n{\n    CFBD_UARTHandle* uart = asUARTNative(native_handle);\n    uart-&gt;ops-&gt;async_send(uart, (uint8_t*) buffer, buffer_size);\n}\n\nstatic uint32_t log_timestamp(void* _)\n{\n    return getApp(CFBD_FALSE)-&gt;tick_provider();\n}\n\nstatic CFBD_NativeLoggerOperations sync_ops = {.log_native = log_native_sync,\n                                               .timestamp = log_timestamp};\n\nstatic CFBD_NativeLoggerOperations async_ops = {.log_native = log_native_async,\n                                                .timestamp = log_timestamp};\n\nvoid CFBD_InitLoggerWithUART(CFBD_Logger* logger,\n                             CFBD_UARTHandle* uart_handle,\n                             cfbd_log_level_t filter_level,\n                             CFBD_Bool async_ok)\n{\n    if (async_ok) {\n        CFBD_InitLogger(logger,\n                        &amp;async_ops,\n                        uart_handle,\n                        filter_level,\n                        logger_buffer,\n                        CFBD_LOG_BUFFER_SZ);\n    }\n    else {\n        CFBD_InitLogger(logger,\n                        &amp;sync_ops,\n                        uart_handle,\n                        filter_level,\n                        logger_buffer,\n                        CFBD_LOG_BUFFER_SZ);\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/uart__inits_8h/","title":"lib/logger/uart_adapts/uart_inits.h","text":""},{"location":"api/Files/uart__inits_8h/#functions","title":"Functions","text":"Name void CFBD_InitLoggerWithUART(CFBD_Logger * logger, CFBD_UARTHandle * uart_handle, cfbd_log_level_t filter_level, CFBD_Bool async_ok)"},{"location":"api/Files/uart__inits_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/uart__inits_8h/#function-cfbd_initloggerwithuart","title":"function CFBD_InitLoggerWithUART","text":"<pre><code>void CFBD_InitLoggerWithUART(\n    CFBD_Logger * logger,\n    CFBD_UARTHandle * uart_handle,\n    cfbd_log_level_t filter_level,\n    CFBD_Bool async_ok\n)\n</code></pre>"},{"location":"api/Files/uart__inits_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cfbd_log.h\"\n#include \"uart.h\"\n\nvoid CFBD_InitLoggerWithUART(CFBD_Logger* logger,\n                             CFBD_UARTHandle* uart_handle,\n                             cfbd_log_level_t filter_level,\n                             CFBD_Bool async_ok);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/widget_8c/","title":"lib/graphic/widget/widget/widget.c","text":""},{"location":"api/Files/widget_8c/#functions","title":"Functions","text":"Name void detach_from_parent(CFBD_Widget * child) void CFBD_WidgetSetParent_Default(CFBD_Widget * self, CFBD_Widget * new_parent) void CFBD_WidgetCreateBase(CFBD_Widget * self, CFBD_WidgetCreationPack * pack) void CFBD_WidgetAssignedChildPlace(CFBD_Widget * self, CFBD_Widget ** children_array, size_t children_container_sz)"},{"location":"api/Files/widget_8c/#attributes","title":"Attributes","text":"Name CFBD_WidgetOperations g_cfbd_widget_default_ops"},{"location":"api/Files/widget_8c/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/widget_8c/#function-detach_from_parent","title":"function detach_from_parent","text":"<pre><code>static void detach_from_parent(\n    CFBD_Widget * child\n)\n</code></pre>"},{"location":"api/Files/widget_8c/#function-cfbd_widgetsetparent_default","title":"function CFBD_WidgetSetParent_Default","text":"<pre><code>static void CFBD_WidgetSetParent_Default(\n    CFBD_Widget * self,\n    CFBD_Widget * new_parent\n)\n</code></pre>"},{"location":"api/Files/widget_8c/#function-cfbd_widgetcreatebase","title":"function CFBD_WidgetCreateBase","text":"<pre><code>void CFBD_WidgetCreateBase(\n    CFBD_Widget * self,\n    CFBD_WidgetCreationPack * pack\n)\n</code></pre>"},{"location":"api/Files/widget_8c/#function-cfbd_widgetassignedchildplace","title":"function CFBD_WidgetAssignedChildPlace","text":"<pre><code>void CFBD_WidgetAssignedChildPlace(\n    CFBD_Widget * self,\n    CFBD_Widget ** children_array,\n    size_t children_container_sz\n)\n</code></pre>"},{"location":"api/Files/widget_8c/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/widget_8c/#variable-g_cfbd_widget_default_ops","title":"variable g_cfbd_widget_default_ops","text":"<pre><code>static CFBD_WidgetOperations g_cfbd_widget_default_ops = {\n        .set_parent = CFBD_WidgetSetParent_Default,\n};\n</code></pre>"},{"location":"api/Files/widget_8c/#source-code","title":"Source code","text":"<pre><code>#include \"widget.h\"\n\n#include &lt;stddef.h&gt;\n\n#include \"cfbd_define.h\"\n\n\n/*\n Helper: detach child from its current parent (if any).\n This will search the parent's children array and set the matching slot to NULL,\n and decrement parent's children_cnt accordingly.\n After this call, child's parent will be set to NULL.\n*/\nstatic void detach_from_parent(CFBD_Widget* child)\n{\n    if (!child)\n        return;\n    CFBD_Widget* old_parent = child-&gt;parent;\n    if (!old_parent) {\n        child-&gt;parent = NULL;\n        return;\n    }\n\n    CFBD_Widget** arr = old_parent-&gt;children;\n    size_t cap = old_parent-&gt;children_container_sz;\n    if (!arr || cap == 0) {\n        // parent's container not available: just clear parent reference\n        child-&gt;parent = NULL;\n        return;\n    }\n\n    CFBD_Bool removed = CFBD_FALSE;\n    for (size_t i = 0; i &lt; cap; ++i) {\n        if (arr[i] == child) {\n            arr[i] = NULL;\n            removed = CFBD_TRUE;\n            break;\n        }\n    }\n    if (removed) {\n        // Recompute children_cnt conservatively (faster: decrement if &gt;0, but ensure correctness)\n        size_t cnt = 0;\n        for (size_t i = 0; i &lt; cap; ++i) {\n            if (arr[i] != NULL)\n                ++cnt;\n        }\n        old_parent-&gt;children_cnt = cnt;\n    }\n    child-&gt;parent = NULL;\n}\n\n/*\n Public API implementations\n*/\n\nstatic void CFBD_WidgetSetParent_Default(CFBD_Widget* self, CFBD_Widget* new_parent)\n{\n    if (self-&gt;parent) {\n        CFBD_Widget* old = self-&gt;parent;\n        if (old-&gt;children &amp;&amp; old-&gt;children_container_sz) {\n            for (size_t i = 0; i &lt; old-&gt;children_container_sz; ++i) {\n                if (old-&gt;children[i] == self) {\n                    old-&gt;children[i] = NULL;\n                    break;\n                }\n            }\n\n            /* \u91cd\u65b0\u7edf\u8ba1 */\n            size_t cnt = 0;\n            for (size_t i = 0; i &lt; old-&gt;children_container_sz; ++i) {\n                if (old-&gt;children[i])\n                    cnt++;\n            }\n            old-&gt;children_cnt = cnt;\n        }\n    }\n\n    self-&gt;parent = NULL;\n\n    if (!new_parent)\n        return;\n\n    if (!new_parent-&gt;children || new_parent-&gt;children_container_sz == 0)\n        return;\n\n    for (size_t i = 0; i &lt; new_parent-&gt;children_container_sz; ++i) {\n        if (new_parent-&gt;children[i] == NULL) {\n            new_parent-&gt;children[i] = self;\n            new_parent-&gt;children_cnt++;\n            self-&gt;parent = new_parent;\n            return;\n        }\n    }\n}\n\nstatic CFBD_WidgetOperations g_cfbd_widget_default_ops = {\n        .set_parent = CFBD_WidgetSetParent_Default,\n};\n\nvoid CFBD_WidgetCreateBase(CFBD_Widget* self, CFBD_WidgetCreationPack* pack)\n{\n    if (!self || !pack)\n        return;\n\n    self-&gt;ops = &amp;g_cfbd_widget_default_ops;\n    self-&gt;override_ops = NULL;\n\n    self-&gt;parent = NULL;\n    self-&gt;children = pack-&gt;children;\n    self-&gt;children_container_sz = pack-&gt;children_container_sz;\n    self-&gt;children_cnt = 0;\n\n    self-&gt;tl_point = pack-&gt;tl_point;\n    self-&gt;size = pack-&gt;size;\n\n    /* \u7edf\u8ba1\u5df2\u6709 children */\n    if (self-&gt;children) {\n        for (size_t i = 0; i &lt; self-&gt;children_container_sz; ++i) {\n            if (self-&gt;children[i]) {\n                self-&gt;children[i]-&gt;parent = self;\n                self-&gt;children_cnt++;\n            }\n        }\n    }\n\n    /* \u4f7f\u7528 ops-&gt;set_parent */\n    if (pack-&gt;parent) {\n        self-&gt;ops-&gt;set_parent(self, pack-&gt;parent);\n    }\n}\n\nvoid CFBD_WidgetAssignedChildPlace(CFBD_Widget* self,\n                                   CFBD_Widget** children_array,\n                                   size_t children_container_sz)\n{\n    if (!self)\n        return;\n\n    // Detach existing children: set their parent to NULL and clear existing container slots\n    if (self-&gt;children &amp;&amp; self-&gt;children_container_sz &gt; 0) {\n        for (size_t i = 0; i &lt; self-&gt;children_container_sz; ++i) {\n            CFBD_Widget* c = self-&gt;children[i];\n            if (c != NULL) {\n                // only clear child's parent if it points to us\n                if (c-&gt;parent == self) {\n                    c-&gt;parent = NULL;\n                }\n                self-&gt;children[i] = NULL;\n            }\n        }\n    }\n\n    // assign new container pointer and capacity\n    self-&gt;children = children_array;\n    self-&gt;children_container_sz = children_container_sz;\n    self-&gt;children_cnt = 0;\n\n    // populate new container: ensure each non-NULL child points to self\n    if (self-&gt;children &amp;&amp; self-&gt;children_container_sz &gt; 0) {\n        size_t cnt = 0;\n        for (size_t i = 0; i &lt; self-&gt;children_container_sz; ++i) {\n            CFBD_Widget* c = self-&gt;children[i];\n            if (c != NULL) {\n                // detach from child's old parent first (so parent's arrays remain consistent)\n                detach_from_parent(c);\n                c-&gt;parent = self;\n                ++cnt;\n            }\n        }\n        self-&gt;children_cnt = cnt;\n    }\n}\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/widget_8h/","title":"lib/graphic/widget/widget/widget.h","text":""},{"location":"api/Files/widget_8h/#classes","title":"Classes","text":"Name struct CFBD_WidgetRequestOverrideOperations struct CFBD_WidgetOperations struct __CFBD_Widget Clean and LightWighted Containers for the widget sessions. struct CFBD_WidgetCreationPack"},{"location":"api/Files/widget_8h/#types","title":"Types","text":"Name typedef struct __CFBD_Widget CFBD_Widget Clean and LightWighted Containers for the widget sessions."},{"location":"api/Files/widget_8h/#functions","title":"Functions","text":"Name void CFBD_WidgetCreateBase(CFBD_Widget * self, CFBD_WidgetCreationPack * pack) void CFBD_WidgetAssignedChildPlace(CFBD_Widget * self, CFBD_Widget ** children_array, size_t children_container_sz)"},{"location":"api/Files/widget_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/widget_8h/#typedef-cfbd_widget","title":"typedef CFBD_Widget","text":"<pre><code>typedef struct __CFBD_Widget CFBD_Widget;\n</code></pre> <p>Clean and LightWighted Containers for the widget sessions. </p>"},{"location":"api/Files/widget_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/widget_8h/#function-cfbd_widgetcreatebase","title":"function CFBD_WidgetCreateBase","text":"<pre><code>void CFBD_WidgetCreateBase(\n    CFBD_Widget * self,\n    CFBD_WidgetCreationPack * pack\n)\n</code></pre>"},{"location":"api/Files/widget_8h/#function-cfbd_widgetassignedchildplace","title":"function CFBD_WidgetAssignedChildPlace","text":"<pre><code>void CFBD_WidgetAssignedChildPlace(\n    CFBD_Widget * self,\n    CFBD_Widget ** children_array,\n    size_t children_container_sz\n)\n</code></pre>"},{"location":"api/Files/widget_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stddef.h&gt;\n\n#include \"base/point.h\"\n#include \"base/size.h\"\n#include \"cfbd_graphic_define.h\"\n\ntypedef struct __CFBD_Widget CFBD_Widget;\n\ntypedef struct\n{\n    void (*paint)(CFBD_Widget* w, CFBD_GraphicDevice* graphic_device);\n} CFBD_WidgetRequestOverrideOperations;\n\ntypedef struct\n{\n    // When NULL parent, parent of old will auto clear arrays\n    void (*set_parent)(CFBD_Widget* self, CFBD_Widget* parent);\n} CFBD_WidgetOperations;\n\ntypedef struct __CFBD_Widget\n{\n    CFBD_Widget* parent;\n    CFBD_Widget** children; // child can be dymanic\n    size_t children_container_sz;\n    size_t children_cnt;\n\n    // one must assigned the ops for able use\n    CFBD_WidgetRequestOverrideOperations* override_ops;\n\n    CFBD_WidgetOperations* ops;\n\n    CFBDGraphic_Point tl_point;\n    CFBDGraphicSize size;\n\n    void* external_data; // ah, yeah!\n} CFBD_Widget;\n\ntypedef struct\n{\n    CFBDGraphic_Point tl_point;\n    CFBDGraphicSize size;\n    CFBD_Widget** children; // child containers\n    size_t children_container_sz;\n    CFBD_Widget* parent; // owns parent? NULL if no :)\n} CFBD_WidgetCreationPack;\n\nvoid CFBD_WidgetCreateBase(CFBD_Widget* self, CFBD_WidgetCreationPack* pack);\nvoid CFBD_WidgetAssignedChildPlace(CFBD_Widget* self,\n                                   CFBD_Widget** children_array,\n                                   size_t children_container_sz);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Files/widget__wrappers_8h/","title":"lib/graphic/widget/widget/widget_wrappers.h","text":"<p>Old days designs adapters.  More...</p>"},{"location":"api/Files/widget__wrappers_8h/#functions","title":"Functions","text":"Name PREANNOUNCE_TYPE(CFBD_GraphicArc ) PREANNOUNCE_TYPE(CFBDGraphicCircle ) void CFBD_WrapArc2Widget(CFBD_Widget * blank_widget, CFBD_GraphicArc * arc, CFBD_Bool isFilled) void CFBD_WrapCircle2Widget(CFBD_Widget * blank_widget, CFBDGraphicCircle * circle, CFBD_Bool isFilled)"},{"location":"api/Files/widget__wrappers_8h/#defines","title":"Defines","text":"Name PREANNOUNCE_TYPE(Type)"},{"location":"api/Files/widget__wrappers_8h/#detailed-description","title":"Detailed Description","text":"<p>Old days designs adapters. </p> <p>Author: Charliechen114514 (chengh1922@mails.jlu.edu.cn) </p> <p>Version: 0.1 </p> <p>Date: 2026-01-19</p> <p>Copyright: Copyright \u00a9 2026 </p>"},{"location":"api/Files/widget__wrappers_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/widget__wrappers_8h/#function-preannounce_type","title":"function PREANNOUNCE_TYPE","text":"<pre><code>PREANNOUNCE_TYPE(\n    CFBD_GraphicArc \n)\n</code></pre>"},{"location":"api/Files/widget__wrappers_8h/#function-preannounce_type_1","title":"function PREANNOUNCE_TYPE","text":"<pre><code>PREANNOUNCE_TYPE(\n    CFBDGraphicCircle \n)\n</code></pre>"},{"location":"api/Files/widget__wrappers_8h/#function-cfbd_wraparc2widget","title":"function CFBD_WrapArc2Widget","text":"<pre><code>void CFBD_WrapArc2Widget(\n    CFBD_Widget * blank_widget,\n    CFBD_GraphicArc * arc,\n    CFBD_Bool isFilled\n)\n</code></pre>"},{"location":"api/Files/widget__wrappers_8h/#function-cfbd_wrapcircle2widget","title":"function CFBD_WrapCircle2Widget","text":"<pre><code>void CFBD_WrapCircle2Widget(\n    CFBD_Widget * blank_widget,\n    CFBDGraphicCircle * circle,\n    CFBD_Bool isFilled\n)\n</code></pre>"},{"location":"api/Files/widget__wrappers_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/widget__wrappers_8h/#define-preannounce_type","title":"define PREANNOUNCE_TYPE","text":"<pre><code>#define PREANNOUNCE_TYPE(\n    Type\n)\ntypedef struct __##Type Type\n</code></pre>"},{"location":"api/Files/widget__wrappers_8h/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"cfbd_define.h\"\n#include \"widget.h\"\n\n#define PREANNOUNCE_TYPE(Type) typedef struct __##Type Type\n\nPREANNOUNCE_TYPE(CFBD_GraphicArc);\nPREANNOUNCE_TYPE(CFBDGraphicCircle);\n\nvoid CFBD_WrapArc2Widget(CFBD_Widget* blank_widget, CFBD_GraphicArc* arc, CFBD_Bool isFilled);\nvoid CFBD_WrapCircle2Widget(CFBD_Widget* blank_widget,\n                            CFBDGraphicCircle* circle,\n                            CFBD_Bool isFilled);\n\n#undef PREANNOUNCE_TYPE\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Application__Module/","title":"Application Management","text":"<p>Application-level bootstrap and clock providers.  More...</p>"},{"location":"api/Modules/group__Application__Module/#files","title":"Files","text":"Name lib/application/app.h Application descriptor and clock/boot provider interfaces."},{"location":"api/Modules/group__Application__Module/#classes","title":"Classes","text":"Name struct __CFBDApplication Application descriptor."},{"location":"api/Modules/group__Application__Module/#types","title":"Types","text":"Name typedef uint32_t(*)(void) CFBD_ClockFreqProvider Function returning the system clock frequency in Hertz. typedef uint32_t(*)(void) CFBD_ClockTickProvider Function returning a monotonically increasing tick value. typedef struct __CFBDApplication CFBDApplication Application descriptor."},{"location":"api/Modules/group__Application__Module/#functions","title":"Functions","text":"Name CFBDBootTuple * CFBD_AppBootMaker(void )Return a pointer to a boot tuple table for the application. CFBD_ClockFreqProvider CFBD_AppClockProvider(void )Return the application's clock frequency provider. CFBD_ClockTickProvider CFBD_AppTickProvider(void )Return the application's tick provider. CFBDApplication * getApp(CFBD_Bool request_auto_boot)Obtain the global <code>CFBDApplication</code> instance."},{"location":"api/Modules/group__Application__Module/#detailed-description","title":"Detailed Description","text":"<p>Application-level bootstrap and clock providers. </p> <p>Provides the core application descriptor and helper functions for managing application initialization and timing services. This module allows applications to register their bootstrap sequences and clock providers with the CFBD framework. </p>"},{"location":"api/Modules/group__Application__Module/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Application__Module/#typedef-cfbd_clockfreqprovider","title":"typedef CFBD_ClockFreqProvider","text":"<pre><code>CFBD_ClockFreqProvider;\n</code></pre> <p>Function returning the system clock frequency in Hertz. </p> <p>See: </p> <ul> <li>CFBD_ClockTickProvider</li> <li>CFBDApplication</li> </ul> <p>Return: uint32_t Current clock frequency in Hertz (Hz).</p> <p>Par: Example</p> <pre><code>uint32_t stm32_clock_freq(void) {\n    // STM32F103 typically runs at 72 MHz\n    return 72000000;\n}\n</code></pre> <p>Provider returns the current core/system clock frequency in Hz. This value is used by timing helpers and drivers to convert between ticks and wall-clock time. If the platform supports dynamic clock scaling, the provider should return the up-to-date frequency when called.</p> <p>Implementations must ensure the returned value is accurate and stable for use in timing-critical calculations. Typical implementations read clock configuration registers or return a hardcoded constant.</p>"},{"location":"api/Modules/group__Application__Module/#typedef-cfbd_clocktickprovider","title":"typedef CFBD_ClockTickProvider","text":"<pre><code>CFBD_ClockTickProvider;\n</code></pre> <p>Function returning a monotonically increasing tick value. </p> <p>See: </p> <ul> <li>CFBD_ClockFreqProvider</li> <li>CFBDApplication</li> </ul> <p>Return: uint32_t Current tick counter value. Should increment steadily and wrap around gracefully.</p> <p>Par: Example</p> <pre><code>extern volatile uint32_t g_systick_count;\n\nuint32_t get_systick(void) {\n    return g_systick_count;\n}\n</code></pre> <p>Provider returns a tick counter value (units are implementation defined, typically processor ticks or a hardware timer count). The value should be monotonically increasing and suitable for measuring short intervals when combined with the frequency provider.</p> <p>Common implementations include:</p> <ul> <li>System timer (SysTick) count for ARM Cortex-M processors</li> <li>Hardware timer register values</li> <li>Software tick counters incremented by interrupts</li> </ul>"},{"location":"api/Modules/group__Application__Module/#typedef-cfbdapplication","title":"typedef CFBDApplication","text":"<pre><code>typedef struct __CFBDApplication CFBDApplication;\n</code></pre> <p>Application descriptor. </p> <p>See: </p> <ul> <li>getApp()</li> <li>CFBD_AppBootMaker()</li> <li>CFBD_AppClockProvider()</li> <li>CFBD_AppTickProvider()</li> </ul> <p>Aggregates the bootstrap function and clock providers for an application. Typical usage is to expose a single application instance via <code>[getApp()](Modules/group__Application__Module.md#function-getapp)</code> that other framework components query to obtain boot actions and timing sources.</p> <p>The application descriptor serves as a central registry for all application-level services, allowing framework components to access initialization routines and timing information without requiring direct coupling to application code.</p>"},{"location":"api/Modules/group__Application__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Application__Module/#function-cfbd_appbootmaker","title":"function CFBD_AppBootMaker","text":"<pre><code>CFBDBootTuple * CFBD_AppBootMaker(\n    void \n)\n</code></pre> <p>Return a pointer to a boot tuple table for the application. </p> <p>See: </p> <ul> <li>CFBDBootTuple</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Return: CFBDBootTuple* Pointer to the boot tuple table or NULL.</p> <p>The returned pointer typically refers to a static array of <code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code> entries describing ordered bootstrap actions. The caller must not attempt to free the returned pointer. Return value may be NULL if the application exposes no explicit boot table.</p> <p>The boot table provides a declarative way to specify initialization sequences without requiring explicit function calls.</p>"},{"location":"api/Modules/group__Application__Module/#function-cfbd_appclockprovider","title":"function CFBD_AppClockProvider","text":"<pre><code>CFBD_ClockFreqProvider CFBD_AppClockProvider(\n    void \n)\n</code></pre> <p>Return the application's clock frequency provider. </p> <p>See: </p> <ul> <li>CFBD_ClockFreqProvider</li> <li>getApp()</li> </ul> <p>Return: CFBD_ClockFreqProvider Function pointer returning system frequency in Hz, or NULL if not provided.</p> <p>Retrieves the frequency provider function registered with the application descriptor. This allows framework components to query the system clock frequency without direct application coupling.</p>"},{"location":"api/Modules/group__Application__Module/#function-cfbd_apptickprovider","title":"function CFBD_AppTickProvider","text":"<pre><code>CFBD_ClockTickProvider CFBD_AppTickProvider(\n    void \n)\n</code></pre> <p>Return the application's tick provider. </p> <p>See: </p> <ul> <li>CFBD_ClockTickProvider</li> <li>getApp()</li> </ul> <p>Return: CFBD_ClockTickProvider Function pointer returning current tick count, or NULL if not provided.</p> <p>Retrieves the tick provider function registered with the application descriptor. This allows framework components to measure time intervals without direct application coupling.</p>"},{"location":"api/Modules/group__Application__Module/#function-getapp","title":"function getApp","text":"<pre><code>CFBDApplication * getApp(\n    CFBD_Bool request_auto_boot\n)\n</code></pre> <p>Obtain the global <code>CFBDApplication</code> instance. </p> <p>Parameters: </p> <ul> <li>request_auto_boot If <code>CFBD_TRUE</code>, request that the application performs any auto-boot actions before returning (implementation-defined). If <code>CFBD_FALSE</code>, returns the descriptor without triggering bootstrap.</li> </ul> <p>See: </p> <ul> <li>CFBDApplication</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Return: CFBDApplication* Pointer to the application descriptor, or NULL if no application is registered.</p> <p>Par: </p> <ul> <li>Example: Get application with automatic bootstrap</li> </ul> <p><pre><code>CFBDApplication* app = getApp(CFBD_TRUE);\nif (app &amp;&amp; app-&gt;freq_provider) {\n    uint32_t freq = app-&gt;freq_provider();\n}\n</code></pre>   * Example: Get application descriptor without bootstrap</p> <pre><code>CFBDApplication* app = getApp(CFBD_FALSE);\n// Manually call bootstrap if needed\nif (app &amp;&amp; app-&gt;selfBootFunc) {\n    app-&gt;selfBootFunc(app, app-&gt;bootargs);\n}\n</code></pre> <p>Returns a pointer to the global application descriptor. If <code>request_auto_boot</code> is true the function may trigger automatic application bootstrap actions according to the platform policy.</p> <p>This is the primary entry point for framework components to access application-level services.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Arc__Module/","title":"Arc Drawing","text":""},{"location":"api/Modules/group__Arc__Module/#classes","title":"Classes","text":"Name struct CFBD_GraphicArc Represents a circular arc defined by center, radius, and angular range. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__BaseHelpers__Module/","title":"Graphic Base Helpers","text":"<p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__Boot/","title":"Boot","text":"<p>Minimal boot/bootstrap types and helpers.  More...</p>"},{"location":"api/Modules/group__CFBD__Boot/#classes","title":"Classes","text":"Name struct CFBDBootTuple"},{"location":"api/Modules/group__CFBD__Boot/#types","title":"Types","text":"Name typedef void * CFBD_BootArgs Opaque pointer to bootstrap-specific arguments. typedef CFBD_Bool(*)(CFBD_BootArgs args) CFBD_BootStrapFunc Function-pointer type for bootstrap/startup routines."},{"location":"api/Modules/group__CFBD__Boot/#detailed-description","title":"Detailed Description","text":"<p>Minimal boot/bootstrap types and helpers. </p> <p>Types used to describe and invoke bootstrap/startup routines.</p> <p>The CFBD_Boot module provides a generic, extensible mechanism for managing application startup sequences. It decouples initialization logic from the main application, enabling a clean modular architecture where each subsystem (hardware, drivers, services) registers its own bootstrap function. </p>"},{"location":"api/Modules/group__CFBD__Boot/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__CFBD__Boot/#typedef-cfbd_bootargs","title":"typedef CFBD_BootArgs","text":"<pre><code>CFBD_BootArgs;\n</code></pre> <p>Opaque pointer to bootstrap-specific arguments. </p> <p>See: </p> <ul> <li>CFBDBootTuple</li> <li>CFBD_BootStrapFunc</li> </ul> <p>Since: 0.1 </p> <p>Par: Example - Basic Argument Casting</p> <pre><code>// Define a boot-time configuration structure\nstruct MyBootConfig {\n    uint32_t clock_frequency;\n    uint8_t device_id;\n} my_config = { 72000000, 0x01 };\n\n// Cast to generic CFBD_BootArgs\nCFBD_BootArgs args = (CFBD_BootArgs)&amp;my_config;\n\n// In the bootstrap function, cast back to concrete type\nCFBD_Bool my_bootstrap(CFBD_BootArgs args) {\n    struct MyBootConfig *cfg = (struct MyBootConfig *)args;\n    initialize_clock(cfg-&gt;clock_frequency);\n    return CFBD_True;\n}\n</code></pre> <p>Bootstrap argument containers are intentionally typedeffed to <code>void*</code> to keep the interface generic. Callers should cast to a concrete structure type known to both the caller and the bootstrap function.</p>"},{"location":"api/Modules/group__CFBD__Boot/#typedef-cfbd_bootstrapfunc","title":"typedef CFBD_BootStrapFunc","text":"<pre><code>CFBD_BootStrapFunc;\n</code></pre> <p>Function-pointer type for bootstrap/startup routines. </p> <p>Parameters: </p> <ul> <li>args Opaque pointer to bootstrap-specific arguments (may be NULL). </li> </ul> <p>See: </p> <ul> <li>CFBD_BootArgs</li> <li>CFBDBootTuple</li> </ul> <p>Return: CFBD_Bool Return <code>CFBD_True</code> on success, <code>CFBD_False</code> on failure.</p> <p>Since: 0.1 </p> <p>Note: The exact concrete type behind <code>CFBD_BootArgs</code> is application specific. Use <code>@ref CFBD_BootArgs</code> casts to access fields.</p> <p>Par: </p> <ul> <li>Example - Simple Bootstrap Function</li> </ul> <p><pre><code>// Hardware initialization bootstrap function\nCFBD_Bool boot_hardware(CFBD_BootArgs args) {\n    struct HwConfig *hw_cfg = (struct HwConfig *)args;\n\n    // Initialize clock\n    if (!init_system_clock(hw_cfg-&gt;clock_freq)) {\n        return CFBD_False;\n    }\n\n    // Initialize GPIO\n    if (!init_gpio_subsystem(hw_cfg-&gt;gpio_config)) {\n        return CFBD_False;\n    }\n\n    return CFBD_True;\n}\n</code></pre>   * Example - Bootstrap Function with Null Arguments</p> <pre><code>// Application initialization that doesn't need configuration\nCFBD_Bool boot_application(CFBD_BootArgs args) {\n    (void)args;  // Unused\n\n    app_init_subsystems();\n    app_start_scheduler();\n\n    return CFBD_True;\n}\n</code></pre> <p>Bootstrap functions receive a single opaque argument (<code>CFBD_BootArgs</code>) and return a <code>CFBD_Bool</code> indicating success (<code>CFBD_True</code>) or failure (<code>CFBD_False</code>). Implementations should perform any necessary initialization and return quickly. Long-running tasks or blocking operations should be avoided unless explicitly required by the platform.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__Core/","title":"Core Definitions","text":"<p>Small portable types and macros used throughout the project.  More...</p>"},{"location":"api/Modules/group__CFBD__Core/#types","title":"Types","text":"Name typedef uint8_t CFBD_Bool Minimal boolean type (1 byte). typedef CFBD_Bool(*)(void *self_handle, void *args) SelfInitFunc Generic initialization callback signature for objects/components. typedef void(*)(void *args) PlainFunc Generic callback taking a single opaque argument and returning void."},{"location":"api/Modules/group__CFBD__Core/#defines","title":"Defines","text":"Name CFBD_FALSE Integer value representing boolean false. CFBD_TRUE Integer value representing boolean true."},{"location":"api/Modules/group__CFBD__Core/#detailed-description","title":"Detailed Description","text":"<p>Small portable types and macros used throughout the project. </p> <p>Provides fundamental building blocks for the CFBD framework including platform-independent boolean type, callback function signatures, and related constants. These definitions are designed to be included widely across platform and application code without introducing unnecessary dependencies. </p>"},{"location":"api/Modules/group__CFBD__Core/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__CFBD__Core/#typedef-cfbd_bool","title":"typedef CFBD_Bool","text":"<pre><code>CFBD_Bool;\n</code></pre> <p>Minimal boolean type (1 byte). </p> <p>See: </p> <ul> <li>CFBD_TRUE</li> <li>CFBD_FALSE</li> </ul> <p>Uses an unsigned 8-bit integer to represent boolean values. The explicit width helps keep ABI and header dependencies predictable on constrained targets. This type is portable across different platforms and compilers, making it suitable for use in headers that must be included in diverse contexts.</p>"},{"location":"api/Modules/group__CFBD__Core/#typedef-selfinitfunc","title":"typedef SelfInitFunc","text":"<pre><code>SelfInitFunc;\n</code></pre> <p>Generic initialization callback signature for objects/components. </p> <p>Parameters: </p> <ul> <li>self_handle Pointer to the instance being initialized (may be NULL). Typically cast to the specific component type. </li> <li>args Opaque pointer to initialization parameters (may be NULL). Interpretation depends on the component implementation. </li> </ul> <p>See: </p> <ul> <li>CFBD_Bool</li> <li>PlainFunc</li> </ul> <p>Return: CFBD_Bool <code>CFBD_TRUE</code> on successful initialization, <code>CFBD_FALSE</code> if initialization failed.</p> <p>Par: Example</p> <pre><code>CFBD_Bool initialize_component(void* self_handle, void* args) {\n    // Cast to actual type\n    ComponentState* component = (ComponentState*)self_handle;\n    ComponentInitArgs* init_args = (ComponentInitArgs*)args;\n\n    if (!component || !init_args) {\n        return CFBD_FALSE;\n    }\n\n    // Perform initialization\n    component-&gt;initialized = CFBD_TRUE;\n    return CFBD_TRUE;\n}\n</code></pre> <p>Initialization callbacks receive an opaque <code>self_handle</code> which is typically a pointer to the object being initialized, and an opaque <code>args</code> pointer for passing platform or application-specific data. Implementations should return <code>CFBD_TRUE</code> on successful initialization or <code>CFBD_FALSE</code> otherwise.</p> <p>This function pointer type enables a plugin-like architecture where components can be initialized through a common interface without requiring type knowledge at call sites.</p>"},{"location":"api/Modules/group__CFBD__Core/#typedef-plainfunc","title":"typedef PlainFunc","text":"<pre><code>PlainFunc;\n</code></pre> <p>Generic callback taking a single opaque argument and returning void. </p> <p>Parameters: </p> <ul> <li>args Opaque pointer passed to the callback (may be NULL). Interpretation and lifetime ownership is defined by the code that registers and invokes the callback.</li> </ul> <p>See: SelfInitFunc</p> <p>Par: Example</p> <pre><code>void on_timer_tick(void* args) {\n    TimerContext* ctx = (TimerContext*)args;\n    ctx-&gt;tick_count++;\n}\n\n// Register callback\nPlainFunc tick_handler = on_timer_tick;\ntick_handler(timer_context);\n</code></pre> <p>Useful for simple callbacks, event handlers or deferred work items where no return status is required. This function pointer type enables flexible callback registration and invocation without type coupling.</p>"},{"location":"api/Modules/group__CFBD__Core/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__Core/#define-cfbd_false","title":"define CFBD_FALSE","text":"<pre><code>#define CFBD_FALSE (0)\n</code></pre> <p>Integer value representing boolean false. </p> <p>See: CFBD_Bool</p> <p>This macro expands to 0, the standard false value. </p>"},{"location":"api/Modules/group__CFBD__Core/#define-cfbd_true","title":"define CFBD_TRUE","text":"<pre><code>#define CFBD_TRUE (1)\n</code></pre> <p>Integer value representing boolean true. </p> <p>See: CFBD_Bool</p> <p>This macro expands to 1, the standard true value. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Backend/","title":"I2C Backend Implementation","text":"<p>Backend implementation interface for I2C drivers.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Backend/#classes","title":"Classes","text":"Name struct CFBD_I2COperations Function table that a backend must implement to drive an I2C bus."},{"location":"api/Modules/group__CFBD__IIC__Backend/#detailed-description","title":"Detailed Description","text":"<p>Backend implementation interface for I2C drivers. </p> <p>Device-specific implementations must provide a CFBD_I2COperations table and initialize CFBD_I2CHandle with appropriate values. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/","title":"I2C/IIC Error Codes","text":"<p>Standard error codes for I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#defines","title":"Defines","text":"Name I2C_OK Success return code. I2C_ERR_TIMEOUT Operation timed out (-ETIMEDOUT). I2C_ERR_NACK Protocol error / NACK received (-EPROTO). I2C_ERR_BUSY Bus or peripheral busy (-EBUSY). I2C_ERR_IO Generic I/O error (-EIO). I2C_ERR_INVAL Invalid argument supplied (-EINVAL)."},{"location":"api/Modules/group__CFBD__IIC__Error/#detailed-description","title":"Detailed Description","text":"<p>Standard error codes for I2C operations. </p> <p>This module provides a set of standard error codes for I2C/IIC operations in the CFBD driver suite. All error codes follow POSIX errno conventions. </p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_ok","title":"define I2C_OK","text":"<pre><code>#define I2C_OK 0\n</code></pre> <p>Success return code. </p> <p>Par: Example</p> <pre><code>int status = CFBD_I2CTransfer(bus, msg, count, timeout);\nif (status == I2C_OK) {\n    // Process received data\n    process_data(msg[0].buf, msg[0].len);\n}\n</code></pre> <p>Returned when an I2C operation completes successfully without errors. All subsequent device states are valid and the operation result (if any) is reliable.</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_timeout","title":"define I2C_ERR_TIMEOUT","text":"<pre><code>#define I2C_ERR_TIMEOUT -110 /* -ETIMEDOUT */\n</code></pre> <p>Operation timed out (-ETIMEDOUT). </p> <p>Par: Recovery Strategy</p> <pre><code>if (status == I2C_ERR_TIMEOUT) {\n    // Option 1: Attempt bus recovery\n    CFBD_I2CRecoverBus(bus);\n\n    // Option 2: Retry with extended timeout\n    delay_ms(50);\n    status = CFBD_I2CTransfer(bus, msg, count, 2000);\n}\n</code></pre> <p>The I2C operation did not complete within the specified timeout period. This typically indicates:</p> <ul> <li>Clock line held low by slave (clock stretching exceeded timeout)</li> <li>No acknowledgment within expected time window</li> <li>Bus unresponsive for entire timeout duration</li> </ul>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_nack","title":"define I2C_ERR_NACK","text":"<pre><code>#define I2C_ERR_NACK -121 /* -EPROTO (nack) */\n</code></pre> <p>Protocol error / NACK received (-EPROTO). </p> <p>Par: Troubleshooting</p> <pre><code>if (status == I2C_ERR_NACK) {\n    // Check if device is ready\n    status = CFBD_I2CTransferIsDeviceReady(bus, addr, 5, 100);\n\n    if (status != I2C_OK) {\n        // Device not present or not responding\n        return -1;  // Abort operation\n    }\n}\n</code></pre> <p>The addressed slave device did not acknowledge the address or data byte. This indicates:</p> <ul> <li>Device not present at specified address</li> <li>Device in error state or not responding</li> <li>Address selection error</li> </ul>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_busy","title":"define I2C_ERR_BUSY","text":"<pre><code>#define I2C_ERR_BUSY -16 /* -EBUSY */\n</code></pre> <p>Bus or peripheral busy (-EBUSY). </p> <p>Par: Recommended Action</p> <pre><code>if (status == I2C_ERR_BUSY) {\n    // Small delay and retry\n    delay_ms(1);\n    status = CFBD_I2CTransfer(bus, msg, count, timeout);\n}\n</code></pre> <p>The I2C bus is currently occupied by another master or the peripheral cannot accept new commands. This is typically a transient condition.</p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_io","title":"define I2C_ERR_IO","text":"<pre><code>#define I2C_ERR_IO -5 /* -EIO */\n</code></pre> <p>Generic I/O error (-EIO). </p> <p>A generic I/O error occurred during the I2C transaction. This may indicate hardware malfunction, disconnected bus, or electrical issues. The specific cause requires platform-specific debugging. </p>"},{"location":"api/Modules/group__CFBD__IIC__Error/#define-i2c_err_inval","title":"define I2C_ERR_INVAL","text":"<pre><code>#define I2C_ERR_INVAL -22 /* -EINVAL */\n</code></pre> <p>Invalid argument supplied (-EINVAL). </p> <p>Par: Validation Example</p> <pre><code>if (addr &gt; 0x7F) {\n    return I2C_ERR_INVAL;  // 7-bit address out of range\n}\nif (num_messages &lt;= 0 || !messages) {\n    return I2C_ERR_INVAL;  // Invalid message array\n}\n</code></pre> <p>Invalid parameters were passed to the I2C function. Common causes:</p> <ul> <li>NULL handle or message pointer</li> <li>Invalid device address (outside 7-bit range)</li> <li>Zero message count</li> <li>Invalid timeout value</li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/","title":"I2C High-Level Helpers","text":"<p>Convenience functions for common I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#functions","title":"Functions","text":"Name int CFBD_I2CRead(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)High-level helper to read from an I2C device using IORequestParams. int CFBD_I2CWrite(CFBD_I2CHandle * handle, CFBD_I2C_IORequestParams * r)High-level helper to write to an I2C device using IORequestParams."},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#detailed-description","title":"Detailed Description","text":"<p>Convenience functions for common I2C operations. </p> <p>Simplify typical read/write patterns with automatic message construction. </p>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#function-cfbd_i2cread","title":"function CFBD_I2CRead","text":"<pre><code>int CFBD_I2CRead(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre> <p>High-level helper to read from an I2C device using IORequestParams. </p> <p>Parameters: </p> <ul> <li>handle Pointer to I2C bus handle </li> <li>r Pointer to IORequestParams describing the read operation </li> </ul> <p>Return: int I2C_OK on success or negative error code.</p> <p>Par: Example - EEPROM Read</p> <pre><code>uint8_t buffer[16];\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x50,          // EEPROM address\n    .mem_addr = 0x200,      // Byte offset in EEPROM\n    .mem_addr_size = 2,     // 16-bit address\n    .data = buffer,\n    .len = 16,\n    .timeout_ms = 1000\n};\n\nif (CFBD_I2CRead(bus_handle, &amp;req) == I2C_OK) {\n    // Process 16 bytes from EEPROM address 0x200\n}\n</code></pre> <p>Automatically constructs a read transaction that:</p> <ol> <li>Writes the device memory/register address to the device</li> <li>Reads the requested data from that address</li> </ol>"},{"location":"api/Modules/group__CFBD__IIC__HighLevel/#function-cfbd_i2cwrite","title":"function CFBD_I2CWrite","text":"<pre><code>int CFBD_I2CWrite(\n    CFBD_I2CHandle * handle,\n    CFBD_I2C_IORequestParams * r\n)\n</code></pre> <p>High-level helper to write to an I2C device using IORequestParams. </p> <p>Parameters: </p> <ul> <li>handle Pointer to I2C bus handle </li> <li>r Pointer to IORequestParams describing the write operation </li> </ul> <p>Return: int I2C_OK on success or negative error code.</p> <p>Par: Example - Configuration Write</p> <pre><code>uint8_t config_data[] = { 0xAA, 0xBB, 0xCC };\nCFBD_I2C_IORequestParams req = {\n    .addr7 = 0x30,\n    .mem_addr = 0x10,       // Register offset\n    .mem_addr_size = 1,\n    .data = config_data,\n    .len = sizeof(config_data),\n    .timeout_ms = 500\n};\n\nint status = CFBD_I2CWrite(bus_handle, &amp;req);\n</code></pre> <p>Constructs a write transaction that sends both the device memory/register address and data in a single I2C transaction.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/","title":"I2C Inline Wrappers","text":"<p>Convenience inline functions for I2C operations.  More...</p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#functions","title":"Functions","text":"Name int CFBD_I2CInit(CFBD_I2CHandle * bus)Inline helper to initialize an I2C bus using the backend. int CFBD_I2CDeInit(CFBD_I2CHandle * bus)Inline helper to deinitialize an I2C bus. int CFBD_I2CTransfer(CFBD_I2CHandle * bus, CFBD_I2C_Message * msgs, int num, uint32_t timeout_ms)Inline wrapper for message transfers. int CFBD_I2CTransferIsDeviceReady(CFBD_I2CHandle * bus, uint16_t addr, uint32_t trials, uint32_t timeout_ms)Check if a device is ready using the backend provider. int CFBD_I2CRecoverBus(CFBD_I2CHandle * bus)Attempt bus recovery using backend hook."},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#detailed-description","title":"Detailed Description","text":"<p>Convenience inline functions for I2C operations. </p> <p>These inline functions wrap backend operations, adding basic validation and NULL-safety checks before delegating to the backend. </p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2cinit","title":"function CFBD_I2CInit","text":"<pre><code>static inline int CFBD_I2CInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Inline helper to initialize an I2C bus using the backend. </p> <p>Parameters: </p> <ul> <li>bus Pointer to I2C handle </li> </ul> <p>Return: int I2C_OK on success or a negative error code.</p> <p>Par: Example</p> <pre><code>CFBD_I2CHandle bus = get_i2c_bus();\nif (CFBD_I2CInit(&amp;bus) != I2C_OK) {\n    handle_init_error();\n}\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2cdeinit","title":"function CFBD_I2CDeInit","text":"<pre><code>static inline int CFBD_I2CDeInit(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Inline helper to deinitialize an I2C bus. </p> <p>Parameters: </p> <ul> <li>bus Pointer to I2C handle </li> </ul> <p>Return: int I2C_OK on success or a negative error code. </p>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2ctransfer","title":"function CFBD_I2CTransfer","text":"<pre><code>static inline int CFBD_I2CTransfer(\n    CFBD_I2CHandle * bus,\n    CFBD_I2C_Message * msgs,\n    int num,\n    uint32_t timeout_ms\n)\n</code></pre> <p>Inline wrapper for message transfers. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>msgs Array of I2C messages </li> <li>num Number of messages in array </li> <li>timeout_ms Operation timeout in milliseconds </li> </ul> <p>Return: int I2C_OK on success or a negative error code.</p> <p>Par: Example - Simple Write</p> <pre><code>uint8_t cmd[] = { 0x01, 0x02, 0x03 };\nCFBD_I2C_Message msg = {\n    .addr = 0x50,\n    .flags = 0,  // Write\n    .len = sizeof(cmd),\n    .buf = cmd\n};\n\nint status = CFBD_I2CTransfer(bus, &amp;msg, 1, 1000);\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2ctransferisdeviceready","title":"function CFBD_I2CTransferIsDeviceReady","text":"<pre><code>static inline int CFBD_I2CTransferIsDeviceReady(\n    CFBD_I2CHandle * bus,\n    uint16_t addr,\n    uint32_t trials,\n    uint32_t timeout_ms\n)\n</code></pre> <p>Check if a device is ready using the backend provider. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> <li>addr 7-bit device address </li> <li>trials Number of probe attempts </li> <li>timeout_ms Per-trial timeout in milliseconds </li> </ul> <p>Return: int I2C_OK if device ready, negative error code otherwise.</p> <p>Par: Example - Device Presence Check</p> <pre><code>// Wait for device to become ready (useful after power-on)\nint status = CFBD_I2CTransferIsDeviceReady(bus, 0x3C, 10, 100);\nif (status == I2C_OK) {\n    // Device is present and responding\n} else if (status == I2C_ERR_NACK) {\n    // Device not responding\n}\n</code></pre>"},{"location":"api/Modules/group__CFBD__IIC__Wrappers/#function-cfbd_i2crecoverbus","title":"function CFBD_I2CRecoverBus","text":"<pre><code>static inline int CFBD_I2CRecoverBus(\n    CFBD_I2CHandle * bus\n)\n</code></pre> <p>Attempt bus recovery using backend hook. </p> <p>Parameters: </p> <ul> <li>bus I2C bus handle </li> </ul> <p>Return: int I2C_OK if recovery successful, error code if failed.</p> <p>Par: Example - Stuck Bus Recovery</p> <pre><code>int retry_count = 0;\nint status;\n\ndo {\n    status = CFBD_I2CTransfer(bus, msgs, count, 100);\n    if (status == I2C_OK) {\n        break;\n    }\n\n    if (status == I2C_ERR_TIMEOUT || status == I2C_ERR_IO) {\n        CFBD_I2CRecoverBus(bus);  // Attempt recovery\n        delay_ms(50);\n    }\n} while (++retry_count &lt; 3);\n</code></pre> <p>Call this when transfers are failing persistently. Recovery typically involves toggling SCL, sending dummy clocks, or issuing STOP conditions.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/","title":"OLED Display Cache Configuration","text":"<p>OLED display framebuffer dimensions and settings.  More...</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#defines","title":"Defines","text":"Name CACHED_HEIGHT Cache height in pixels. CACHED_WIDTH Cache width in pixels. CACHED_HEIGHT Cache height in pixels. CACHED_WIDTH Cache width in pixels."},{"location":"api/Modules/group__CFBD__OLED__Cache/#detailed-description","title":"Detailed Description","text":"<p>OLED display framebuffer dimensions and settings. </p> <p>Configures the off-screen pixel cache used by OLED drivers. These constants define the resolution that display drivers must support and the memory layout for pixel operations. </p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_height","title":"define CACHED_HEIGHT","text":"<pre><code>#define CACHED_HEIGHT (8)\n</code></pre> <p>Cache height in pixels. </p> <p>Note: Changing this requires updating all driver code that references display height or page counts.</p> <p>Par: Calculation</p> <p>Actual vertical pixels = CACHED_HEIGHT \u00d7 8 </p> <p>Specifies the vertical dimension of the display cache. In the typical SSD1306 page-based layout, this represents the number of 8-pixel-tall pages. With CACHED_HEIGHT = 8, the actual vertical resolution is 64 pixels (8 pages \u00d7 8 pixels per page).</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_width","title":"define CACHED_WIDTH","text":"<pre><code>#define CACHED_WIDTH (144)\n</code></pre> <p>Cache width in pixels. </p> <p>Note: Changing this requires updating all driver code that handles horizontal pixel operations, boundaries, and wrapping.</p> <p>Par: </p> <ul> <li>Total Memory</li> </ul> <p>Cache size = (CACHED_HEIGHT \u00d7 8 \u00d7 CACHED_WIDTH) / 8 bytes = (64 \u00d7 144) / 8 = 1152 bytes   * Example - Buffer Allocation</p> <pre><code>// Static allocation of OLED cache\nstatic uint8_t oled_cache[CACHED_HEIGHT * CACHED_WIDTH];\n\n// Total memory: 8 * 144 = 1152 bytes\n</code></pre> <p>Specifies the horizontal dimension of the display cache in pixels. With CACHED_WIDTH = 144, the display can show 144 characters at 6 pixels wide, or 128 characters at standard 5-pixel-wide fonts, depending on text rendering implementation.</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_height_1","title":"define CACHED_HEIGHT","text":"<pre><code>#define CACHED_HEIGHT (8)\n</code></pre> <p>Cache height in pixels. </p> <p>Note: Changing this requires updating all driver code that references display height or page counts.</p> <p>Par: Calculation</p> <p>Actual vertical pixels = CACHED_HEIGHT \u00d7 8 </p> <p>Specifies the vertical dimension of the display cache. In the typical SSD1306 page-based layout, this represents the number of 8-pixel-tall pages. With CACHED_HEIGHT = 8, the actual vertical resolution is 64 pixels (8 pages \u00d7 8 pixels per page).</p>"},{"location":"api/Modules/group__CFBD__OLED__Cache/#define-cached_width_1","title":"define CACHED_WIDTH","text":"<pre><code>#define CACHED_WIDTH (144)\n</code></pre> <p>Cache width in pixels. </p> <p>Note: Changing this requires updating all driver code that handles horizontal pixel operations, boundaries, and wrapping.</p> <p>Par: </p> <ul> <li>Total Memory</li> </ul> <p>Cache size = (CACHED_HEIGHT \u00d7 8 \u00d7 CACHED_WIDTH) / 8 bytes = (64 \u00d7 144) / 8 = 1152 bytes   * Example - Buffer Allocation</p> <pre><code>// Static allocation of OLED cache\nstatic uint8_t oled_cache[CACHED_HEIGHT * CACHED_WIDTH];\n\n// Total memory: 8 * 144 = 1152 bytes\n</code></pre> <p>Specifies the horizontal dimension of the display cache in pixels. With CACHED_WIDTH = 144, the display can show 144 characters at 6 pixels wide, or 128 characters at standard 5-pixel-wide fonts, depending on text rendering implementation.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__CFBD__OLED__Integration/","title":"OLED Display Integration","text":"<p>OLED driver initialization and platform integration.  More...</p>"},{"location":"api/Modules/group__CFBD__OLED__Integration/#classes","title":"Classes","text":"Name struct CFBD_OLED_IICInitsParams Initialization parameters for OLED devices using I2C."},{"location":"api/Modules/group__CFBD__OLED__Integration/#detailed-description","title":"Detailed Description","text":"<p>OLED driver initialization and platform integration. </p> <p>Provides structures and patterns for integrating OLED displays with platform-specific I2C buses and device configurations. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Circle__Module/","title":"Circle Drawing","text":""},{"location":"api/Modules/group__Circle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicCircle Represents a circle defined by center point and radius. <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Core__Utilities/","title":"Core System Utilities","text":"<p>System-level utilities for error handling and emergency states.  More...</p>"},{"location":"api/Modules/group__Core__Utilities/#files","title":"Files","text":"Name lib/config/ah_no.h Emergency halt helper used when unrecoverable errors occur."},{"location":"api/Modules/group__Core__Utilities/#functions","title":"Functions","text":"Name void CFBD_AH_NO(void )Enter an infinite halt state for unrecoverable errors."},{"location":"api/Modules/group__Core__Utilities/#detailed-description","title":"Detailed Description","text":"<p>System-level utilities for error handling and emergency states. </p> <p>These utilities provide critical functionality for managing system state during error conditions and emergency scenarios. </p>"},{"location":"api/Modules/group__Core__Utilities/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Core__Utilities/#function-cfbd_ah_no","title":"function CFBD_AH_NO","text":"<pre><code>static inline void CFBD_AH_NO(\n    void \n)\n</code></pre> <p>Enter an infinite halt state for unrecoverable errors. </p> <p>See: </p> <ul> <li>CFBD_Bool</li> <li>CFBD_FALSE</li> <li>CFBD_TRUE</li> </ul> <p>Note: Because the function does not return, callers should ensure any required side-effects (flush logs, disable interrupts, etc.) are performed prior to calling.</p> <p>Warning: This is a blocking operation that yields control indefinitely. It should only be called when recovery is impossible.</p> <p>Par: Example</p> <pre><code>#include \"lib/config/ah_no.h\"\n\nvoid critical_init() {\n    if (!hardware_initialized) {\n        // Could log error here before halt\n        CFBD_AH_NO();  // Never returns\n    }\n}\n</code></pre> <p>This function never returns. It is intended to be called from fatal error paths where continuing execution would be unsafe. Callers may optionally perform architecture-specific diagnostic actions (for example writing to a debug console) before invoking this helper.</p> <p>Common use cases:</p> <ul> <li>Null pointer dereference detection</li> <li>Memory allocation failures in critical subsystems</li> <li>Hardware initialization failures</li> <li>Watchdog timer expiration handling</li> <li>Stack corruption detection</li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Ellipse__Module/","title":"Ellipse Drawing","text":""},{"location":"api/Modules/group__Ellipse__Module/#classes","title":"Classes","text":"Name struct __CFBD_GraphicEllipse struct CFBD_GraphicEllipse Represents an ellipse defined by center point and two radii."},{"location":"api/Modules/group__Ellipse__Module/#types","title":"Types","text":"Name typedef struct __CFBD_GraphicEllipse CFBD_GraphicEllipse"},{"location":"api/Modules/group__Ellipse__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawEllipse(CFBD_GraphicDevice * device, CFBD_GraphicEllipse * ellipse) void CFBDGraphic_DrawFilledEllipse(CFBD_GraphicDevice * device, CFBD_GraphicEllipse * ellipse)"},{"location":"api/Modules/group__Ellipse__Module/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Ellipse__Module/#typedef-cfbd_graphicellipse","title":"typedef CFBD_GraphicEllipse","text":"<pre><code>typedef struct __CFBD_GraphicEllipse CFBD_GraphicEllipse;\n</code></pre>"},{"location":"api/Modules/group__Ellipse__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Ellipse__Module/#function-cfbdgraphic_drawellipse","title":"function CFBDGraphic_DrawEllipse","text":"<pre><code>void CFBDGraphic_DrawEllipse(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicEllipse * ellipse\n)\n</code></pre>"},{"location":"api/Modules/group__Ellipse__Module/#function-cfbdgraphic_drawfilledellipse","title":"function CFBDGraphic_DrawFilledEllipse","text":"<pre><code>void CFBDGraphic_DrawFilledEllipse(\n    CFBD_GraphicDevice * device,\n    CFBD_GraphicEllipse * ellipse\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Animation/","title":"Animation Framework","text":"<p>Frame-based animation system for graphics widgets.  More...</p>"},{"location":"api/Modules/group__Graphics__Animation/#classes","title":"Classes","text":"Name struct CFBD_BaseAnimationOps Operation callbacks for animation timing control. struct __CFBD_BaseAnimation struct CFBD_BaseAnimation Base animation state and configuration."},{"location":"api/Modules/group__Graphics__Animation/#types","title":"Types","text":"Name typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation"},{"location":"api/Modules/group__Graphics__Animation/#functions","title":"Functions","text":"Name void CFBD_InitBaseAnimation(CFBD_BaseAnimation * pBaseAnimation)"},{"location":"api/Modules/group__Graphics__Animation/#detailed-description","title":"Detailed Description","text":"<p>Frame-based animation system for graphics widgets. </p> <p>See: animation_config.hfor configuration parameters </p> <p>This module provides the core animation framework used throughout the graphics subsystem. It enables smooth visual transitions, UI element animations, and temporal effects.</p> <p>Key features:</p> <ul> <li>Frame-based animation timing</li> <li>Configurable animation duration and frame count</li> <li>Customizable delay callbacks for timing control</li> <li>Integration with widget and graphics subsystems</li> </ul> <p>Animations are created with CFBD_InitBaseAnimation() and configured through CFBD_BaseAnimationOps for delay handling.</p>"},{"location":"api/Modules/group__Graphics__Animation/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Graphics__Animation/#typedef-cfbd_baseanimation","title":"typedef CFBD_BaseAnimation","text":"<pre><code>typedef struct __CFBD_BaseAnimation CFBD_BaseAnimation;\n</code></pre>"},{"location":"api/Modules/group__Graphics__Animation/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__Animation/#function-cfbd_initbaseanimation","title":"function CFBD_InitBaseAnimation","text":"<pre><code>void CFBD_InitBaseAnimation(\n    CFBD_BaseAnimation * pBaseAnimation\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Defines/","title":"Graphics Core Definitions","text":"<p>Fundamental type definitions for graphics system. </p>"},{"location":"api/Modules/group__Graphics__Defines/#files","title":"Files","text":"Name lib/graphic/cfbd_graphic_define.h Core graphics type definitions and forward declarations."},{"location":"api/Modules/group__Graphics__Defines/#types","title":"Types","text":"Name typedef uint16_t PointBaseType Base type for point coordinate values. typedef PointBaseType SizeBaseType Base type for size dimension values. typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice Forward declaration of graphics device structure."},{"location":"api/Modules/group__Graphics__Defines/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Graphics__Defines/#typedef-pointbasetype","title":"typedef PointBaseType","text":"<pre><code>PointBaseType;\n</code></pre> <p>Base type for point coordinate values. </p> <p>See: CFBDGraphic_Point</p> <p>Used for X and Y coordinates in graphics operations. Using uint16_t allows coordinates from 0-65535, supporting displays up to 65K x 65K resolution. </p>"},{"location":"api/Modules/group__Graphics__Defines/#typedef-sizebasetype","title":"typedef SizeBaseType","text":"<pre><code>SizeBaseType;\n</code></pre> <p>Base type for size dimension values. </p> <p>See: CFBDGraphicSize</p> <p>Used for width and height dimensions in graphics operations. Identical to PointBaseType for consistent coordinate/size handling. </p>"},{"location":"api/Modules/group__Graphics__Defines/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre> <p>Forward declaration of graphics device structure. </p> <p>See: CFBD_GraphicDevice in [graphic_device.h]</p> <p>CFBD_GraphicDevice is the main graphics abstraction providing rendering operations. This forward declaration enables circular dependencies in device-related headers without requiring full device structure definition. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Device/","title":"Graphics Device Abstraction","text":"<p>Generic graphics device interface and operations.  More...</p>"},{"location":"api/Modules/group__Graphics__Device/#modules","title":"Modules","text":"Name OLED Graphics Device Adapter OLED-specific graphics device implementation."},{"location":"api/Modules/group__Graphics__Device/#classes","title":"Classes","text":"Name struct CFBD_GraphicDeviceOperation Virtual operation table for graphics device functionality. struct _CFBD_GraphicDevice struct CFBD_GraphicDevice The main graphics device object."},{"location":"api/Modules/group__Graphics__Device/#types","title":"Types","text":"Name enum CFBDGraphic_DeviceType { OLED}Enumeration of supported graphics device types. typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, uint16_t x, uint16_t y, uint16_t width, uint16_t height) GraphicAreaOperations Function pointer type for area-based graphics operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicFrameOperation Function pointer type for full-frame graphics operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device) GraphicOLEDSelfOperation Function pointer type for device lifecycle operations. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, const char *property, void *args, void *request_data) GraphicOLED_QueryOperation Function pointer type for querying device properties. typedef CFBD_Bool(*)(CFBD_GraphicDevice *device, const char *property, void *args, void *request_data) GraphicOLED_PropertySetsOperation Function pointer type for settings device properties. typedef void * CFBDGraphicDeviceHandle Opaque handle type for device-specific state."},{"location":"api/Modules/group__Graphics__Device/#functions","title":"Functions","text":"Name CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(CFBD_GraphicDevice * device) void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(CFBD_GraphicDevice * device, CFBD_Bool requests) void CFBDGraphic_DeviceClearImmediate(CFBD_GraphicDevice * device) void CFBDGraphic_BindDevice(CFBD_GraphicDevice * device, CFBDGraphic_DeviceType device_type, CFBDGraphicDeviceHandle internal_handle)"},{"location":"api/Modules/group__Graphics__Device/#detailed-description","title":"Detailed Description","text":"<p>Generic graphics device interface and operations. </p> <p>See: oled_graphic_device.hforOLED device binding </p> <p>This module defines the generic graphics device interface used by the graphics subsystem. It provides a unified API for controlling various graphics display hardware (OLED, LCD, LED matrices, etc.) through a standardized operation table.</p> <p>Key features:</p> <ul> <li>Device-agnostic rendering interface</li> <li>Support for immediate or deferred drawing modes</li> <li>Area-based and frame-based operations</li> <li>Device property queries</li> <li>Hardware binding flexibility</li> </ul>"},{"location":"api/Modules/group__Graphics__Device/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Graphics__Device/#enum-cfbdgraphic_devicetype","title":"enum CFBDGraphic_DeviceType","text":"Enumerator Value Description OLED OLED display device <p>Enumeration of supported graphics device types. </p> <p>Specifies which type of graphics hardware device is being used. Each device type may have different initialization parameters and rendering characteristics. </p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-cfbd_graphicdevice","title":"typedef CFBD_GraphicDevice","text":"<pre><code>typedef struct _CFBD_GraphicDevice CFBD_GraphicDevice;\n</code></pre>"},{"location":"api/Modules/group__Graphics__Device/#typedef-graphicareaoperations","title":"typedef GraphicAreaOperations","text":"<pre><code>GraphicAreaOperations;\n</code></pre> <p>Function pointer type for area-based graphics operations. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>x X coordinate of the area's top-left corner. </li> <li>y Y coordinate of the area's top-left corner. </li> <li>width Width of the area in pixels. </li> <li>height Height of the area in pixels.</li> </ul> <p>See: CFBD_GraphicDeviceOperationfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature handles rectangular area operations on the graphics device, such as updating, clearing, or reverting specific regions of the display.</p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-graphicframeoperation","title":"typedef GraphicFrameOperation","text":"<pre><code>GraphicFrameOperation;\n</code></pre> <p>Function pointer type for full-frame graphics operations. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> </ul> <p>See: CFBD_GraphicDeviceOperationfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature handles operations that affect the entire graphics frame, such as updating the complete display, clearing all pixels, or reverting to the previous frame content.</p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-graphicoledselfoperation","title":"typedef GraphicOLEDSelfOperation","text":"<pre><code>GraphicOLEDSelfOperation;\n</code></pre> <p>Function pointer type for device lifecycle operations. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> </ul> <p>See: CFBD_GraphicDeviceOperationfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature handles device lifecycle management operations such as opening (enabling) or closing (disabling) the graphics device.</p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-graphicoled_queryoperation","title":"typedef GraphicOLED_QueryOperation","text":"<pre><code>GraphicOLED_QueryOperation;\n</code></pre> <p>Function pointer type for querying device properties. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>property Null-terminated string naming the queried property. </li> <li>args Optional input arguments for the query (implementation-defined). </li> <li>request_data Output pointer where query results are written.</li> </ul> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure. </p> <p>This function pointer signature handles runtime queries for device capabilities and properties. Implementations should support standard properties: \"width\" (uint16_t), \"height\" (uint16_t), and \"rgb\" (CFBD_Bool).</p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-graphicoled_propertysetsoperation","title":"typedef GraphicOLED_PropertySetsOperation","text":"<pre><code>GraphicOLED_PropertySetsOperation;\n</code></pre> <p>Function pointer type for settings device properties. </p> <p>Parameters: </p> <ul> <li>device Pointer to the CFBD_GraphicDevice instance. </li> <li>property Null-terminated string naming the queried property. </li> <li>args Optional input arguments for the query (implementation-defined). </li> <li>request_data Output pointer where to write results are.</li> </ul> <p>See: CFBD_GraphicDeviceOperationfor operation table definition </p> <p>Return: CFBD_Bool CFBD_TRUE on success, CFBD_FALSE on failure.</p> <p>This function pointer signature handles runtime sets for device capabilities and properties. Implementations should support standard.</p>"},{"location":"api/Modules/group__Graphics__Device/#typedef-cfbdgraphicdevicehandle","title":"typedef CFBDGraphicDeviceHandle","text":"<pre><code>CFBDGraphicDeviceHandle;\n</code></pre> <p>Opaque handle type for device-specific state. </p>"},{"location":"api/Modules/group__Graphics__Device/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__Device/#function-cfbdgraphic_devicerequestupdateatonce","title":"function CFBDGraphic_DeviceRequestUpdateAtOnce","text":"<pre><code>static inline CFBD_Bool CFBDGraphic_DeviceRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Device/#function-cfbdgraphic_devicesetifrequestupdateatonce","title":"function CFBDGraphic_DeviceSetIfRequestUpdateAtOnce","text":"<pre><code>static inline void CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(\n    CFBD_GraphicDevice * device,\n    CFBD_Bool requests\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Device/#function-cfbdgraphic_deviceclearimmediate","title":"function CFBDGraphic_DeviceClearImmediate","text":"<pre><code>static inline void CFBDGraphic_DeviceClearImmediate(\n    CFBD_GraphicDevice * device\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Device/#function-cfbdgraphic_binddevice","title":"function CFBDGraphic_BindDevice","text":"<pre><code>void CFBDGraphic_BindDevice(\n    CFBD_GraphicDevice * device,\n    CFBDGraphic_DeviceType device_type,\n    CFBDGraphicDeviceHandle internal_handle\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Helpers/","title":"Graphics Utility Helpers","text":"<p>Utility macros and functions for graphics operations.  More...</p>"},{"location":"api/Modules/group__Graphics__Helpers/#functions","title":"Functions","text":"Name int32_t clamp_i32(int32_t v, int32_t lo, int32_t hi)"},{"location":"api/Modules/group__Graphics__Helpers/#defines","title":"Defines","text":"Name MAX(a, b) Return the maximum of two values. MIN(a, b) Return the minimum of two values."},{"location":"api/Modules/group__Graphics__Helpers/#detailed-description","title":"Detailed Description","text":"<p>Utility macros and functions for graphics operations. </p> <p>This module provides commonly used utility macros and inline functions to simplify graphics programming and reduce code duplication. These utilities cover common operations like value comparison, clamping, and boundary checking.</p> <p>Includes:</p> <ul> <li>MIN/MAX macros for value comparison</li> <li>Clamping function for range constraint</li> <li>Additional graphics-specific helpers</li> </ul>"},{"location":"api/Modules/group__Graphics__Helpers/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__Helpers/#function-clamp_i32","title":"function clamp_i32","text":"<pre><code>static inline int32_t clamp_i32(\n    int32_t v,\n    int32_t lo,\n    int32_t hi\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Helpers/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__Graphics__Helpers/#define-max","title":"define MAX","text":"<pre><code>#define MAX(\n    a,\n    b\n)\n((a) &gt; (b) ? (a) : (b))\n</code></pre> <p>Return the maximum of two values. </p> <p>Parameters: </p> <ul> <li>a First value to compare. </li> <li>b Second value to compare. </li> </ul> <p>Return: The maximum value.</p> <p>Note: Only defined if not already defined elsewhere. </p> <p>Evaluates to the greater of the two arguments. Arguments are evaluated only once when possible.</p>"},{"location":"api/Modules/group__Graphics__Helpers/#define-min","title":"define MIN","text":"<pre><code>#define MIN(\n    a,\n    b\n)\n((a) &lt; (b) ? (a) : (b))\n</code></pre> <p>Return the minimum of two values. </p> <p>Parameters: </p> <ul> <li>a First value to compare. </li> <li>b Second value to compare. </li> </ul> <p>Return: The minimum value.</p> <p>Note: Only defined if not already defined elsewhere. </p> <p>Evaluates to the lesser of the two arguments. Arguments are evaluated only once when possible.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__MenuConfig/","title":"Menu Configuration","text":"<p>Configuration parameters for menu widget appearance. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#defines","title":"Defines","text":"Name CFBD_MENU_INDICATOR_WIDTH Default menu indicator width in pixels. CFBD_MENU_INDICATOR_POSX Default menu indicator X position. CFBD_MENU_INDICATOR_MAX_WIDTH_PX Maximum menu indicator width in pixels. CFBD_MENU_INDICATOR_MAX_HEIGHT_PX Maximum menu indicator height in pixels. CFBD_MENU_INDICATOR_GAP Horizontal gap between indicator and menu items in pixels. CFBD_MENU_ITEM_Y_GAP Vertical gap between menu items in pixels."},{"location":"api/Modules/group__Graphics__MenuConfig/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_indicator_width","title":"define CFBD_MENU_INDICATOR_WIDTH","text":"<pre><code>#define CFBD_MENU_INDICATOR_WIDTH (4)\n</code></pre> <p>Default menu indicator width in pixels. </p> <p>See: CFBD_MENU_INDICATOR_MAX_WIDTH_PX</p> <p>Note: Valid range: 0-8 pixels </p> <p>Default sliding indicator bar width. Set to 0 to disable indicator. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_indicator_posx","title":"define CFBD_MENU_INDICATOR_POSX","text":"<pre><code>#define CFBD_MENU_INDICATOR_POSX (0)\n</code></pre> <p>Default menu indicator X position. </p> <p>See: CFBD_MenuIndicator</p> <p>Note: Typically 0 (left edge of menu) </p> <p>Left edge position of indicator bar in pixels. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_indicator_max_width_px","title":"define CFBD_MENU_INDICATOR_MAX_WIDTH_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_WIDTH_PX 8\n</code></pre> <p>Maximum menu indicator width in pixels. </p> <p>Hard limit for indicator width, prevents indicator from exceeding this value regardless of configuration. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_indicator_max_height_px","title":"define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX","text":"<pre><code>#define CFBD_MENU_INDICATOR_MAX_HEIGHT_PX 16\n</code></pre> <p>Maximum menu indicator height in pixels. </p> <p>Hard limit for indicator height to match typical menu item height. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_indicator_gap","title":"define CFBD_MENU_INDICATOR_GAP","text":"<pre><code>#define CFBD_MENU_INDICATOR_GAP (4)\n</code></pre> <p>Horizontal gap between indicator and menu items in pixels. </p> <p>Spacing between sliding indicator bar and item text. </p>"},{"location":"api/Modules/group__Graphics__MenuConfig/#define-cfbd_menu_item_y_gap","title":"define CFBD_MENU_ITEM_Y_GAP","text":"<pre><code>#define CFBD_MENU_ITEM_Y_GAP (0)\n</code></pre> <p>Vertical gap between menu items in pixels. </p> <p>Note: Set to 0 for tight packing, positive values for visual separation. </p> <p>Line spacing in pixels between consecutive menu items. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__OLED/","title":"OLED Graphics Device Adapter","text":"<p>Module: Graphics Device Abstraction</p> <p>OLED-specific graphics device implementation.  More...</p>"},{"location":"api/Modules/group__Graphics__OLED/#functions","title":"Functions","text":"Name void CFBDGraphic_BindOLEDAsDevice(CFBD_GraphicDevice * device, CFBD_OLED * oled)"},{"location":"api/Modules/group__Graphics__OLED/#detailed-description","title":"Detailed Description","text":"<p>OLED-specific graphics device implementation. </p> <p>This module implements the graphics device interface for OLED displays. It bridges the generic graphics API with OLED-specific hardware capabilities and rendering characteristics.</p> <p>The OLED graphics adapter enables:</p> <ul> <li>Standard graphics operations on OLED displays</li> <li>Seamless integration with the graphics widget framework</li> <li>Consistent rendering interface across different OLED controllers</li> </ul>"},{"location":"api/Modules/group__Graphics__OLED/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__OLED/#function-cfbdgraphic_bindoledasdevice","title":"function CFBDGraphic_BindOLEDAsDevice","text":"<pre><code>void CFBDGraphic_BindOLEDAsDevice(\n    CFBD_GraphicDevice * device,\n    CFBD_OLED * oled\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Resources/","title":"Graphics Resources","text":"<p>Resource management and configuration for graphics subsystem.  More...</p>"},{"location":"api/Modules/group__Graphics__Resources/#files","title":"Files","text":"Name lib/graphic/resource/config.h Graphics resource configuration and feature toggles."},{"location":"api/Modules/group__Graphics__Resources/#defines","title":"Defines","text":"Name ENABLE_ASCII_6x8_SOURCES Enable/disable 6x8 pixel ASCII font resource. ENABLE_ASCII_8x16_SOURCES Enable/disable 8x16 pixel ASCII font resource."},{"location":"api/Modules/group__Graphics__Resources/#detailed-description","title":"Detailed Description","text":"<p>Resource management and configuration for graphics subsystem. </p> <p>This module manages the configuration of graphics resources including character fonts, textures, and other rendering assets. It provides compile-time feature selection and resource management.</p>"},{"location":"api/Modules/group__Graphics__Resources/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__Graphics__Resources/#define-enable_ascii_6x8_sources","title":"define ENABLE_ASCII_6x8_SOURCES","text":"<pre><code>#define ENABLE_ASCII_6x8_SOURCES 1\n</code></pre> <p>Enable/disable 6x8 pixel ASCII font resource. </p> <p>Controls compilation of the 6x8 pixel ASCII font. This compact font is useful for dense text or small screens.</p> <p>Default: 1 (enabled) Can be disabled by defining DISABLE_ASCII_6X8_SOURCES. </p>"},{"location":"api/Modules/group__Graphics__Resources/#define-enable_ascii_8x16_sources","title":"define ENABLE_ASCII_8x16_SOURCES","text":"<pre><code>#define ENABLE_ASCII_8x16_SOURCES 1\n</code></pre> <p>Enable/disable 8x16 pixel ASCII font resource. </p> <p>Controls compilation of the 8x16 pixel ASCII font. This standard font provides good readability for most applications.</p> <p>Default: 1 (enabled) Can be disabled by defining DISABLE_ASCII_8X16_SOURCES. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__Text/","title":"Text Widget System","text":"<p>Text rendering and typography system.  More...</p>"},{"location":"api/Modules/group__Graphics__Text/#modules","title":"Modules","text":"Name Text Configuration Font size and text rendering configuration."},{"location":"api/Modules/group__Graphics__Text/#files","title":"Files","text":"Name lib/graphic/widget/text.h Text widget for rendering ASCII text strings. lib/graphic/widget/text_config.h Text widget font configuration and selection."},{"location":"api/Modules/group__Graphics__Text/#classes","title":"Classes","text":"Name struct CFBDGraphic_Text"},{"location":"api/Modules/group__Graphics__Text/#types","title":"Types","text":"Name enum AppendMethod { CCGraphic_AsciiTextItem_AppendContinously, CCGraphic_AsciiTextItem_AppendNextLine, CCGraphic_AsciiTextItem_RequestOldPoint}Text append/layout method enumeration."},{"location":"api/Modules/group__Graphics__Text/#functions","title":"Functions","text":"Name void CFBDGraphic_InitText(CFBDGraphic_Text * item, CFBDGraphic_Point tl_point, CFBDGraphicSize textHandleSize, Ascii_Font_Size text_size) void CFBDGraphic_SetText(CFBDGraphic_Text * item, char * text) void CFBDGraphic_SetTextTLPointPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CFBDGraphic_SetTextIndexedPoint(CFBDGraphic_Text * item, CFBDGraphic_Point * p) void CCGraphicWidget_AsciiTextItem_relocate(CFBDGraphic_Text * item, CFBDGraphic_Point * tl_point, CFBDGraphicSize textHandleSize) CFBDGraphic_Point CFBDGraphic_DrawText(CFBD_GraphicDevice * device_handle, CFBDGraphic_Text * item, AppendMethod method)"},{"location":"api/Modules/group__Graphics__Text/#defines","title":"Defines","text":"Name CFBDGraphic_TEXT_PADDING_WIDTH Default horizontal padding between characters in pixels. CFBDGraphic_TEXT_PADDING_HEIGHT Default vertical padding between lines in pixels."},{"location":"api/Modules/group__Graphics__Text/#detailed-description","title":"Detailed Description","text":"<p>Text rendering and typography system. </p> <p>Comprehensive text widget supporting multiple fonts, multiline rendering, and flexible layout options. </p>"},{"location":"api/Modules/group__Graphics__Text/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Graphics__Text/#enum-appendmethod","title":"enum AppendMethod","text":"Enumerator Value Description CCGraphic_AsciiTextItem_AppendContinously Continue on same line, wrap to next when reaching width limit.  Standard paragraph layout mode CCGraphic_AsciiTextItem_AppendNextLine Start new line for next text segment.  Forces line break after rendering CCGraphic_AsciiTextItem_RequestOldPoint Return to previous line's ending position without drawing.  Query-only mode: returns position without rendering <p>Text append/layout method enumeration. </p> <p>Specifies how to layout text when drawing:</p> <ul> <li>Continuously on same line with wrapping</li> <li>Start new line after each character/word</li> <li>Query previous render position CFBDGraphic_DrawText()</li> </ul>"},{"location":"api/Modules/group__Graphics__Text/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__Text/#function-cfbdgraphic_inittext","title":"function CFBDGraphic_InitText","text":"<pre><code>void CFBDGraphic_InitText(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point tl_point,\n    CFBDGraphicSize textHandleSize,\n    Ascii_Font_Size text_size\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#function-cfbdgraphic_settext","title":"function CFBDGraphic_SetText","text":"<pre><code>static inline void CFBDGraphic_SetText(\n    CFBDGraphic_Text * item,\n    char * text\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#function-cfbdgraphic_settexttlpointpoint","title":"function CFBDGraphic_SetTextTLPointPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextTLPointPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#function-cfbdgraphic_settextindexedpoint","title":"function CFBDGraphic_SetTextIndexedPoint","text":"<pre><code>static inline void CFBDGraphic_SetTextIndexedPoint(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * p\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#function-ccgraphicwidget_asciitextitem_relocate","title":"function CCGraphicWidget_AsciiTextItem_relocate","text":"<pre><code>static inline void CCGraphicWidget_AsciiTextItem_relocate(\n    CFBDGraphic_Text * item,\n    CFBDGraphic_Point * tl_point,\n    CFBDGraphicSize textHandleSize\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#function-cfbdgraphic_drawtext","title":"function CFBDGraphic_DrawText","text":"<pre><code>CFBDGraphic_Point CFBDGraphic_DrawText(\n    CFBD_GraphicDevice * device_handle,\n    CFBDGraphic_Text * item,\n    AppendMethod method\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__Text/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__Graphics__Text/#define-cfbdgraphic_text_padding_width","title":"define CFBDGraphic_TEXT_PADDING_WIDTH","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_WIDTH (1)\n</code></pre> <p>Default horizontal padding between characters in pixels. </p> <p>See: CFBDGraphic_TEXT_PADDING_HEIGHT</p> <p>Space added between consecutive characters for visual separation. Set to 1 pixel for standard monospace layout. </p>"},{"location":"api/Modules/group__Graphics__Text/#define-cfbdgraphic_text_padding_height","title":"define CFBDGraphic_TEXT_PADDING_HEIGHT","text":"<pre><code>#define CFBDGraphic_TEXT_PADDING_HEIGHT (0)\n</code></pre> <p>Default vertical padding between lines in pixels. </p> <p>See: CFBDGraphic_TEXT_PADDING_WIDTH</p> <p>Space added between text lines for multiline text. Set to 0 for tight line spacing. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Graphics__TextConfig/","title":"Text Configuration","text":"<p>Module: Text Widget System</p> <p>Font size and text rendering configuration.  More...</p>"},{"location":"api/Modules/group__Graphics__TextConfig/#files","title":"Files","text":"Name lib/graphic/widget/text_config.h Text widget font configuration and selection."},{"location":"api/Modules/group__Graphics__TextConfig/#types","title":"Types","text":"Name enum Ascii_Font_Size { NO_ASCII_SIZE}Enumeration of available ASCII font sizes. enum Unicode_Font_Size { Unicode_16x16}Enumeration of available Unicode font sizes."},{"location":"api/Modules/group__Graphics__TextConfig/#functions","title":"Functions","text":"Name uint8_t * __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch) CFBDGraphicSize __fetch_font_size(const Ascii_Font_Size s)"},{"location":"api/Modules/group__Graphics__TextConfig/#defines","title":"Defines","text":"Name UNSUPPORTIVE_FONT_SOURCE"},{"location":"api/Modules/group__Graphics__TextConfig/#detailed-description","title":"Detailed Description","text":"<p>Font size and text rendering configuration. </p> <p>Compile-time configuration system for text resources, controlled by resource/config.h macros. </p>"},{"location":"api/Modules/group__Graphics__TextConfig/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__Graphics__TextConfig/#enum-ascii_font_size","title":"enum Ascii_Font_Size","text":"Enumerator Value Description NO_ASCII_SIZE Sentinel value indicating no valid font size available. <p>Enumeration of available ASCII font sizes. </p> <p>Specifies available monospace font sizes for text rendering. Enabled fonts are determined at compile-time via:</p> <ul> <li><code>ENABLE_ASCII_6x8_SOURCES</code> (6x8 pixel font)</li> <li><code>ENABLE_ASCII_8x16_SOURCES</code> (8x16 pixel font) Current implementation supports:</li> </ul> <p>6x8: 6 pixels wide x 8 pixels tall per character</p> <ul> <li> <p>8x16: 8 pixels wide x 16 pixels tall per character To add more fonts:</p> </li> <li> <p>Provide font bitmap data source</p> </li> <li>Implement __select_from_ascii_font_size() for new size</li> <li>Add enable macro in resource/config.h__select_from_ascii_font_size()</li> </ul> <p>__fetch_font_size()</p>"},{"location":"api/Modules/group__Graphics__TextConfig/#enum-unicode_font_size","title":"enum Unicode_Font_Size","text":"Enumerator Value Description Unicode_16x16 16x16 pixel Unicode font - for CJK and other wide characters <p>Enumeration of available Unicode font sizes. </p> <p>See: Ascii_Font_Size</p> <p>Note: Unicode support requires:</p> <ul> <li>Additional memory for character data (Chinese, Japanese, etc.)</li> <li>Larger display for readable text</li> <li>Future implementation phase </li> </ul> <p>Specifies Unicode font sizes for international character support. Currently supports 16x16 pixel Unicode characters. </p>"},{"location":"api/Modules/group__Graphics__TextConfig/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Graphics__TextConfig/#function-__select_from_ascii_font_size","title":"function __select_from_ascii_font_size","text":"<pre><code>uint8_t * __select_from_ascii_font_size(\n    const Ascii_Font_Size s,\n    const char ch\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__TextConfig/#function-__fetch_font_size","title":"function __fetch_font_size","text":"<pre><code>CFBDGraphicSize __fetch_font_size(\n    const Ascii_Font_Size s\n)\n</code></pre>"},{"location":"api/Modules/group__Graphics__TextConfig/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__Graphics__TextConfig/#define-unsupportive_font_source","title":"define UNSUPPORTIVE_FONT_SOURCE","text":"<pre><code>#define UNSUPPORTIVE_FONT_SOURCE ((void*) 0)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__IconTextMenu/","title":"Icon-Text Menu Widget","text":"<p>Horizontal scrollable menu for icon+text display.  More...</p>"},{"location":"api/Modules/group__IconTextMenu/#classes","title":"Classes","text":"Name struct CFBD_IconTextMenuItem struct _CFBD_IconTextMenuOps Operation table for icon-text menu. struct _CFBD_IconTextMenu"},{"location":"api/Modules/group__IconTextMenu/#types","title":"Types","text":"Name enum CFBD_IconTextMenuItemState { CFBD_ICONTEXT_ITEM_NORMAL = 0, CFBD_ICONTEXT_ITEM_FOCUSED = 1, CFBD_ICONTEXT_ITEM_PRESSED = 2, CFBD_ICONTEXT_ITEM_DISABLED = 3}Menu item visual state enumeration. enum CFBD_IconTextScrollDirection { CFBD_ICONTEXT_SCROLL_LEFT = -1, CFBD_ICONTEXT_SCROLL_RIGHT = 1, CFBD_ICONTEXT_SCROLL_NONE = 0}Scroll direction enumeration. typedef struct _CFBD_IconTextMenuOps CFBD_IconTextMenuOps Operation table for icon-text menu. typedef struct _CFBD_IconTextMenu CFBD_IconTextMenu Forward declaration of icon-text menu structure."},{"location":"api/Modules/group__IconTextMenu/#functions","title":"Functions","text":"Name void CFBD_InitIconTextMenu(CFBD_IconTextMenu * pMenu, CFBD_GraphicDevice * device, CFBDGraphicRect * viewport, CFBD_IconTextMenuItem * items_buffer, size_t capacity)"},{"location":"api/Modules/group__IconTextMenu/#defines","title":"Defines","text":"Name CFBD_ICONTEXT_MENU_DEFAULT_ITEM_WIDTH Configuration constants for icon-text menu. CFBD_ICONTEXT_MENU_DEFAULT_ITEM_HEIGHT Height of each menu item. CFBD_ICONTEXT_MENU_ICON_SIZE Icon bitmap dimensions. CFBD_ICONTEXT_MENU_ICON_TEXT_GAP Gap between icon and text. CFBD_ICONTEXT_MENU_TEXT_SIZE Font size for labels. CFBD_ICONTEXT_MENU_ANIMATION_DURATION_MS Scroll animation duration. CFBD_ICONTEXT_MENU_VISIBLE_ITEMS Number of visible items."},{"location":"api/Modules/group__IconTextMenu/#detailed-description","title":"Detailed Description","text":"<p>Horizontal scrollable menu for icon+text display. </p> <p>Menu system with icon+text items, designed for small screens with smooth animations and gesture-based navigation. </p>"},{"location":"api/Modules/group__IconTextMenu/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__IconTextMenu/#enum-cfbd_icontextmenuitemstate","title":"enum CFBD_IconTextMenuItemState","text":"Enumerator Value Description CFBD_ICONTEXT_ITEM_NORMAL 0 Default unselected state. CFBD_ICONTEXT_ITEM_FOCUSED 1 Item has focus/is selected. CFBD_ICONTEXT_ITEM_PRESSED 2 Item is being pressed/activated. CFBD_ICONTEXT_ITEM_DISABLED 3 Item is disabled/unavailable. <p>Menu item visual state enumeration. </p> <p>Indicates the current visual state of a menu item </p>"},{"location":"api/Modules/group__IconTextMenu/#enum-cfbd_icontextscrolldirection","title":"enum CFBD_IconTextScrollDirection","text":"Enumerator Value Description CFBD_ICONTEXT_SCROLL_LEFT -1 Scroll towards previous items. CFBD_ICONTEXT_SCROLL_RIGHT 1 Scroll towards next items. CFBD_ICONTEXT_SCROLL_NONE 0 No scrolling. <p>Scroll direction enumeration. </p>"},{"location":"api/Modules/group__IconTextMenu/#typedef-cfbd_icontextmenuops","title":"typedef CFBD_IconTextMenuOps","text":"<pre><code>typedef struct _CFBD_IconTextMenuOps CFBD_IconTextMenuOps;\n</code></pre> <p>Operation table for icon-text menu. </p> <p>Virtual function table for icon-text menu operations </p>"},{"location":"api/Modules/group__IconTextMenu/#typedef-cfbd_icontextmenu","title":"typedef CFBD_IconTextMenu","text":"<pre><code>typedef struct _CFBD_IconTextMenu CFBD_IconTextMenu;\n</code></pre> <p>Forward declaration of icon-text menu structure. </p> <p>Main icon-text menu widget structure.</p> <p>Manages scrollable menu state including items, animations, selection, and scroll position. </p>"},{"location":"api/Modules/group__IconTextMenu/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__IconTextMenu/#function-cfbd_initicontextmenu","title":"function CFBD_InitIconTextMenu","text":"<pre><code>void CFBD_InitIconTextMenu(\n    CFBD_IconTextMenu * pMenu,\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * viewport,\n    CFBD_IconTextMenuItem * items_buffer,\n    size_t capacity\n)\n</code></pre>"},{"location":"api/Modules/group__IconTextMenu/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_default_item_width","title":"define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_WIDTH","text":"<pre><code>#define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_WIDTH (60)\n</code></pre> <p>Configuration constants for icon-text menu. </p> <p>Width of each menu item </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_default_item_height","title":"define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_HEIGHT","text":"<pre><code>#define CFBD_ICONTEXT_MENU_DEFAULT_ITEM_HEIGHT (80)\n</code></pre> <p>Height of each menu item. </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_icon_size","title":"define CFBD_ICONTEXT_MENU_ICON_SIZE","text":"<pre><code>#define CFBD_ICONTEXT_MENU_ICON_SIZE (48)\n</code></pre> <p>Icon bitmap dimensions. </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_icon_text_gap","title":"define CFBD_ICONTEXT_MENU_ICON_TEXT_GAP","text":"<pre><code>#define CFBD_ICONTEXT_MENU_ICON_TEXT_GAP (4)\n</code></pre> <p>Gap between icon and text. </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_text_size","title":"define CFBD_ICONTEXT_MENU_TEXT_SIZE","text":"<pre><code>#define CFBD_ICONTEXT_MENU_TEXT_SIZE ASCII_6x8\n</code></pre> <p>Font size for labels. </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_animation_duration_ms","title":"define CFBD_ICONTEXT_MENU_ANIMATION_DURATION_MS","text":"<pre><code>#define CFBD_ICONTEXT_MENU_ANIMATION_DURATION_MS (300)\n</code></pre> <p>Scroll animation duration. </p>"},{"location":"api/Modules/group__IconTextMenu/#define-cfbd_icontext_menu_visible_items","title":"define CFBD_ICONTEXT_MENU_VISIBLE_ITEMS","text":"<pre><code>#define CFBD_ICONTEXT_MENU_VISIBLE_ITEMS (3)\n</code></pre> <p>Number of visible items. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Line__Module/","title":"Line Drawing","text":""},{"location":"api/Modules/group__Line__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Line Represents a line segment defined by two endpoints."},{"location":"api/Modules/group__Line__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawLine(CFBD_GraphicDevice * handler, CFBDGraphic_Line * line)"},{"location":"api/Modules/group__Line__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Line__Module/#function-cfbdgraphic_drawline","title":"function CFBDGraphic_DrawLine","text":"<pre><code>void CFBDGraphic_DrawLine(\n    CFBD_GraphicDevice * handler,\n    CFBDGraphic_Line * line\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__OLED/","title":"OLED Display Driver","text":"<p>More...</p>"},{"location":"api/Modules/group__OLED/#modules","title":"Modules","text":"Name OLED Backend Implementations Backend transport implementations (I2C, SPI) for OLED drivers. OLED Device Interface Device-specific descriptors and configurations for OLED drivers."},{"location":"api/Modules/group__OLED/#namespaces","title":"Namespaces","text":"Name CFBD::OLED OLED display driver subsystem *."},{"location":"api/Modules/group__OLED/#detailed-description","title":"Detailed Description","text":"<p>See: </p> <ul> <li>driver/device/device_interface.hfor device descriptor interface </li> <li>driver/backend/oled_iic.h for I2C backend initialization </li> <li>driver/device/ssd1306/ssd1306.hfor SSD1306 implementation </li> <li>driver/device/ssd1309/ssd1309.hfor SSD1309 implementation </li> </ul> <p>Version: 0.1 </p> <p>Date: 2026-01-09</p> <p>This module defines the core OLED subsystem API: the generic CFBD_OLED object, operation table (CFBD_OLEDOperations), and supporting types used throughout the driver ecosystem. Concrete device drivers (SSD1306, SSD1309, etc.) implement and populate the operation table to provide a uniform API to application code.</p> <p>The module provides:</p> <ul> <li>Device abstraction via CFBD_OLED structure</li> <li>Operation tables for rendering, updates, and device management</li> <li>Transport-agnostic driver type selection (I2C or SPI)</li> <li>Query interface for device capabilities</li> <li>Area-based and frame-based operations</li> </ul> <p>Application code should interact primarily through:</p> <ul> <li>CFBD_GetOLEDHandle() for device initialization</li> <li>Operations in the ops table for rendering (setPixel, setArea, update, etc.)</li> <li>Query operations for device properties (resolution, RGB support)</li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__OLED__Backend/","title":"OLED Backend Implementations","text":"<p>Module: OLED Display Driver</p> <p>Backend transport implementations (I2C, SPI) for OLED drivers.  More...</p>"},{"location":"api/Modules/group__OLED__Backend/#functions","title":"Functions","text":"Name void CFBD_OLED_IIC130XInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle) void CFBD_OLED_IIC132XInit(CFBD_OLED * handle, CFBD_OLED_IICInitsParams * pvt_handle)"},{"location":"api/Modules/group__OLED__Backend/#detailed-description","title":"Detailed Description","text":"<p>Backend transport implementations (I2C, SPI) for OLED drivers. </p> <p>This group contains transport-specific implementations for communicating with OLED devices. Each backend (I2C, SPI) provides initialization routines to wire transport parameters with the generic OLED driver.</p> <p>Backends must handle:</p> <ul> <li>Device address/chip-select configuration</li> <li>Transport handle binding</li> <li>Asynchronous transaction notifications</li> <li>Error handling and retry logic<ul> <li> <ul> <li>Backend implementation organization</li> </ul> </li> <li> <ul> <li>Transport abstraction documentation</li> </ul> </li> <li> <ul> <li>Function Documentation:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_IICInit(): Complete I2C initialization with:</li> </ul> </li> <li> <ul> <li>Parameter descriptions</li> </ul> </li> <li> <ul> <li>Step-by-step initialization flow</li> </ul> </li> <li> <ul> <li>Complete working example</li> </ul> </li> <li> <ul> <li>Thread-safety notes</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#example-supported-property-queries","title":"Example: Supported Property Queries","text":"<ul> <li> <ul> <li>The documentation now clearly specifies all supported property queries:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Query display width</code></li> <li><code>uint16_t width = 0;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);</code></li> <li>``</li> <li><code>// Query display height &lt;br&gt;</code></li> <li><code>uint16_t height = 0;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);</code></li> <li>``</li> <li><code>// Query RGB color support</code></li> <li><code>CFBD_bool is_rgb = CFBD_FALSE;</code></li> <li><code>oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#expected-doxygen-generation","title":"Expected Doxygen Generation","text":"<ul> <li> <ul> <li>When Doxygen processes these enhanced comments, it will generate:</li> </ul> </li> <li> <ul> <li>Modules Tab:</li> </ul> </li> <li> <ul> <li>OLED - OLED Display Driver (main group)</li> </ul> </li> <li> <ul> <li>OLED_Device - OLED Device Interface</li> </ul> </li> <li> <ul> <li>OLED_Backend - OLED Backend Implementations</li> </ul> </li> <li> <ul> <li>Examples Tab:</li> </ul> </li> <li> <ul> <li>Multiple code examples from </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Backend/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__OLED__Backend/#function-cfbd_oled_iic130xinit","title":"function CFBD_OLED_IIC130XInit","text":"<pre><code>void CFBD_OLED_IIC130XInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre>"},{"location":"api/Modules/group__OLED__Backend/#function-cfbd_oled_iic132xinit","title":"function CFBD_OLED_IIC132XInit","text":"<pre><code>void CFBD_OLED_IIC132XInit(\n    CFBD_OLED * handle,\n    CFBD_OLED_IICInitsParams * pvt_handle\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__OLED__Device/","title":"OLED Device Interface","text":"<p>Module: OLED Display Driver</p> <p>Device-specific descriptors and configurations for OLED drivers.  More...</p>"},{"location":"api/Modules/group__OLED__Device/#files","title":"Files","text":"Name lib/oled/driver/device/device_interface.h Generic device descriptor used by OLED drivers. lib/oled/driver/device/ssd1306/ssd1306.h SSD1306 device-specific descriptor and factory. lib/oled/driver/device/ssd1309/ssd1309.h SSD1309 device-specific descriptor and factory."},{"location":"api/Modules/group__OLED__Device/#classes","title":"Classes","text":"Name struct CFBD_OLED_DeviceSpecific Device-specific configuration for an OLED panel."},{"location":"api/Modules/group__OLED__Device/#defines","title":"Defines","text":"Name SSD1309_DRIVER_ADDRESS Default I2C address for SSD1309 devices."},{"location":"api/Modules/group__OLED__Device/#detailed-description","title":"Detailed Description","text":"<p>Device-specific descriptors and configurations for OLED drivers. </p> <p>See: </p> <ul> <li>ssd1306.hfor SSD1306 implementation </li> <li>ssd1309.hfor SSD1309 implementation</li> </ul> <p>This module provides the generic device descriptor interface used by all OLED drivers. It abstracts hardware-specific details into a standardized structure that concrete device implementations (SSD1306, SSD1309, etc.) populate with device-specific data.</p> <p>Device drivers must provide:</p> <ul> <li>Initialization command tables</li> <li>GRAM/frame buffer pointers</li> <li>Communication prefixes (for I2C data/command differentiation)</li> <li> <p>Display geometry information</p> </li> <li> <ul> <li>Hierarchical module organization</li> </ul> </li> <li> <ul> <li>Cross-references to device implementations</li> </ul> </li> <li> <ul> <li>Module relationships</li> </ul> </li> <li> <ul> <li>Structure Documentation:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_DeviceSpecific: Comprehensive documentation with:</li> </ul> </li> <li> <ul> <li>Field descriptions</li> </ul> </li> <li> <ul> <li>Implementation requirements</li> </ul> </li> <li> <ul> <li>Usage examples</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#device-driver-enhancements","title":"Device Driver Enhancements","text":"<ul> <li> <ul> <li>ssd1306.h:</li> </ul> </li> <li> <ul> <li>Extended file documentation with SSD1306 capabilities</li> </ul> </li> <li> <ul> <li>getSSD1306Specific(): Complete factory function documentation</li> </ul> </li> <li> <ul> <li>Usage examples and cross-references</li> </ul> </li> <li> <ul> <li>ssd1309.h:</li> </ul> </li> <li> <ul> <li>Extended file documentation with SSD1309 enhancements</li> </ul> </li> <li> <ul> <li>SSD1309_DRIVER_ADDRESS: Address constant documentation</li> </ul> </li> <li> <ul> <li>getSSD1309Specific(): Comprehensive factory documentation</li> </ul> </li> <li> <ul> <li>Multi-example usage patterns</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#oled_iich-enhancements","title":"oled_iic.h Enhancements","text":"<ul> <li> <ul> <li>**New </li> </ul> </li> </ul>"},{"location":"api/Modules/group__OLED__Device/#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Modules/group__OLED__Device/#define-ssd1309_driver_address","title":"define SSD1309_DRIVER_ADDRESS","text":"<pre><code>#define SSD1309_DRIVER_ADDRESS (0x78)\n</code></pre> <p>Default I2C address for SSD1309 devices. </p> <p>Note: This address is used when initializing I2C communication with the SSD1309 device. </p> <p>The standard I2C address for SSD1309 OLED controllers is 0x78 (0111 1000). This is the primary address used for single-device configurations. Some modules may support alternative addresses via hardware configuration.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Point__Module/","title":"Point Utilities","text":""},{"location":"api/Modules/group__Point__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Point Represents a 2D point in the graphics coordinate system. struct CFBDGraphic_Vec2i Represents a 2D vector with signed 32-bit integer components."},{"location":"api/Modules/group__Point__Module/#functions","title":"Functions","text":"Name CFBDGraphic_Point point_add(CFBDGraphic_Point a, CFBDGraphic_Point b) CFBDGraphic_Vec2i point_sub(CFBDGraphic_Point a, CFBDGraphic_Point b)"},{"location":"api/Modules/group__Point__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Point__Module/#function-point_add","title":"function point_add","text":"<pre><code>static inline CFBDGraphic_Point point_add(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre>"},{"location":"api/Modules/group__Point__Module/#function-point_sub","title":"function point_sub","text":"<pre><code>static inline CFBDGraphic_Vec2i point_sub(\n    CFBDGraphic_Point a,\n    CFBDGraphic_Point b\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Advanced/","title":"Advanced Rectangle Operations","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Complex rectangle manipulation and analysis functions. </p>"},{"location":"api/Modules/group__RectUtil__Advanced/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_intersection(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_union(const CFBDGraphicRect * a, const CFBDGraphicRect * b) CFBDGraphicRect rect_offset(const CFBDGraphicRect * r, int32_t dx, int32_t dy) CFBDGraphicRect rect_inset(const CFBDGraphicRect * r, int32_t left, int32_t top, int32_t right, int32_t bottom) CFBDGraphicRect rect_scale_about_center(const CFBDGraphicRect * r, float sx, float sy) CFBDGraphicRect rect_align_in_parent(const CFBDGraphicRect * parent, const CFBDGraphicRect * child, uint8_t anchor) CFBDGraphic_Point rect_closest_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) uint32_t rect_distance_to_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBDGraphicRect rect_expand_to_include_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_clip_line(CFBDGraphicRect * r, CFBDGraphic_Point * p0, CFBDGraphic_Point * p1) CFBDGraphicRect rect_clamp_to_screen(const CFBDGraphicRect * r, uint16_t screen_w, uint16_t screen_h) uint32_t rect_area(const CFBDGraphicRect * r) CFBDGraphicSize rect_size(const CFBDGraphicRect * r) uint32_t rect_overlap_area(const CFBDGraphicRect * a, const CFBDGraphicRect * b)"},{"location":"api/Modules/group__RectUtil__Advanced/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_intersection","title":"function rect_intersection","text":"<pre><code>CFBDGraphicRect rect_intersection(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_union","title":"function rect_union","text":"<pre><code>CFBDGraphicRect rect_union(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_offset","title":"function rect_offset","text":"<pre><code>CFBDGraphicRect rect_offset(\n    const CFBDGraphicRect * r,\n    int32_t dx,\n    int32_t dy\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_inset","title":"function rect_inset","text":"<pre><code>CFBDGraphicRect rect_inset(\n    const CFBDGraphicRect * r,\n    int32_t left,\n    int32_t top,\n    int32_t right,\n    int32_t bottom\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_scale_about_center","title":"function rect_scale_about_center","text":"<pre><code>CFBDGraphicRect rect_scale_about_center(\n    const CFBDGraphicRect * r,\n    float sx,\n    float sy\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_align_in_parent","title":"function rect_align_in_parent","text":"<pre><code>CFBDGraphicRect rect_align_in_parent(\n    const CFBDGraphicRect * parent,\n    const CFBDGraphicRect * child,\n    uint8_t anchor\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_closest_point","title":"function rect_closest_point","text":"<pre><code>CFBDGraphic_Point rect_closest_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_distance_to_point","title":"function rect_distance_to_point","text":"<pre><code>uint32_t rect_distance_to_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_expand_to_include_point","title":"function rect_expand_to_include_point","text":"<pre><code>CFBDGraphicRect rect_expand_to_include_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_clip_line","title":"function rect_clip_line","text":"<pre><code>CFBD_Bool rect_clip_line(\n    CFBDGraphicRect * r,\n    CFBDGraphic_Point * p0,\n    CFBDGraphic_Point * p1\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_clamp_to_screen","title":"function rect_clamp_to_screen","text":"<pre><code>CFBDGraphicRect rect_clamp_to_screen(\n    const CFBDGraphicRect * r,\n    uint16_t screen_w,\n    uint16_t screen_h\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_area","title":"function rect_area","text":"<pre><code>static inline uint32_t rect_area(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_size","title":"function rect_size","text":"<pre><code>static inline CFBDGraphicSize rect_size(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Advanced/#function-rect_overlap_area","title":"function rect_overlap_area","text":"<pre><code>static inline uint32_t rect_overlap_area(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Anchor/","title":"Anchor Flags","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Flags for specifying rectangle alignment anchors. </p>"},{"location":"api/Modules/group__RectUtil__Anchor/#types","title":"Types","text":"Name enum CCGraphicAnchor { RECT_ANCHOR_LEFT = 1 &lt;&lt; 0, RECT_ANCHOR_HCENTER = 1 &lt;&lt; 1, RECT_ANCHOR_RIGHT = 1 &lt;&lt; 2, RECT_ANCHOR_TOP = 1 &lt;&lt; 3, RECT_ANCHOR_VCENTER = 1 &lt;&lt; 4, RECT_ANCHOR_BOTTOM = 1 &lt;&lt; 5}Defines anchor points for rectangle alignment operations."},{"location":"api/Modules/group__RectUtil__Anchor/#types-documentation","title":"Types Documentation","text":""},{"location":"api/Modules/group__RectUtil__Anchor/#enum-ccgraphicanchor","title":"enum CCGraphicAnchor","text":"Enumerator Value Description RECT_ANCHOR_LEFT 1 &lt;&lt; 0 Align to left edge (horizontal) RECT_ANCHOR_HCENTER 1 &lt;&lt; 1 Align to horizontal center RECT_ANCHOR_RIGHT 1 &lt;&lt; 2 Align to right edge (horizontal) RECT_ANCHOR_TOP 1 &lt;&lt; 3 Align to top edge (vertical) RECT_ANCHOR_VCENTER 1 &lt;&lt; 4 Align to vertical center RECT_ANCHOR_BOTTOM 1 &lt;&lt; 5 Align to bottom edge (vertical) <p>Defines anchor points for rectangle alignment operations. </p> <p>These flags specify horizontal and vertical anchor positions. Use bitwise OR to combine one horizontal and one vertical flag. </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Containment/","title":"Point and Rectangle Containment","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Functions to check containment and intersection relationships. </p>"},{"location":"api/Modules/group__RectUtil__Containment/#functions","title":"Functions","text":"Name CFBD_Bool rect_contains_point(const CFBDGraphicRect * r, CFBDGraphic_Point p) CFBD_Bool rect_intersects(const CFBDGraphicRect * a, const CFBDGraphicRect * b)"},{"location":"api/Modules/group__RectUtil__Containment/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Containment/#function-rect_contains_point","title":"function rect_contains_point","text":"<pre><code>static inline CFBD_Bool rect_contains_point(\n    const CFBDGraphicRect * r,\n    CFBDGraphic_Point p\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Containment/#function-rect_intersects","title":"function rect_intersects","text":"<pre><code>static inline CFBD_Bool rect_intersects(\n    const CFBDGraphicRect * a,\n    const CFBDGraphicRect * b\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Conversion/","title":"Rectangle Format Conversion","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Conversion between different rectangle representations. </p>"},{"location":"api/Modules/group__RectUtil__Conversion/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_from_xywh(int32_t x, int32_t y, int32_t w, int32_t h) void rect_to_xywh(const CFBDGraphicRect * r, int32_t * out_x, int32_t * out_y, int32_t * out_w, int32_t * out_h)"},{"location":"api/Modules/group__RectUtil__Conversion/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Conversion/#function-rect_from_xywh","title":"function rect_from_xywh","text":"<pre><code>static inline CFBDGraphicRect rect_from_xywh(\n    int32_t x,\n    int32_t y,\n    int32_t w,\n    int32_t h\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Conversion/#function-rect_to_xywh","title":"function rect_to_xywh","text":"<pre><code>static inline void rect_to_xywh(\n    const CFBDGraphicRect * r,\n    int32_t * out_x,\n    int32_t * out_y,\n    int32_t * out_w,\n    int32_t * out_h\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Dimensions/","title":"Rectangle Dimensions","text":"<p>Module: Rectangle Operations / Rectangle Normalization</p> <p>Functions to calculate rectangle dimensions. </p>"},{"location":"api/Modules/group__RectUtil__Dimensions/#functions","title":"Functions","text":"Name uint32_t rect_width(const CFBDGraphicRect * r) uint32_t rect_height(const CFBDGraphicRect * r) CFBD_Bool rect_is_empty(const CFBDGraphicRect * r)"},{"location":"api/Modules/group__RectUtil__Dimensions/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_width","title":"function rect_width","text":"<pre><code>static inline uint32_t rect_width(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_height","title":"function rect_height","text":"<pre><code>static inline uint32_t rect_height(\n    const CFBDGraphicRect * r\n)\n</code></pre>"},{"location":"api/Modules/group__RectUtil__Dimensions/#function-rect_is_empty","title":"function rect_is_empty","text":"<pre><code>static inline CFBD_Bool rect_is_empty(\n    const CFBDGraphicRect * r\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__RectUtil__Normalization/","title":"Rectangle Normalization","text":"<p>Module: Rectangle Operations</p> <p>Utilities for normalizing rectangle corner points. </p>"},{"location":"api/Modules/group__RectUtil__Normalization/#modules","title":"Modules","text":"Name Rectangle Dimensions Functions to calculate rectangle dimensions. Rectangle Format Conversion Conversion between different rectangle representations. Point and Rectangle Containment Functions to check containment and intersection relationships. Anchor Flags Flags for specifying rectangle alignment anchors. Advanced Rectangle Operations Complex rectangle manipulation and analysis functions."},{"location":"api/Modules/group__RectUtil__Normalization/#functions","title":"Functions","text":"Name CFBDGraphicRect rect_normalize(CFBDGraphicRect r)"},{"location":"api/Modules/group__RectUtil__Normalization/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__RectUtil__Normalization/#function-rect_normalize","title":"function rect_normalize","text":"<pre><code>static inline CFBDGraphicRect rect_normalize(\n    CFBDGraphicRect r\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Rectangle__Module/","title":"Rectangle Operations","text":""},{"location":"api/Modules/group__Rectangle__Module/#modules","title":"Modules","text":"Name Rectangle Normalization Utilities for normalizing rectangle corner points."},{"location":"api/Modules/group__Rectangle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicRect Represents a rectangle defined by top-left and bottom-right corner points."},{"location":"api/Modules/group__Rectangle__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_DrawRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect) void CFBDGraphic_FillRect(CFBD_GraphicDevice * device, CFBDGraphicRect * rect)"},{"location":"api/Modules/group__Rectangle__Module/#attributes","title":"Attributes","text":"Name CFBDGraphic_Point tl CFBDGraphic_Point br"},{"location":"api/Modules/group__Rectangle__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Rectangle__Module/#function-cfbdgraphic_drawrect","title":"function CFBDGraphic_DrawRect","text":"<pre><code>void CFBDGraphic_DrawRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Modules/group__Rectangle__Module/#function-cfbdgraphic_fillrect","title":"function CFBDGraphic_FillRect","text":"<pre><code>void CFBDGraphic_FillRect(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicRect * rect\n)\n</code></pre>"},{"location":"api/Modules/group__Rectangle__Module/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Modules/group__Rectangle__Module/#variable-tl","title":"variable tl","text":"<pre><code>CFBDGraphic_Point tl;\n</code></pre> <p>Top-left corner point of the rectangle </p>"},{"location":"api/Modules/group__Rectangle__Module/#variable-br","title":"variable br","text":"<pre><code>CFBDGraphic_Point br;\n</code></pre> <p>Bottom-right corner point of the rectangle </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Size__Module/","title":"Size Utilities","text":""},{"location":"api/Modules/group__Size__Module/#classes","title":"Classes","text":"Name struct CFBDGraphicSize Represents dimensions (width and height) of a rectangular area."},{"location":"api/Modules/group__Size__Module/#functions","title":"Functions","text":"Name void CFBDGraphic_GetScreenSize(CFBD_GraphicDevice * device, CFBDGraphicSize * pSize)"},{"location":"api/Modules/group__Size__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Size__Module/#function-cfbdgraphic_getscreensize","title":"function CFBDGraphic_GetScreenSize","text":"<pre><code>void CFBDGraphic_GetScreenSize(\n    CFBD_GraphicDevice * device,\n    CFBDGraphicSize * pSize\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Timing__Module/","title":"System Clock and Timing","text":"<p>Short blocking delay primitives for timing operations.  More...</p>"},{"location":"api/Modules/group__Timing__Module/#files","title":"Files","text":"Name lib/application/sys_clock/system_clock.h System timing primitives and delay helpers."},{"location":"api/Modules/group__Timing__Module/#functions","title":"Functions","text":"Name void system_delay_ms(uint32_t delay_ms)Delay execution for at least the given number of milliseconds. void system_delay_us(uint32_t us)Delay execution for at least the given number of microseconds."},{"location":"api/Modules/group__Timing__Module/#detailed-description","title":"Detailed Description","text":"<p>Short blocking delay primitives for timing operations. </p> <p>Provides minimal, portable timing helpers for embedded systems development. These primitives are intended for short delays in initialization sequences, debouncing, and protocol timing. For longer or more precise timing requirements, consider using hardware timers or dedicated scheduling systems. </p>"},{"location":"api/Modules/group__Timing__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Timing__Module/#function-system_delay_ms","title":"function system_delay_ms","text":"<pre><code>void system_delay_ms(\n    uint32_t delay_ms\n)\n</code></pre> <p>Delay execution for at least the given number of milliseconds. </p> <p>Parameters: </p> <ul> <li>delay_ms Number of milliseconds to delay (&gt;= 0). A value of 0 should return immediately. Values greater than a few seconds should generally be avoided due to busy-wait power consumption.</li> <li>delay_ms </li> </ul> <p>See: system_delay_us()</p> <p>Since: 0.1 </p> <p>Note: we must use for loop for delay, as the large decrement makes the slow deviation for the delay </p> <p>Par: </p> <ul> <li>Thread-safety</li> </ul> <p>The function may or may not be safe to call from interrupt context; check the platform implementation before invoking from ISRs.   * Performance Notes</p> <p>Implementations typically use busy-wait loops or hardware timers. The actual delay may be slightly longer than requested due to instruction execution overhead.   * Example</p> <pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\n// Wait 100 ms for a sensor to stabilize\nsystem_delay_ms(100);\n\n// Multiple delays in sequence\nfor (int i = 0; i &lt; 5; i++) {\n    system_delay_ms(500);  // 500 ms between actions\n}\n</code></pre> <p>Blocks the calling context for approximately <code>delay_ms</code> milliseconds. The actual resolution and maximum accuracy depend on the platform timer implementation. The function is intended for short delays such as debouncing or simple timing sequences. For longer waits or low power idle, prefer platform-specific sleep APIs if available.</p> <p>Common use cases:</p> <ul> <li>GPIO debouncing (typically 10-50 ms)</li> <li>Sensor settling time</li> <li>UI interaction delays</li> <li>Initialization sequencing</li> </ul> <p>Delay execution for at least the given number of milliseconds.</p>"},{"location":"api/Modules/group__Timing__Module/#function-system_delay_us","title":"function system_delay_us","text":"<pre><code>void system_delay_us(\n    uint32_t us\n)\n</code></pre> <p>Delay execution for at least the given number of microseconds. </p> <p>Parameters: </p> <ul> <li>us Number of microseconds to delay (&gt;= 0). A value of 0 should return immediately. Large values (&gt; 1000000) should generally use <code>[system_delay_ms()](Modules/group__Timing__Module.md#function-system-delay-ms)</code> instead.</li> <li>us </li> </ul> <p>See: system_delay_ms()</p> <p>Since: 0.1 </p> <p>Par: </p> <ul> <li>Performance</li> </ul> <p>Implementations may use busy-wait loops; avoid calling with large values in performance-sensitive or low-power scenarios. Accuracy may degrade for delays shorter than 10 microseconds depending on platform overhead.   * Precision Warning</p> <p>Timing accuracy depends heavily on:</p> <ul> <li>System clock frequency stability</li> <li>Instruction execution time</li> <li>Interrupt latency (if not called from ISR with interrupts disabled) Do not rely on precise timing for critical applications without additional hardware support.</li> <li>Example</li> </ul> <pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\n// Create a small pulse of 5 microseconds\nsystem_delay_us(5);\n\n// Bit-banged I2C start condition timing\nset_sda_low();\nsystem_delay_us(2);  // Setup time\nset_scl_low();\n\n// Multiple sub-millisecond delays\nfor (int bit = 0; bit &lt; 8; bit++) {\n    transmit_bit(bit);\n    system_delay_us(10);  // Inter-bit timing\n}\n</code></pre> <p>Blocks the calling context for approximately <code>us</code> microseconds. This helper is useful for short, sub-millisecond timing (peripheral timing requirements, bit-banged protocols, etc.). Accuracy and minimum granularity depend on the underlying timer implementation.</p> <p>The resolution on most platforms is typically 1-10 microseconds, though exact behavior is implementation-defined. For very precise timing, consider using dedicated hardware peripherals.</p> <p>Common use cases:</p> <ul> <li>I2C/SPI timing sequences</li> <li>Pulse width generation for bit-banging</li> <li>Hardware-specific timing requirements</li> <li>Precise interval measurements below millisecond granularity</li> </ul> <p>Delay execution for at least the given number of microseconds.</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__Triangle__Module/","title":"Triangle Drawing","text":""},{"location":"api/Modules/group__Triangle__Module/#classes","title":"Classes","text":"Name struct CFBDGraphic_Triangle Represents a triangle defined by three vertices."},{"location":"api/Modules/group__Triangle__Module/#functions","title":"Functions","text":"Name void CCGraphic_DrawTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle) void CCGraphic_DrawFilledTriangle(CFBD_GraphicDevice * handle, CFBDGraphic_Triangle * triangle)"},{"location":"api/Modules/group__Triangle__Module/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Modules/group__Triangle__Module/#function-ccgraphic_drawtriangle","title":"function CCGraphic_DrawTriangle","text":"<pre><code>void CCGraphic_DrawTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre>"},{"location":"api/Modules/group__Triangle__Module/#function-ccgraphic_drawfilledtriangle","title":"function CCGraphic_DrawFilledTriangle","text":"<pre><code>void CCGraphic_DrawFilledTriangle(\n    CFBD_GraphicDevice * handle,\n    CFBDGraphic_Triangle * triangle\n)\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__for/","title":"new module concepts","text":"<p>More...</p>"},{"location":"api/Modules/group__for/#detailed-description","title":"Detailed Description","text":"<ul> <li> <ol> <li>Add</li> </ol> </li> <li> <ul> <li>``</li> </ul> </li> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Modules/group__strong/","title":"Group  strong","text":"<p>title: &gt;: Hierarchical organization of related components</p>"},{"location":"api/Modules/group__strong/#-hierarchical-organization-of-related-components","title":"&gt;: Hierarchical organization of related components","text":"<p>More...</p>"},{"location":"api/Modules/group__strong/#detailed-description","title":"Detailed Description","text":"<ul> <li> <ul> <li>**Examples ( **</li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Namespaces/namespaceCFBD/","title":"CFBD","text":"<p>Core Framework Bare Device (CFBD) namespace *.  More...</p>"},{"location":"api/Namespaces/namespaceCFBD/#namespaces","title":"Namespaces","text":"Name CFBD::OLED OLED display driver subsystem *."},{"location":"api/Namespaces/namespaceCFBD/#detailed-description","title":"Detailed Description","text":"<p>Core Framework Bare Device (CFBD) namespace *. </p> <ul> <li> <p>*</p> </li> <li> <p>The CFBD namespace encompasses all core framework types and operations</p> </li> <li>for bare-metal embedded device drivers. This includes display interfaces,</li> <li>communication protocols, and device abstraction layers.</li> <li> <ul> <li>The namespace is organized into several submodules:</li> </ul> </li> <li> <ul> <li>OLED: Generic OLED display driver subsystem</li> </ul> </li> <li> <ul> <li>Device abstraction layers for hardware communication</li> </ul> </li> <li> <ul> <li>Type definitions and constants for device control */</li> </ul> </li> </ul> <p>/**</p> <ul> <li></li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Namespaces/namespaceCFBD_1_1OLED/","title":"CFBD::OLED","text":"<p>Module: OLED Display Driver</p> <p>OLED display driver subsystem *.  More...</p>"},{"location":"api/Namespaces/namespaceCFBD_1_1OLED/#detailed-description","title":"Detailed Description","text":"<p>OLED display driver subsystem *. </p> <ul> <li>The CFBD::OLED namespace contains all OLED-related types, operations,</li> <li>and device drivers. It provides a generic, transport-agnostic interface</li> <li>for controlling OLED displays through various communication backends.</li> <li> <ul> <li>Key components:</li> </ul> </li> <li> <ul> <li>CFBD_OLED: Main device object</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations: Virtual operation table</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType: Transport type enumeration</li> </ul> </li> <li> <ul> <li>Device-specific factories (getSSD1306Specific, getSSD1309Specific) */ </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Namespaces/namespacefor/","title":"for","text":"<p>More...</p>"},{"location":"api/Namespaces/namespacefor/#detailed-description","title":"Detailed Description","text":"<p>namespace documentation</p> <ul> <li>*/ </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/Graphics_Complete_Examples/","title":"Graphics Framework - Complete Code Examples","text":"<ul> <li> <ul> <li> <ul> <li> <ul> <li>Comprehensive code examples demonstrating all graphics subsystem features,</li> </ul> </li> </ul> </li> </ul> </li> <li>organized by functional area: device setup, drawing operations, text widgets,</li> <li>and complex UI compositions.</li> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#part-1-graphics-device-foundation","title":"PART 1: Graphics Device Foundation","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#basic-graphics-device-setup","title":"Basic Graphics Device Setup","text":"<ul> <li> <ul> <li>The simplest example showing graphics device initialization:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic_device.h\"\n* #include \"oled_graphic_device.h\"\n* #include \"oled.h\"\n*\n* void example_basic_graphics_setup(void) {\n*     // Initialize OLED display\n*     CFBD_OLED oled;\n*     CFBD_OLED_IICInitsParams iic_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*\n*     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n*     oled.ops-&gt;open(&amp;oled);\n*\n*     // Create graphics device and bind to OLED\n*     CFBD_GraphicDevice graphics;\n*     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n*     graphics.ops-&gt;open(&amp;graphics);\n*\n*     // Graphics device is now ready to use\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#immediate-drawing-mode","title":"Immediate Drawing Mode","text":"<ul> <li> <ul> <li>Drawing with immediate updates after each operation:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_immediate_drawing(CFBD_GraphicDevice* graphics) {\n*     // Enable immediate draw mode\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_TRUE);\n*\n*     // Clear display (immediate update)\n*     graphics-&gt;ops-&gt;clear(graphics);\n*\n*     // Each pixel is visible immediately\n*     for (uint16_t x = 0; x &lt; 128; x += 2) {\n*         graphics-&gt;ops-&gt;setPixel(graphics, x, 32);\n*         // Display updates automatically\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#deferred-drawing-mode","title":"Deferred Drawing Mode","text":"<ul> <li> <ul> <li>Batch drawing operations for better performance:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_deferred_drawing(CFBD_GraphicDevice* graphics) {\n*     // Enable deferred mode (batch operations)\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n*\n*     // Clear display (buffered)\n*     graphics-&gt;ops-&gt;clear(graphics);\n*\n*     // Draw multiple pixels without updating display\n*     for (uint16_t y = 0; y &lt; 64; y += 4) {\n*         for (uint16_t x = 0; x &lt; 128; x += 4) {\n*             graphics-&gt;ops-&gt;setPixel(graphics, x, y);\n*         }\n*     }\n*\n*     // Update display once with all changes\n*     graphics-&gt;ops-&gt;update(graphics);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#area-based-drawing","title":"Area-Based Drawing","text":"<ul> <li> <ul> <li>Efficient rectangular area operations:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_area_operations(CFBD_GraphicDevice* graphics) {\n*     uint8_t bitmap[32] = {0};  // 16x16 pixel bitmap\n*\n*     // Draw bitmap to area\n*     graphics-&gt;ops-&gt;setArea(graphics, 56, 24, 16, 16, bitmap);\n*\n*     // Update only affected area\n*     graphics-&gt;ops-&gt;update_area(graphics, 56, 24, 16, 16);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#query-device-properties","title":"Query Device Properties","text":"<ul> <li> <ul> <li>Getting display capabilities:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_query_device(CFBD_GraphicDevice* graphics) {\n*     uint16_t width = 0, height = 0;\n*     CFBD_bool is_rgb = CFBD_FALSE;\n*\n*     // Query display dimensions\n*     graphics-&gt;ops-&gt;self_consult(graphics, \"width\", NULL, &amp;width);\n*     graphics-&gt;ops-&gt;self_consult(graphics, \"height\", NULL, &amp;height);\n*\n*     // Query color capability\n*     graphics-&gt;ops-&gt;self_consult(graphics, \"rgb\", NULL, &amp;is_rgb);\n*\n*     printf(\"Display: %u x %u %s\\n\",\n*            width, height,\n*            is_rgb ? \"RGB\" : \"Monochrome\");\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#dynamic-mode-switching","title":"Dynamic Mode Switching","text":"<ul> <li> <ul> <li>Switching between immediate and deferred modes:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_mode_switching(CFBD_GraphicDevice* graphics) {\n*     // Check current mode\n*     if (CFBDGraphic_DeviceRequestUpdateAtOnce(graphics)) {\n*         printf(\"Currently in immediate mode\\n\");\n*     } else {\n*         printf(\"Currently in deferred mode\\n\");\n*     }\n*\n*     // Switch to deferred mode\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n*\n*     // Perform batch operations\n*     for (int i = 0; i &lt; 100; i++) {\n*         graphics-&gt;ops-&gt;setPixel(graphics, i, 32);\n*     }\n*     graphics-&gt;ops-&gt;update(graphics);\n*\n*     // Switch back to immediate\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_TRUE);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#clear-display-utility","title":"Clear Display Utility","text":"<ul> <li> <ul> <li>Using the clear immediate convenience function:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_clear_immediate(CFBD_GraphicDevice* graphics) {\n*     // Clear entire display with single operation\n*     CFBDGraphic_DeviceClearImmediate(graphics);\n*\n*     // Equivalent to:\n*     // graphics-&gt;ops-&gt;clear(graphics);\n*     // graphics-&gt;ops-&gt;update(graphics);\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#part-2-animation-and-rendering","title":"PART 2: Animation and Rendering","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#animated-frame-rendering","title":"Animated Frame Rendering","text":"<ul> <li> <ul> <li>Smooth animation with frame-based timing:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_animated_frames(CFBD_GraphicDevice* graphics) {\n*     CFBD_BaseAnimation anim;\n*     CFBD_InitBaseAnimation(&amp;anim);\n*     anim.anim_frames = 16;\n*     anim.anim_frame_delay_ms = 50;\n*\n*     // Disable immediate mode for batch updates\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(graphics, CFBD_FALSE);\n*\n*     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n*         graphics-&gt;ops-&gt;clear(graphics);\n*\n*         // Draw frame-dependent content\n*         uint16_t y = 16 + (frame * 3);  // Animate Y position\n*         graphics-&gt;ops-&gt;setPixel(graphics, 64, y);\n*\n*         graphics-&gt;ops-&gt;update(graphics);\n*\n*         if (anim.anim_frame_delay_ms &gt; 0) {\n*             HAL_Delay(anim.anim_frame_delay_ms);\n*         }\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#complete-animated-scene","title":"Complete Animated Scene","text":"<ul> <li> <ul> <li>Full example combining multiple concepts:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic_device.h\"\n* #include \"oled_graphic_device.h\"\n* #include \"oled.h\"\n* #include \"widget/animation/animation.h\"\n* #include \"widget/base_support/common/helpers.h\"\n*\n* void example_complete_animation(void) {\n*     // Initialize OLED\n*     CFBD_OLED oled;\n*     CFBD_OLED_IICInitsParams iic_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_params, CFBD_TRUE);\n*     oled.ops-&gt;open(&amp;oled);\n*\n*     // Create graphics device\n*     CFBD_GraphicDevice graphics;\n*     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n*     graphics.ops-&gt;open(&amp;graphics);\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n*\n*     // Setup animation\n*     CFBD_BaseAnimation anim;\n*     CFBD_InitBaseAnimation(&amp;anim);\n*     anim.anim_frames = 8;\n*     anim.anim_frame_delay_ms = 50;\n*\n*     // Animate bouncing ball\n*     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n*         graphics.ops-&gt;clear(&amp;graphics);\n*\n*         // Calculate position\n*         int16_t x = 64 + 30 * (frame % 4) - 45;\n*         int16_t y = 32 + (frame * 2);\n*\n*         // Clamp to display bounds\n*         x = clamp_i32(x, 0, 127);\n*         y = clamp_i32(y, 0, 63);\n*\n*         // Draw ball\n*         graphics.ops-&gt;setPixel(&amp;graphics, x, y);\n*         graphics.ops-&gt;update(&amp;graphics);\n*\n*         HAL_Delay(anim.anim_frame_delay_ms);\n*     }\n*\n*     // Cleanup\n*     graphics.ops-&gt;close(&amp;graphics);\n*     oled.ops-&gt;close(&amp;oled);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#using-utility-functions","title":"Using Utility Functions","text":"<ul> <li> <ul> <li>Applying helper utilities in graphics code:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"widget/base_support/common/helpers.h\"\n*\n* void example_utility_functions(CFBD_GraphicDevice* graphics) {\n*     int width = 128, height = 64;\n*\n*     // Clamp coordinate to valid range\n*     int user_x = get_user_input();\n*     int x = clamp_i32(user_x, 0, width - 1);\n*\n*     // Find center\n*     int center_x = MAX(0, width / 2);\n*     int center_y = MIN(64, height / 2);\n*\n*     // Draw centered point\n*     graphics-&gt;ops-&gt;setPixel(graphics, center_x, center_y);\n*     graphics-&gt;ops-&gt;update(graphics);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#resource-configuration","title":"Resource Configuration","text":"<ul> <li> <ul> <li>Configuring graphics resources:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // In your project, before including graphics headers:\n*\n* // Option 1: Keep all defaults\n* #include \"graphic/resource/config.h\"\n*\n* // Option 2: Disable all, then enable selectively\n* #define _USE_NO_DEFAULT_SOURCES\n* #include \"graphic/resource/config.h\"\n*\n* // Option 3: Disable specific resources\n* #define DISABLE_ASCII_6X8_SOURCES\n* #include \"graphic/resource/config.h\"\n* // Now only 8x16 font is available\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#part-3-text-widget-examples","title":"PART 3: Text Widget Examples","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#basic-text-rendering","title":"Basic Text Rendering","text":"<ul> <li> <ul> <li>Simple text display on graphics device:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_basic_text(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 16};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     CFBDGraphic_SetText(&amp;text, \"Hello!\");\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#multiple-text-elements","title":"Multiple Text Elements","text":"<ul> <li> <ul> <li>Rendering multiple independent text widgets:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_multiple_texts(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text title, status;\n*\n*     // Title at top\n*     CFBDGraphic_Point title_pos = {0, 0};\n*     CFBDGraphicSize title_area = {128, 16};\n*     CFBDGraphic_InitText(&amp;title, title_pos, title_area, ASCII_8x16);\n*     CFBDGraphic_SetText(&amp;title, \"Game Status\");\n*     CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Status at bottom\n*     CFBDGraphic_Point status_pos = {0, 50};\n*     CFBDGraphicSize status_area = {128, 14};\n*     CFBDGraphic_InitText(&amp;status, status_pos, status_area, ASCII_6x8);\n*     CFBDGraphic_SetText(&amp;status, \"Running... 60FPS\");\n*     CFBDGraphic_DrawText(dev, &amp;status, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#multiline-text-with-breaks","title":"Multiline Text with Breaks","text":"<ul> <li> <ul> <li>Multiple lines with explicit line breaks:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_multiline_text(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 64};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     // First line\n*     CFBDGraphic_SetText(&amp;text, \"Line 1\");\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Second line\n*     CFBDGraphic_SetText(&amp;text, \"Line 2\");\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     // Third line\n*     CFBDGraphic_SetText(&amp;text, \"Line 3\");\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#continuous-text-with-auto-wrap","title":"Continuous Text with Auto-Wrap","text":"<ul> <li> <ul> <li>Text that wraps automatically:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_continuous_text(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 64};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n*\n*     // Long text automatically wraps\n*     CFBDGraphic_SetText(&amp;text, \"This is a long text that will wrap\");\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#dynamic-text-with-sprintf","title":"Dynamic Text with sprintf","text":"<ul> <li> <ul> <li>Formatted text with variables:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_dynamic_text(CFBD_GraphicDevice* dev, int score, int lives) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 55};\n*     CFBDGraphicSize area = {128, 8};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n*\n*     char buffer[32];\n*     sprintf(buffer, \"Score:%d Lives:%d\", score, lives);\n*     CFBDGraphic_SetText(&amp;text, buffer);\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#font-selection-with-config","title":"Font Selection with Config","text":"<ul> <li> <ul> <li>Conditional font usage based on compile-time configuration:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_font_selection(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 20};\n*\n* #if ENABLE_ASCII_8x16_SOURCES\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*     CFBDGraphic_SetText(&amp;text, \"Large Text\");\n* #elif ENABLE_ASCII_6x8_SOURCES\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_6x8);\n*     CFBDGraphic_SetText(&amp;text, \"Small Text\");\n* #else\n*     printf(\"No ASCII fonts available\\n\");\n*     return;\n* #endif\n*\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#querying-text-metrics","title":"Querying Text Metrics","text":"<ul> <li> <ul> <li>Get text size without rendering:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_text_metrics(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 64};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     // Query text size\n*     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n*     printf(\"Font size: %u x %u pixels\\n\", font_size.width, font_size.height);\n*\n*     // Query next position without drawing\n*     CFBDGraphic_SetText(&amp;text, \"Sample\");\n*     CFBDGraphic_Point end_pos = CFBDGraphic_DrawText(\n*         dev, &amp;text,\n*         CCGraphic_AsciiTextItem_RequestOldPoint\n*     );\n*     printf(\"Text would end at (%u, %u)\\n\", end_pos.x, end_pos.y);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#repositioning-text","title":"Repositioning Text","text":"<ul> <li> <ul> <li>Dynamic repositioning of text elements:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_reposition_text(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 32};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     CFBDGraphic_SetText(&amp;text, \"Hello\");\n*\n*     // Draw at original position\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*     dev-&gt;ops-&gt;update(dev);\n*     HAL_Delay(500);\n*\n*     // Move to new position\n*     CFBDGraphic_Point new_pos = {30, 25};\n*     CFBDGraphic_SetTextTLPointPoint(&amp;text, &amp;new_pos);\n*\n*     dev-&gt;ops-&gt;clear(dev);\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#centered-text","title":"Centered Text","text":"<ul> <li> <ul> <li>Centering text horizontally:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_centered_text(CFBD_GraphicDevice* dev, const char* text_str) {\n*     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n*\n*     // Calculate text width\n*     size_t text_len = strlen(text_str);\n*     int text_width = text_len * (font_size.width + CFBDGraphic_TEXT_PADDING_WIDTH);\n*\n*     // Center horizontally (128 pixel display)\n*     int center_x = (128 - text_width) / 2;\n*     CFBDGraphic_Point pos = {center_x, 25};\n*\n*     CFBDGraphic_Text text;\n*     CFBDGraphicSize area = {text_width + 5, 16};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*     CFBDGraphic_SetText(&amp;text, (char*)text_str);\n*     CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#scrolling-text-effect","title":"Scrolling Text Effect","text":"<ul> <li> <ul> <li>Horizontal text scrolling:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_scrolling_text(CFBD_GraphicDevice* dev) {\n*     const char* text_str = \"Scrolling Text Example\";\n*     CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n*     int text_width = strlen(text_str) * (font_size.width + 1);\n*\n*     // Scroll from right to left\n*     for (int x = 128; x &gt; -text_width; x -= 2) {\n*         CFBDGraphic_Text text;\n*         CFBDGraphic_Point pos = {x, 25};\n*         CFBDGraphicSize area = {text_width + 5, 16};\n*         CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*         CFBDGraphic_SetText(&amp;text, (char*)text_str);\n*\n*         dev-&gt;ops-&gt;clear(dev);\n*         CFBDGraphic_DrawText(dev, &amp;text, CCGraphic_AsciiTextItem_AppendContinously);\n*         dev-&gt;ops-&gt;update(dev);\n*\n*         HAL_Delay(50);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#part-4-graphics-widget-examples-image-menu-progress-bar","title":"PART 4: Graphics Widget Examples (Image, Menu, Progress Bar)","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#basic-image-drawing","title":"Basic Image Drawing","text":"<ul> <li> <ul> <li>Simple bitmap rendering:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_draw_bitmap(CFBD_GraphicDevice* dev) {\n*     uint8_t heart_bitmap[64] = {\n*         0x00, 0x00, 0x00, 0x00,\n*         0x66, 0x99, 0x99, 0x66,\n*         0xFF, 0xFF, 0xFF, 0xFF,\n*         0xFF, 0xFF, 0xFF, 0xFF,\n*         // ... (16x16 bitmap)\n*     };\n*\n*     CCGraphic_Image heart;\n*     CFBDGraphic_Point pos = {56, 24};\n*     CFBDGraphicSize size = {16, 16};\n*     CFBDGraphic_InitImage(&amp;heart, &amp;pos, &amp;size, heart_bitmap);\n*\n*     dev-&gt;ops-&gt;clear(dev);\n*     CFBDGraphic_DrawImage(dev, &amp;heart);\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#animated-image-transitions","title":"Animated Image Transitions","text":"<ul> <li> <ul> <li>Multiple images with frame-based animation:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_animated_image(CFBD_GraphicDevice* dev) {\n*     CCGraphic_Image frames[4];\n*     uint8_t frame_data[4][64] = {...};  // 4 animation frames\n*     CFBDGraphic_Point pos = {48, 24};\n*     CFBDGraphicSize size = {32, 16};\n*\n*     // Initialize all frames\n*     for (int i = 0; i &lt; 4; i++) {\n*         CFBDGraphic_InitImage(&amp;frames[i], &amp;pos, &amp;size, frame_data[i]);\n*     }\n*\n*     // Animate through frames\n*     CFBD_BaseAnimation anim = {4, 100};  // 4 frames, 100ms each\n*     for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {\n*         dev-&gt;ops-&gt;clear(dev);\n*         CFBDGraphic_DrawImage(dev, &amp;frames[frame % 4]);\n*         dev-&gt;ops-&gt;update(dev);\n*         HAL_Delay(anim.anim_frame_delay_ms);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#basic-menu","title":"Basic Menu","text":"<ul> <li> <ul> <li>Minimal menu with 3 items:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void on_item_selected(void* ctx) {\n*     printf(\"Item selected!\\n\");\n* }\n*\n* void example_simple_menu(CFBD_GraphicDevice* dev) {\n*     // Allocate item array\n*     CFBD_MenuItem items[3];\n*     CFBD_MenuItemGroup item_group = {items, 3, 0};\n*\n*     // Initialize menu\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n*\n*     // Add items\n*     CFBD_MenuItemCallbackPack cb = {on_item_selected, NULL};\n*     menu.operations-&gt;add_item(&amp;menu, \"Start\", ASCII_8x16, &amp;cb);\n*     menu.operations-&gt;add_item(&amp;menu, \"Options\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n*\n*     // Draw menu\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#interactive-menu-navigation","title":"Interactive Menu Navigation","text":"<ul> <li> <ul> <li>Simulated keyboard input and menu selection:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_menu_navigation(CFBD_GraphicDevice* dev) {\n*     // Setup menu (from previous example)\n*     CFBD_MenuItem items[5];\n*     CFBD_MenuItemGroup item_group = {items, 5, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n*\n*     for (int i = 0; i &lt; 5; i++) {\n*         char label[16];\n*         sprintf(label, \"Item %d\", i + 1);\n*         menu.operations-&gt;add_item(&amp;menu, label, ASCII_6x8, NULL);\n*     }\n*\n*     // Simulate navigation\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n*\n*     // Down arrow - move to next item\n*     OLED_Menu_SelectNext(&amp;menu);\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n*     HAL_Delay(300);\n*\n*     // Down arrow again\n*     OLED_Menu_SelectNext(&amp;menu);\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n*     HAL_Delay(300);\n*\n*     // Up arrow - move to previous\n*     OLED_Menu_SelectPrev(&amp;menu);\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n*     HAL_Delay(300);\n*\n*     // Enter - activate current item\n*     menu.operations-&gt;activate_current(&amp;menu);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#menu-with-custom-indicator","title":"Menu with Custom Indicator","text":"<ul> <li> <ul> <li>Menu with styled selection indicator:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_menu_with_indicator(CFBD_GraphicDevice* dev) {\n*     CFBD_MenuItem items[4];\n*     CFBD_MenuItemGroup item_group = {items, 4, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 120);\n*\n*     // Configure indicator\n*     CFBD_MenuIndicator indicator;\n*     CFBD_InitDefaultMenuIndicator(&amp;indicator);\n*     indicator.width = 6;      // 6-pixel wide indicator\n*     indicator.x = 2;          // 2 pixels from left edge\n*     menu.operations-&gt;set_indicator_property(&amp;menu, &amp;indicator);\n*\n*     // Add items with callbacks\n*     CFBD_MenuItemCallbackPack cb1 = {on_item_selected, (void*)1};\n*     CFBD_MenuItemCallbackPack cb2 = {on_item_selected, (void*)2};\n*     menu.operations-&gt;add_item(&amp;menu, \"Play\", ASCII_8x16, &amp;cb1);\n*     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, &amp;cb2);\n*     menu.operations-&gt;add_item(&amp;menu, \"About\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n*\n*     // Draw\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#menu-with-transitions","title":"Menu with Transitions","text":"<ul> <li> <ul> <li>Menu with animated selection changes:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_animated_menu(CFBD_GraphicDevice* dev) {\n*     CFBD_MenuItem items[3];\n*     CFBD_MenuItemGroup item_group = {items, 3, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n*\n*     menu.operations-&gt;add_item(&amp;menu, \"One\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Two\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Three\", ASCII_8x16, NULL);\n*\n*     // Enable animation\n*     CFBD_BaseAnimation anim = {6, 40};  // 6 frames, 40ms per frame\n*     menu.operations-&gt;set_animation(&amp;menu, &amp;anim);\n*\n*     // Navigate with visual feedback\n*     for (int i = 0; i &lt; 3; i++) {\n*         OLED_Menu_SelectNext(&amp;menu);\n*         for (int f = 0; f &lt; anim.anim_frames; f++) {\n*             menu.operations-&gt;immediate_draw(&amp;menu);\n*             HAL_Delay(anim.anim_frame_delay_ms);\n*         }\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#simple-progress-bar","title":"Simple Progress Bar","text":"<ul> <li> <ul> <li>Basic progress bar with fill animation:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_progress_bar(CFBD_GraphicDevice* dev) {\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point pos = {10, 32};\n*     CFBDGraphicSize size = {108, 8};\n*     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n*\n*     // Draw at different values\n*     for (int val = 0; val &lt;= 100; val += 10) {\n*         dev-&gt;ops-&gt;clear(dev);\n*         progress.ops-&gt;set_value(&amp;progress, val);\n*         progress.ops-&gt;immediate_draw(&amp;progress);\n*         dev-&gt;ops-&gt;update(dev);\n*         HAL_Delay(100);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#progress-bar-with-border","title":"Progress Bar with Border","text":"<ul> <li> <ul> <li>Styled progress bar with border and padding:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_styled_progress(CFBD_GraphicDevice* dev) {\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point pos = {10, 32};\n*     CFBDGraphicSize size = {108, 10};\n*     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n*\n*     // Enable border and padding\n*     uint8_t border = 1;\n*     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n*     uint8_t padding = 1;\n*     progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n*\n*     // Animate from 0 to 100\n*     for (int val = 0; val &lt;= 100; val += 5) {\n*         dev-&gt;ops-&gt;clear(dev);\n*         progress.ops-&gt;set_value(&amp;progress, val);\n*         progress.ops-&gt;immediate_draw(&amp;progress);\n*         dev-&gt;ops-&gt;update(dev);\n*         HAL_Delay(50);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#progress-bar-with-transitions","title":"Progress Bar with Transitions","text":"<ul> <li> <ul> <li>Progress bar with frame-based animation:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_animated_progress(CFBD_GraphicDevice* dev) {\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point pos = {10, 32};\n*     CFBDGraphicSize size = {108, 8};\n*     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;pos, &amp;size, 0, 100);\n*\n*     // Configure animation\n*     CFBD_BaseAnimation anim = {4, 50};  // 4-frame, 50ms transitions\n*     progress.ops-&gt;set_property(&amp;progress, \"animation\", &amp;anim);\n*\n*     // Smooth progress animation\n*     for (int target = 10; target &lt;= 100; target += 10) {\n*         for (int frame = 0; frame &lt; anim.anim_frames; frame++) {\n*             int current = (progress.value * (anim.anim_frames - frame) +\n*                           target * frame) / anim.anim_frames;\n*             dev-&gt;ops-&gt;clear(dev);\n*             progress.ops-&gt;set_value(&amp;progress, current);\n*             progress.ops-&gt;immediate_draw(&amp;progress);\n*             dev-&gt;ops-&gt;update(dev);\n*             HAL_Delay(anim.anim_frame_delay_ms);\n*         }\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#part-5-complex-ui-compositions","title":"PART 5: Complex UI Compositions","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#menu-with-text-items","title":"Menu with Text Items","text":"<ul> <li> <ul> <li>Text-based menu display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_menu_text(CFBD_GraphicDevice* dev) {\n*     CFBDGraphic_Text menu;\n*     CFBDGraphic_Point pos = {10, 10};\n*     CFBDGraphicSize area = {108, 54};\n*     CFBDGraphic_InitText(&amp;menu, pos, area, ASCII_8x16);\n*\n*     dev-&gt;ops-&gt;clear(dev);\n*\n*     // Title\n*     CFBDGraphic_SetText(&amp;menu, \"MENU\");\n*     CFBDGraphic_DrawText(dev, &amp;menu, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Menu items\n*     const char* items[] = {\"Start\", \"Settings\", \"Exit\"};\n*     for (int i = 0; i &lt; 3; i++) {\n*         char item_text[16];\n*         sprintf(item_text, \"%d. %s\", i + 1, items[i]);\n*         CFBDGraphic_SetText(&amp;menu, item_text);\n*         CFBDGraphic_DrawText(dev, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n*     }\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#complete-ui-with-mixed-text","title":"Complete UI with Mixed Text","text":"<ul> <li> <ul> <li>Complex interface combining multiple text elements:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_complete_ui(CFBD_GraphicDevice* dev, int score, int level) {\n*     CFBDGraphic_Text title, body, footer;\n*\n*     // Title\n*     CFBDGraphic_Point title_pos = {0, 0};\n*     CFBDGraphicSize title_size = {128, 16};\n*     CFBDGraphic_InitText(&amp;title, title_pos, title_size, ASCII_8x16);\n*     CFBDGraphic_SetText(&amp;title, \"Game Screen\");\n*     CFBDGraphic_DrawText(dev, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Body text\n*     CFBDGraphic_Point body_pos = {0, 20};\n*     CFBDGraphicSize body_size = {128, 36};\n*     CFBDGraphic_InitText(&amp;body, body_pos, body_size, ASCII_6x8);\n*     CFBDGraphic_SetText(&amp;body, \"Level in progress...\");\n*     CFBDGraphic_DrawText(dev, &amp;body, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Footer with stats\n*     CFBDGraphic_Point footer_pos = {0, 55};\n*     CFBDGraphicSize footer_size = {128, 8};\n*     CFBDGraphic_InitText(&amp;footer, footer_pos, footer_size, ASCII_6x8);\n*     char footer_text[32];\n*     sprintf(footer_text, \"Score:%d Level:%d\", score, level);\n*     CFBDGraphic_SetText(&amp;footer, footer_text);\n*     CFBDGraphic_DrawText(dev, &amp;footer, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     dev-&gt;ops-&gt;update(dev);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#multiple-widgets-together","title":"Multiple Widgets Together","text":"<ul> <li> <ul> <li>Complex UI with image, menu, and progress bar:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Global state\n* typedef enum {\n*     SCREEN_MENU,\n*     SCREEN_LOADING,\n*     SCREEN_GAME\n* } ScreenState;\n*\n* void example_multi_widget_ui(CFBD_GraphicDevice* dev) {\n*     ScreenState screen = SCREEN_MENU;\n*\n*     // Setup menu\n*     CFBD_MenuItem items[3];\n*     CFBD_MenuItemGroup item_group = {items, 3, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n*     menu.operations-&gt;add_item(&amp;menu, \"Start Game\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Exit\", ASCII_8x16, NULL);\n*\n*     // Setup progress bar for loading screen\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point prog_pos = {10, 50};\n*     CFBDGraphicSize prog_sz = {108, 8};\n*     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;prog_pos, &amp;prog_sz, 0, 100);\n*     uint8_t border = 1;\n*     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n*\n*     // Setup image for loading screen\n*     uint8_t logo_bitmap[128] = {...};  // 32x32 logo\n*     CCGraphic_Image logo;\n*     CFBDGraphic_Point logo_pos = {48, 8};\n*     CFBDGraphicSize logo_sz = {32, 32};\n*     CFBDGraphic_InitImage(&amp;logo, &amp;logo_pos, &amp;logo_sz, logo_bitmap);\n*\n*     while (1) {\n*         switch (screen) {\n*         case SCREEN_MENU:\n*             dev-&gt;ops-&gt;clear(dev);\n*             menu.operations-&gt;immediate_draw(&amp;menu);\n*             // Handle input to change screen\n*             break;\n*\n*         case SCREEN_LOADING:\n*             CFBDGraphic_DrawImage(dev, &amp;logo);\n*             for (int i = 0; i &lt;= 100; i += 10) {\n*                 progress.ops-&gt;set_value(&amp;progress, i);\n*                 progress.ops-&gt;immediate_draw(&amp;progress);\n*                 dev-&gt;ops-&gt;update(dev);\n*                 HAL_Delay(100);\n*             }\n*             screen = SCREEN_GAME;\n*             break;\n*         }\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_Examples/#batch-drawing-for-performance","title":"Batch Drawing for Performance","text":"<ul> <li> <ul> <li>Multiple widgets with deferred updates:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_batch_widgets(CFBD_GraphicDevice* dev) {\n*     // Enable deferred mode\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(dev, CFBD_FALSE);\n*\n*     // Setup widgets\n*     CCGraphic_Image bg;\n*     CFBDGraphic_InitImage(&amp;bg, &amp;(CFBDGraphic_Point){0, 0},\n*                          &amp;(CFBDGraphicSize){128, 64}, background_data);\n*\n*     CFBD_MenuItem items[2];\n*     CFBD_MenuItemGroup item_group = {items, 2, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, dev, &amp;item_group, 128);\n*     menu.operations-&gt;add_item(&amp;menu, \"Option 1\", ASCII_6x8, NULL);\n*     menu.operations-&gt;add_item(&amp;menu, \"Option 2\", ASCII_6x8, NULL);\n*\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point p = {20, 55};\n*     CFBDGraphicSize s = {88, 6};\n*     CFBD_ProgressBar_Init(&amp;progress, dev, &amp;p, &amp;s, 0, 100);\n*\n*     // Draw all widgets, update only once\n*     dev-&gt;ops-&gt;clear(dev);\n*     CFBDGraphic_DrawImage(dev, &amp;bg);\n*     menu.operations-&gt;immediate_draw(&amp;menu);\n*     progress.ops-&gt;set_value(&amp;progress, 75);\n*     progress.ops-&gt;immediate_draw(&amp;progress);\n*     dev-&gt;ops-&gt;update(dev);  // Single update for all widgets\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li>Graphics_UserGuide - Detailed graphics framework guide</li> </ul> </li> <li> <p>Widget_UserGuide - Complete widget guide</p> </li> <li> <p>Text_UserGuide - Complete text guide</p> </li> <li> <p>CFBD_GraphicDevice - Device structure</p> </li> <li> <p>CFBD_Menu - Menu structure</p> </li> <li> <p>CFBD_ProgressBar - Progress bar structure</p> </li> <li> <p>CCGraphic_Image - Image structure</p> </li> <li> <p>CFBDGraphic_Text - Text structure</p> </li> <li> <p>CFBD_BaseAnimation - Animation structure */ </p> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/Graphics_Complete_UserGuide/","title":"Graphics Framework - Complete User Guide","text":"<ul> <li> <ul> <li> <ul> <li> <ul> <li>\u2014</li> </ul> </li> </ul> </li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#part-i-graphics-subsystem-overview","title":"PART I: Graphics Subsystem Overview","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#overview","title":"Overview","text":"<ul> <li> <ul> <li>The Graphics subsystem provides a complete framework for rendering graphical</li> </ul> </li> <li>content on various display devices. It is built on a modular architecture</li> <li>consisting of:</li> <li> <ul> <li> <ul> <li>Graphics Device Abstraction: Unified interface for different display hardware</li> </ul> </li> </ul> </li> <li> <ul> <li>OLED Device Binding: Integration with OLED displays</li> </ul> </li> <li> <ul> <li>Animation Framework: Smooth transitions and visual effects</li> </ul> </li> <li> <ul> <li>Widget System: High-level UI components (Text, Menu, ProgressBar, Image)</li> </ul> </li> <li> <ul> <li>Resource Management: Fonts, textures, and other rendering assets</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#architecture","title":"Architecture","text":"<ul> <li> <ul> <li>The Graphics subsystem is organized in layers:</li> </ul> </li> <li> <ul> <li>``</li> </ul> </li> <li><code>Application Code</code></li> <li><code>|</code></li> <li><code>v</code></li> <li><code>Widget Framework (text, menu, animation, image, etc.)</code></li> <li><code>|</code></li> <li><code>v</code></li> <li><code>Graphics Device Abstraction ([graphic_device.h])</code></li> <li><code>|</code></li> <li><code>+-&gt; OLED Device Binding ([oled_graphic_device.h](Files/oled__graphic__device_8h.md#file-oled-graphic-device.h))</code></li> <li><code>|</code></li> <li><code>v</code></li> <li><code>Hardware Drivers (OLED, LCD, etc.) *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#getting-started-with-graphics","title":"Getting Started with Graphics","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#include-required-headers","title":"Include Required Headers","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"graphic_device.h\"</code></li> <li><code>#include \"oled_graphic_device.h\"</code></li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"driver/backend/oled_iic.h\" *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#initialize-oled-display","title":"Initialize OLED Display","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled;</code></li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) iic_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS,</code></li> <li><code>.i2c_handle = &amp;my_i2c,</code></li> <li><code>};</code></li> <li>``</li> <li><code>CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_config, CFBD_TRUE);</code></li> <li><code>oled.ops-&gt;open(&amp;oled); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#create-graphics-device","title":"Create Graphics Device","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_GraphicDevice](Classes/structCFBD__GraphicDevice.md) graphics;</code></li> <li><code>CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);</code></li> <li><code>graphics.ops-&gt;open(&amp;graphics); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#render-graphics-content","title":"Render Graphics Content","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>graphics.ops-&gt;clear(&amp;graphics);</code></li> <li><code>graphics.ops-&gt;setPixel(&amp;graphics, 64, 32);</code></li> <li><code>graphics.ops-&gt;update(&amp;graphics); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#drawing-modes","title":"Drawing Modes","text":"<ul> <li> <ul> <li>The graphics device supports two drawing modes:</li> </ul> </li> <li> <ul> <li>Immediate Mode: Each drawing operation immediately updates the display</li> </ul> </li> <li><code>cpp</code></li> <li><code>CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_TRUE);</code></li> <li><code>graphics.ops-&gt;setPixel(&amp;graphics, 64, 32); // Visible immediately *</code></li> <li> <ul> <li>Deferred Mode: Drawing operations are buffered; display is updated explicitly</li> </ul> </li> <li><code>cpp</code></li> <li><code>CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);</code></li> <li><code>graphics.ops-&gt;setPixel(&amp;graphics, 64, 32);</code></li> <li><code>graphics.ops-&gt;setPixel(&amp;graphics, 65, 32);</code></li> <li><code>graphics.ops-&gt;update(&amp;graphics); // Both pixels visible now *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#using-animations","title":"Using Animations","text":"<ul> <li> <ul> <li>The Animation framework provides frame-based animations:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Initialize animation with defaults</code></li> <li><code>[CFBD_BaseAnimation](Classes/structCFBD__BaseAnimation.md) anim;</code></li> <li><code>CFBD_InitBaseAnimation(&amp;anim);</code></li> <li><code>anim.anim_frames = 16;</code></li> <li><code>anim.anim_frame_delay_ms = 30;</code></li> <li>``</li> <li><code>// Use in animation loop</code></li> <li><code>for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {</code></li> <li><code>float progress = (float)frame / anim.anim_frames;</code></li> <li><code>// Render frame based on progress</code></li> <li><code>if (anim.anim_frame_delay_ms &gt; 0) {</code></li> <li><code>HAL_Delay(anim.anim_frame_delay_ms);</code></li> <li><code>}</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#resource-configuration","title":"Resource Configuration","text":"<ul> <li> <ul> <li>Graphics resources (fonts, etc.) are configured in resource/config.h:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Enable/disable font resources</code></li> <li><code>#define ENABLE_ASCII_6x8_SOURCES 1</code></li> <li><code>#define ENABLE_ASCII_8x16_SOURCES 1</code></li> <li>``</li> <li><code>// Or disable all defaults and customize</code></li> <li><code>#define _USE_NO_DEFAULT_SOURCES *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#utility-functions","title":"Utility Functions","text":"<ul> <li> <ul> <li>The helpers module provides common utilities:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Min/Max operations</code></li> <li><code>int larger = [MAX(100, 200)](Files/rectangle_8c.md#define-max);</code></li> <li><code>int smaller = [MIN(100, 200)](Files/rectangle_8c.md#define-min);</code></li> <li>``</li> <li><code>// Value clamping</code></li> <li><code>int32_t x = clamp_i32(user_input, 0, 127); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#complete-graphics-setup-example","title":"Complete Graphics Setup Example","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"graphic_device.h\"</code></li> <li><code>#include \"oled_graphic_device.h\"</code></li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"widget/animation/animation.h\"</code></li> <li>``</li> <li><code>void graphics_demo(void) {</code></li> <li><code>// Initialize OLED</code></li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled;</code></li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) iic_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS,</code></li> <li><code>.i2c_handle = &amp;my_i2c,</code></li> <li><code>};</code></li> <li><code>CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic_config, CFBD_TRUE);</code></li> <li><code>oled.ops-&gt;open(&amp;oled);</code></li> <li>``</li> <li><code>// Create graphics device</code></li> <li><code>[CFBD_GraphicDevice](Classes/structCFBD__GraphicDevice.md) graphics;</code></li> <li><code>CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);</code></li> <li><code>graphics.ops-&gt;open(&amp;graphics);</code></li> <li><code>CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);</code></li> <li>``</li> <li><code>// Setup animation</code></li> <li><code>[CFBD_BaseAnimation](Classes/structCFBD__BaseAnimation.md) anim;</code></li> <li><code>CFBD_InitBaseAnimation(&amp;anim);</code></li> <li><code>anim.anim_frames = 8;</code></li> <li><code>anim.anim_frame_delay_ms = 50;</code></li> <li>``</li> <li><code>// Clear display</code></li> <li><code>graphics.ops-&gt;clear(&amp;graphics);</code></li> <li><code>graphics.ops-&gt;update(&amp;graphics);</code></li> <li>``</li> <li><code>// Draw animated pattern</code></li> <li><code>for (uint8_t frame = 0; frame &lt; anim.anim_frames; frame++) {</code></li> <li><code>graphics.ops-&gt;clear(&amp;graphics);</code></li> <li>``</li> <li><code>// Draw frame-dependent content</code></li> <li><code>for (uint16_t x = 0; x &lt; 128; x += 2) {</code></li> <li><code>graphics.ops-&gt;setPixel(&amp;graphics, x, 32 + frame);</code></li> <li><code>}</code></li> <li>``</li> <li><code>graphics.ops-&gt;update(&amp;graphics);</code></li> <li><code>HAL_Delay(anim.anim_frame_delay_ms);</code></li> <li><code>}</code></li> <li>``</li> <li><code>// Cleanup</code></li> <li><code>graphics.ops-&gt;close(&amp;graphics);</code></li> <li><code>oled.ops-&gt;close(&amp;oled);</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#performance-tips","title":"Performance Tips","text":"<ul> <li> <ul> <li> <ul> <li>Deferred Mode: Use for batch operations to reduce display updates</li> </ul> </li> </ul> </li> <li> <ul> <li>Area Updates: Use update_area() for partial display refresh</li> </ul> </li> <li> <ul> <li>Animation Frames: 4-8 frames for UI feedback, 16+ for smooth transitions</li> </ul> </li> <li> <ul> <li>Resource Management: Disable unused resources (fonts) to save memory</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#error-handling","title":"Error Handling","text":"<ul> <li> <ul> <li>Always check return values for graphics operations:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>if (graphics.ops-&gt;setPixel(&amp;graphics, x, y)) {</code></li> <li><code>// Operation succeeded</code></li> <li><code>} else {</code></li> <li><code>// Operation failed (invalid coordinates, device error, etc.)</code></li> <li><code>} *</code></li> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#part-ii-text-widget-system","title":"PART II: Text Widget System","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#introduction-to-text-widget","title":"Introduction to Text Widget","text":"<ul> <li> <ul> <li>The Graphics Text Widget provides comprehensive text rendering capabilities</li> </ul> </li> <li>with support for multiple monospace fonts, multiline layout, and flexible</li> <li>positioning. Text is rendered character-by-character using pre-compiled</li> <li>font bitmaps.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#key-features","title":"Key Features","text":"<ul> <li> <ul> <li> <ul> <li>Multiple Font Sizes: 6x8 and 8x16 pixel ASCII fonts</li> </ul> </li> </ul> </li> <li> <ul> <li>Multiline Support: Automatic line wrapping and manual line breaks</li> </ul> </li> <li> <ul> <li>Flexible Layout: Continuous flow or explicit newlines</li> </ul> </li> <li> <ul> <li>Position Queries: Get next character position without drawing</li> </ul> </li> <li> <ul> <li>Compile-Time Configuration: Enable/disable fonts via config macros</li> </ul> </li> <li> <ul> <li>Device Agnostic: Works with any graphics device (OLED, LCD, etc.)</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#font-system","title":"Font System","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#supported-font-sizes","title":"Supported Font Sizes","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code> * ASCII Fonts (Compile-Time Selectable):\n * \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502 ASCII_6x8:  6 pixels wide x 8 pixels tall   \u2502\n * \u2502             Compact, dense text layout      \u2502\n * \u2502             Good for: status messages       \u2502\n * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n * \u2502 ASCII_8x16: 8 pixels wide x 16 pixels tall  \u2502\n * \u2502             Standard readability            \u2502\n * \u2502             Good for: main menu text        \u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * ```\n\n* * \n\n\n\n## Font Enablement\n\n\n\n* * Fonts are enabled/disabled via [resource/config.h](Files/config_8h.md#file-config.h) macros:\n* * \n\n```cpp\n* // In your project configuration:\n* #define ENABLE_ASCII_6x8_SOURCES    // Enable 6x8 font\n* #define ENABLE_ASCII_8x16_SOURCES   // Enable 8x16 font\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#quick-start-with-text","title":"Quick Start with Text","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#basic-text-rendering","title":"Basic Text Rendering","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/widget/text.h\"\n*\n* void display_text(CFBD_GraphicDevice* device) {\n*     // Initialize text widget\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 64};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     // Set and render text\n*     CFBDGraphic_SetText(&amp;text, \"Hello World!\");\n*     CFBDGraphic_DrawText(device, &amp;text,\n*                         CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Update display\n*     device-&gt;ops-&gt;update(device);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#multiline-text","title":"Multiline Text","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void display_multiline(CFBD_GraphicDevice* device) {\n*     CFBDGraphic_Text text;\n*     CFBDGraphic_Point pos = {0, 0};\n*     CFBDGraphicSize area = {128, 64};\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n*\n*     // First line\n*     CFBDGraphic_SetText(&amp;text, \"Menu:\");\n*     CFBDGraphic_DrawText(device, &amp;text,\n*                         CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Second line\n*     CFBDGraphic_SetText(&amp;text, \"1. Start\");\n*     CFBDGraphic_DrawText(device, &amp;text,\n*                         CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     // Third line\n*     CFBDGraphic_SetText(&amp;text, \"2. Settings\");\n*     CFBDGraphic_DrawText(device, &amp;text,\n*                         CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     device-&gt;ops-&gt;update(device);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#layout-methods","title":"Layout Methods","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#continuous-default","title":"Continuous (Default)","text":"<ul> <li> <ul> <li>Characters flow continuously on same line until width limit, then wrap.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CCGraphic_AsciiTextItem_AppendContinously\n* \n</code></pre> <ul> <li> <ul> <li>Use for: Paragraph text, automatic wrapping, word processing</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#explicit-newline","title":"Explicit Newline","text":"<ul> <li> <ul> <li>Forces next text segment to start on new line.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CCGraphic_AsciiTextItem_AppendNextLine\n* \n</code></pre> <ul> <li> <ul> <li>Use for: Menu items, structured lists, formatted text</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#query-position","title":"Query Position","text":"<ul> <li> <ul> <li>Get position after hypothetical rendering without actual drawing.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CCGraphic_AsciiTextItem_RequestOldPoint\n* \n</code></pre> <ul> <li> <ul> <li>Use for: Calculate text metrics, layout planning, responsive design</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#positioning-and-layout","title":"Positioning and Layout","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#initial-setup","title":"Initial Setup","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CFBDGraphic_Text text;\n* CFBDGraphic_Point pos = {x_start, y_start};\n* CFBDGraphicSize area = {width, height};\n* CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#repositioning","title":"Repositioning","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Move text to new position and resize area\n* CFBDGraphic_Point new_pos = {20, 30};\n* CFBDGraphicSize new_area = {88, 34};\n* CCGraphicWidget_AsciiTextItem_relocate(&amp;text, &amp;new_pos, new_area);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#resume-at-position","title":"Resume at Position","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Continue text at specific position\n* CFBDGraphic_Point continue_pos = {0, 16};  // Next line\n* CFBDGraphic_SetTextIndexedPoint(&amp;text, &amp;continue_pos);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#font-selection","title":"Font Selection","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#compile-time-selection","title":"Compile-Time Selection","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // In project config:\n* #define ENABLE_ASCII_8x16_SOURCES  // Enable 8x16 only\n* #undef ENABLE_ASCII_6x8_SOURCES    // Disable 6x8\n*\n* // In code:\n* #if ENABLE_ASCII_8x16_SOURCES\n*     CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n* #else\n*     printf(\"8x16 font not available\\n\");\n* #endif\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#runtime-query","title":"Runtime Query","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Get font dimensions\n* CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n* printf(\"Font: %u x %u pixels\\n\", font_size.width, font_size.height);\n*\n* // Get character bitmap\n* uint8_t* char_bitmap = __select_from_ascii_font_size(ASCII_8x16, 'A');\n* if (char_bitmap == UNSUPPORTIVE_FONT_SOURCE) {\n*     printf(\"Font not available\\n\");\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#spacing-and-padding","title":"Spacing and Padding","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Character horizontal spacing (padding between chars)\n* #define CFBDGraphic_TEXT_PADDING_WIDTH (1)  // 1 pixel\n*\n* // Line vertical spacing\n* #define CFBDGraphic_TEXT_PADDING_HEIGHT (0) // 0 pixels\n* \n</code></pre> <ul> <li> <ul> <li>Configure these macros to adjust text layout density.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#text-best-practices","title":"Text Best Practices","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#always-check-font-availability","title":"Always Check Font Availability","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* uint8_t* font = __select_from_ascii_font_size(ASCII_8x16, 'A');\n* if (font == UNSUPPORTIVE_FONT_SOURCE) {\n*     // Font not enabled - provide fallback\n*     return handle_missing_font();\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#maintain-string-validity","title":"Maintain String Validity","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // GOOD: Static string\n* CFBDGraphic_SetText(&amp;text, \"Static Text\");\n* CFBDGraphic_DrawText(device, &amp;text, ...);\n*\n* // GOOD: Stack buffer in local scope\n* char buffer[32];\n* sprintf(buffer, \"Score: %d\", score);\n* CFBDGraphic_SetText(&amp;text, buffer);\n* CFBDGraphic_DrawText(device, &amp;text, ...);\n* // buffer still valid during draw\n*\n* // BAD: Pointer to temporary\n* CFBDGraphic_SetText(&amp;text, \"Value: \");\n* // sprintf result to temporary - DON'T DO THIS\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#use-deferred-mode-for-multiple-texts","title":"Use Deferred Mode for Multiple Texts","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Multiple text elements - use deferred mode\n* CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(device, CFBD_FALSE);\n*\n* // Draw multiple text elements\n* CFBDGraphic_DrawText(device, &amp;title_text, ...);\n* CFBDGraphic_DrawText(device, &amp;body_text, ...);\n* CFBDGraphic_DrawText(device, &amp;footer_text, ...);\n*\n* // Single update for all\n* device-&gt;ops-&gt;update(device);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#plan-for-text-bounds","title":"Plan for Text Bounds","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Calculate required size\n* CFBDGraphicSize font_size = __fetch_font_size(ASCII_8x16);\n* int text_width = 11 * (font_size.width + CFBDGraphic_TEXT_PADDING_WIDTH);\n* int text_height = font_size.height;\n*\n* // Allocate adequate area\n* CFBDGraphicSize area = {text_width + 10, text_height + 10};\n* CFBDGraphic_InitText(&amp;text, pos, area, ASCII_8x16);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#complete-text-system-example","title":"Complete Text System Example","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/device/graphic_device.h\"\n* #include \"graphic/widget/text.h\"\n*\n* void display_system_menu(CFBD_GraphicDevice* device) {\n*     // Initialize text for title\n*     CFBDGraphic_Text title;\n*     CFBDGraphic_Point title_pos = {0, 0};\n*     CFBDGraphicSize title_area = {128, 16};\n*     CFBDGraphic_InitText(&amp;title, title_pos, title_area, ASCII_8x16);\n*\n*     // Initialize text for menu items\n*     CFBDGraphic_Text menu;\n*     CFBDGraphic_Point menu_pos = {10, 18};\n*     CFBDGraphicSize menu_area = {108, 46};\n*     CFBDGraphic_InitText(&amp;menu, menu_pos, menu_area, ASCII_8x16);\n*\n*     // Draw title\n*     CFBDGraphic_SetText(&amp;title, \"MENU\");\n*     CFBDGraphic_DrawText(device, &amp;title, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     // Draw menu items\n*     CFBDGraphic_SetText(&amp;menu, \"Start\");\n*     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     CFBDGraphic_SetText(&amp;menu, \"Settings\");\n*     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     CFBDGraphic_SetText(&amp;menu, \"About\");\n*     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     CFBDGraphic_SetText(&amp;menu, \"Exit\");\n*     CFBDGraphic_DrawText(device, &amp;menu, CCGraphic_AsciiTextItem_AppendNextLine);\n*\n*     // Update display\n*     device-&gt;ops-&gt;update(device);\n* }\n*\n* void display_score(CFBD_GraphicDevice* device, int score) {\n*     CFBDGraphic_Text score_text;\n*     CFBDGraphic_Point pos = {80, 55};\n*     CFBDGraphicSize area = {48, 8};\n*     CFBDGraphic_InitText(&amp;score_text, pos, area, ASCII_6x8);\n*\n*     char score_buf[12];\n*     sprintf(score_buf, \"Score:%d\", score);\n*     CFBDGraphic_SetText(&amp;score_text, score_buf);\n*     CFBDGraphic_DrawText(device, &amp;score_text, CCGraphic_AsciiTextItem_AppendContinously);\n*\n*     device-&gt;ops-&gt;update(device);\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#part-iii-widget-system","title":"PART III: Widget System","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#introduction-to-graphics-widgets","title":"Introduction to Graphics Widgets","text":"<ul> <li> <ul> <li>The Graphics Widget system provides reusable, customizable UI components</li> </ul> </li> <li>built on top of the core Graphics Device abstraction. Widgets include:</li> <li> <ul> <li> <ul> <li>Image - Bitmap rendering at arbitrary positions</li> </ul> </li> </ul> </li> <li> <ul> <li>Menu - Hierarchical item selection with navigation</li> </ul> </li> <li> <ul> <li>ProgressBar - Progress visualization with animation</li> </ul> </li> <li> <ul> <li>Text - Text rendering (documented in previous section)</li> </ul> </li> <li> <ul> <li>Animation - Frame-based timing framework</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#widget-architecture","title":"Widget Architecture","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code> *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502      Graphics Widgets                       \u2502\n *  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n *  \u2502 Image | Menu | ProgressBar | Text          \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *                      \u2193\n *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502    Graphics Device Abstraction              \u2502\n *  \u2502  (immediate_draw, deferred_draw, update)    \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *                      \u2193\n *  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *  \u2502    Display Driver (OLED, LCD, etc.)         \u2502\n *  \u2502              Transport Layer                 \u2502\n *  \u2502              (I2C, SPI, GPIO)               \u2502\n *  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * ```\n\n* * \n\n\n\n# Design Principles\n\n\n\n* * - **No Dynamic Allocation** - All widgets use stack-allocated structures\n* - **Reference-Based** - Widgets reference device and data structures owned by caller\n* - **Operation Tables** - Callbacks enable polymorphic behavior without inheritance\n* - **Animation Support** - All visual widgets support frame-based animation\n* - **Flexible Drawing** - Immediate or deferred mode for optimization\n* * \n\n\n\n# Animation Framework\n\n\n\n* * All widgets support frame-based animation through [CFBD_BaseAnimation](Classes/structCFBD__BaseAnimation.md):\n* * \n\n```cpp\n* #include \"graphic/widget/animation/animation.h\"\n*\n* // Animation configuration\n* CFBD_BaseAnimation anim;\n* CFBD_InitBaseAnimation(&amp;anim);\n* anim.anim_frames = 16;        // 16 frames\n* anim.anim_frame_delay_ms = 25; // 25ms per frame = ~400ms total\n*\n* // Typical frame counts:\n* // UI feedback: 4-8 frames\n* // Smooth transitions: 8-16 frames\n* // Detailed animations: 16-32 frames\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#image-widget","title":"Image Widget","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#overview_1","title":"Overview","text":"<ul> <li> <ul> <li>The Image widget renders bitmap data at specified positions. Images must be</li> </ul> </li> <li>pre-allocated as arrays, and the widget references this data.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#initialization","title":"Initialization","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/widget/base_support/image.h\"\n*\n* // Create bitmap data (32x32 pixels, 1 byte per pixel)\n* uint8_t logo_bitmap[128] = {\n*     0xFF, 0xFF, ...,  // Row 0\n*     0x00, 0xFF, ...,  // Row 1\n*     // ...\n* };\n*\n* // Initialize image\n* CCGraphic_Image logo;\n* CFBDGraphic_Point pos = {48, 16};      // X=48, Y=16\n* CFBDGraphicSize sz = {32, 32};        // 32x32 pixels\n* CFBDGraphic_InitImage(&amp;logo, &amp;pos, &amp;sz, logo_bitmap);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#drawing","title":"Drawing","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Draw image on graphics device\n* CFBDGraphic_DrawImage(graphics_device, &amp;logo);\n*\n* // If in deferred mode, manually update\n* graphics_device-&gt;ops-&gt;update(graphics_device);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#menu-widget","title":"Menu Widget","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#overview_2","title":"Overview","text":"<ul> <li> <ul> <li>The Menu widget provides interactive list selection with:</li> </ul> </li> <li> <ul> <li>Keyboard navigation (next/previous item)</li> </ul> </li> <li> <ul> <li>Visual indicator bar showing current selection</li> </ul> </li> <li> <ul> <li>Callback support for item activation</li> </ul> </li> <li> <ul> <li>Animated transitions</li> </ul> </li> <li> <ul> <li>Configurable dimensions and fonts</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#initialization_1","title":"Initialization","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/widget/menu/menu.h\"\n* #include \"graphic/widget/menu/menu_indicator.h\"\n* #include \"graphic/widget/animation/animation.h\"\n*\n* // Pre-allocate menu items array\n* #define MAX_MENU_ITEMS 8\n* CFBD_MenuItem item_array[MAX_MENU_ITEMS];\n* CFBD_MenuItemGroup items = {\n*     .pItems = item_array,\n*     .capacity = MAX_MENU_ITEMS,\n*     .count = 0\n* };\n*\n* // Initialize menu\n* CFBD_Menu menu;\n* CFBDGraphic_Point menu_pos = {0, 0};\n* CFBD_InitMenu(&amp;menu, graphics_device, &amp;items, 128);\n* menu.tl_point = menu_pos;\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#adding-items","title":"Adding Items","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Callback when item selected\n* void on_start_game(void* ctx) {\n*     int* state = (int*)ctx;\n*     *state = STATE_RUNNING;\n* }\n*\n* // Configure indicator\n* CFBD_MenuIndicator indicator;\n* CFBD_InitDefaultMenuIndicator(&amp;indicator);\n* indicator.width = 4;\n* menu.operations-&gt;set_indicator_property(&amp;menu, &amp;indicator);\n*\n* // Add menu items\n* CFBD_MenuItemCallbackPack cb = {on_start_game, &amp;app_state};\n* menu.operations-&gt;add_item(&amp;menu, \"Start\", ASCII_8x16, &amp;cb);\n* menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n* menu.operations-&gt;add_item(&amp;menu, \"About\", ASCII_8x16, NULL);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#rendering","title":"Rendering","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Draw menu on graphics device\n* menu.operations-&gt;immediate_draw(&amp;menu);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#navigation","title":"Navigation","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Handle keyboard events\n* void on_up_button(CFBD_Menu* menu) {\n*     OLED_Menu_SelectPrev(menu);\n*     menu-&gt;operations-&gt;immediate_draw(menu);\n* }\n*\n* void on_down_button(CFBD_Menu* menu) {\n*     OLED_Menu_SelectNext(menu);\n*     menu-&gt;operations-&gt;immediate_draw(menu);\n* }\n*\n* void on_select_button(CFBD_Menu* menu) {\n*     menu-&gt;operations-&gt;activate_current(menu);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#menu-animation","title":"Menu Animation","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Enable smooth transitions\n* CFBD_BaseAnimation anim = {\n*     .anim_frames = 8,\n*     .anim_frame_delay_ms = 30\n* };\n* menu.operations-&gt;set_animation(&amp;menu, &amp;anim);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#progressbar-widget","title":"ProgressBar Widget","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#overview_3","title":"Overview","text":"<ul> <li> <ul> <li>The ProgressBar widget visualizes numeric progress with:</li> </ul> </li> <li> <ul> <li>Configurable min/max value range</li> </ul> </li> <li> <ul> <li>Optional border and padding</li> </ul> </li> <li> <ul> <li>Animated fill transitions</li> </ul> </li> <li> <ul> <li>Custom properties via property map</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#initialization_2","title":"Initialization","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/widget/progressbar/progressbar.h\"\n*\n* // Create progress bar\n* CFBD_ProgressBar progress;\n* CFBDGraphic_Point pos = {10, 50};\n* CFBDGraphicSize sz = {108, 8};\n* CFBD_ProgressBar_Init(&amp;progress, graphics_device, &amp;pos, &amp;sz, 0, 100);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#configuration","title":"Configuration","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Enable border\n* uint8_t border = 1;\n* progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n*\n* // Set padding (space between border and fill)\n* uint8_t padding = 2;\n* progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n*\n* // Configure animation\n* CFBD_BaseAnimation anim = {4, 50};  // 4 frames, 50ms each\n* progress.ops-&gt;set_property(&amp;progress, \"animation\", &amp;anim);\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#progress-updates","title":"Progress Updates","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Update progress (0-100)\n* for (int value = 0; value &lt;= 100; value += 5) {\n*     progress.ops-&gt;set_value(&amp;progress, value);\n*     progress.ops-&gt;immediate_draw(&amp;progress);\n*     HAL_Delay(100);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#widget-best-practices","title":"Widget Best Practices","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#memory-management","title":"Memory Management","text":"<ul> <li> <ul> <li> <ul> <li>Pre-allocate all widget structures statically or on stack</li> </ul> </li> </ul> </li> <li> <ul> <li>Pass pointers to graphics device and supporting data</li> </ul> </li> <li> <ul> <li>Ensure pointers remain valid for widget lifetime</li> </ul> </li> <li> <ul> <li>Use static arrays for menu items and bitmap data</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#performance","title":"Performance","text":"<ul> <li> <ul> <li> <ul> <li>Use deferred mode (request_updates = false) for batch widget updates</li> </ul> </li> </ul> </li> <li> <ul> <li>Call device-&gt;ops-&gt;update() once after drawing multiple widgets</li> </ul> </li> <li> <ul> <li>Minimize animation frame delay for UI responsiveness (25-50ms recommended)</li> </ul> </li> <li> <ul> <li>Disable animations for constrained environments</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#drawing-order","title":"Drawing Order","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Recommended drawing order:\n* graphics-&gt;ops-&gt;clear(graphics);\n* CFBDGraphic_DrawImage(graphics, &amp;bg_image);      // Background\n* menu.operations-&gt;immediate_draw(&amp;menu);           // UI elements\n* progress.ops-&gt;immediate_draw(&amp;progress);          // Foreground elements\n* graphics-&gt;ops-&gt;update(graphics);                  // Commit all changes\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#error-handling_1","title":"Error Handling","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* // Always check return values\n* if (!graphics-&gt;ops-&gt;setPixel(graphics, x, y)) {\n*     // Handle coordinate out of bounds\n* }\n*\n* if (!menu.operations-&gt;add_item(&amp;menu, \"Item\", size, &amp;cb)) {\n*     // Handle menu full (no more item slots)\n* }\n*\n* if (!progress.ops-&gt;set_property(&amp;progress, \"unknown\", NULL)) {\n*     // Handle unknown property\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#complete-widget-integration","title":"Complete Widget Integration","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"graphic/device/graphic_device.h\"\n* #include \"graphic/device/oled/oled_graphic_device.h\"\n* #include \"graphic/widget/base_support/image.h\"\n* #include \"graphic/widget/menu/menu.h\"\n* #include \"graphic/widget/progressbar/progressbar.h\"\n*\n* // Global state\n* int app_state = STATE_MENU;\n* int selected_game = 0;\n* int progress_percent = 0;\n*\n* // Callback for menu selection\n* void on_game_selected(void* ctx) {\n*     int* state = (int*)ctx;\n*     *state = STATE_LOADING;\n* }\n*\n* void main(void) {\n*     // Initialize OLED\n*     CFBD_OLED oled;\n*     CFBD_OLED_IICInitsParams iic = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = i2c_interface,\n*     };\n*     CFBD_GetOLEDHandle(&amp;oled, CFBD_OLEDDriverType_IIC, &amp;iic, CFBD_TRUE);\n*     oled.ops-&gt;open(&amp;oled);\n*\n*     // Bind graphics device\n*     CFBD_GraphicDevice graphics;\n*     CFBDGraphic_BindOLEDAsDevice(&amp;graphics, &amp;oled);\n*     graphics.ops-&gt;open(&amp;graphics);\n*     CFBDGraphic_DeviceSetIfRequestUpdateAtOnce(&amp;graphics, CFBD_FALSE);\n*\n*     // Setup menu\n*     CFBD_MenuItem items[4];\n*     CFBD_MenuItemGroup item_group = {items, 4, 0};\n*     CFBD_Menu menu;\n*     CFBD_InitMenu(&amp;menu, &amp;graphics, &amp;item_group, 128);\n*\n*     CFBD_MenuItemCallbackPack cb = {on_game_selected, &amp;app_state};\n*     menu.operations-&gt;add_item(&amp;menu, \"Tetris\", ASCII_8x16, &amp;cb);\n*     menu.operations-&gt;add_item(&amp;menu, \"Breakout\", ASCII_8x16, &amp;cb);\n*     menu.operations-&gt;add_item(&amp;menu, \"Settings\", ASCII_8x16, NULL);\n*\n*     // Setup progress bar for loading\n*     CFBD_ProgressBar progress;\n*     CFBDGraphic_Point prog_pos = {10, 50};\n*     CFBDGraphicSize prog_sz = {108, 8};\n*     CFBD_ProgressBar_Init(&amp;progress, &amp;graphics, &amp;prog_pos, &amp;prog_sz, 0, 100);\n*\n*     uint8_t border = 1, padding = 1;\n*     progress.ops-&gt;set_property(&amp;progress, \"border\", &amp;border);\n*     progress.ops-&gt;set_property(&amp;progress, \"padding\", &amp;padding);\n*\n*     // Main loop\n*     while (1) {\n*         switch (app_state) {\n*         case STATE_MENU:\n*             menu.operations-&gt;immediate_draw(&amp;menu);\n*             handle_menu_input(&amp;menu);\n*             break;\n*\n*         case STATE_LOADING:\n*             graphics.ops-&gt;clear(&amp;graphics);\n*             CFBDGraphic_DrawImage(&amp;graphics, &amp;loading_image);\n*             for (int i = 0; i &lt;= 100; i += 10) {\n*                 progress.ops-&gt;set_value(&amp;progress, i);\n*                 progress.ops-&gt;immediate_draw(&amp;progress);\n*                 graphics.ops-&gt;update(&amp;graphics);\n*                 HAL_Delay(100);\n*             }\n*             app_state = STATE_GAME;\n*             break;\n*         }\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li>\u2014</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/Graphics_Complete_UserGuide/#complete-documentation-references","title":"Complete Documentation References","text":"<ul> <li> <ul> <li> <ul> <li>Graphics Device Abstraction</li> </ul> </li> </ul> </li> <li> <ul> <li>Animation Framework</li> </ul> </li> <li> <ul> <li>Utility Helpers</li> </ul> </li> <li> <ul> <li>Resource Configuration</li> </ul> </li> <li> <ul> <li>Code Examples</li> </ul> </li> <li> <ul> <li>Widget Examples</li> </ul> </li> <li> <ul> <li>Complete Examples */ </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/Graphics_Widget_Documentation/","title":"Graphics Widget Documentation Summary","text":""},{"location":"api/Pages/Graphics_Widget_Documentation/#introduction-to-graphics-widgets","title":"Introduction to Graphics Widgets","text":"<ul> <li> <ul> <li>This document summarizes comprehensive Doxygen documentation enhancements</li> </ul> </li> <li>made to the Graphics Widget subsystem, complementing the core Graphics Device</li> <li>abstraction with reusable UI components.</li> </ul> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#widget-module-hierarchyn","title":"Widget Module Hierarchy\\n","text":"<p>*</p> <pre><code>\\n\n * Graphics\\n\n * \u251c\u2500\u2500 Graphics_Widget (Main Widget Module)\\n\n * \u2502   \u251c\u2500\u2500 Graphics_Image (Bitmap widget)\\n\n * \u2502   \u251c\u2500\u2500 Graphics_Menu (Menu widget with subcomponents)\\n\n * \u2502   \u2502   \u251c\u2500\u2500 Graphics_MenuItem (Individual menu items)\\n\n * \u2502   \u2502   \u251c\u2500\u2500 Graphics_MenuIndicator (Selection indicator)\\n\n * \u2502   \u2502   \u2514\u2500\u2500 Graphics_MenuConfig (Compile-time configuration)\\n\n * \u2502   \u2514\u2500\u2500 Graphics_ProgressBar (Progress visualization)\\n\n * \u2514\u2500\u2500 [existing Graphics_Device, Graphics_Animation, etc.]\\n\n * ```\n\n\n\n *\n* \n\n\n\n# Graphics_Image Module\\n\n\n*\n\n\n* **Location**: [lib/graphic/widget/base_support/image.h](Files/image_8h.md#file-image.h)\n\n *\n* **Purpose**: Bitmap image rendering at arbitrary positions\n\n *\n* **Key Components**:\n* - `[CCGraphic_Image](Classes/structCCGraphic__Image.md)` - Image structure (point, size, bitmap pointer)\n* - `[CFBDGraphic_InitImage()](Files/image_8c.md#function-cfbdgraphic-initimage)` - Initialize image with data\n* - `[CFBDGraphic_DrawImage()](Files/image_8c.md#function-cfbdgraphic-drawimage)` - Render image to graphics device\n\n *\n* **Features**:\n* - Flexible bitmap data ownership (caller owned)\n* - No size restrictions (limited by device resolution)\n* - Respects device drawing mode (immediate/deferred)\n\n *\n* **Usage Pattern**:\n* \n\n```cpp\n\\n\n* 1. Create bitmap data array\\n\n* 2. Call CFBDGraphic_InitImage() with position and size\\n\n* 3. Call CFBDGraphic_DrawImage() to render\\n\n* 4. Update device if in deferred mode\\n\n* \n</code></pre> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_menu-modulen","title":"Graphics_Menu Module\\n","text":"<p>*</p> <ul> <li>Location: lib/graphic/widget/menu/menu.h (with config, indicator, item support)</li> </ul> <p>* * Purpose: Interactive menu system with navigation and selection</p> <p>* * Submodules:</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_menuindicatorn","title":"Graphics_MenuIndicator\\n","text":"<p>*</p> <ul> <li>Purpose: Visual selection indicator bar</li> </ul> <p>* * Components: * - <code>CFBD_MenuIndicator</code> - Configuration (width, x position) * - <code>[CFBD_InitDefaultMenuIndicator()](Files/menu__indicator_8c.md#function-cfbd-initdefaultmenuindicator)</code> - Initialize from config macros * - <code>[CFBD_DrawMenuIndicator()](Files/menu__indicator_8c.md#function-cfbd-drawmenuindicator)</code> - Render indicator</p> <p>* * Configuration: * - Width: 0-8 pixels (0 = disabled) * - X position: Left edge in pixels</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_menuitemn","title":"Graphics_MenuItem\\n","text":"<p>*</p> <ul> <li>Purpose: Individual menu items with labels and callbacks</li> </ul> <p>* * Components: * - <code>CFBD_MenuItem</code> - Single item structure * - <code>CFBD_MenuItemGroup</code> - Array container * - <code>CFBD_MenuItemCallback</code> - Callback function type * - <code>[CFBD_MenuItemCallbackPack](Classes/structCFBD__MenuItemCallbackPack.md)</code> - Callback + user data wrapper * - <code>[CFBD_MenuItemInit()](Files/menu__item_8c.md#function-cfbd-menuiteminit)</code> - Initialize item</p> <p>* * Features: * - Zero-terminated string labels (caller owned) * - Optional selection callback with user data * - Configurable text rendering properties</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_menuconfign","title":"Graphics_MenuConfig\\n","text":"<p>*</p> <ul> <li>Purpose: Compile-time menu appearance configuration</li> </ul> <p>* * Configuration Macros: * - <code>CFBD_MENU_INDICATOR_WIDTH</code> - Default indicator width (4px) * - <code>CFBD_MENU_INDICATOR_POSX</code> - Default indicator X position (0) * - <code>CFBD_MENU_INDICATOR_MAX_WIDTH_PX</code> - Maximum width (8px) * - <code>CFBD_MENU_INDICATOR_MAX_HEIGHT_PX</code> - Maximum height (16px) * - <code>CFBD_MENU_INDICATOR_GAP</code> - Gap between indicator and items (4px) * - <code>CFBD_MENU_ITEM_Y_GAP</code> - Vertical spacing between items (0px)</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_menu-mainn","title":"Graphics_Menu (Main)\\n","text":"<p>*</p> <ul> <li>Key Components:</li> <li> <ul> <li><code>CFBD_Menu</code> - Main menu structure</li> </ul> </li> <li> <ul> <li><code>[CFBD_MenuOps](Classes/structCFBD__MenuOps.md)</code> - Operation table with 8 callbacks</li> </ul> </li> <li> <ul> <li><code>[CFBD_InitMenu()](Files/menu_8c.md#function-cfbd-initmenu)</code> - Initialize menu</li> </ul> </li> <li> <ul> <li><code>[OLED_Menu_SelectNext()](Files/menu_8h.md#function-oled-menu-selectnext)</code> - Navigate down (inline)</li> </ul> </li> <li> <ul> <li><code>[OLED_Menu_SelectPrev()](Files/menu_8h.md#function-oled-menu-selectprev)</code> - Navigate up (inline)</li> </ul> </li> </ul> <p>* * Operations: * - bind_item_groups_contains() - Associate items array * - add_item() - Add item dynamically * - set_indicator_property() - Configure indicator * - set_animation() - Set transition animation * - immediate_draw() - Render complete menu * - select_index() - Change selection * - activate_current() - Invoke item callback * - reset_tl_points() - Reposition menu</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#graphics_progressbar-modulen","title":"Graphics_ProgressBar Module\\n","text":"<p>*</p> <ul> <li>Location: lib/graphic/widget/progressbar/progressbar.h</li> </ul> <p>* * Purpose: Progress visualization with fill animation</p> <p>* * Key Components: * - <code>CFBD_ProgressBar</code> - Main structure * - <code>[CFBD_ProgressBarOps](Classes/structCFBD__ProgressBarOps.md)</code> - Operation table * - <code>[CFBD_ProgressBar_Init()](Files/progressbar_8c.md#function-cfbd-progressbar-init)</code> - Initialize progress bar</p> <p>* * Operations: * - immediate_draw() - Render current progress * - set_value() - Update progress value * - set_property() - Configure visual properties</p> <p>* * Configuration: * - \"border\" (uint8_t) - Border enabled/disabled * - \"padding\" (uint8_t) - Inner padding (0-8px) * - \"animation\" (CFBD_BaseAnimation*) - Transition timing</p> <p>* * </p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#documentation-enhancementsn","title":"Documentation Enhancements\\n","text":"<p>*</p>"},{"location":"api/Pages/Graphics_Widget_Documentation/#file-level-documentationn","title":"File-Level Documentation\\n","text":"<p>*</p> <ul> <li>Every widget header enhanced with:</li> <li> <ul> <li> </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/OLED_Documentation_Summary/","title":"OLED Documentation Summary","text":"<ul> <li> <ul> <li>This page summarizes the comprehensive Doxygen documentation additions made</li> </ul> </li> <li>to the OLED driver subsystem.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Documentation_Summary/#overview-of-enhancements","title":"Overview of Enhancements","text":"<ul> <li> <ul> <li>The OLED driver documentation has been significantly enhanced to support</li> </ul> </li> <li>Doxygen's advanced features, including:</li> <li> <ul> <li> <ul> <li>**Modules ( **</li> </ul> </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/OLED_Examples/","title":"OLED Driver Examples","text":"<ul> <li> <ul> <li> <ul> <li> <ul> <li>This page contains comprehensive code examples demonstrating how to use</li> </ul> </li> </ul> </li> </ul> </li> <li>the OLED driver for various common tasks.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#basic-device-initialization","title":"Basic Device Initialization","text":"<ul> <li> <ul> <li>The most fundamental example showing device setup and initialization:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #include \"oled.h\"\n* #include \"driver/backend/oled_iic.h\"\n* #include \"driver/device/ssd1309/ssd1309.h\"\n*\n* void example_basic_init(void) {\n*     // Create OLED device structure\n*     CFBD_OLED oled;\n*\n*     // Setup I2C parameters\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,  // Use standard address\n*         .i2c_handle = get_my_i2c_interface(),\n*     };\n*\n*     // Initialize OLED with I2C backend\n*     CFBD_bool success = CFBD_GetOLEDHandle(\n*         &amp;oled,\n*         CFBD_OLEDDriverType_IIC,\n*         &amp;i2c_params,\n*         CFBD_TRUE  // Immediate initialization\n*     );\n*\n*     if (success &amp;&amp; oled.ops-&gt;open(&amp;oled)) {\n*         // Device is now ready for use\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#clear-display","title":"Clear Display","text":"<ul> <li> <ul> <li>Clear all pixels and update the physical display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_clear_display(CFBD_OLED* oled) {\n*     // Clear all pixels in the local buffer\n*     oled-&gt;ops-&gt;clear(oled);\n*\n*     // Synchronize with physical display\n*     oled-&gt;ops-&gt;update(oled);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#drawing-individual-pixels","title":"Drawing Individual Pixels","text":"<ul> <li> <ul> <li>Set individual pixels to create a pattern:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_draw_checkerboard(CFBD_OLED* oled) {\n*     // Get display dimensions\n*     uint16_t width = 0, height = 0;\n*     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n*     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n*\n*     // Draw checkerboard pattern\n*     for (uint16_t y = 0; y &lt; height; y += 2) {\n*         for (uint16_t x = 0; x &lt; width; x += 2) {\n*             if ((x + y) % 4 == 0) {\n*                 oled-&gt;ops-&gt;setPixel(oled, x, y);\n*             }\n*         }\n*     }\n*\n*     // Update display\n*     oled-&gt;ops-&gt;update(oled);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#area-based-drawing","title":"Area-Based Drawing","text":"<ul> <li> <ul> <li>Efficiently update rectangular regions of the display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_draw_rectangle(CFBD_OLED* oled,\n*                             uint16_t x, uint16_t y,\n*                             uint16_t width, uint16_t height) {\n*     // Prepare bitmap data (format depends on device)\n*     uint8_t* bitmap = prepare_rectangle_data(width, height);\n*\n*     // Write the area\n*     CFBD_bool success = oled-&gt;ops-&gt;setArea(oled, x, y, width, height, bitmap);\n*\n*     if (success) {\n*         // Update only this area on the display\n*         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n*     }\n*\n*     free_bitmap_data(bitmap);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#device-property-queries","title":"Device Property Queries","text":"<ul> <li> <ul> <li>Query device capabilities and properties:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_query_device(CFBD_OLED* oled) {\n*     uint16_t width = 0, height = 0;\n*     CFBD_bool is_rgb = CFBD_FALSE;\n*\n*     // Query basic properties\n*     oled-&gt;ops-&gt;self_consult(oled, \"width\", NULL, &amp;width);\n*     oled-&gt;ops-&gt;self_consult(oled, \"height\", NULL, &amp;height);\n*     oled-&gt;ops-&gt;self_consult(oled, \"rgb\", NULL, &amp;is_rgb);\n*\n*     // Report display information\n*     printf(\"Display Resolution: %u x %u pixels\\n\", width, height);\n*     printf(\"Color Mode: %s\\n\", is_rgb ? \"RGB Color\" : \"Monochrome\");\n*     printf(\"Total Pixels: %u\\n\", (unsigned long)width * height);\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#clearing-specific-regions","title":"Clearing Specific Regions","text":"<ul> <li> <ul> <li>Clear only a portion of the display:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_clear_area(CFBD_OLED* oled,\n*                        uint16_t x, uint16_t y,\n*                        uint16_t width, uint16_t height) {\n*     // Clear rectangular area in the frame buffer\n*     CFBD_bool success = oled-&gt;ops-&gt;clear_area(oled, x, y, width, height);\n*\n*     if (success) {\n*         // Update the cleared area on the physical display\n*         oled-&gt;ops-&gt;update_area(oled, x, y, width, height);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#multiple-oled-devices","title":"Multiple OLED Devices","text":"<ul> <li> <ul> <li>Control multiple OLED displays on different I2C addresses:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* #define NUM_DISPLAYS 2\n*\n* void example_multiple_displays(void) {\n*     CFBD_OLED oled_displays[NUM_DISPLAYS];\n*\n*     // Configuration for each display\n*     struct {\n*         uint8_t address;\n*     } configs[NUM_DISPLAYS] = {\n*         { 0x78 },  // First device\n*         { 0x7A },  // Second device (alternate address)\n*     };\n*\n*     // Initialize all displays\n*     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n*         CFBD_OLED_IICInitsParams i2c_params = {\n*             .device_address = configs[i].address,\n*             .i2c_handle = get_i2c_interface(),\n*         };\n*\n*         if (CFBD_GetOLEDHandle(&amp;oled_displays[i],\n*                                CFBD_OLEDDriverType_IIC,\n*                                &amp;i2c_params,\n*                                CFBD_TRUE)) {\n*             oled_displays[i].ops-&gt;open(&amp;oled_displays[i]);\n*         }\n*     }\n*\n*     // Use both displays independently\n*     for (int i = 0; i &lt; NUM_DISPLAYS; i++) {\n*         oled_displays[i].ops-&gt;clear(&amp;oled_displays[i]);\n*         oled_displays[i].ops-&gt;update(&amp;oled_displays[i]);\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#deferred-initialization","title":"Deferred Initialization","text":"<ul> <li> <ul> <li>Create device handle but delay initialization:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_deferred_init(void) {\n*     CFBD_OLED oled;\n*\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*\n*     // Create handle without immediate initialization\n*     if (CFBD_GetOLEDHandle(&amp;oled,\n*                            CFBD_OLEDDriverType_IIC,\n*                            &amp;i2c_params,\n*                            CFBD_FALSE)) {  // Deferred init\n*\n*         // ... perform other setup operations ...\n*\n*         // Later, initialize when needed\n*         oled.ops-&gt;init(&amp;oled, NULL);\n*         oled.ops-&gt;open(&amp;oled);\n*\n*         // Now ready for use\n*     }\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#error-handling","title":"Error Handling","text":"<ul> <li> <ul> <li>Proper error checking throughout device usage:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* CFBD_bool safe_display_operation(void) {\n*     CFBD_OLED oled;\n*\n*     // Step 1: Initialize with error checking\n*     CFBD_OLED_IICInitsParams i2c_params = {\n*         .device_address = SSD1309_DRIVER_ADDRESS,\n*         .i2c_handle = get_i2c_interface(),\n*     };\n*\n*     if (!CFBD_GetOLEDHandle(&amp;oled,\n*                             CFBD_OLEDDriverType_IIC,\n*                             &amp;i2c_params,\n*                             CFBD_TRUE)) {\n*         printf(\"ERROR: Failed to get OLED handle\\n\");\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 2: Open device with error checking\n*     if (!oled.ops-&gt;open(&amp;oled)) {\n*         printf(\"ERROR: Failed to open OLED device\\n\");\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 3: Perform operations with error checking\n*     if (!oled.ops-&gt;clear(&amp;oled)) {\n*         printf(\"ERROR: Failed to clear display\\n\");\n*         oled.ops-&gt;close(&amp;oled);\n*         return CFBD_FALSE;\n*     }\n*\n*     if (!oled.ops-&gt;update(&amp;oled)) {\n*         printf(\"ERROR: Failed to update display\\n\");\n*         oled.ops-&gt;close(&amp;oled);\n*         return CFBD_FALSE;\n*     }\n*\n*     // Step 4: Cleanup\n*     oled.ops-&gt;close(&amp;oled);\n*     return CFBD_TRUE;\n* }\n* \n</code></pre> <ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_Examples/#text-display-pattern","title":"Text Display Pattern","text":"<ul> <li> <ul> <li>Example showing how to structure text display operations:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul> <pre><code>* void example_display_pattern(CFBD_OLED* oled) {\n*     // Get display dimensions\n*     uint16_t width = 128, height = 64;  // Typical SSD1309\n*\n*     // Clear and prepare\n*     oled-&gt;ops-&gt;clear(oled);\n*     oled-&gt;ops-&gt;update(oled);\n*\n*     // Create a pattern (horizontal lines)\n*     for (uint16_t y = 0; y &lt; height; y += 4) {\n*         for (uint16_t x = 0; x &lt; width; x++) {\n*             oled-&gt;ops-&gt;setPixel(oled, x, y);\n*         }\n*     }\n*\n*     // Update display with new pattern\n*     oled-&gt;ops-&gt;update(oled);\n*\n*     // Alternative: update only affected area for efficiency\n*     // oled-&gt;ops-&gt;update_area(oled, 0, 0, width, height);\n* }\n* \n</code></pre> <ul> <li> <ul> <li>OLED Driver Usage Guidefor detailed usage documentation</li> </ul> </li> <li> <p>CFBD_OLEDfor device structure documentation</p> </li> <li> <p>CFBD_OLEDOperationsfor operation table documentation */ </p> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/OLED_UsageGuide/","title":"OLED Driver Usage Guide","text":""},{"location":"api/Pages/OLED_UsageGuide/#overview","title":"Overview","text":"<ul> <li> <ul> <li>The OLED subsystem provides a generic, transport-agnostic interface for</li> </ul> </li> <li>controlling OLED displays. It supports multiple device types (SSD1306, SSD1309, etc.)</li> <li>and multiple communication backends (I2C, SPI).</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#architecture","title":"Architecture","text":"<ul> <li> <ul> <li>The OLED driver architecture consists of three main layers:</li> </ul> </li> <li> <ul> <li> <ul> <li>Generic OLED Driver: The top-level interface (<code>[oled.h](Files/oled_8h.md#file-oled.h)</code>) that application</li> </ul> </li> </ul> </li> <li>code interacts with. Provides a device-agnostic API for rendering and control.</li> <li> <ul> <li> <ul> <li>Device Drivers: Device-specific implementations (SSD1306, SSD1309) that</li> </ul> </li> </ul> </li> <li>provide device-specific initialization, memory layouts, and communication prefixes.</li> <li> <ul> <li> <ul> <li>Transport Backends: Transport-specific implementations (I2C, SPI) that</li> </ul> </li> </ul> </li> <li>handle the actual hardware communication with the device.</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#gettingstarted","title":"GettingStarted","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#include-required-headers","title":"Include Required Headers","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"driver/backend/oled_iic.h\"</code></li> <li><code>#include \"driver/device/ssd1309/ssd1309.h\" *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#initialize-i2c-transport","title":"Initialize I2C Transport","text":"<ul> <li> <ul> <li>Before initializing the OLED device, ensure your I2C interface is properly</li> </ul> </li> <li>configured. Prepare the I2C initialization parameters:</li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) i2c_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS, // 0x78</code></li> <li><code>.i2c_handle = &amp;my_i2c_interface,</code></li> <li><code>.notify_tx_complete = on_i2c_transmit_complete,</code></li> <li><code>.notify_error = on_i2c_error,</code></li> <li><code>}; *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#get-oled-device-handle","title":"Get OLED Device Handle","text":"<ul> <li> <ul> <li>Use <code>[CFBD_GetOLEDHandle()](Files/oled_8c.md#function-cfbd-getoledhandle)</code> to create and initialize an OLED device:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled_device;</code></li> <li>``</li> <li><code>if (CFBD_GetOLEDHandle(&amp;oled_device,</code></li> <li><code>CFBD_OLEDDriverType_IIC,</code></li> <li><code>&amp;i2c_config,</code></li> <li><code>CFBD_TRUE)) { // Request immediate initialization</code></li> <li><code>// Device handle created successfully</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#enable-the-display","title":"Enable the Display","text":"<ul> <li> <ul> <li>Open/enable the OLED display:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>if (oled_device.ops-&gt;open(&amp;oled_device)) {</code></li> <li><code>// Display is now powered on and ready</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#commonoperations","title":"CommonOperations","text":"<ul> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#clear-the-entire-display","title":"Clear the Entire Display","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Clear all pixels</code></li> <li><code>oled_device.ops-&gt;clear(&amp;oled_device);</code></li> <li>``</li> <li><code>// Push changes to physical display</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#draw-individual-pixels","title":"Draw Individual Pixels","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Set pixel at (x=64, y=32) to on</code></li> <li><code>CFBD_bool success = oled_device.ops-&gt;setPixel(&amp;oled_device, 64, 32);</code></li> <li>``</li> <li><code>// Update display to show the pixel</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#draw-a-block-of-data","title":"Draw a Block of Data","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Example: Draw a 16x16 bitmap at position (0, 0)</code></li> <li><code>uint8_t bitmap_data[32]; // 16x16 pixels, monochrome format</code></li> <li>``</li> <li><code>oled_device.ops-&gt;setArea(&amp;oled_device,</code></li> <li><code>0, 0, // x, y position</code></li> <li><code>16, 16, // width, height</code></li> <li><code>bitmap_data); // source data</code></li> <li>``</li> <li><code>// Update the area on display</code></li> <li><code>oled_device.ops-&gt;update_area(&amp;oled_device, 0, 0, 16, 16); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#query-display-properties","title":"Query Display Properties","text":"<ul> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>// Query display width</code></li> <li><code>uint16_t width = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);</code></li> <li>``</li> <li><code>// Query display height</code></li> <li><code>uint16_t height = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);</code></li> <li>``</li> <li><code>// Query color support (RGB vs monochrome)</code></li> <li><code>CFBD_bool is_rgb = CFBD_FALSE;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"rgb\", NULL, &amp;is_rgb);</code></li> <li>``</li> <li><code>printf(\"Display: %u x %u, Color Mode: %s\\n\",</code></li> <li><code>width, height, is_rgb ? \"RGB\" : \"Monochrome\"); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#closedisable-the-display","title":"Close/Disable the Display","text":"<ul> <li> <ul> <li>When finished with the display, close it to power off and release resources:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>oled_device.ops-&gt;close(&amp;oled_device); *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#completeexample","title":"CompleteExample","text":"<ul> <li> <ul> <li>Here's a complete example demonstrating the OLED driver usage:</li> </ul> </li> <li> <ul> <li><code>cpp</code></li> </ul> </li> <li><code>#include \"oled.h\"</code></li> <li><code>#include \"driver/backend/oled_iic.h\"</code></li> <li><code>#include \"driver/device/ssd1309/ssd1309.h\"</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li>``</li> <li><code>void oled_demo(void) {</code></li> <li><code>// Step 1: Setup I2C configuration</code></li> <li><code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md) i2c_config = {</code></li> <li><code>.device_address = SSD1309_DRIVER_ADDRESS,</code></li> <li><code>.i2c_handle = get_i2c_interface(),</code></li> <li><code>};</code></li> <li>``</li> <li><code>// Step 2: Get OLED device handle</code></li> <li><code>[CFBD_OLED](Classes/structCFBD__OLED.md) oled_device;</code></li> <li><code>if (!CFBD_GetOLEDHandle(&amp;oled_device,</code></li> <li><code>CFBD_OLEDDriverType_IIC,</code></li> <li><code>&amp;i2c_config,</code></li> <li><code>CFBD_TRUE)) {</code></li> <li><code>printf(\"Failed to initialize OLED device\\n\");</code></li> <li><code>return;</code></li> <li><code>}</code></li> <li>``</li> <li><code>// Step 3: Open the display</code></li> <li><code>if (!oled_device.ops-&gt;open(&amp;oled_device)) {</code></li> <li><code>printf(\"Failed to open OLED device\\n\");</code></li> <li><code>return;</code></li> <li><code>}</code></li> <li>``</li> <li><code>// Step 4: Query and display device information</code></li> <li><code>uint16_t width = 0, height = 0;</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"width\", NULL, &amp;width);</code></li> <li><code>oled_device.ops-&gt;self_consult(&amp;oled_device, \"height\", NULL, &amp;height);</code></li> <li><code>printf(\"OLED Display: %u x %u pixels\\n\", width, height);</code></li> <li>``</li> <li><code>// Step 5: Clear the display</code></li> <li><code>oled_device.ops-&gt;clear(&amp;oled_device);</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device);</code></li> <li>``</li> <li><code>// Step 6: Draw some pixels</code></li> <li><code>for (uint16_t x = 0; x &lt; width; x += 2) {</code></li> <li><code>oled_device.ops-&gt;setPixel(&amp;oled_device, x, 10);</code></li> <li><code>}</code></li> <li><code>oled_device.ops-&gt;update(&amp;oled_device);</code></li> <li>``</li> <li><code>// Step 7: Close the display</code></li> <li><code>oled_device.ops-&gt;close(&amp;oled_device);</code></li> <li><code>} *</code></li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#supporteddevices","title":"SupportedDevices","text":"<ul> <li> <ul> <li>Currently supported OLED controller chips:</li> </ul> </li> <li> <ul> <li>SSD1306: Common monochrome controller, 128x64 resolution typical</li> </ul> </li> <li> <ul> <li>SSD1309: Enhanced version with improved contrast and timing control</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#supportedtransports","title":"SupportedTransports","text":"<ul> <li> <ul> <li>Available transport backends:</li> </ul> </li> <li> <ul> <li>I2C (IIC): Two-wire interface, default at 0x78 for SSD1309</li> </ul> </li> <li> <ul> <li>SPI: High-speed serial interface (implementation available)</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#error-handling","title":"Error Handling","text":"<ul> <li> <ul> <li>Most operations return <code>CFBD_bool</code> (TRUE/FALSE) to indicate success or failure.</li> </ul> </li> <li>Common error conditions:</li> <li> <ul> <li>Invalid device address</li> </ul> </li> <li> <ul> <li>I2C communication errors</li> </ul> </li> <li> <ul> <li>Device not initialized or opened</li> </ul> </li> <li> <ul> <li>Out-of-bounds coordinate access</li> </ul> </li> <li> <ul> <li>Always check return values before proceeding with display operations.</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#considerations","title":"Considerations","text":"<ul> <li> <ul> <li> <ul> <li>Full frame updates: Use <code>[update()](Files/oled__iic__130x_8c.md#function-update)</code> for complete display refresh</li> </ul> </li> </ul> </li> <li> <ul> <li>Partial updates: Use <code>update_area()</code> for better performance when</li> </ul> </li> <li>updating only specific regions</li> <li> <ul> <li>Buffering: The driver maintains a local frame buffer; changes are</li> </ul> </li> <li>not visible on the display until <code>[update()](Files/oled__iic__130x_8c.md#function-update)</code> or <code>update_area()</code> is called</li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <ul> <li>Display not responding: Verify I2C address and electrical connections</li> </ul> </li> <li> <ul> <li>Garbled display: Check frame buffer data format and pixel ordering</li> </ul> </li> <li> <ul> <li>Slow updates: Consider using area-based updates instead of full updates</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/OLED_UsageGuide/#complete-documentation-references","title":"Complete Documentation References","text":"<ul> <li> <ul> <li> <ul> <li>OLED Display Driver Main OLED driver module</li> </ul> </li> </ul> </li> <li> <ul> <li>OLED Device Interface Device interface documentation</li> </ul> </li> <li> <ul> <li>OLED Backend Implementations Backend transport implementations</li> </ul> </li> <li>*/ </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/_2strong/","title":"2strong","text":"<p>title: &gt;: Comprehensive guides and reference documentation</p>"},{"location":"api/Pages/_2strong/#-comprehensive-guides-and-reference-documentation","title":"&gt;: Comprehensive guides and reference documentation","text":"<ul> <li> <ul> <li>Detailed Comments: Extended sections with implementation guidance</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#module-organization","title":"Module Organization","text":"<ul> <li> <ul> <li>The OLED subsystem is organized into the following modules:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled---main-display-driver","title":"OLED - Main Display Driver","text":"<ul> <li> <ul> <li>Location: oled.h</li> </ul> </li> <li> <ul> <li>Purpose: Generic OLED interface and device operations</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED device structure</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations virtual operation table</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType transport enumeration</li> </ul> </li> <li> <ul> <li>CFBD_GetOLEDHandle() factory function</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_device---device-interface","title":"OLED_Device - Device Interface","text":"<ul> <li> <ul> <li>Location: device_interface.h, ssd1306.h, ssd1309.h</li> </ul> </li> <li> <ul> <li>Purpose: Device-specific configurations and factories</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_DeviceSpecific structure</li> </ul> </li> <li> <ul> <li>getSSD1306Specific() factory function</li> </ul> </li> <li> <ul> <li>getSSD1309Specific() factory function</li> </ul> </li> <li> <ul> <li>SSD1309_DRIVER_ADDRESS constant</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_backend---transport-backends","title":"OLED_Backend - Transport Backends","text":"<ul> <li> <ul> <li>Location: oled_iic.h (and potentially future spi backends)</li> </ul> </li> <li> <ul> <li>Purpose: Transport-specific implementations</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD_OLED_IICInit() I2C initialization</li> </ul> </li> <li> <ul> <li>Backend parameter structures</li> </ul> </li> <li> <ul> <li>Transport configuration</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#new-documentation-files","title":"New Documentation Files","text":"<ul> <li> <ul> <li>Three comprehensive documentation files have been created:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_usageguidemd-page-oled_usageguide","title":"OLED_UsageGuide.md (@page OLED_UsageGuide)","text":"<ul> <li> <ul> <li>Purpose: Comprehensive user guide for OLED driver usage</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>Architecture overview</li> </ul> </li> <li> <ul> <li>Getting started instructions (steps 1-4)</li> </ul> </li> <li> <ul> <li>Common operations guide</li> </ul> </li> <li> <ul> <li>Complete working example</li> </ul> </li> <li> <ul> <li>Performance considerations</li> </ul> </li> <li> <ul> <li>Troubleshooting guide</li> </ul> </li> <li> <ul> <li>Target Audience: Application developers</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_examplesmd-page-oled_examples","title":"OLED_Examples.md (@page OLED_Examples)","text":"<ul> <li> <ul> <li>Purpose: Collection of practical code examples</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>10+ complete, runnable examples</li> </ul> </li> <li> <ul> <li>Basic initialization</li> </ul> </li> <li> <ul> <li>Display clearing and updating</li> </ul> </li> <li> <ul> <li>Pixel and area drawing</li> </ul> </li> <li> <ul> <li>Device property queries</li> </ul> </li> <li> <ul> <li>Multi-display management</li> </ul> </li> <li> <ul> <li>Error handling patterns</li> </ul> </li> <li> <ul> <li>Deferred initialization</li> </ul> </li> <li> <ul> <li>Target Audience: Developers learning by example</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oled_namespacemd-page-oled-namespace","title":"OLED_Namespace.md (@page OLED Namespace)","text":"<ul> <li> <ul> <li>Purpose: Namespace organization documentation</li> </ul> </li> <li> <ul> <li>Contents:</li> </ul> </li> <li> <ul> <li>CFBD namespace overview</li> </ul> </li> <li> <ul> <li>CFBD::OLED sub-namespace</li> </ul> </li> <li> <ul> <li>Component organization</li> </ul> </li> <li> <ul> <li>Target Audience: Architecture documentation readers</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#enhanced-inline-documentation","title":"Enhanced Inline Documentation","text":"<ul> <li> <ul> <li>All header files have received extensive documentation improvements:</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#oledh-enhancements","title":"oled.h Enhancements","text":"<ul> <li> <ul> <li>Enumerations:</li> </ul> </li> <li> <ul> <li>CFBD_OLEDDriverType: Expanded with detailed transport descriptions</li> </ul> </li> <li> <ul> <li>Type Definitions:</li> </ul> </li> <li> <ul> <li>AreaOperations: Enhanced with usage examples</li> </ul> </li> <li> <ul> <li>FrameOperation: Detailed operation semantics</li> </ul> </li> <li> <ul> <li>OLEDSelfOperation: Lifecycle management documentation</li> </ul> </li> <li> <ul> <li>OLED_QueryOperation: Property query protocol and examples</li> </ul> </li> <li> <ul> <li>CFBDOLED_Params_Inits: Transport-specific parameter abstraction</li> </ul> </li> <li> <ul> <li>Structures:</li> </ul> </li> <li> <ul> <li>CFBD_OLEDOperations: Complete operation table with:</li> </ul> </li> <li> <ul> <li>Field-by-field documentation</li> </ul> </li> <li> <ul> <li>Usage examples</li> </ul> </li> <li> <ul> <li>Supported operation types</li> </ul> </li> <li> <ul> <li>CFBD_OLED: Device object with:</li> </ul> </li> <li> <ul> <li>Member descriptions</li> </ul> </li> <li> <ul> <li>Usage patterns</li> </ul> </li> <li> <ul> <li>Lifecycle documentation</li> </ul> </li> <li> <ul> <li>Functions:</li> </ul> </li> <li> <ul> <li>CFBD_GetOLEDHandle(): Extended documentation with:</li> </ul> </li> <li> <ul> <li>Multiple usage examples</li> </ul> </li> <li> <ul> <li>Transport-specific parameter guidelines</li> </ul> </li> <li> <ul> <li>Error handling guidance</li> </ul> </li> <li> <ul> <li>Two complete code examples</li> </ul> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/_2strong/#device_interfaceh-enhancements","title":"device_interface.h Enhancements","text":"<ul> <li> <ul> <li>**New </li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/application_setup/","title":"Application Initialization and Setup","text":""},{"location":"api/Pages/application_setup/#overview","title":"Overview","text":"<p>The application module provides a unified interface for initializing and managing an embedded application's boot sequence and clock providers. This design allows applications to register their initialization routines and timing sources with the CFBD framework.</p>"},{"location":"api/Pages/application_setup/#architecture","title":"Architecture","text":"<p>The <code>CFBDApplication</code> structure acts as a central registry containing:</p> <ul> <li>Bootstrap function and parameters for system initialization</li> <li>Clock frequency provider for timing calculations</li> <li>Tick counter provider for interval measurement</li> </ul>"},{"location":"api/Pages/application_setup/#basic-application-setup","title":"Basic Application Setup","text":"<pre><code>#include \"lib/application/app.h\"\n\n// Clock providers (from platform code)\nuint32_t get_system_clock_hz(void) {\n    return 72000000;  // STM32F103 at 72 MHz\n}\n\nuint32_t get_tick_count(void) {\n    return SysTick-&gt;VAL;  // Read from system timer\n}\n\n// Application bootstrap\nCFBD_Bool app_bootstrap(void* self_handle, void* args) {\n    // Initialize peripherals\n    init_gpio();\n    init_uart();\n    return CFBD_TRUE;\n}\n\n// Application instance\nCFBDApplication g_app = {\n    .selfBootFunc = app_bootstrap,\n    .bootargs = NULL,\n    .freq_provider = get_system_clock_hz,\n    .tick_provider = get_tick_count\n};\n\n// Application retrieval\nCFBDApplication* getApp(CFBD_Bool request_auto_boot) {\n    if (request_auto_boot &amp;&amp; g_app.selfBootFunc) {\n        g_app.selfBootFunc(&amp;g_app, g_app.bootargs);\n    }\n    return &amp;g_app;\n}\n</code></pre>"},{"location":"api/Pages/application_setup/#timing-and-clock-coordination","title":"Timing and Clock Coordination","text":"<pre><code>// Get current timing information\nCFBDApplication* app = getApp(CFBD_FALSE);\nuint32_t freq = app-&gt;freq_provider();  // Get clock frequency\nuint32_t ticks = app-&gt;tick_provider(); // Get current tick count\n\n// Calculate delay in milliseconds\nuint32_t ms_per_tick = 1000 / freq;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/boot_page/","title":"Boot System Design","text":""},{"location":"api/Pages/boot_page/#introduction","title":"Introduction","text":"<p>The CFBD Boot System provides a lightweight, generic framework for managing application startup sequences. It separates bootstrap logic from main application code, enabling modular initialization of hardware, drivers, and application layers.</p>"},{"location":"api/Pages/boot_page/#architecture","title":"Architecture","text":"<p>The boot system consists of three core components:</p> <ul> <li>Bootstrap Arguments (CFBD_BootArgs): Opaque containers for configuration data</li> <li>Bootstrap Functions (CFBD_BootStrapFunc): Entry points executed during startup</li> <li>Bootstrap Tuples (CFBDBootTuple): Associations between functions and their arguments</li> </ul>"},{"location":"api/Pages/boot_page/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Define boot configuration structures for each initialization stage</li> <li>Create bootstrap functions that operate on those configurations</li> <li>Build a static boot table using <code>[CFBDBootTuple](Classes/structCFBDBootTuple.md)</code> entries</li> <li>Iterate the table and invoke each function sequentially</li> <li>Handle failures by stopping the sequence or triggering recovery</li> </ol> <p>0.1 </p> <p>2026-01-09 </p> <p>Copyright \u00a9 2026 </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/core_types_guide/","title":"Core Types and Definitions Guide","text":""},{"location":"api/Pages/core_types_guide/#introduction","title":"Introduction","text":"<p>The CFBD core type system provides minimal but essential building blocks for embedded systems development. These types ensure consistent behavior across different platforms and compilers.</p>"},{"location":"api/Pages/core_types_guide/#boolean-type","title":"Boolean Type","text":"<pre><code>#include \"lib/config/cfbd_define.h\"\n\n// Simple boolean usage\nCFBD_Bool is_initialized = CFBD_FALSE;\nif (initialize_system()) {\n    is_initialized = CFBD_TRUE;\n}\n</code></pre>"},{"location":"api/Pages/core_types_guide/#callback-function-types","title":"Callback Function Types","text":"<pre><code>#include \"lib/config/cfbd_define.h\"\n\n// Initialization callback\nCFBD_Bool my_init(void* self_handle, void* args) {\n    // Initialize component\n    return CFBD_TRUE;  // Success\n}\n\n// Simple callback\nvoid my_callback(void* args) {\n    // Handle event\n}\n\n// Use in your component\nSelfInitFunc init = my_init;\nPlainFunc callback = my_callback;\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/documents/","title":"for Pages tab\\n","text":"<ul> <li>\u2713 CFBD namespace organization for Namespaces tab</li> <li>\u2713 Hierarchical structure (Graphics \u2192 Widget \u2192 Image/Menu/ProgressBar)</li> <li>\u2713 Best practices and maintenance guidelines</li> </ul> <p>* * Widget_UserGuide - Start here for widget usage * Graphics_Widget_Examples - Copy-paste ready examples * Graphics_UserGuide - Core graphics system * CFBD_GraphicDevice - Core device interface</p> <p>*/</p> <ul> <li> <ol> <li>Maintain cross-references between related items</li> </ol> </li> <li> <ol> <li>Keep examples in sync with implementation</li> </ol> </li> <li> <ul> <li></li> </ul> </li> </ul>"},{"location":"api/Pages/documents/#doxygen-features-used","title":"Doxygen Features Used","text":"<ul> <li> <ul> <li>This documentation makes use of:</li> </ul> </li> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/error_handling/","title":"Error Handling Guide","text":""},{"location":"api/Pages/error_handling/#overview","title":"Overview","text":"<p>The <code>[ah_no.h](Files/ah__no_8h.md#file-ah-no.h)</code> header provides emergency halt functionality for handling unrecoverable system errors on bare-metal embedded systems. When a fatal error is detected and continuing execution would be unsafe, applications should invoke <code>[CFBD_AH_NO()](Modules/group__Core__Utilities.md#function-cfbd-ah-no)</code> to enter a halt state.</p>"},{"location":"api/Pages/error_handling/#usage-pattern","title":"Usage Pattern","text":"<pre><code>#include \"lib/config/ah_no.h\"\n\n// Example: Halt on critical failure\nif (critical_resource_failed) {\n    // Log or signal error if needed\n    CFBD_AH_NO();  // Enter infinite halt\n    // Execution never reaches here\n}\n</code></pre>"},{"location":"api/Pages/error_handling/#platform-integration","title":"Platform Integration","text":"<p>On many platforms, external mechanisms like watchdogs or debuggers can detect and handle the halt state:</p> <ul> <li>Watchdog timers can trigger system reset</li> <li>Debuggers can break on the infinite loop</li> <li>Custom firmware may signal error indicators before the halt </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/for/","title":"standalone pages","text":"<ul> <li> <ul> <li>``</li> </ul> </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/","title":"Arc Drawing and Geometry Guide","text":""},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#arc-fundamentals","title":"Arc Fundamentals","text":"<p>Arcs represent portions of a circle defined by:</p> <ul> <li>Center point and radius (like circles)</li> <li>Angular range (start and end degrees)</li> <li>Direction of sweep (typically counter-clockwise)</li> </ul>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#angular-measurement","title":"Angular Measurement","text":"<p>Angles are specified in degrees (0-359):</p> <ul> <li>0\u00b0 points to the right (3 o'clock position)</li> <li>90\u00b0 points downward (6 o'clock position)</li> <li>180\u00b0 points to the left (9 o'clock position)</li> <li>270\u00b0 points upward (12 o'clock position)</li> <li>Positive angles sweep counter-clockwise</li> <li>Angles wrap at 360\u00b0 boundaries</li> </ul>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#arc-types","title":"Arc Types","text":"<ol> <li>Arc outline: Just the curved edge (CFBDGraphic_DrawArc)</li> <li>Filled arc/sector: Arc plus two radii forming a pie slice (CFBDGraphic_DrawFilledArc)</li> </ol>"},{"location":"api/Pages/group__Arc__Module_Arc_Guide/#practical-applications","title":"Practical Applications","text":"<ul> <li>Gauges and progress indicators</li> <li>Pie charts and donut charts</li> <li>Circular menus and dial controls</li> <li>Clock and timer displays</li> <li>Compass and rotation indicators</li> <li>Loading animations </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/","title":"Graphic Base Helpers User Guide","text":""},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#overview","title":"Overview","text":"<p>The BaseHelpers module provides lightweight inline conversion utilities designed specifically for the BareMetal graphics system. These helpers ensure safe arithmetic between different numeric types used throughout the graphics library.</p>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#key-features","title":"Key Features","text":"<ul> <li>Type-safe conversions between PointBaseType and 32-bit integers</li> <li>Automatic range clamping to prevent overflow</li> <li>Zero-cost abstraction suitable for embedded systems</li> <li>Inline implementation for optimal performance</li> </ul>"},{"location":"api/Pages/group__BaseHelpers__Module_BaseHelpers_Guide/#usage-patterns","title":"Usage Patterns","text":"<pre><code>// Converting unsigned 16-bit point coordinate to signed for calculations\nCFBDGraphic_Point pt = {100, 50};\nint32_t signed_x = asInt32_t(pt.x);  // 100 -&gt; 100 (signed)\nint32_t signed_y = asInt32_t(pt.y);  // 50 -&gt; 50 (signed)\n\n// Clamping coordinates after arithmetic operations\nint32_t new_x = 100 + 50000;  // Might overflow\nPointBaseType safe_x = clamp_u16_from_i32(new_x);\n// Result: UINT16_MAX (65535)\n\n// Handling negative displacements\nint32_t delta = -50;\nPointBaseType pos = clamp_u16_from_i32(delta);  // Result: 0\n</code></pre> <p>Graphics_Module </p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/","title":"Circle Drawing and Geometry Guide","text":""},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#circle-fundamentals","title":"Circle Fundamentals","text":"<p>Circles are defined by their center point and a radius. The BareMetal graphics library provides efficient rendering functions for both circle outlines and filled circles. These functions are optimized for embedded displays.</p>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#circle-structure","title":"Circle Structure","text":"<p>Each circle is represented by:</p> <ul> <li>A center point (CFBDGraphic_Point) specifying the circle's location</li> <li>A radius (SizeBaseType) in device coordinate units</li> </ul>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#rendering-algorithms","title":"Rendering Algorithms","text":"<p>Implementations typically use the Midpoint Circle Algorithm (Bresenham's circle algorithm) for efficient rasterization:</p> <ul> <li>Minimizes floating-point operations</li> <li>Generates anti-aliased appearance on pixel grids</li> <li>Scales well for circles of any size</li> </ul>"},{"location":"api/Pages/group__Circle__Module_Circle_Guide/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>UI buttons with circular shapes</li> <li>Radar displays and gauges</li> <li>Particle effects and animations</li> <li>Collision detection debugging</li> <li>Indicator lights and status displays </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/iic_error_page/","title":"I2C Error Handling","text":""},{"location":"api/Pages/iic_error_page/#introduction","title":"Introduction","text":"<p>The I2C/IIC error subsystem provides a standardized set of error codes compatible with POSIX conventions. This enables consistent error handling across different platforms and I2C implementations within the CFBD project.</p>"},{"location":"api/Pages/iic_error_page/#error-code-reference","title":"Error Code Reference","text":"<p>All I2C operations return an integer status code:</p> <ul> <li>I2C_OK (0): Operation completed successfully</li> <li>I2C_ERR_TIMEOUT (-110): Operation exceeded time limit</li> <li>I2C_ERR_NACK (-121): Device did not acknowledge (protocol error)</li> <li>I2C_ERR_BUSY (-16): Bus or device is currently busy</li> <li>I2C_ERR_IO (-5): Generic I/O error occurred</li> <li>I2C_ERR_INVAL (-22): Invalid arguments provided</li> </ul>"},{"location":"api/Pages/iic_error_page/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"api/Pages/iic_error_page/#basic-error-checking","title":"Basic Error Checking","text":"<pre><code>int status = CFBD_I2CTransfer(bus, messages, num_messages, 1000);\nif (status != I2C_OK) {\n    // Handle error based on type\n    if (status == I2C_ERR_TIMEOUT) {\n        // Timeout occurred - retry or increase timeout\n    } else if (status == I2C_ERR_NACK) {\n        // Device not responding - check address and connections\n    }\n}\n</code></pre>"},{"location":"api/Pages/iic_error_page/#recovery-strategies","title":"Recovery Strategies","text":"<pre><code>int attempt = 0;\nconst int MAX_RETRIES = 3;\nint status;\n\ndo {\n    status = CFBD_I2CTransfer(bus, messages, num_messages, 1000);\n    if (status == I2C_OK) {\n        break;  // Success\n    } else if (status == I2C_ERR_BUSY) {\n        // Wait before retry\n        delay_ms(10);\n    } else if (status == I2C_ERR_NACK || status == I2C_ERR_IO) {\n        // Attempt bus recovery\n        CFBD_I2CRecoverBus(bus);\n        delay_ms(50);\n    }\n} while (++attempt &lt; MAX_RETRIES &amp;&amp; status != I2C_OK);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/iic_integration_page/","title":"I2C Integration Guide","text":""},{"location":"api/Pages/iic_integration_page/#overview","title":"Overview","text":"<p>The CFBD I2C abstraction provides a platform-independent interface for I2C communication. Backend implementations (e.g., STM32) provide concrete device drivers, while the abstraction layer ensures consistent behavior across different hardware platforms.</p>"},{"location":"api/Pages/iic_integration_page/#architecture","title":"Architecture","text":"<p>The I2C system consists of:</p> <ul> <li>Operations Table (<code>[CFBD_I2COperations](Classes/structCFBD__I2COperations.md)</code>): Backend implementation hooks</li> <li>I2C Handle (<code>[CFBD_I2CHandle](Classes/structCFBD__I2CHandle.md)</code>): Public interface + private backend state</li> <li>Messages (<code>[CFBD_I2C_Message](Classes/structCFBD__I2C__Message.md)</code>): Protocol-level read/write operations</li> <li>High-Level Helpers (<code>CFBD_I2CRead</code>, <code>CFBD_I2CWrite</code>): Convenience functions</li> </ul>"},{"location":"api/Pages/iic_integration_page/#typical-usage-workflow","title":"Typical Usage Workflow","text":""},{"location":"api/Pages/iic_integration_page/#initialization","title":"Initialization","text":"<pre><code>// 1. Create I2C handle (typically done by backend platform code)\nCFBD_I2CHandle i2c_bus = {\n    .ops = &amp;i2c_stm_operations,      // Backend operations table\n    .private_handle = &amp;i2c_hardware  // Platform-specific state\n};\n\n// 2. Initialize the I2C bus\nint status = CFBD_I2CInit(&amp;i2c_bus);\nif (status != I2C_OK) {\n    // Handle initialization error\n}\n</code></pre>"},{"location":"api/Pages/iic_integration_page/#message-transfer","title":"Message Transfer","text":"<pre><code>// Example: Read from OLED at address 0x3C\nCFBD_I2C_Message msgs[2];\nuint8_t reg_addr = 0x00;  // Register to read\nuint8_t data_buffer[32];  // Read buffer\n\n// Message 1: Write register address\nmsgs[0].addr = 0x3C;\nmsgs[0].flags = 0;\nmsgs[0].len = 1;\nmsgs[0].buf = &amp;reg_addr;\n\n// Message 2: Read data (uses I2C_M_RD flag)\nmsgs[1].addr = 0x3C;\nmsgs[1].flags = I2C_M_RD;\nmsgs[1].len = sizeof(data_buffer);\nmsgs[1].buf = data_buffer;\n\n// Execute combined write-read transaction\nstatus = CFBD_I2CTransfer(&amp;i2c_bus, msgs, 2, 1000);\nif (status == I2C_OK) {\n    // data_buffer now contains read data\n}\n</code></pre>"},{"location":"api/Pages/iic_integration_page/#using-convenience-helpers","title":"Using Convenience Helpers","text":"<pre><code>CFBD_I2C_IORequestParams req = {\n    .addr7 = 0x3C,\n    .mem_addr = 0x10,        // Device internal address\n    .mem_addr_size = 1,      // 1 byte address\n    .data = buffer,\n    .len = sizeof(buffer),\n    .timeout_ms = 1000\n};\n\n// Simple high-level read\nstatus = CFBD_I2CRead(&amp;i2c_bus, &amp;req);\n</code></pre> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2graphic_2Graphics__Complete__Examples/","title":"Graphics_Complete_Examples","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2graphic_2Graphics__Complete__UserGuide/","title":"Graphics_Complete_UserGuide","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2graphic_2Graphics__Widget__Documentation/","title":"Graphics_Widget_Documentation","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Documentation__Summary/","title":"OLED_Documentation_Summary","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Examples/","title":"OLED_Examples","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Namespace/","title":"OLED_Namespace","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/md_lib_2oled_2OLED__Usage__Guide/","title":"OLED_Usage_Guide","text":"<p>/**</p> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/oled_cache_page/","title":"OLED Display Cache Architecture","text":""},{"location":"api/Pages/oled_cache_page/#introduction","title":"Introduction","text":"<p>The OLED cache (framebuffer) is a critical component of the display system. It maintains an off-screen representation of the display content, allowing efficient updates and animations while minimizing I2C traffic.</p>"},{"location":"api/Pages/oled_cache_page/#cache-dimensions","title":"Cache Dimensions","text":"<p>The OLED cache is organized as:</p> <ul> <li>Height: CACHED_HEIGHT = 8 pixels (1 byte in vertical compression)</li> <li>Width: CACHED_WIDTH = 144 pixels</li> <li>Total Pixels: 1152 pixels</li> <li>Memory Layout: Packed vertically (8 pixels per byte)</li> </ul>"},{"location":"api/Pages/oled_cache_page/#memory-layout","title":"Memory Layout","text":"<p>The cache uses a page-based layout common to SSD1306-compatible displays: </p> <pre><code>Byte layout (vertical compression):\nBit 7: Page 0, Row 7\nBit 6: Page 0, Row 6\nBit 5: Page 0, Row 5\nBit 4: Page 0, Row 4\nBit 3: Page 0, Row 3\nBit 2: Page 0, Row 2\nBit 1: Page 0, Row 1\nBit 0: Page 0, Row 0\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#typical-cache-operations","title":"Typical Cache Operations","text":""},{"location":"api/Pages/oled_cache_page/#setting-a-pixel","title":"Setting a Pixel","text":"<pre><code>void set_pixel(int x, int y, int color) {\n    if (x &lt; 0 || x &gt;= CACHED_WIDTH || y &lt; 0 || y &gt;= CACHED_HEIGHT * 8) {\n        return;  // Out of bounds\n    }\n\n    int page = y / 8;      // Which byte (page)\n    int bit = y % 8;       // Which bit within byte\n    int offset = page * CACHED_WIDTH + x;\n\n    if (color) {\n        cache[offset] |= (1 &lt;&lt; bit);   // Set pixel\n    } else {\n        cache[offset] &amp;= ~(1 &lt;&lt; bit);  // Clear pixel\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#updating-display-from-cache","title":"Updating Display from Cache","text":"<pre><code>void display_refresh(void) {\n    for (int page = 0; page &lt; CACHED_HEIGHT; page++) {\n        // Set page address command\n        write_command(0xB0 | page);\n\n        // Write entire page (144 bytes)\n        for (int x = 0; x &lt; CACHED_WIDTH; x++) {\n            int offset = page * CACHED_WIDTH + x;\n            write_data(cache[offset]);\n        }\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_cache_page/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory: (CACHED_HEIGHT * 8) * CACHED_WIDTH / 8 bytes = 1152 bytes</li> <li>Update Time: Full refresh ~1-2ms at 400kHz I2C</li> <li>Partial Updates: Recommended for animations (update only changed regions) </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/oled_integration_page/","title":"OLED Driver Integration","text":""},{"location":"api/Pages/oled_integration_page/#introduction","title":"Introduction","text":"<p>This module facilitates platform-specific initialization of OLED displays by providing a standardized initialization parameter structure. It decouples the generic OLED driver from platform-specific details (I2C bus selection, display models, timing parameters, etc.).</p>"},{"location":"api/Pages/oled_integration_page/#integration-flow","title":"Integration Flow","text":""},{"location":"api/Pages/oled_integration_page/#platform-code-boardsystem-initialization","title":"Platform Code (board/system initialization)","text":"<ol> <li>Initialize the I2C bus using platform-specific code</li> <li>Create a <code>[CFBD_OLED_IICInitsParams](Classes/structCFBD__OLED__IICInitsParams.md)</code> structure with:<ul> <li>I2C bus handle</li> <li>Device address (0x3C or 0x3D for typical OLED displays)</li> <li>Device-specific callbacks and configuration</li> <li>Optional I2C callback for transaction status</li> </ul> </li> <li>Call OLED driver's init function with the parameters</li> </ol>"},{"location":"api/Pages/oled_integration_page/#typical-platform-initialization","title":"Typical Platform Initialization","text":"<pre><code>// In platform/board initialization code\n\n// Step 1: I2C bus is already initialized\nextern CFBD_I2CHandle i2c1_bus;\n\n// Step 2: Define OLED device specifics (e.g., SSD1306)\nextern CFBD_OLED_DeviceSpecific ssd1306_specs;\n\n// Step 3: Create initialization parameters\nCFBD_OLED_IICInitsParams oled_params = {\n    .i2cHandle = &amp;i2c1_bus,\n    .accepted_time_delay = 1,                // 1 tick delay\n    .device_address = 0x3C,                  // SSD1306 default\n    .device_specifics = &amp;ssd1306_specs,\n    .iic_transition_callback = my_iic_handler\n};\n\n// Step 4: Initialize OLED\nint status = CFBD_OLED_Init(&amp;oled_params);\nif (status != OLED_OK) {\n    // Handle initialization error\n    handle_error();\n}\n</code></pre>"},{"location":"api/Pages/oled_integration_page/#supported-device-models","title":"Supported Device Models","text":"<p>The framework supports multiple OLED controller models through the <code>[CFBD_OLED_DeviceSpecific](Classes/structCFBD__OLED__DeviceSpecific.md)</code> structure:</p> <ul> <li>SSD1306: 128\u00d764 I2C OLED displays</li> <li>SSD1309: Enhanced variant with higher speeds</li> <li>SH1106: Alternative controller (less common)</li> </ul>"},{"location":"api/Pages/oled_integration_page/#callback-pattern","title":"Callback Pattern","text":"<p>The I2C transition callback enables asynchronous notification when I2C transactions complete:</p> <pre><code>void my_iic_handler(int status) {\n    if (status == I2C_OK) {\n        // I2C transaction succeeded\n        signal_display_updated();\n    } else if (status == I2C_ERR_NACK) {\n        // Display not responding\n        log_error(\"Display not found on I2C bus\");\n    } else if (status == I2C_ERR_TIMEOUT) {\n        // Transaction timeout\n        log_error(\"Display I2C timeout\");\n    }\n}\n</code></pre>"},{"location":"api/Pages/oled_integration_page/#timing-configuration","title":"Timing Configuration","text":"<p>The <code>accepted_time_delay</code> parameter controls inter-transaction delays. This is useful for:</p> <ul> <li>Allowing display controller time to process commands</li> <li>Pacing rapid consecutive updates</li> <li>Accommodating system scheduler granularity </li> </ul> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"},{"location":"api/Pages/timing_guide/","title":"System Timing and Delay Guide","text":""},{"location":"api/Pages/timing_guide/#overview","title":"Overview","text":"<p>The system clock module provides simple delay primitives for timing-dependent operations in embedded applications. These functions are intentionally minimal to work across diverse platform implementations.</p>"},{"location":"api/Pages/timing_guide/#key-concepts","title":"Key Concepts","text":"<ul> <li>Millisecond delays (<code>system_delay_ms</code>) for longer timing sequences</li> <li>Microsecond delays (<code>system_delay_us</code>) for precise sub-millisecond timing</li> <li>Platform-specific implementation for accuracy and power efficiency</li> </ul>"},{"location":"api/Pages/timing_guide/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Debouncing GPIO inputs</li> <li>Timing I2C/SPI transaction sequences</li> <li>Adding delays between hardware initialization steps</li> <li>Bit-banging protocol timing</li> </ul>"},{"location":"api/Pages/timing_guide/#practical-examples","title":"Practical Examples","text":""},{"location":"api/Pages/timing_guide/#gpio-debouncing","title":"GPIO Debouncing","text":"<pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n#include \"lib/gpio/gpio.h\"\n\nCFBD_Bool read_debounced_button(CFBD_GPIOHandle* button_pin) {\n    // Initial read\n    CFBD_Bool first_read = CFBD_GPIORead(button_pin);\n\n    // Wait for switch to settle\n    system_delay_ms(20);\n\n    // Confirm state hasn't changed\n    CFBD_Bool second_read = CFBD_GPIORead(button_pin);\n    return (first_read == second_read) ? first_read : CFBD_FALSE;\n}\n</code></pre>"},{"location":"api/Pages/timing_guide/#i2c-bus-timing","title":"I2C Bus Timing","text":"<pre><code>#include \"lib/application/sys_clock/system_clock.h\"\n\nvoid i2c_bit_banged_start_condition(void) {\n    // SDA and SCL high\n    set_sda_high();\n    set_scl_high();\n    system_delay_us(5);\n\n    // Bring SDA low while SCL is high\n    set_sda_low();\n    system_delay_us(5);\n\n    // Bring SCL low\n    set_scl_low();\n}\n</code></pre>"},{"location":"api/Pages/timing_guide/#platform-considerations","title":"Platform Considerations","text":"<ul> <li>Accuracy: Actual delay may vary depending on system load and interrupt activity</li> <li>Interrupt Safety: Check platform documentation for ISR usage restrictions</li> <li>Power: Consider sleep/standby modes for longer waits</li> <li>Busy-wait: Current implementations typically use busy-wait loops</li> </ul>"},{"location":"api/Pages/timing_guide/#best-practices","title":"Best Practices","text":"<ol> <li>Use millisecond delays for non-critical timing sequences</li> <li>Use microsecond delays only when necessary for precision</li> <li>Avoid calling from interrupt handlers (unless documented as safe)</li> <li>Consider application clock frequency when porting between platforms</li> <li>Combine with hardware timers for more accurate long-duration timing </li> </ol> <p>Updated on 2026-02-03 at 13:21:55 +0000</p>"}]}